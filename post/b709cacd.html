<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CLobster+Two:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"nimbusk.cc","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="背景前一段时间，公司小组内调整，我被安插到一个在线客服的项目下。人不多，就我一个人作为主开发。其主要原因是，项目整体大的需求少数，总体趋于稳定，故而开发很少。但是，从我接手到目前（2018-8-16），总共也就不到1个半月，前前后后遇到产线事件不下数10起，其中2~3起事件，定位不到问题。本片发稿日（2018-8-16），白日再次被公司上集领导层点名批评，说这个系统不好用，怎么怎么样。确实，从我接">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala&amp;Akka学习纪要">
<meta property="og:url" content="https://nimbusk.cc/post/b709cacd.html">
<meta property="og:site_name" content="NimbusK&#39;s Blog">
<meta property="og:description" content="背景前一段时间，公司小组内调整，我被安插到一个在线客服的项目下。人不多，就我一个人作为主开发。其主要原因是，项目整体大的需求少数，总体趋于稳定，故而开发很少。但是，从我接手到目前（2018-8-16），总共也就不到1个半月，前前后后遇到产线事件不下数10起，其中2~3起事件，定位不到问题。本片发稿日（2018-8-16），白日再次被公司上集领导层点名批评，说这个系统不好用，怎么怎么样。确实，从我接">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nimbusk.cc/post/b709cacd/non-blocking-IO.jpg">
<meta property="og:image" content="https://nimbusk.cc/post/b709cacd/future_collection_scala_java.png">
<meta property="og:image" content="https://nimbusk.cc/post/b709cacd/ask_communication.png">
<meta property="og:image" content="https://nimbusk.cc/post/b709cacd/tell_communication.png">
<meta property="og:image" content="https://nimbusk.cc/post/b709cacd/actor_with_map_parameters.png">
<meta property="og:image" content="https://nimbusk.cc/post/b709cacd/actor_forword.png">
<meta property="article:published_time" content="2018-08-17T00:06:18.000Z">
<meta property="article:modified_time" content="2024-10-28T20:30:21.000Z">
<meta property="article:author" content="nimbusk">
<meta property="article:tag" content="Akka">
<meta property="article:tag" content="Scala">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nimbusk.cc/post/b709cacd/non-blocking-IO.jpg">


<link rel="canonical" href="https://nimbusk.cc/post/b709cacd.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://nimbusk.cc/post/b709cacd.html","path":"post/b709cacd.html","title":"Scala&Akka学习纪要"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Scala&Akka学习纪要 | NimbusK's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">NimbusK's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0"><span class="nav-number">2.</span> <span class="nav-text">书籍笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Akka%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98"><span class="nav-number">2.1.</span> <span class="nav-text">Akka入门实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Actor%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">2.1.1.</span> <span class="nav-text">第二章 Actor与并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">响应式系统设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%81%B5%E6%95%8F%E6%80%A7"><span class="nav-number">2.1.1.1.1.</span> <span class="nav-text">灵敏性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%B8%E7%BC%A9%E6%80%A7"><span class="nav-number">2.1.1.1.2.</span> <span class="nav-text">伸缩性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E6%80%A7"><span class="nav-number">2.1.1.1.3.</span> <span class="nav-text">容错性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8"><span class="nav-number">2.1.1.1.4.</span> <span class="nav-text">事件驱动&#x2F;消息驱动</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%96%E6%9E%90Actor"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">剖析Actor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Java-Actor-API"><span class="nav-number">2.1.1.2.1.</span> <span class="nav-text">Java Actor API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Scala-Actor-API"><span class="nav-number">2.1.1.2.2.</span> <span class="nav-text">Scala Actor API</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Actor%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">Actor的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Props"><span class="nav-number">2.1.1.3.1.</span> <span class="nav-text">Props</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise%E3%80%81Future%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">Promise、Future和事件驱动的编程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8API"><span class="nav-number">2.1.1.4.1.</span> <span class="nav-text">阻塞与事件驱动API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Future%E8%BF%9B%E8%A1%8C%E5%93%8D%E5%BA%94%E7%9A%84Actor"><span class="nav-number">2.1.1.4.2.</span> <span class="nav-text">使用Future进行响应的Actor</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Java%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.1.4.2.1.</span> <span class="nav-text">Java示例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Scala%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.1.4.2.2.</span> <span class="nav-text">Scala示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%90%86%E8%A7%A3Future%E5%92%8CPromise"><span class="nav-number">2.1.1.4.3.</span> <span class="nav-text">理解Future和Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%96%E6%9E%90Future"><span class="nav-number">2.1.1.4.3.1.</span> <span class="nav-text">剖析Future</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%A4%B1%E8%B4%A5%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="nav-number">2.1.1.4.4.</span> <span class="nav-text">在失败情况下执行代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E5%A4%B1%E8%B4%A5%E4%B8%AD%E6%81%A2%E5%A4%8D"><span class="nav-number">2.1.1.4.5.</span> <span class="nav-text">从失败中恢复</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%9C%B0%E4%BB%8E%E5%A4%B1%E8%B4%A5%E4%B8%AD%E6%81%A2%E5%A4%8D"><span class="nav-number">2.1.1.4.6.</span> <span class="nav-text">异步地从失败中恢复</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88Future"><span class="nav-number">2.1.1.4.7.</span> <span class="nav-text">组合Future</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86Future-List"><span class="nav-number">2.1.1.4.8.</span> <span class="nav-text">处理Future List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Future%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="nav-number">2.1.1.4.9.</span> <span class="nav-text">Future速查表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF"><span class="nav-number">2.1.2.</span> <span class="nav-text">第三章 传递消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">消息传递</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Ask%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.2.1.1.</span> <span class="nav-text">Ask消息模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tell"><span class="nav-number">2.1.2.1.2.</span> <span class="nav-text">Tell</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Forward"><span class="nav-number">2.1.2.1.3.</span> <span class="nav-text">Forward</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-Actor%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E2%80%94%E2%80%94%E5%A4%84%E7%90%86%E7%8A%B6%E6%80%81%E4%B8%8E%E9%94%99%E8%AF%AF"><span class="nav-number">2.1.3.</span> <span class="nav-text">第四章 Actor的生命周期——处理状态与错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E7%9A%848%E4%B8%AA%E8%AF%AF%E5%8C%BA"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">分布式计算的8个误区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%98%AF%E5%8F%AF%E9%9D%A0%E7%9A%84%EF%BC%88The-network-is-reliable%EF%BC%89"><span class="nav-number">2.1.3.1.1.</span> <span class="nav-text">网络是可靠的（The network is reliable）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E5%BB%B6%E8%BF%9F%EF%BC%88Latency-is-zero%EF%BC%89"><span class="nav-number">2.1.3.1.2.</span> <span class="nav-text">没有延迟（Latency is zero）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6%E5%AE%BD%E6%98%AF%E6%97%A0%E9%99%90%E7%9A%84%EF%BC%88Bandwidth-is-infinite%EF%BC%89"><span class="nav-number">2.1.3.1.3.</span> <span class="nav-text">带宽是无限的（Bandwidth is infinite）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%88The-network-is-secure%EF%BC%89"><span class="nav-number">2.1.3.1.4.</span> <span class="nav-text">网络是安全的（The network is secure）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%EF%BC%88Topology-doesn%E2%80%99t-change%EF%BC%89"><span class="nav-number">2.1.3.1.5.</span> <span class="nav-text">网络拓扑不会改变（Topology doesn’t change）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E7%AE%A1%E7%90%86%E5%91%98%EF%BC%88There-is-one-administrator%EF%BC%89"><span class="nav-number">2.1.3.1.6.</span> <span class="nav-text">只有一个管理员（There is one administrator）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%B2%A1%E6%9C%89%E5%BC%80%E9%94%80%EF%BC%88Transport-cost-is-zero%EF%BC%89"><span class="nav-number">2.1.3.1.7.</span> <span class="nav-text">网络传输没有开销（Transport cost is zero）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%98%AF%E5%90%8C%E6%9E%84%E7%9A%84%EF%BC%88The-network-is-homogeneous%EF%BC%89"><span class="nav-number">2.1.3.1.8.</span> <span class="nav-text">网络是同构的（The network is homogeneous）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">错误</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E9%94%99%E8%AF%AF"><span class="nav-number">2.1.3.2.1.</span> <span class="nav-text">隔离错误</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E7%9D%A3"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">监督</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%9B%91%E7%9D%A3%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.3.3.1.</span> <span class="nav-text">定义监督策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Actor%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.1.3.3.2.</span> <span class="nav-text">Actor生命周期</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF-%E7%A6%BB%E7%BA%BF%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.3.4.1.</span> <span class="nav-text">在线&#x2F;离线状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.1.3.4.2.</span> <span class="nav-text">条件语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%83%AD%E4%BA%A4%E6%8D%A2%EF%BC%88Hotswap%EF%BC%89%EF%BC%9ABecome-Unbecome"><span class="nav-number">2.1.3.4.3.</span> <span class="nav-text">热交换（Hotswap）：Become&#x2F;Unbecome</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%B5%E5%90%91%E6%89%A9%E5%B1%95"><span class="nav-number">2.1.4.</span> <span class="nav-text">纵向扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Dispatcher"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">使用Dispatcher</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Dispatcher%E8%A7%A3%E6%9E%90"><span class="nav-number">2.1.4.1.1.</span> <span class="nav-text">Dispatcher解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executor"><span class="nav-number">2.1.4.1.2.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BADispatcher"><span class="nav-number">2.1.4.1.3.</span> <span class="nav-text">创建Dispatcher</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%B3%E5%AE%9A%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8DDispatcher"><span class="nav-number">2.1.4.1.4.</span> <span class="nav-text">决定何时使用哪种Dispatcher</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Future%E7%9A%84%E9%98%BB%E5%A1%9EIO-Dispatcher"><span class="nav-number">2.1.4.1.5.</span> <span class="nav-text">使用Future的阻塞IO Dispatcher</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95%E2%80%94%E2%80%94%E9%9B%86%E7%BE%A4%E5%8C%96"><span class="nav-number">2.1.5.</span> <span class="nav-text">第6章 横向扩展——集群化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">集群定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%B1%E8%B4%A5%E6%A3%80%E6%B5%8B"><span class="nav-number">2.1.5.1.1.</span> <span class="nav-text">失败检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87gossip%E5%8D%8F%E8%AE%AE%E8%BE%BE%E5%88%B0%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">2.1.5.1.2.</span> <span class="nav-text">通过gossip协议达到最终一致性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Akka-Cluster%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">使用Akka Cluster构建系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="nav-number">2.1.5.2.1.</span> <span class="nav-text">创建集群</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%A4%84%E7%90%86%E9%82%AE%E7%AE%B1%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.6.</span> <span class="nav-text">第7章 处理邮箱问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="nav-number">3.</span> <span class="nav-text">主要内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">引用</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nimbusk"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">nimbusk</p>
  <div class="site-description" itemprop="description">写好一个博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">131</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/nimbusking" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nimbusking" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kemivong@hotmail.com" title="E-Mail → mailto:kemivong@hotmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nimbusk.cc/post/b709cacd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nimbusk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NimbusK's Blog">
      <meta itemprop="description" content="写好一个博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Scala&Akka学习纪要 | NimbusK's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Scala&Akka学习纪要
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">

  
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-17 00:06:18" itemprop="dateCreated datePublished" datetime="2018-08-17T00:06:18+00:00">2018-08-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2024-10-28 20:30:21" itemprop="dateModified" datetime="2024-10-28T20:30:21+00:00">2024-10-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Scala%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Scala系列</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前一段时间，公司小组内调整，我被安插到一个在线客服的项目下。人不多，就我一个人作为主开发。其主要原因是，项目整体大的需求少数，总体趋于稳定，故而开发很少。<br>但是，从我接手到目前（2018-8-16），总共也就不到1个半月，前前后后遇到产线事件不下数10起，其中2~3起事件，定位不到问题。<br>本片发稿日（2018-8-16），白日再次被公司上集领导层点名批评，说这个系统不好用，怎么怎么样。<br>确实，从我接手看，这个系统很成问题，为什么说很？经常性出问题！<br>反观自己，确实，对于这套东西本省就很不熟，当初答应接下来，就是因为想挑战挑战。但是从目前看，效果并不明显。<br>总结开来：<strong>遇到这些所谓奇怪的问题，总结开来就是：无从下手排查。导致平凡出现问题后，解决问题的失效，本质性有没有解决问题等等。客户并不满意！</strong></p>
<p>这套在线客服系统，大体用到的技术包含，如下：</p>
<ul>
<li>Java</li>
<li>Scala</li>
<li>Akka</li>
<li>SocketIO</li>
<li>Redis</li>
<li>Java Web一套</li>
</ul>
<p>其中，Scala、Akka、Redis在此之前的工作中并没有很好的接触。特别是Scala、Akka根本碰都没碰过，然而在这套系统里面，这俩又是核心骨架。</p>
<p>先从Scala、Akka这两个陌生的东西开始看起！</p>
<h1 id="书籍笔记"><a href="#书籍笔记" class="headerlink" title="书籍笔记"></a>书籍笔记</h1><h2 id="Akka入门实战"><a href="#Akka入门实战" class="headerlink" title="Akka入门实战"></a>Akka入门实战</h2><p>这本书是翻译的，讲实话，翻译质量不高，当中有不少细节不能接受。比如ActorSystem本来就是Akka框架中一个核心类，非要硬翻译成Actor系统，额。。。这有点未免有点“门外汉”的意思了吧。不过作为入门书籍，基本类介绍的还是非常详细的。英文水平不错的可以直接去阅读英文版书籍吧。<br>这本书年代还是有点久远，15年，在那前后akka的稳定版还是处在2.3.6版本前后，故而对于2021年的akka版本（2.16.5）来说，可能有部分场景的类，并不能发很好的适配。解释需要参阅官方的API进行调整。</p>
<h3 id="第二章-Actor与并发"><a href="#第二章-Actor与并发" class="headerlink" title="第二章 Actor与并发"></a>第二章 Actor与并发</h3><p>书中写的很有意思：如果读者早已熟稔Scala 的Future，Play 的Promise或是Java8的CompletableFuture，那么可以跳过本章。如果曾经使用过Guava 或Spring 的ListenableFuture，可能需要了解本章所介绍API的不同之处。如果从来没有使用过monadic风格的Future，那就需要花点时间学习一下本章了。<br>对于我来说，还真是一个都不懂。。。</p>
<h4 id="响应式系统设计"><a href="#响应式系统设计" class="headerlink" title="响应式系统设计"></a>响应式系统设计</h4><p>源自一个响应式宣言（Reactive Manifesto /ˌmanəˈfestō/，有些地方翻译为反应时宣言，一个意思。），原文在这里<a href="b709cacd/the-reactive-manifesto-2.0.pdf">the-reactive-manifesto-2.0</a> ，这里面提到了四个准则：</p>
<h5 id="灵敏性"><a href="#灵敏性" class="headerlink" title="灵敏性"></a>灵敏性</h5><p>应用程序应该尽可能快地对请求做出响应。</p>
<h5 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h5><p>应用程序应该能够根据不同的工作负载进行伸缩扩展（尤其是通过增加计算资源来\进行扩展）。为了提供伸缩性，系统应该努力消除瓶颈。</p>
<h5 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h5><p>应用程序应该考虑到错误发生的情况，并且从容地对错误情况做出响应。</p>
<h5 id="事件驱动-消息驱动"><a href="#事件驱动-消息驱动" class="headerlink" title="事件驱动/消息驱动"></a>事件驱动/消息驱动</h5><p>使用消息而不直接进行方法调用提供了一种帮助我们满足另外3 个响应式准则的方法。消息驱动的系统着重于控制何时、何地以及如何对请求做出响应，允许做出响应的组件进行路由以及负载均。</p>
<h4 id="剖析Actor"><a href="#剖析Actor" class="headerlink" title="剖析Actor"></a>剖析Actor</h4><p>书中提到：Java 和Scala 的API 差别很大，因此需要分别介绍。</p>
<h5 id="Java-Actor-API"><a href="#Java-Actor-API" class="headerlink" title="Java Actor API"></a>Java Actor API</h5><p>先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaPongActor</span> <span class="keyword">extends</span> <span class="title class_">AbstractActor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> PartialFunction <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ReceiveBuilder</span><br><span class="line">                .matchEquals(<span class="string">&quot;Ping&quot;</span>, s -&gt; sender().tell(<span class="string">&quot;Pong&quot;</span>, ActorRef.noSender()))</span><br><span class="line">                .matchAny(x -&gt; sender().tell(<span class="keyword">new</span> <span class="title class_">Status</span>.Failure(<span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;unknown message&quot;</span>)), self()))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，有几个关键性的点：</p>
<ul>
<li>AbstractActor：首先，我们继承了AbstractActor。这是一个Java 8特有的API，利用了Java 8 的匿名函数（lambda）的特性。与之对应的还有一个 <code>UntypedActor</code> 这是一个较为古老的API，其内部需要通过原始的if来判断消息类型。</li>
<li>Receive：receive方法返回的类型是PartialFunction，这个类来自Scala API。在Java 中，并没有提供任何原生方法来构造Scala 的PartialFunction（并不对所有可能输入进行处理的函数），因此Akka 为我们提供了一个抽象的构造方法类ReceiveBuilder，用于生成PartialFunction 作为返回值。</li>
<li>ReceiveBuilder：先匹配消息，再通过build()方法生成需要返回的PartialFunction。</li>
<li>Match：<ul>
<li>match(class, function)：描述了对于任何尚未匹配的该类型的示例，应该如何响应。<br><code>match(String.class, s -&gt; &#123;if(s.equals(&quot;Ping&quot;)) respondToPing(s);&#125;)</code></li>
<li>match(class, predicate, function)：描述了对于predicate 条件函数为真的某特定类型的消息，应该如何响应。<br>  <code>match(String.class, s -&gt; s.equals(&quot;Ping&quot;), s -&gt; respondToPing(s))</code></li>
<li>matchEquals(object, function)：描述了对于和传入的第一个参数相等的消息，应该如何响应。<br>  <code>matchEquals(&quot;Ping&quot;, s -&gt; respondToPing(s))</code></li>
<li>matchAny(function)：该函数匹配所有尚未匹配的消息。通常来说，最佳实践是返回错误信息，或者至少将错误信息记录到日志，帮助开发过程中的错误调试。</li>
</ul>
</li>
<li>向sender()返回消息：调用了sender()方法后，我们就可以返回所收到的消息的响应了。响应的对象既可能是一个Actor，也可能是来自于Actor 系统外部的请求。第一种情况相当直接：返回的消息会直接发送到该Actor 的收件信箱中。</li>
<li>tell()：sender()函数会返回一个ActorRef。在上面的例子中，我们调用了sender().tell()。而tell()是最基本的单向消息传输模式。<strong>第一个参数是我们想要发送至对方信箱的消息。第二个参数则是希望对方Actor 看到的发送者。</strong>具体描述的是：接收到的消息是String时应该做出的响应。由于需要检查接收到的字符串是否为“Ping”，因此需要进行判断，然后描述响应行为：<em>通过tell()方法向sender()返回一条消息。我们返回的消息是字符串“Pong”。Java 的tell方法要求提供消息发送者的身份：这里使用ActorRef.noSender()表示没有返回地址。</em></li>
<li> 返回 <code>akka.actor.Status.Failure</code>：为了向发送方报告错误信息，需要向其发送一条消息。如果Actor 中抛出了异常，就会通知对其进行监督的Actor。不过无论如何，如果想要报告错误消息，需要将错误发送给发送方。如果发送方使用Future 来接收响应，那么返回错误消息会导致Future的结果为失败。<h5 id="Scala-Actor-API"><a href="#Scala-Actor-API" class="headerlink" title="Scala Actor API"></a>Scala Actor API</h5>贴代码：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaPongActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;Ping&quot;</span> =&gt; sender() ! <span class="string">&quot;Pong&quot;</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">    sender() ! <span class="type">Status</span>.<span class="type">Failure</span>(<span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;unknown message&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
首先写法上，确实要少了不少东西：</li>
<li>Actor：要定义一个Actor，首先要继承Actor 基类。Actor基类是基本的Scala ActorAPI，非常简单，并且符合Scala语言的特性。</li>
<li>Receive：在Actor 中重写基类的receive 方法。并且返回一个PartialFunction。要注意的是，receive 方法的返回类型是Receive。Receive 只不过是定义的一种类型，表示 <code>scala.PartialFunction[scala.Any, scala.Unit]</code> (注：有关scala中相关 <strong>偏函数</strong>的介绍，可以参考引用1，更多需要查阅相关专业书籍进行更深入的探索)。如果读者不是非常熟悉ScalaAPI 中的PartialFunction，也不必担心，只需要构造一些模式匹配的case 语句，每个语句都返回Unit，并且知道这些语句并不一定要覆盖所有的可能情况即可。</li>
<li>向sender()返回消息：在示例Actor 代码中，我们接着通过sender()方法获取了发送者的ActorRef。我们可以向该ActorRef 发送消息，对发送者做出响应。在这个例子中，返回了“Pong”。</li>
<li>tell 方法（!）：我们使用tell方法向发送方发送响应消息。在Scala中，通过“！”来调用tell 方法。如果读者看了Java的部分，那么会注意到在Java API 的tell方法中必须指定消息的发送者，不过在Scala中，消息发送者是隐式传入的，因此我们不需要再显式传入消息发送者的引用。在tell 方法“！”的方法签名中，有一个隐式的ActorRef参数。如果在Actor外部调用tell 方法的话，该参数的默认值会设为noSender。下面就是该方法的签名：<br><code>def !(message: Any)(implicit sender: ActorRef = Actor.noSender): Unit</code></li>
<li>Actor 中有一个隐式的变量self，Actor 通过self 得到消息发送者的值。因此Actor中tell 方法的消息发送者永远是self。</li>
</ul>
<h4 id="Actor的创建"><a href="#Actor的创建" class="headerlink" title="Actor的创建"></a>Actor的创建</h4><p>通过使用基于消息的方法，我们可以相当完整地将Actor的实例封装起来。如果只通过消息进行相互通信的话，那么永远都不会需要获取Actor 的实例。我们只需要一种机制来支持向Actor发送消息并接收响应。<br>在Akka中，这个指向Actor实例的引用叫做ActorRef。ActorRef是一个无类型的引用，将其指向的Actor 封装起来，提供了更高层的抽象，并且给用户提供了一种与Actor进行通信的机制。上文已经介绍过，ActorSystem就是包含所有Actor 的地方。有一点可能相当明显：我们也正是在ActorSystem中创建新的Actor并获取指向Actor的引用。actorOf方法会生成一个新的Actor，并返回指向该Actor的引用。<br>例如：<br>在java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActorRef</span> <span class="variable">actor</span> <span class="operator">=</span> actorSystem.actorOf(Props.create(JavaPongActor.class));</span><br></pre></td></tr></table></figure>
<p>在sacala中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> actor: <span class="type">ActorRef</span> = actorSystem.actorOf(<span class="type">Props</span>(classOf[<span class="type">ScalaPongActor</span>]))</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>这里我们实际上并没有新建Actor，例如，我们没有调用 <strong>actorOf(new PongActor)。</strong></p>
<h5 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h5><p>为了保证能够将Actor 的实例封装起来，不让其被外部直接访问，我们将所有构造函数的参数传给一个Props的实例。Props 允许我们传入Actor 的类型以及一个变长的参数列表。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Props.create(PongActor.class, arg1, arg2, argn);</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Props</span>(classOf[<span class="type">PongActor</span>], arg1, arg2, argn)</span><br></pre></td></tr></table></figure>
<p>如果Actor 的构造函数有参数，那么推荐的做法是通过一个工厂方法来创建Props。假如我们不希望Pong Actor 返回“Pong”，而是希望其返回另一条消息，那么可能就会需要这样的构造参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Props <span class="title function_">props</span><span class="params">(String response)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Props.create(<span class="built_in">this</span>.class, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaPongActor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>(response: <span class="type">String</span>): <span class="type">Props</span> = &#123;</span><br><span class="line">    <span class="type">Props</span>(classOf[<span class="type">ScalaPongActor</span>], response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以使用Props 的工厂方法来创建Actor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActorRef</span> <span class="variable">actor</span> <span class="operator">=</span> actorSystem.actorOf(JavaPongActor.props(<span class="string">&quot;PongFoo&quot;</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> actor: <span class="type">ActorRef</span> = actorSystem.actorOf(<span class="type">ScalaPongActor</span> <span class="string">props&quot;PongFoo&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>actorOf创建一个Actor，并返回指向该Actor的引用ActorRef。除此之外，还有另一种方法可以获取指向Actor的引用： <code>actorSelection</code>。<br>为了理解actorSelection，我们需要先来看一下Actor的路径。每个Actor在创建时都会有一个路径，我们可以通过ActorRef.path 来查看该路径。该路径看上去如下所示：<br><strong>akka://default/user/BruceWillis</strong><br>该路径是一个URI，它甚至可以指向使用akka.tcp协议的远程Actor。<br><strong>akka.tcp://my-sys@remotehost:5678/user/CharlieChaplin</strong><br>要注意的是，路径的前缀说明使用的协议是akka.tcp，并且指定了远程ActorSystem的主机名和端口号。如果知道Actor的路径，就可以使用actorSelection来获取指向该Actor引用的ActorSelection（无论该Actor 在本地还是远程）。<br><strong>ActorSelection selection = system.actorSelection(“akka.tcp://actorSystem@host.jason-goodwin.com:5678/user/KeanuReeves”);</strong></p>
<h4 id="Promise、Future和事件驱动的编程模型"><a href="#Promise、Future和事件驱动的编程模型" class="headerlink" title="Promise、Future和事件驱动的编程模型"></a>Promise、Future和事件驱动的编程模型</h4><h5 id="阻塞与事件驱动API"><a href="#阻塞与事件驱动API" class="headerlink" title="阻塞与事件驱动API"></a>阻塞与事件驱动API</h5><p>要转而使用事件驱动的模型，我们需要在代码中用不同的方法来表示结果。我们需要用一个占位符来表示最终将会返回的结果：Future。然后注册事件完成时应该进行的操作：打印结果。我们注册的代码会在Future占位符的值真正返回可用时被调用执行。“事件驱动”这个术语正是描述了这种方法：在发生某些特定事件时，就执行某些对应的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java版本</span></span><br><span class="line">CompletableFuture&lt;String&gt; usernameFuture = getUsernameFromDatabaseAsync(userId);</span><br><span class="line">usernameFuture.thenRun(username -&gt;</span><br><span class="line">  <span class="comment">//executed somewhere else</span></span><br><span class="line">  System.out.println(username)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scala版本</span></span><br><span class="line"><span class="keyword">val</span> future = getUsernameFromDatabaseAsync(userId)</span><br><span class="line">future.onComplete(username =&gt;</span><br><span class="line">  <span class="comment">//executed somewhere else</span></span><br><span class="line">  println(username)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>从线程的角度来看，代码首先会调用方法，然后进入该方法内部，接着几乎立即返回一个Future/CompletableFuture。返回的这个结果只是一个占位符，真正的值在未来某个时刻最终会返回到这个占位符内。<br>需要理解的是：<strong>该方法会立即返回，而数据库调用及结果的生成是在另一个线程上执行的。ExecutionContext 表示了执行这些操作的线程，我们将在本书后面的章节中对此进行介绍。（在Akka 中，可以看到ActorSystem 中有一个dispatcher，就是ExecutionContext 的一种实现。）</strong><br>方法返回Future之后，我们只得到了一个承诺，表示真正的值最终会返回到Future中。我们并不希望发起调用的线程等待返回结果，而是希望其在真正的结果返回后再执行特定的操作（打印到控制台）。<strong>在一个事件驱动的系统中，需要做的就是描述某个事件发生时需要执行的代码。</strong>在Actor中，描述接收到某个消息时进行的操作。同样地，在Future中，我们描述Future 的值真正可用时进行的操作。在Java 8中，使用thenRun来注册事件成功完成时需要执行的代码；而在Scala中，使用onComplete。<br><img data-src="b709cacd/non-blocking-IO.jpg" alt="non-blocking-IO"><br><strong>打印语句并不会运行在进行事件注册的线程上。它会运行在另一个线程上，该线程信息由ExecutionContext 维护。Future 永远是通过Execution Context来创建的，因此我们可以选择在哪里运行Future 中真正需要执行的代码。</strong></p>
<p>在书中提到了，如果你对Java8的Lambda表达式不是很清楚，可以参考oracle官方的教程，来学习一下：<a target="_blank" rel="noopener" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html">Java SE 8: Lambda Quick Start</a></p>
<h5 id="使用Future进行响应的Actor"><a href="#使用Future进行响应的Actor" class="headerlink" title="使用Future进行响应的Actor"></a>使用Future进行响应的Actor</h5><h6 id="Java示例"><a href="#Java示例" class="headerlink" title="Java示例"></a>Java示例</h6><p>所有返回Future的异步方法返回的所有返回Future 的异步方法返回的都是Scala的scala.concurrent.Future</p>
<p><strong>创建Actor</strong><br>首先创建一个ActorSystem，然后通过actorOf在刚创建的Actor系统中创建一个Actor，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActorSystem</span> <span class="variable">system</span> <span class="operator">=</span> ActorSystem.create();</span><br><span class="line"><span class="type">ActorRef</span> <span class="variable">actorRef</span> <span class="operator">=</span> system.actorOf(Props.create(JavaPongActor.class));</span><br></pre></td></tr></table></figure>
<p>现在向Actor询问其对于某个消息的响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Future</span> <span class="variable">sFuture</span> <span class="operator">=</span> ask(actorRef, <span class="string">&quot;Ping&quot;</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>这一做法相当直接，我们调用ask方法，传入以下参数：</p>
<ul>
<li>消息发送至的Actor 引用；</li>
<li>想要发送给Actor 的消息；</li>
<li>Future的超时参数：等待结果多久以后就认为询问失败。<br>ask会返回一个Scala Future，作为响应的占位符。在Actor的代码中，Actor会向sender()发送回一条消息，这条消息就是在ask 返回的Scala Future中将接收到的响应。<br>虽然我们无法在Java 8中使用Scala Future，但是可以通过之前导入的库将其转换为CompletableFuture：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletionStage&lt;String&gt; cs = toJava(sFuture);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;String&gt; jFuture = (CompletableFuture&lt;String&gt;) cs;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>首先使用 <code>scala.compat.java8.FutureConverters.toJava</code> 对Scala Future 进行转换，该方法会返回一个CompletionStage。CompletionStage是CompletableFuture 实现的接口，而且这是一个只读的接口。为了调用get 方法，我们将结果的类型转换为CompletableFuture。在测试用例外部，我们并不需要进行该转换。</p>
<p><strong>要注意的是，</strong> 我们在Future内存放的数据类型是String，而Actor 是无类型的，会返回Object，因此读者可能会觉得这种无限制的类型转换有问题。当然，<strong>在ActorSystem外部与Actor 进行通信的时候需要在这方面多加小心。</strong></p>
<h6 id="Scala示例"><a href="#Scala示例" class="headerlink" title="Scala示例"></a>Scala示例</h6><h5 id="理解Future和Promise"><a href="#理解Future和Promise" class="headerlink" title="理解Future和Promise"></a>理解Future和Promise</h5><p>Future隐式地处理了两种情况：<strong>失败与延迟</strong>。要了解如何把阻塞式的IO转为非阻塞式IO，需要学习 <strong>一些不同的表示失败处理和延时处理的抽象概念。</strong></p>
<p><strong>Future-在类型中表达失败与延迟</strong><br>像ask模式这样的异步API会返回一个占位符，类似前面提到的Future类型。<br>准备一个简单的Java示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个封装Future方法的示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;String&gt; <span class="title function_">askPong</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="type">Future</span> <span class="variable">sFuture</span> <span class="operator">=</span> ask(actorRef, message, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 调用toJava转换CompletionStage</span></span><br><span class="line">    <span class="keyword">final</span> CompletionStage&lt;String&gt; cs = toJava(sFuture);</span><br><span class="line">    <span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Future Examples，在里面调用askPong</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldPrintToConsole</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    askPong(<span class="string">&quot;Ping&quot;</span>).thenAccept(x -&gt; System.out.println(<span class="string">&quot;replied with: &quot;</span> + x));</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//no assertion - just prints to console. Try to complete a CompletableFuture instead.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scala示例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askPong</span></span>(message: <span class="type">String</span>): <span class="type">Future</span>[<span class="type">String</span>] = (pongActor ? message).mapTo[<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;FutureExamples&quot;</span>)&#123;</span><br><span class="line">  <span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line">  it(<span class="string">&quot;should print to console&quot;</span>)&#123;</span><br><span class="line">    (pongActor ? <span class="string">&quot;Ping&quot;</span>).onSuccess(&#123;</span><br><span class="line">      <span class="keyword">case</span> x: <span class="type">String</span> =&gt; println(<span class="string">&quot;replied with: &quot;</span> + x)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="剖析Future"><a href="#剖析Future" class="headerlink" title="剖析Future"></a>剖析Future</h6><p>Future[T]/CompletableFuture<T>成功时会返回一个类型为T 的值，失败时则会返回Throwable。我们将分别学习如何处理这两种情况（成功与失败），以及如何将Future的值转换成有用的结果。</p>
<p><strong>成功情况的处理</strong><br>就像上面的例子中那样，在Java 8中，可以使用thenAccept来操作返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">askPong(<span class="string">&quot;Ping&quot;</span>).thenAccept(x -&gt; System.out.println(<span class="string">&quot;replied with: &quot;</span> + x));</span><br></pre></td></tr></table></figure>

<p>而在Scala中，可以使用onSuccess：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(pongActor ? <span class="string">&quot;Ping&quot;</span>).onSuccess()&#123;</span><br><span class="line">  <span class="keyword">case</span> x: <span class="type">String</span> =&gt; println(<span class="string">&quot;replied with: &quot;</span> + x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>失败情况的处理</strong><br>失败情况是有可能发生的，而我们也需要去处理这些失败情况。所有的失败情况最终都会由一个Throwable 来表示。和成功的情况类似，有许多方法可以帮助我们来处理失败情况，甚至是从失败中恢复。</p>
<h5 id="在失败情况下执行代码"><a href="#在失败情况下执行代码" class="headerlink" title="在失败情况下执行代码"></a>在失败情况下执行代码</h5><p>很多时候，我们都想要在失败情况下做些什么。最基本的就是在失败情况下向日志中打印一些信息。在Scala中，有一种很简单的方法支持这种需求：onFailure。这个方法接受一个部分函数作为参数，而这个部分函数接受一个Throwable。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">askPong(<span class="string">&quot;causeError&quot;</span>).onFailure &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; println(<span class="string">&quot;Got exception&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不幸的是，在Java 8中，没有面向用户的用于失败处理的方法，因此我们在这里引入handle()来处理这种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一点是在异常场景中，需要特别注意的</span></span><br><span class="line">askPong(<span class="string">&quot;cause error&quot;</span>).handle((x, t) -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Error: &quot;</span> + t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>对于这个场景的java代码的说明：</strong><br>handle 接受一个BiFunction 作为参数，该函数会对成功或失败情况进行转换。handle中的函数在成功情况下会提供结果，在失败情况下则会提供Throwable，因此需要检查Throwable 是否存在（结果和Throwable 中只有一个不是null）。如果Throwable 存在，就向日志输出一条语句。由于我们需要在该函数中返回一个值，而失败情况下又不需要对返回值做任何操作，因此直接返回null。</p>
<h5 id="从失败中恢复"><a href="#从失败中恢复" class="headerlink" title="从失败中恢复"></a>从失败中恢复</h5><p>很多时候，在发生错误的时候我们仍然想要使用某个结果值。如果想要从错误中恢复的话，可以对该Future 进行转换，使之包含一个成功的结果值。<br>在Java中，可以使用exceptionally将Throwable 转换为一个可用的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage&lt;String&gt; cs = askPong(<span class="string">&quot;cause error&quot;</span>)</span><br><span class="line">  .exceptionally(t -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在Scala中，有一个recover方法提供相同的功能。同样地，recover方法也接受一个PartialFunction 作为参数，所以我们可以对异常的类型进行模式匹配：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f = askPong(<span class="string">&quot;causeError&quot;</span>).recover &#123;</span><br><span class="line">  <span class="keyword">case</span> t: <span class="type">Exception</span> =&gt; <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="异步地从失败中恢复"><a href="#异步地从失败中恢复" class="headerlink" title="异步地从失败中恢复"></a>异步地从失败中恢复</h5><p>我们经常需要在发生错误时使用另一个异步方法来恢复，例如下面是两个用例：</p>
<ul>
<li>重试某个失败的操作。</li>
<li>没有命中缓存时，需要调用另一个服务的操作。</li>
</ul>
<p>例如一则Java示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">askPong(<span class="string">&quot;cause error&quot;</span>)</span><br><span class="line">  .handle( (pong, ex) -&gt; ex == <span class="literal">null</span></span><br><span class="line">    ? CompletableFuture.completedFuture(pong)</span><br><span class="line">    : askPong(<span class="string">&quot;Ping&quot;</span>)</span><br><span class="line">  ).thenCompose(x -&gt; x);</span><br></pre></td></tr></table></figure>
<p>首先，检查exception是否为null。如果为null，就返回包含结果的Future，否则返回重试的Future。接着，调用thenCompose将CompletionStage[CompletionStage[String]]扁平化。<br>而在Scala中，我们要调用的函数是recoverWith：类似专门用于错误情况的flatMap。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">askPong(<span class="string">&quot;causeError&quot;</span>).recoverWith(&#123;</span><br><span class="line">  <span class="keyword">case</span> t: <span class="type">Exception</span> =&gt; askPong(<span class="string">&quot;Ping&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="组合Future"><a href="#组合Future" class="headerlink" title="组合Future"></a>组合Future</h5><p>在Java 中，可以使用CompletableFuture的thenCombine方法，在Future的值可用时访问到这些值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">askPong(<span class="string">&quot;Ping&quot;</span>)</span><br><span class="line">  .thenCombine(askPong(<span class="string">&quot;Ping&quot;</span>), (a,b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">//&quot;PongPong&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在Scala 中，也可以使用for推导式将多个Future组合起来。我们能够像处理任何其他集合一样，解析出两个Future 的结果并对它们进行处理。（要注意的是，这只不过是flatMap的一个“语法糖”）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：在scala中，这种语法非常灵活</span></span><br><span class="line"><span class="keyword">val</span> f1 = <span class="type">Future</span> &#123;<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">val</span> f2 = <span class="type">Future</span> &#123;<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">val</span> futureAddition: <span class="type">Future</span>[<span class="type">Int</span>] =</span><br><span class="line"><span class="keyword">for</span> (</span><br><span class="line">  res1 &lt;- f1;</span><br><span class="line">  res2 &lt;- f2</span><br><span class="line">) <span class="keyword">yield</span> res1 + res2</span><br></pre></td></tr></table></figure>

<h5 id="处理Future-List"><a href="#处理Future-List" class="headerlink" title="处理Future List"></a>处理Future List</h5><p><strong>注：</strong> 这个场景，我真没想到什么情况下会使用，暂时先跳过本小节阅读，记得在scala中有这么一种反转的处理方式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listOfFutures: <span class="type">List</span>[<span class="type">Future</span>[<span class="type">String</span>]] = <span class="type">List</span>(<span class="string">&quot;Pong&quot;</span>, <span class="string">&quot;Pong&quot;</span>, <span class="string">&quot;failed&quot;</span>).map(x =&gt; askPong(x))</span><br><span class="line"><span class="keyword">val</span> futureOfList: <span class="type">Future</span>[<span class="type">List</span>[<span class="type">String</span>]] = <span class="type">Future</span>.sequence(listOfFutures)</span><br></pre></td></tr></table></figure>

<h5 id="Future速查表"><a href="#Future速查表" class="headerlink" title="Future速查表"></a>Future速查表</h5><p><strong>注：</strong> 在书中提到的本小节涉及的一些Future操作<br><img data-src="b709cacd/future_collection_scala_java.png" alt="Future操作对应表"></p>
<h3 id="第三章-传递消息"><a href="#第三章-传递消息" class="headerlink" title="第三章 传递消息"></a>第三章 传递消息</h3><p>了解不同的消息模式，也就是在不同Actor 之间传递消息的不同方法。</p>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>有4种核心的Actor消息模式：tell、ask、forward 和pipe。我们已经了解过tell和ask，不过sender()都不是Actor。在这里，将从Actor之间发送消息的角度来介绍所有关于消息传递的概念。</p>
<ul>
<li>Ask：向Actor发送一条消息，返回一个Future。当Actor 返回响应时，会完成Future。不会向消息发送者的邮箱返回任何消息。</li>
<li>Tell：向Actor发送一条消息。所有发送至sender()的响应都会返回给发送消息的Actor。</li>
<li>Forward：将接收到的消息再发送给另一个Actor。所有发送至sender()的响应都会返回给原始消息的发送者。</li>
<li>Pipe：用于将Future的结果返回给sender()或另一个Actor。如果正在使用Ask或是处理一个Future，那么使用Pipe 可以正确地返回Future 的结果。</li>
</ul>
<h5 id="Ask消息模式"><a href="#Ask消息模式" class="headerlink" title="Ask消息模式"></a>Ask消息模式</h5><p>Ask模式会生成一个Future，表示Actor返回的响应。ActorSystem外部的普通对象与Actor进行通信时经常会使用这种模式。<br><strong>实际运作模式</strong><br>在调用ask 向Actor 发起请求时，Akka 实际上会在Actor 系统中创建一个临时Actor。接收请求的Actor 在返回响应时使用的sender()引用就是这个临时Actor。当一个Actor接收到ask 请求发来的消息并返回响应时，这个临时Actor 会使用返回的响应来完成Future。如下图所示：<br><img data-src="b709cacd/ask_communication.png" alt="Ask模式"><br>Ask模式要求定义一个超时参数，如果对方没有在超时参数限定的时间内返回这个ask的响应，那么Future就会返回失败。在Java中可以使用akka.util.Timeout来定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">import</span> akka.pattern.Patterns.ask;</span><br><span class="line"><span class="type">Timeout</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">akka</span>.util.Timeout(</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  java.util.concurrent.TimeUnit.SECONDS</span><br><span class="line">);</span><br><span class="line"><span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> ask(actor, message, timeout);</span><br></pre></td></tr></table></figure>
<p>在Scala中，则可以使用scala.concurrent.duration来定义Timeout。Scala的duration领域特定语言（Domain Specific Languages，DSL）很强大，允许用户直接使用1 second这样的方式来定义一段时间。在Scala中，ask 的超时参数是隐式传入的，这样有助于简化ask的语义，并且使得ask语句更为简洁：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"><span class="keyword">import</span> akka.pattern.ask</span><br><span class="line"><span class="comment">// 隐式写法</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> timeout = akka.util.<span class="type">Timeout</span>(<span class="number">1</span> second)</span><br><span class="line"><span class="keyword">val</span> future = actorRef ? <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="Tell"><a href="#Tell" class="headerlink" title="Tell"></a>Tell</h5><p>Tell是最简单的消息模式，不过要花上一些时间才能够学会这种模式的最佳实践。这也是为什么我们先介绍ask，再介绍tell的原因。Tell 通常被看做是一种“fire and forget”消息传递机制，无需指定发送者。不过通过一些巧妙的方法，也可以使用tell来完成“request/reply”风格的消息传递。如下图所示：<br><img data-src="b709cacd/tell_communication.png" alt="Tell模式"><br><strong>Tell是ActorRef/ActorSelection 类的一个方法。它也可以接受一个响应地址作为参数，接收消息的Actor 中的sender()其实就是这个响应地址。</strong> 在Scala 中，默认情况下，sender会被隐式定义为发送消息的Actor。如果没有sender（如在Actor 外部发起请求），那么响应地址不会默认设置为任何邮箱（叫做DeadLetters）。</p>
<p><strong>使用Tell处理响应</strong><br>由于在返回消息时可以访问到指向发送者的引用，所以要对某条消息做出响应是很容易的。不过，<em>在处理响应的时候，我们需要知道Actor收到的是哪一条消息的响应。</em> 如果我们在Actor中存储一些状态，记录Actor 希望收到响应的消息，那么就能够高效地向Actor发送请求，解决前面提到的ask模式的问题。</p>
<p><strong>我们可以在Actor中将一些上下文信息存储在一个map中，将map的key 放在消息中一起发送。然后，当有着相同key的消息返回时，就可以恢复上下文，完成消息的处理了。</strong><br><img data-src="b709cacd/actor_with_map_parameters.png" alt="Actor中传递Map参数"></p>
<h5 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h5><p>Tell在语义上是用于将一条消息发送至另一个Actor，并将响应地址设置为当前的Actor。而Forward 和邮件转发非常类似：<strong>初始发送者保持不变，只不过新增了一个收件人。</strong><br>在使用tell时，我们指定了一个响应地址，或是将响应地址隐式设为发送消息的Actor。而使用forward传递消息时，响应地址就是原始消息的发送者，如下图所示：<br><img data-src="b709cacd/actor_forword.png" alt="Forword模式"><br>有时候我们需要将接受到的消息传递给另一个Actor来处理，<strong>而最终的处理结果需要传回给初始发起请求的一方</strong>。此时forward是很有用的。<br><strong>处理过程：</strong> 处理中间步骤的Actor转发接收到的消息，或是发送一条新消息，但是仍然会将初始发送者与新消息一起发送。</p>
<h3 id="第四章-Actor的生命周期——处理状态与错误"><a href="#第四章-Actor的生命周期——处理状态与错误" class="headerlink" title="第四章 Actor的生命周期——处理状态与错误"></a>第四章 Actor的生命周期——处理状态与错误</h3><p>这一节介绍了几个有意思的点，这些点都是在目前工作中经常会遇到会涉及到，不排除需要着手去处理的场景</p>
<ul>
<li>分布式计算的误区（The Fallacies of Distributed Computing）</li>
<li>当Actor 运行失败时会发生什么；</li>
<li>如何通过监督Actor 来处理失败；</li>
<li>如何利用become()以及有限自动机来修改Actor 的行为。</li>
</ul>
<h4 id="分布式计算的8个误区"><a href="#分布式计算的8个误区" class="headerlink" title="分布式计算的8个误区"></a>分布式计算的8个误区</h4><p>分布式计算误区由Sun Microsystems的一个团队总结出来，包含缺乏经验的开发者对于在网络上通信的系统的一些错误的假设。<br>具体场景可以参考维基百科上具体细节<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">Fallacies_of_distributed_computing</a></p>
<h5 id="网络是可靠的（The-network-is-reliable）"><a href="#网络是可靠的（The-network-is-reliable）" class="headerlink" title="网络是可靠的（The network is reliable）"></a>网络是可靠的（The network is reliable）</h5><p>我们很容易会用和处理本地系统相同的方式来处理远程系统，也就会像跟本地Actor进行交互一样和远程Actor 进行交互。而Akka在这个错误的假设上更进一步，通过提高网络通信的抽象层次为我们提供了位置透明性。</p>
<h5 id="没有延迟（Latency-is-zero）"><a href="#没有延迟（Latency-is-zero）" class="headerlink" title="没有延迟（Latency is zero）"></a>没有延迟（Latency is zero）</h5><h5 id="带宽是无限的（Bandwidth-is-infinite）"><a href="#带宽是无限的（Bandwidth-is-infinite）" class="headerlink" title="带宽是无限的（Bandwidth is infinite）"></a>带宽是无限的（Bandwidth is infinite）</h5><p>在大型的分布式系统中，经常会使用能够在CPU上快速执行的压缩算法，比如Snappy和LZO（例如，Cassandra将LZO 用于节点内部的通信）。如果要将对这一点的考虑实际应用到数据库中，就要通过压缩来减少消息的大小。压缩也是有开销的：它会消耗CPU 资源。有一些专用的算法把重点放在压缩效率，而非压缩比上。<strong>我们可以使用其中之一（比如Snappy），在将序列化后的消息发送到远程Actor前先对其进行压缩，接收到消息后先解压缩，再反序列化。</strong></p>
<h5 id="网络是安全的（The-network-is-secure）"><a href="#网络是安全的（The-network-is-secure）" class="headerlink" title="网络是安全的（The network is secure）"></a>网络是安全的（The network is secure）</h5><h5 id="网络拓扑不会改变（Topology-doesn’t-change）"><a href="#网络拓扑不会改变（Topology-doesn’t-change）" class="headerlink" title="网络拓扑不会改变（Topology doesn’t change）"></a>网络拓扑不会改变（Topology doesn’t change）</h5><h5 id="只有一个管理员（There-is-one-administrator）"><a href="#只有一个管理员（There-is-one-administrator）" class="headerlink" title="只有一个管理员（There is one administrator）"></a>只有一个管理员（There is one administrator）</h5><h5 id="网络传输没有开销（Transport-cost-is-zero）"><a href="#网络传输没有开销（Transport-cost-is-zero）" class="headerlink" title="网络传输没有开销（Transport cost is zero）"></a>网络传输没有开销（Transport cost is zero）</h5><h5 id="网络是同构的（The-network-is-homogeneous）"><a href="#网络是同构的（The-network-is-homogeneous）" class="headerlink" title="网络是同构的（The network is homogeneous）"></a>网络是同构的（The network is homogeneous）</h5><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>使用Akka的一个附带的好处就是容错性。（oh，笔者在目前老框架架构下，似乎并没有很好的处理好相应的功能）</p>
<h5 id="隔离错误"><a href="#隔离错误" class="headerlink" title="隔离错误"></a>隔离错误</h5><p>先了解一些在分布式应用程序中都应该遵循的通用策略：<strong>隔离错误。</strong><br>假设每个组件都是一个定时炸弹，那么我们希望能够确保无论其中任何一个发生爆炸，都不会引发链式反应，导致其他组件也爆炸。也可以说，我们希望能够隔离错误，或是将可能引发失败情况的组件分离开来。</p>
<p><strong>冗余</strong><br>保持系统在发生错误时仍能运行的方法之一就是实现各组件的冗余性，确保不存在单点故障。假设我们有一个服务，那么有多种方法可以通过冗余设计来保证服务的高可用性。</p>
<h4 id="监督"><a href="#监督" class="headerlink" title="监督"></a>监督</h4><p><strong>Erlang将容错性引入了Actor模型，它使用的概念叫做监督（supervision）</strong>。监督的核心思想就是把对于失败的响应和可能引起失败的组件分隔开，并且把可能发生错误的组件通过层级结构来组织，以便管理。<br><strong>监督的层级结构</strong><br>Akka使用Actor层级结构来描述监督。当我们创建Actor时，新建的Actor都是作为另一个Actor的子Actor，父Actor负责监督子Actor。Actor的路径结构就展示了它的层级结构，所以和文件系统中的文件夹有点像。<br><strong>监督策略</strong></p>
<ul>
<li>继续（resume）：Actor继续处理下一条消息</li>
<li>停止（stop）：停止Actor，不再做任何操作</li>
<li>重启（restart）：新建一个Actor，代替原来的Actor</li>
<li>向上反映（escalate）：将异常信息传递给下一个监督者。</li>
</ul>
<h5 id="定义监督策略"><a href="#定义监督策略" class="headerlink" title="定义监督策略"></a>定义监督策略</h5><p>Actor有默认的监督策略。如果没有修改监督策略，那么监督Actor的行为基本上和如下场景：</p>
<ul>
<li>Actor 运行过程中抛出异常：restart()；</li>
<li>Actor 运行过程中发生错误：escalate()；</li>
<li>Actor 初始化过程中发生异常：stop()。</li>
</ul>
<p>在默认监督策略中还定义了另一种情况：ActorKilledException。如果Actor 被“杀”（kill）了，那么这个Actor 的监督者会接收到一个ActorKilledException，执行stop()会接收到该异常。</p>
<p>在Java中定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java中通过DeciderBuilder来创建一个Scala的PartialFunction，用于表示策略。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> akka.actor.SupervisorStrategy <span class="title function_">supervisorStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OneForOneStrategy</span>(<span class="number">5</span>, Duration.create(<span class="string">&quot;1 minute&quot;</span>),</span><br><span class="line">    akka.japi.pf.DeciderBuilder</span><br><span class="line">    .match(BrokenPlateException.class, e -&gt; SupervisorStrategy.resume())</span><br><span class="line">    .match(DrunkenFoolException.class, e -&gt; SupervisorStrategy.restart())</span><br><span class="line">    .match(RestaurantFireError.class, e -&gt; SupervisorStrategy.escalate())</span><br><span class="line">    .match(TiredChefException.class, e -&gt; SupervisorStrategy.stop())</span><br><span class="line">    .matchAny(e -&gt; SupervisorStrategy.escalate())</span><br><span class="line">    .build()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在scala中要相对简洁一点：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Scala的例子中，我们还是重写Actor的supervisorStrategy方法，然后定义一个PartialFunction，匹配抛出的异常，并返回Directive</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">supervisorStrategy</span> </span>= &#123;</span><br><span class="line">  <span class="type">OneForOneStrategy</span>() &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">BrokenPlateException</span> =&gt; <span class="type">Resume</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">DrunkenFoolException</span> =&gt; <span class="type">Restart</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">RestaurantFireError</span> =&gt;<span class="type">Escalate</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">TiredChefException</span> =&gt; <span class="type">Stop</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">Escalate</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Actor生命周期"><a href="#Actor生命周期" class="headerlink" title="Actor生命周期"></a>Actor生命周期</h5><p>在Actor 的生命周期中会调用几个方法，我们在需要时可以重写这些方法:</p>
<ul>
<li>prestart()：在构造函数之后调用。</li>
<li>postStop()：在重启之前调用。</li>
<li>preRestart(reason, message)：默认情况下会调用postStop()。</li>
<li>postRestart()：默认情况下会调用preStart()。</li>
</ul>
<p>在Actor生命周期中个事件的发生顺序如下图所示：<br><a href="b709cacd/actor_lifecycle.png">Actor生命周期调用</a><br><strong>注意</strong><br>要注意的是preRestart和postRestart只在重启的时候才会被调用。它们默认调用了preStart和postStop，但是调用它们的时候就不再直接调用preStart和postStop了。这样我们就能够决定，到底是只在Actor启动或停止的时候调用一次preStart和postStop，还是每次重启一个Actor的时候就调用preStart和postStop。</p>
<p><strong>重启和停止时的消息处理</strong><br>我们可以定义监督策略，在抛出异常前重新尝试发送失败的消息，重试次数没有限制。也可以设置时间限制，比如最多重试10 次或1 分钟，只要达到其中任一限制就停止重试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">OneForOneStrategy</span>(<span class="number">2</span>, <span class="type">Duration</span>.create(<span class="string">&quot;1 minute&quot;</span>), <span class="type">PartialFunction</span>)</span><br><span class="line">  <span class="type">OneForOneStrategy</span>(</span><br><span class="line">  maxNrOfRetries = <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">IOException</span> =&gt; <span class="type">Restart</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>终止或kill一个Actor</strong><br>有多种不同的方法可以用来停止一个Actor。下面任一方法都可以停止Actor：</p>
<ul>
<li>调用ActorSystem.stop(actorRef)；</li>
<li>调用ActorContext.stop(actorRef)；</li>
<li>给Actor发送一条PoisonPill消息，会在Actor完成消息处理后将其停止；</li>
<li>给Actor发送一条kill消息，会导致Actor抛出ActorKilledException异常</li>
</ul>
<p><strong>生命周期监控和DeathWatch</strong><br>监督机制描述了如何对子Actor的状态进行响应。而Actor也可以对其他任何Actor进行监督。通过调用context.watch(actorRef)注册后，Actor就能够监控另一个Actor的终止，而调用context.unwatch(actorRef)就可以取消监控注册。如果被监控的Actor停止了，负责监控的Actor就会收到一条Terminated(ActorRef)消息。</p>
<p><strong>安全重启</strong><br>有时候：有一种情况是：如果Actor已经处在运行中，那么就能够安全地重新启动；但是如果无法完成初始化，我们就必须编写额外的代码实现监督策略，来处理Actor无法在启动时连接到数据库的情况。</p>
<p>很多时候，我们不希望Actor在初始化的过程中发生错误，而是会给Actor发送一条初始化消息，然后在Actor运行的过程中处理状态的变化。可以在preStart()中向Actor自己发送一条Connect消息来达到这一效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preStart</span><span class="params">()</span> &#123;</span><br><span class="line">  self().tell(<span class="keyword">new</span> <span class="title class_">Connect</span>(), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span> </span>= self ! <span class="type">Connect</span></span><br></pre></td></tr></table></figure>
<p>这样一来，Actor 只在运行中才可能会出现错误，而且能够成功重启。所以就可以不断尝试连接数据库直到连上为止了。</p>
<p>有一个很重要的地方需要注意：上面的介绍中还没有涉及到一些细节和问题。<strong>首先，我们没有处理Actor 在连接成功之前接收到的消息；其次，如果Actor长时间无法连接的话，邮箱可能会被填满。</strong></p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>我们可以使用几种不同的机制来改变Actor的行为：</p>
<ul>
<li>基于Actor 状态的条件语句；</li>
<li>热交换（Hotswap）：become()和unbecome()；</li>
<li>有限自动机</li>
</ul>
<h5 id="在线-离线状态"><a href="#在线-离线状态" class="headerlink" title="在线/离线状态"></a>在线/离线状态</h5><p><strong>在状态之间暂存消息（stash）</strong><br>Actor也经常会处在一个无法处理某些消息的状态。如果数据库客户端离线了，那么在重新上线之前，它都无法处理任何消息。我们可以选择不断重新建立客户端的连接，直到连接成功为止。在这种情况下，在成功连接之前，客户端会丢弃收到的所有消息。另一种做法是把客户端无法处理的消息先放在一旁，等到客户端恢复连接状态之后再做处理。</p>
<p>Akka提供了一种叫做 <strong>stash的机制</strong> 来支持这一功能。stash 消息会把消息暂存到一个独立的队列中，该队列中存储目前无法处理的消息，例如下面的java伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cantHandleMessage) &#123;</span><br><span class="line">  <span class="comment">// 通过stash来进行消息暂存在队列中</span></span><br><span class="line">  stash();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  handleMessage(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unstash则把消息从暂存队列中取出，放回邮箱队列中，Actor就能继续处理这些消息了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">changeStateToOnline();</span><br><span class="line">unstash();</span><br><span class="line">To use stash in Java, your Actor will extend AbstractActorWithStash:</span><br><span class="line">class RemoteActorProxy extends AbstractActorWithStash &#123;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br><span class="line">To use stash in Scala, you mix in the stash trait:</span><br><span class="line">class RemoteActorProxy extends Actor with Stash &#123;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>虽然stash()和unstash()在希望快速改变状态的时候使用起来非常方便，但是stash消息的状态一定要和某个时间限制进行绑定，否则就有可能填满邮箱。</p>
<h5 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h5><p>在这个示例中，展示了怎么通过一个条件语句判断的方式，结合stash和unstatsh方法来处理未处理的消息。<br>java示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">online</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> PartialFunction <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> RecieveBuilder</span><br><span class="line">    .match(GetRequest.class, x -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(online) &#123;</span><br><span class="line">          <span class="comment">// 如果连接成功了，直接处理消息</span></span><br><span class="line">          processMessage(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 否则将消息statsh到队列中</span></span><br><span class="line">          stash();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    .match(Connected.class, x -&gt; &#123;</span><br><span class="line">      online = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 等到连接成功之后，在进行unstash操作，处理之前未处理的消息</span></span><br><span class="line">      unstash();</span><br><span class="line">    &#125;)</span><br><span class="line">    .match(Disconnected.class, x -&gt; online = <span class="literal">false</span>)</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相比java代码需要减少很多</span></span><br><span class="line"><span class="keyword">var</span> online = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">case</span> x: <span class="type">GetRequest</span> =&gt;</span><br><span class="line">    <span class="keyword">if</span>(online)</span><br><span class="line">      processMessage(x)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      stash()</span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">Connected</span> =&gt;</span><br><span class="line">    online = <span class="literal">true</span></span><br><span class="line">    unstash()</span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">Disconnected</span> =&gt;</span><br><span class="line">    online = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多时候，Actor会存储状态，然后根据这个状态值的不同会有不同的行为。使用条件语句是一种非常过程化的用于处理行为和状态的方法。 <em>幸运的是，Akka还提供了一些更好的选择。</em></p>
<h5 id="热交换（Hotswap）：Become-Unbecome"><a href="#热交换（Hotswap）：Become-Unbecome" class="headerlink" title="热交换（Hotswap）：Become/Unbecome"></a>热交换（Hotswap）：Become/Unbecome</h5><p>使用条件语句的代码 <strong>并不是很优雅</strong>，这种写法显然不是声明式的。Akka 提供了become()和unbecome()，用于管理不同的行为，这一用法可以大大改善代码的可读性。在Actor的context()中，有两个方法：</p>
<ul>
<li>become(PartialFunction behavior)：这个方法将receive块中定义的行为修改为一个新的PartialFunction。</li>
<li>unbecome()：这个方法将Actor的行为修改回默认行为。</li>
</ul>
<p>前面那个数据库链接的例子优化之后，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PartialFunction <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> RecieveBuilder</span><br><span class="line">    .match(GetRequest.class, x -&gt; stash())</span><br><span class="line">    .match(Connected.class, x -&gt; &#123;</span><br><span class="line">      context().become(online);</span><br><span class="line">      unstash();</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> PartialFunction&lt;Object, BoxedUnit&gt; <span class="title function_">online</span><span class="params">(<span class="keyword">final</span> ActorRef another)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> RecieveBuilder</span><br><span class="line">    .match(GetRequest.class, x -&gt; processMessage(x))</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同功能的scala代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">case</span> x: <span class="type">GetRequest</span> =&gt;</span><br><span class="line">    stash()</span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">Connected</span> =&gt;</span><br><span class="line">    become(online)</span><br><span class="line">    unstash()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">online</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">  <span class="keyword">case</span> x: <span class="type">GetRequest</span> =&gt;</span><br><span class="line">    processMessage(x)</span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">Disconnected</span> =&gt;</span><br><span class="line">    unbecome()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于条件语句，这种写法可读性更高。每个状态的行为都定义在自己独立的PartialFunction中。在PartialFunction 中，使用模式匹配来定义不同的行为。这样我们就能够互不影响地阅读Actor中不同状态的行为。</p>
<p><strong>stash泄露</strong><br>上面使用stash 的例子有一个问题：如果要花很长时间才能接收到Connected消息，或者压根就收不到Connected消息，那么Actor就会不断地stash消息，最终导致应用程序内存耗尽，或者导致邮箱开始丢弃消息（后面的章节中会介绍邮箱）。<br>我们可以在Actor的构造函数或preStart方法中调度执行这个消息。接收到这个消息之后，就检查Actor是否已经连接。如果还没有连接，那么Actor就可以向上反映问题，由监督者来采取措施：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">system.scheduler().scheduleOnce(</span><br><span class="line">  Duration.create(<span class="number">1000</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">  self(),</span><br><span class="line">  CheckConnected,</span><br><span class="line">  system.dispatcher(),</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果Actor接收到消息时已经在线，那么就忽略该消息。如果Actor接收到消息处在离线状态，就会抛出一个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.match(CheckConnected.class, msg -&gt;throw new ConnectTimeoutException())</span><br><span class="line">case _:</span><br><span class="line">  CheckConnected =&gt; throw new ConnectTimeoutException</span><br></pre></td></tr></table></figure>

<p><strong>有限自动机（Finite State Machine，FSM）</strong><br>还有另一个工具可以用来处理Actor 中的状态：有限自动机（Finite State Machine,FSM）。和热交换很相似的是，FSM中也有状态以及基于状态的行为变化。跟热交换比起来，FSM是一个更重量级的抽象概念，需要更多的代码和类型才能够实现并运行。所以通常来说，<strong>热交换是一个更简单、可读性更高的选择</strong>。<br><strong>注：</strong> 暂时先了解，akka支持比较重的这种控制actor状态的方式。</p>
<h3 id="纵向扩展"><a href="#纵向扩展" class="headerlink" title="纵向扩展"></a>纵向扩展</h3><h4 id="使用Dispatcher"><a href="#使用Dispatcher" class="headerlink" title="使用Dispatcher"></a>使用Dispatcher</h4><h5 id="Dispatcher解析"><a href="#Dispatcher解析" class="headerlink" title="Dispatcher解析"></a>Dispatcher解析</h5><p>Dispatcher将如何执行任务与何时运行任务两者解耦。一般来说，Dispatcher会包含一些线程，这些线程会负责调度并运行任务，比如处理Actor的消息以及线程中的Future事件。Dispatcher是Akka 能够支持响应式编程的关键，是负责完成任务的机制。<br>Dispatcher负责将工作分配给Actor。除此之外Dispatcher还可以分配资源用于处理Future的回调函数。我们会发现Future API 接受Executor/ExecutionContext作为参数。由于Akka的Dispatcher扩展了这些API，因此Dispatcher具备双重功能。</p>
<h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>ThreadPool Executor有一个工作队列，队列中包含了要分配给各线程的工作。线程空闲时就会从队列中认领工作。由于线程资源的创建和销毁开销很大，而ThreadPool允许线程的重用，所以就可以减少创建和销毁线程的次数，提高效率。<br>ForkJoinPool Executor使用一种 <strong>分治算法，递归地将任务分割成更小的子任务</strong>，然后把子任务分配给不同的线程运行。接着再把运行结果组合起来。由于提交的任务不一定都能够被递归地分割成ForkJoinTask，所以ForkJoinPool Executor 有一个工作窃取算法，允许空闲的线程“窃取”分配给另一个线程的工作。由于工作可能无法平均分配并完成，所以工作窃取算法能够更高效地利用硬件资源。</p>
<h5 id="创建Dispatcher"><a href="#创建Dispatcher" class="headerlink" title="创建Dispatcher"></a>创建Dispatcher</h5><p><strong>注：</strong> 这一小节介绍的东西非常进阶，实际可能有很少实际业务场景会用到，但是从框架层面，会经常看到<br>有四种类型的Dispatcher可以用于描述如何在Actor之间共享线程：</p>
<ul>
<li>Dispatcher：默认的Dispatcher类型。将会使用定义的Executor，在Actor中处理消息。在大多数情况下，这种类型能够提供最好的性能。</li>
<li>PinnedDispatcher：给每个Actor都分配自己独有的线程。这种类型的Dispatcher为每个Actor都创建一个ThreadPoolExecutor，每个Executor中都包含一个线程。如果希望确保每个Actor都能够立即响应，那么这似乎是个不错的方法。不过PinnedDispatcher比其他共享资源的方法效率更高的情况其实并不多。可以在单个Actor必须处理很多重要工作的时候试试这种类型的Dispatcher，否则的话不推荐使用。</li>
<li>CallingThreadDispatcher：这个Dispatcher比较特殊，它没有Executor，而是在发起调用的线程上执行工作。这种Dispatcher主要用于测试，特别是调试。由于发起调用的线程负责完成工作，所以清楚地看到栈追踪信息，了解所执行方法的完整上下文。这对于理解异常是非常有用的。每个Actor会获取一个锁，所以每次只有一个线程可以在Actor中执行代码，而如果多个线程向一个Actor发送信息的话，就会导致除了拥有锁的线程之外的所有线程处于等待状态。本书前面介绍过的TestActorRef就是基于CallingThreadDispatcher实现支持在测试中同步执行工作的。</li>
<li>BalancingDispatcher：我们会在一些Akka文档中看到BalancingDispatcher。<strong>现在已经不推荐直接使用BalancingDispatcher了</strong>，应该使用前面介绍过的BalancingPoolRouter。不过Akka中仍然使用了BalancingDispatcher，但是只会通过Router间接使用。我们会在“用于解析文章的Dispatcher”小节中介绍BalancingPool的实际用法。BalancingDispatcher有一点很特殊：Pool中的所有Actor都共享同一个邮箱，并且会为Pool中的每个Actor都创建一个线程。使用BalancingDispatcher的Actor从邮箱中拉取消息，所以只要有Actor处于空闲状态，就不会有任何Actor的工作队列中存在任务。这是工作窃取的一个变种，所有Actor都会从一个共享的邮箱中拉取任务。两者在性能上的优点也类似。</li>
</ul>
<h5 id="决定何时使用哪种Dispatcher"><a href="#决定何时使用哪种Dispatcher" class="headerlink" title="决定何时使用哪种Dispatcher"></a>决定何时使用哪种Dispatcher</h5><p>进行纵向扩展的第一步是理解哪 <strong>些情况的响应即时性最重要</strong>，以及对这些重要的请求做出响应时可 <strong>能会发生资源竞争的地方</strong>。</p>
<p><strong>可以把用于运行高风险任务的资源和运行重要任务的资源隔离开来。</strong> 如果我们新建一些Dispatcher，把运行时间较长或是会阻塞线程的任务都分配给这些Dispatcher，就可以确保应用程序的剩余部分仍然能够保持响应的即时性。我们希望能够把所有需要大量计算、运行时间较长的任务分离到单独的Dispatcher中，确保在糟糕的情况下仍然能够有资源去运行其他任务。</p>
<p>要创建或使用默认Dispatcher/ThreadPool 的话，其实不需要做什么。如果需要的话，只要在classpath内的application.conf文件中定义并配置默认Dispatche 即可。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    default-dispatcher &#123;</span><br><span class="line">      # Min number of threads to cap factor-based parallelism number to</span><br><span class="line">      parallelism-min = 8</span><br><span class="line">      # The parallelism factor is used to determine thread pool size using the</span><br><span class="line">      # following formula: ceil(available processors * factor). Resulting size</span><br><span class="line">      # is then bounded by the parallelism-min and parallelism-max values.</span><br><span class="line">      parallelism-factor = 3.0</span><br><span class="line">      # Max number of threads to cap factor-based parallelism number to</span><br><span class="line">      parallelism-max = 64</span><br><span class="line">      # Throughput for default Dispatcher, set to 1 for as fair as possible</span><br><span class="line">      throughput = 10</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在自己的application.conf文件中定义任意值，覆盖默认配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    default-dispatcher &#123;</span><br><span class="line">      # Throughput for default Dispatcher, set to 1 for as fair as possible</span><br><span class="line">      throughput = 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，Actor完成的所有工作都会在这个Dispatcher中执行。如果需要回去ExecutionContext 并在其中创建Future，那么可以通过ActorSystem访问到默认的线程池，然后将其传递给Future：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActorSystem</span> system = <span class="type">ActorSystem</span>.create();</span><br><span class="line"><span class="type">CompletableFuture</span>.runAsync(() -&gt;<span class="type">System</span>.out.println(<span class="string">&quot;run in ec&quot;</span>), system.dispatcher());</span><br><span class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> ec = system.dispatcher</span><br><span class="line"><span class="keyword">val</span> future = <span class="type">Future</span>(() =&gt; println(<span class="string">&quot;run in ec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 对于在默认Dispatcher中的Future执行的操作要小心，这些操作会消耗Actor 自身的时间。在下一小节中，我们将介绍如何解决这个问题。</p>
<p>在Scala中，<strong>扩展了Actor的类中已经包含了一个implicit val的Dispatcher，所以在Actor中使用Future 的时候就不需要再指定Dispatcher了。</strong> 不过在Actor 中使用Future 的情况其实不是很多，要记住相对于ask，应该优先使用tell。所以如果发现有好多在Actor中使用Future 的情况，那么可能需要衡量一下方法是否合理。</p>
<h5 id="使用Future的阻塞IO-Dispatcher"><a href="#使用Future的阻塞IO-Dispatcher" class="headerlink" title="使用Future的阻塞IO Dispatcher"></a>使用Future的阻塞IO Dispatcher</h5><h3 id="第6章-横向扩展——集群化"><a href="#第6章-横向扩展——集群化" class="headerlink" title="第6章 横向扩展——集群化"></a>第6章 横向扩展——集群化</h3><h4 id="集群定义"><a href="#集群定义" class="headerlink" title="集群定义"></a>集群定义</h4><p>集群就是一组可以互相通信的服务器。集群中的每台服务器成为一个节点或成员。集群可以动态修改大小，并且在发生错误情况时继续运行，把影响降到最低。所以集群需要具备两个功能：<strong>失败发现以及使得集群中的所有成员最终能够提供一致的视图。</strong></p>
<h5 id="失败检测"><a href="#失败检测" class="headerlink" title="失败检测"></a>失败检测</h5><p>如果集群中的每台服务器都需要和其他所有服务器进行通信，那么集群的性能不会随着节点的增加而线性提高。原因在于每增加一个节点，需要的通信开销都会指数增加。为了降低监控其他节点健康程度的复杂度，<strong>Akka中的失败检测只会监控</strong> 某个节点附近特定数目的节点。<br><strong>检测过程</strong><br>在Akka中，失败检测是通过在节点间发送心跳消息并接收响应来完成的。Akka会根据 <strong>心跳的历史记录</strong> 以及当前的心跳信息计算出某个节点可用的可能性。Akka会依照这些数据和配置的容错限制得到计算结果，然后将节点标记为可用或不可用。</p>
<h5 id="通过gossip协议达到最终一致性"><a href="#通过gossip协议达到最终一致性" class="headerlink" title="通过gossip协议达到最终一致性"></a>通过gossip协议达到最终一致性</h5><p>这种最终把状态传递给整个集群的机制叫做gossip协议或是epidemic协议（因为信息在集群中的传播就像病毒一样！）。许多最终一致性的数据库（比如Riak 和Cassandra）的实现方式都非常类似。在这些数据库中，Amazon发表的关于Dynamo 的论文影响力非常大。</p>
<h4 id="使用Akka-Cluster构建系统"><a href="#使用Akka-Cluster构建系统" class="headerlink" title="使用Akka Cluster构建系统"></a>使用Akka Cluster构建系统</h4><h5 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h5><p>两个引用包：akka-cluster、akka-contrib（一个非官方扩展工具包），一则默认使用配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    provider = &quot;akka.cluster.ClusterActorRefProvider&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  remote &#123;</span><br><span class="line">    netty.tcp &#123;</span><br><span class="line">      hostname = &quot;127.0.0.1&quot;</span><br><span class="line">      port = 2552</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cluster &#123;</span><br><span class="line">    seed-nodes = [</span><br><span class="line">      &quot;akka.tcp://Akkademy@127.0.0.1:2552&quot;,</span><br><span class="line">      &quot;akka.tcp://Akkademy@127.0.0.1:2551&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">  // contrib包中cluster客户端支持</span><br><span class="line">  extensions = [&quot;akka.contrib.pattern.ClusterReceptionistExtension&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>种子节点</strong><br><strong>点加入集群的方式</strong>。当一个新节点加入集群时，该节点会尝试连接第一个种子节点。如果成功连接种子节点，新节点就会发布其地址（主机和端口）。种子节点会负责通过gossip协议将新节点的地址最终通知整个集群。如果连接第一个种子节点失败，新节点就会尝试连接第二个种子节点。只要成功连接任何一个种子节点，那么任何节点加入或离开集群时，我们都不需要对配置进行任何修改。</p>
<p>当部署到生产环境时，应该至少定义两个拥有固定IP的种子节点，并且保证任何时候都至少有一个种子节点可用。当一个节点尝试加入集群时，会试图顺序连接种子节点。如果所有的种子节点都不可用，那么新节点将无法加入到集群。</p>
<p><strong>订阅集群事件</strong></p>
<h3 id="第7章-处理邮箱问题"><a href="#第7章-处理邮箱问题" class="headerlink" title="第7章 处理邮箱问题"></a>第7章 处理邮箱问题</h3><p><strong>注：</strong> 本章是对于极端场景，Actor邮箱优化的具体实践，暂时不作具体深入了解。</p>
<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul>
<li>《Scala编程》</li>
<li>《响应式架构 消息模式Actor实现与ScalaAkka应用集成》</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>[1] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20832218">Scala中的Partial Function</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>nimbusk
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://nimbusk.cc/post/b709cacd.html" title="Scala&amp;Akka学习纪要">https://nimbusk.cc/post/b709cacd.html</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Akka/" rel="tag"># Akka</a>
              <a href="/tags/Scala/" rel="tag"># Scala</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/178a5861.html" rel="prev" title="Hexo建站">
                  <i class="fa fa-angle-left"></i> Hexo建站
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/f73b2f1e.html" rel="next" title="Scala编程">
                  Scala编程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">nimbusk</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.1/mermaid.min.js","integrity":"sha256-YbM1pG3wWnzhyYN49g5fPnen+2CKEFaZfopkkwSpNtY="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"nimbusking","repo":"blog_comments","client_id":"3ba56d7e4658bddb03ae","client_secret":"7f7dae0b54cbd02df9ced28e9f1ce739f94e33d4","admin_user":"nimbusking","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en|zh-CN|zh-TW","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"7ae105a17c7a970fe68304c0ba524188"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
