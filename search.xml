<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入学习Java并发</title>
    <url>/post/181e5700.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>罗列java并发体系中的点点滴滴<br>整体并发体系可以参考下图知识图谱所示，未来一些边边角角持续更新中</p>
<span id="more"></span>
<p><img data-src="181e5700/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.jpg" alt="Java并发知识体系"></p>
<h2 id="理论相关"><a href="#理论相关" class="headerlink" title="理论相关"></a>理论相关</h2><h3 id="并发三大特性"><a href="#并发三大特性" class="headerlink" title="并发三大特性"></a>并发三大特性</h3><p>并发编程BUG的源头，都归纳为三个问题：<strong>可见性、原子性与有序性</strong>问题</p>
<h3 id="JMM相关"><a href="#JMM相关" class="headerlink" title="JMM相关"></a>JMM相关</h3><p>Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。<br>JMM规范了Java虚拟机与计算机内存是如何协同工作的：<strong>规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</strong><br>JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式。<br><strong>JMM是围绕原子性、有序性、可见性展开的。</strong></p>
<p><img data-src="181e5700/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="JMM内存模型示意图"></p>
<h4 id="关联两个疑问"><a href="#关联两个疑问" class="headerlink" title="关联两个疑问"></a>关联两个疑问</h4><ol>
<li>本地内存中的变量数据什么时候刷新到主内存中？答：不会立马刷新，而是有一定时间。</li>
<li>本地内存中的变量数据什么时候会失效？答：有缓存淘汰时间，淘汰之后会立马read主内存中新的值。<br>例子中，使用Thread.yield()也可以保证可见，原因：这个方法释放了当前线程的CPU时间片，即存在上下文切换过程，再次获得时间片的时候，会加载上下文，因此会重新读主内存中的值。</li>
</ol>
<h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h3><p><strong>当一个线程修改了共享变量的值，其他线程能够看到修改的值。</strong><br>Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。<br>如何保证内存可见性：</p>
<ul>
<li>通过 volatile 关键字保证可见性。</li>
<li>通过 内存屏障保证可见性。<ul>
<li>UnsafeFactory.getUnsafe().storeFence()，与volatile底层是同一个实现，所以可以。</li>
</ul>
</li>
<li>通过 synchronized 关键字保证可见性。能够的原因：底层还是靠storeFence内存屏障实现的。<ul>
<li>System.out.println(); // 这个里面是有syn同步块的</li>
</ul>
</li>
<li>通过 Lock保证可见性。<ul>
<li>LockSupport.unpark(Thread.currentThread()); // 底层还是内存屏障</li>
</ul>
</li>
<li>通过 final 关键字保证可见性<ul>
<li>比如包装器类，例如Integer，比较特殊，这个也可以。</li>
</ul>
</li>
</ul>
<h4 id="Java中如何保障"><a href="#Java中如何保障" class="headerlink" title="Java中如何保障"></a>Java中如何保障</h4><p>从底层本质归纳起来两种，一种是在JVM层面调用storeFence()内存屏障；另一种就是实现上下文切换。<br>volatile关键字可以保证可见性原因：</p>
<ul>
<li>JVM内存屏障，storeLoad来实现；底层汇编：lock前缀; addl</li>
</ul>
<h3 id="缓存一致性协议-MESI"><a href="#缓存一致性协议-MESI" class="headerlink" title="缓存一致性协议-MESI"></a>缓存一致性协议-MESI</h3><p>通过缓存中数据（Cache Line）施加4个状态，来达到缓存一致性目的：M-修改；E-独占；S-共享；I-失效。<br>当失效的时候，高速缓存会立即加载主内存；<br>注：TODO  可以搜一下这个实现的状态机<br><img data-src="181e5700/MESI%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC%E9%97%AE%E9%A2%98.png" alt="MESI协议状态流转问题"></p>
<p><strong>存在两个问题：</strong></p>
<ol>
<li>如果存在跨缓存行的时候，一致性协议有问题</li>
<li>早期处理器是没有实现缓存一致性协议（<em>不同处理器同时向总线发起总线事务， 通过总线仲裁实现，代价非常大，了解</em>）</li>
</ol>
<h3 id="关于伪共享"><a href="#关于伪共享" class="headerlink" title="关于伪共享"></a>关于伪共享</h3><p>伪共享的本质原因：因为缓存行（Cache Line），linux下默认64字节。当程序的不同变量，在同一个缓存行的时候，不同线程处理对应变量的时候，会造成相互干扰（参考MESI），导致频繁的失效要重新读取，性能严重下降。<br><img data-src="181e5700/%E4%BC%AA%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="伪共享内存交互示意图"><br>上图对应的程序代码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pointer</span> &#123;</span><br><span class="line">	volatie <span class="type">long</span> x;</span><br><span class="line">	volatie <span class="type">long</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 起两个线程，分别对x、y进行累加动作</span></span><br></pre></td></tr></table></figure>
<h4 id="避免伪共享"><a href="#避免伪共享" class="headerlink" title="避免伪共享"></a>避免伪共享</h4><ol>
<li><p><strong>手动填充缓存行</strong>：通过在变量之间插入填充变量（padding），可以将不同的变量分配到不同的缓存行中，从而避免伪共享问题。例如，在多线程环境下访问两个变量a和b，如果它们位于同一个缓存行中，可以在它们之间插入一个long类型的变量c，从而让a和b分别被存储到不同的缓存行中，避免了缓存行的竞争。</p>
</li>
<li><p>使用JDK8提供的<code>@sun.misc.Contended</code>注解：在JDK8中，@sun.misc.Contended注解可以用来避免伪共享问题。这个注解只能用于类和属性，并且需要手动启用JVM的-XX:-RestrictContended参数。使用该注解后，JVM会自动为相关变量添加填充字节，确保它们不会位于同一个缓存行中。</p>
</li>
<li><p><strong>使用OpenMP的归约子句（reduction）</strong>：在并行编程中使用OpenMP的归约子句（reduction），可以将多个线程的变量合并到一个共享变量中，从而减少缓存行的冲突。这种方法不同于数据填充进行边界对齐的方式，代码中不再将结果声明为数组而是声明为普通变量，使用reduction子句会使得每个线程都有一个变量，通过指定的运算符进行归约计算。</p>
</li>
</ol>
<p><strong>注：这个只作为了解即可</strong>，有这么个设计泛型，目前支持OpenMP的只有：C、C++和Fortran。有兴趣的可以去看看该模型的specification，<a href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-5-2.pdf">地址</a>。在Java中，有前面两个功能即可。</p>
<h2 id="Java线程模型相关"><a href="#Java线程模型相关" class="headerlink" title="Java线程模型相关"></a>Java线程模型相关</h2><h3 id="有几个主题问题"><a href="#有几个主题问题" class="headerlink" title="有几个主题问题"></a>有几个主题问题</h3><ol>
<li>CAS涉及到用户模式到内核模式的切换吗？<ol>
<li>CAS不会涉及用户模式到内核模式切换，因为CAS操作最终直接执行的是CPU指令，不涉及切换</li>
</ol>
</li>
<li>为什么说创建Java线程的本质上只有一种？Java线程和go语言的协程有什么区别？</li>
<li>如何优雅的终止线程？</li>
<li>Java线程之间如何通信的，有那些方式？</li>
</ol>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul>
<li><strong>进程</strong>：操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位</li>
<li><strong>线程</strong>：线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位</li>
</ul>
<p><strong>两者具体的区别：</strong></p>
<ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li>
<li>进程间通信较为复杂<ul>
<li>同一台计算机的进程通信称为 IPC（Inter-processcommunication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h3 id="进程之间的通信方式"><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a>进程之间的通信方式</h3><ol>
<li><strong>管道（pipe）及有名管道（named pipe）</strong>：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</li>
<li><strong>信号（signal）</strong>：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</li>
<li><strong>消息队列（message queue）</strong>：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。</li>
<li><strong>共享内存（shared memory）</strong>：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</li>
<li><strong>信号量（semaphore）</strong>：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</li>
<li><strong>套接字（socket）</strong>：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li>
</ol>
<h3 id="线程的同步互斥"><a href="#线程的同步互斥" class="headerlink" title="线程的同步互斥"></a>线程的同步互斥</h3><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><ul>
<li>上下文切换只能在内核模式下发生。</li>
<li>上下文切换时多任务操作系统的一个基本特性</li>
<li>上下文切换通常是计算密集型的</li>
</ul>
<h3 id="内核模式与用户模式"><a href="#内核模式与用户模式" class="headerlink" title="内核模式与用户模式"></a>内核模式与用户模式</h3><h4 id="Kernel-Mode"><a href="#Kernel-Mode" class="headerlink" title="Kernel Mode"></a>Kernel Mode</h4><p>在内核模式下，执行代码可以完全且不受限制地访问底层限制。它可以执行任何CPU指令和引用任何内存地址。内核模式通常为操</p>
<h4 id="User-Mode"><a href="#User-Mode" class="headerlink" title="User Mode"></a>User Mode</h4><h4 id="两者切换的场景"><a href="#两者切换的场景" class="headerlink" title="两者切换的场景"></a>两者切换的场景</h4><p><img data-src="181e5700/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2%E7%9A%84%E5%9C%BA%E6%99%AF.png" alt="用户态和内核态切换的场景"></p>
<ul>
<li>系统调用：调用系统底层API</li>
<li>异常事件：当发生某些预先不可知的异常，就会切换到内核态，以执行相关的异常事件。</li>
<li>设备中断：在使用外围设备时，如外围设备收到用户请求，就会向CPU发送一个中断信号，此时，CPU就会暂停执行原本的下一条指令，转去处理中断事件。此时，如果原来在用户态，自然就会切换到内核态。</li>
</ul>
<h3 id="线程生命周期-操作系统层面"><a href="#线程生命周期-操作系统层面" class="headerlink" title="线程生命周期(操作系统层面)"></a>线程生命周期(操作系统层面)</h3><p>一般的认为有5种：<br><img data-src="181e5700/%E5%A4%9A%E6%95%B0%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="多数的5种状态图"><br>在Java层面划分了6种：<strong>NEW, RUNNABLE, BLOCKED, WAITTING, TIMED_WATTING, TERMINATED</strong>，相互交互的示意图如下：<br><img data-src="181e5700/Java%E5%B1%82%E9%9D%A2%E7%9A%846%E7%A7%8D.png" alt="Java层面的6种"></p>
<h3 id="跟Java线程相关"><a href="#跟Java线程相关" class="headerlink" title="跟Java线程相关"></a>跟Java线程相关</h3><h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><ol>
<li>直接new Thread类</li>
<li>实现Runnable接口配合Thread</li>
<li>使用有返回值的Callable</li>
<li>使用Lambda表达式</li>
</ol>
<p><strong>上述本质上，只有一种创建方式：new Thread(Runnable()).start()方式启动</strong><br>关于Thread类中start方法分析：<br><strong>注：只有通过start方法</strong>，才能真正调用（通过JNI方式调用）操作系统底层创建线程，大体流程是：<br>    1. 使用new Thread()创建一个线程，然后调用start()方法进行java层面的线程启动<br>    2. 调用本地方法start0()，去调用JVM中的JVM_StartThread方法进行线程创建和启动<br>    3. 调用new JavaThread(&amp;thread_entry, sz)进行线程的创建，并根据不同的操作系统平台调用对应的os::create_thread方法进行线程的创建<br>    4. 新创建的线程状态为Initialized，调用sync-&gt;wait()的方法进行等待，等待被唤醒才会继续执行thread-&gt;run()<br>    5. 调用Thread::start(native_thread)方法进行线程启动，此时将线程状态设置为RSUNNABLE，接着调用os::start_thread(thread)，根据不同的操作系统选择不同的线程启动方式<br>    6. 线程启动之后状态设置为RUNNABLE，并唤醒第4步中等待的线程，接着执行thread-&gt;run()的方法<br>    7. JavaThread::run()方法会回调第1步new Thread中复写的run方法</p>
<h4 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h4><p>协程，英文Coroutines, 是一种<strong>基于线程之上，但又比线程更加轻量级的存在</strong>，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行），具有对内核来说不可见的特性。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<h4 id="Java线程的调度机制"><a href="#Java线程的调度机制" class="headerlink" title="Java线程的调度机制"></a>Java线程的调度机制</h4><p>Java线程调度是抢占式调度的</p>
<h4 id="如何优雅的停止线程"><a href="#如何优雅的停止线程" class="headerlink" title="如何优雅的停止线程"></a>如何优雅的停止线程</h4><p>为什么不要用Thread.stop方法，<strong>因为stop方法会释放线程锁，导致并发问题</strong></p>
<h5 id="优雅的方式：利用线程的中断机制"><a href="#优雅的方式：利用线程的中断机制" class="headerlink" title="优雅的方式：利用线程的中断机制"></a>优雅的方式：利用线程的中断机制</h5><p>Java没有提供一种安全、直接的方法来停止某个线程，而是提供了中断机制。<br><strong>中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理。被中断的线程拥有完全的自主权，它既可以选择立即停止，也可以选择一段时间后停止，也可以选择压根不停止。</strong></p>
<p>Java中提供了几个API来实现：</p>
<ul>
<li>interrupt()： 将线程的中断标志位设置为true，不会停止线程</li>
<li>isInterrupted(): 判断当前线程的中断标志位是否为true，不会清除中断标志位</li>
<li>Thread.interrupted()：判断当前线程的中断标志位是否为true，并清除中断标志位，重置为fasle<br>特别要注意，如果使用中断了，一定要注意中断标志位是否被清除，比如在调用sleep（sleep会清除中断标志）期间，一定要还原中断标志<h4 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h4>volatile<h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4>wait/notify ：这种方式需要依赖synchronized加锁才行，另外notify唤醒，没法指定某个线程唤醒</li>
</ul>
<p><strong>park/unpark：这个方式就可以直接指定唤醒具体哪个线程</strong></p>
<h4 id="管道的输入输出流"><a href="#管道的输入输出流" class="headerlink" title="管道的输入输出流"></a>管道的输入输出流</h4><p>Thread.join()</p>
<h3 id="ForkJoin工作原理"><a href="#ForkJoin工作原理" class="headerlink" title="ForkJoin工作原理"></a>ForkJoin工作原理</h3><p>传统线程池ThreadPoolExecutor有两个明显的缺点：</p>
<ol>
<li>一是无法对大任务进行拆分，对于某个任务只能由单线程执行；</li>
<li>二是工作线程从队列中获取任务时存在竞争情况。<br>这两个缺点都会影响任务的执行效率。<br>为了解决传统线程池的缺陷，Java7中引入Fork/Join框架，并在Java8中得到广泛应用。Fork/Join框架的核心是ForkJoinPool类，它是对AbstractExecutorService类的扩展。ForkJoinPool允许其他线程向它提交任务，并根据设定将这些任务拆分为粒度更细的子任务，这些子任务将由ForkJoinPool内部的工作线程来并行执行，并且工作线程之间可以窃取彼此之间的任务。</li>
</ol>
<p><strong>ForkJoinPool最适合计算密集型任务</strong>，而且最好是非阻塞任务。<br>ForkJoinPool是ThreadPoolExecutor线程池的一种补充，是对计算密集型场景的加强。<br>根据经验和实验，<strong>任务总数、单任务执行耗时以及并行数都会影响到Fork/Join的性能</strong>。</p>
<h4 id="ForkJoin使用"><a href="#ForkJoin使用" class="headerlink" title="ForkJoin使用"></a>ForkJoin使用</h4><p>ForkJoinPool 是用于执行 ForkJoinTask 任务的执行池，不再是传统执行池Worker+Queue 的组合式，而是<strong>维护了一个队列数组 WorkQueue（WorkQueue[]）</strong>，这样在提交任务和线程任务的时候大幅度减少碰撞。</p>
<h5 id="4个核心参数"><a href="#4个核心参数" class="headerlink" title="4个核心参数"></a>4个核心参数</h5><p>用于控制线程池的并行数、工作线程的创建、异常处理和模式指定等</p>
<ol>
<li>int parallelism：指定并行级别（parallelism level）。ForkJoinPool将根据这个设定，决定工作线程的数量。如果未设置的话，将使用Runtime.getRuntime().availableProcessors()来设置并行级别；</li>
<li>ForkJoinWorkerThreadFactory factory：ForkJoinPool在创建线程时，会通过factory来创建。注意，这里需要实现的是ForkJoinWorkerThreadFactory，而不是ThreadFactory。如果你不指定factory，那么将由默认的DefaultForkJoinWorkerThreadFactory负责线程的创建工作；</li>
<li>UncaughtExceptionHandler handler：指定异常处理器，当任务在运行中出错时，将由设定的处理器处理；</li>
<li>boolean asyncMode：设置队列的工作模式：asyncMode ? FIFO_QUEUE :LIFO_QUEUE。<strong>当asyncMode为true时，将使用先进先出队列，而为false时则使用后进先出的模式</strong>。</li>
</ol>
<h5 id="按照不同的提交任务"><a href="#按照不同的提交任务" class="headerlink" title="按照不同的提交任务"></a>按照不同的提交任务</h5><table>
<thead>
<tr>
<th>类型</th>
<th align="center">返回值</th>
<th align="center">方法</th>
</tr>
</thead>
<tbody><tr>
<td>提交异步执行</td>
<td align="center">void</td>
<td align="center">execute(ForkJoinTask&lt;?&gt; task) execute(Runnable task)</td>
</tr>
<tr>
<td>等待并获取结果</td>
<td align="center">T</td>
<td align="center">invoke(ForkJoinTask<T> task)</td>
</tr>
<tr>
<td>提交执行获取Future结果</td>
<td align="center">ForkJoinTask<T></td>
<td align="center">submit(ForkJoinTask<T> task)等一共4个</td>
</tr>
</tbody></table>
<ul>
<li>execute类型的方法在提交任务后，不会返回结果。ForkJoinPool不仅允许提交ForkJoinTask类型任务，还允许提交Runnable任务</li>
<li>invoke方法接受ForkJoinTask类型的任务，并在任务执行结束后，返回泛型结果。如果提交的任务是null，将抛出空指针异常。</li>
<li>submit方法支持三种类型的任务提交：ForkJoinTask类型、Callable类型和Runnable类型。在提交任务后，将返回ForkJoinTask类型的结果。如果提交的任务是null，将抛出空指针异常，并且当任务不能按计划执行的话，将抛出任务拒绝异常。</li>
</ul>
<h4 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h4><p><strong>ForkJoinTask是ForkJoinPool的核心之一，它是任务的实际载体，定义了任务执行时的具体逻辑和拆分逻辑。</strong><br>ForkJoinTask继承了Future接口，所以也可以将其看作是轻量级的Future。</p>
<h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h5><ul>
<li><strong>fork()提交任务</strong>：fork()方法用于向当前任务所运行的线程池中提交任务。如果当前线程是ForkJoinWorkerThread类型，将会放入该线程的工作队列，否则放入common线程池的工作队列中。</li>
<li><strong>join()获取任务执行结果</strong>：join()方法用于获取任务的执行结果。调用join()时，将阻塞当前线程直到对应的子任务完成运行并返回结果。<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5>通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下三个子类：</li>
<li><strong>RecursiveAction</strong>：用于递归执行但不需要返回结果的任务。</li>
<li><strong>RecursiveTask</strong> ：用于递归执行需要返回结果的任务。</li>
<li><strong>CountedCompleter<T></strong> ：在任务完成执行后会触发执行一个自定义的钩子函数</li>
</ul>
<h4 id="ForkJoin内部实现"><a href="#ForkJoin内部实现" class="headerlink" title="ForkJoin内部实现"></a>ForkJoin内部实现</h4><ul>
<li>ForkJoinPool 内部有多个工作队列，当我们通过 ForkJoinPool 的 invoke() 或者submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个工作队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的工作队列中。</li>
<li>ForkJoinPool 的每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务（ForkJoinTask）。</li>
<li>每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的top，并且工作线程在处理自己的工作队列时，使用的是 LIFO 方式，也就是说每次从top取出任务来执行。</li>
<li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务，窃取的任务位于其他线程的工作队列的base，也就是说工作线程在窃取其他工作线程的任务时，使用的是FIFO 方式。</li>
<li>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</li>
<li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠 。</li>
</ul>
<h4 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h4><p>ForkJoinPool与ThreadPoolExecutor有个很大的不同之处在于，ForkJoinPool存在引入了工作窃取设计，它是其性能保证的关键之一。<strong>工作窃取，就是允许空闲线程从繁忙线程的双端队列中窃取任务。</strong><br>默认情况下，工作线程从它自己的双端队列的头部获取任务。但是，当自己的任务为空时，线程会从其他繁忙线程双端队列的尾部中获取任务。这种方法，最大限度地减少了线程竞争任务的可能性。<br>ForkJoinPool的大部分操作都发生在工作窃取队列（work-stealing queues ） 中，该队列由<strong>内部类WorkQueue实现</strong>。它是Deques的特殊形式，但仅支持三种操作方式：push、pop和poll（也称为窃取）。在ForkJoinPool中，队列的读取有着严格的约束，push和pop仅能从其所属线程调用，而poll则可以从其他线程调用。<br><img data-src="181e5700/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="工作窃取工作流程示意图"></p>
<ul>
<li>工作窃取算法的优点是充分利用线程进行并行计算，并<strong>减少了</strong>线程间的竞争;</li>
<li>工作窃取算法缺点是在<strong>某些情况下还是存在竞争</strong>，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</li>
</ul>
<h4 id="ForkJoinPool执行流程"><a href="#ForkJoinPool执行流程" class="headerlink" title="ForkJoinPool执行流程"></a>ForkJoinPool执行流程</h4><p><img data-src="181e5700/forkjoinpool%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="forkjoinpool工作流程示意图"></p>
<h2 id="线程安全相关-原子与有序问题"><a href="#线程安全相关-原子与有序问题" class="headerlink" title="线程安全相关(原子与有序问题)"></a>线程安全相关(原子与有序问题)</h2><h3 id="CAS原子性"><a href="#CAS原子性" class="headerlink" title="CAS原子性"></a>CAS原子性</h3><h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p>通常指的是这样一种原子操作：针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给它赋一个新值。<br><strong>CAS 可以看作是它们合并后的整体——一个不可分割的原子操作，并且其原子性是直接在硬件层面得到保障的。</strong><br>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (value == expectedValue) &#123;</span><br><span class="line">	value = newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CAS操作天然能够保持内存可见性，硬件底层指令</strong></p>
<h4 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h4><p>在 Java 中，CAS 操作是由 Unsafe 类提供支持的，该类定义了三种针对不同类型变量的 CAS 操作，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sun.misc.Unsafe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h4><ul>
<li><strong>自旋CAS长时间不成功，则会给CPU带来非常大的开销</strong></li>
<li><strong>只能保证一个共享变量原子操作</strong></li>
<li><strong>ABA问题：通过额外增加版本号逻辑来避免ABA问题</strong></li>
</ul>
<h4 id="LongAdder-DoubleAdder"><a href="#LongAdder-DoubleAdder" class="headerlink" title="LongAdder/DoubleAdder"></a>LongAdder/DoubleAdder</h4><p>解决AtomicLong等在高并发下<strong>自旋造成的性能影响</strong><br>假设一个场景，4个线程，并发采用CAS处理一个变量，LongAdder处理流程如下图所示：<br><img data-src="181e5700/LongAdder%E7%AB%9E%E4%BA%89%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="LongAdder竞争示意图"></p>
<p>其中：<strong>LongAdder内部有一个base变量，一个Cell[]数组：</strong></p>
<ul>
<li>base变量：非竞态条件下，直接累加到该变量上</li>
<li>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区(Critical Section)"></a>临界区(Critical Section)</h4><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li><strong>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</strong><br>一段代码块内如果存在对共享资源的多线程读写操作，称<strong>这段代码块为临界区</strong>，其共享资源为临界资源。</li>
</ul>
</li>
</ul>
<h4 id="竞态条件-Race-Condition"><a href="#竞态条件-Race-Condition" class="headerlink" title="竞态条件(Race Condition)"></a>竞态条件(Race Condition)</h4><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件<br>为了避免临界区的竞态条件发生，有多种手段可以达到目的：</p>
<ul>
<li><strong>阻塞式的解决方案：synchronized，Lock</strong></li>
<li><strong>非阻塞式的解决方案：原子变量(如CAS)</strong><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4>synchronized是JVM内置锁，基于Monitor机制实现，依赖底层操作系统的互斥原语Mutex（互斥量），它是一个重量级锁，性能较低。<br>当然，JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（LightweightLocking）、偏向锁（Biased Locking）、自适应自旋（Adaptive Spinning）等技术来减少锁操作的开销，<strong>内置锁的并发性能已经基本与Lock持平</strong>。</li>
</ul>
<p>Java虚拟机通过一个同步结构支持方法和方法中的<strong>指令序列的同步：monitor</strong>。<br><strong>同步方法</strong>是通过方法中的access_flags中<strong>设置ACC_SYNCHRONIZED标志</strong>来实现；<br><strong>同步代码块</strong>是通过<strong>monitorenter和monitorexit来实现</strong>。<br><strong>两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现</strong>，被阻塞的线程会被挂起、等待重新调度，会导致 <strong>“用户态和内核态”两个态之间来回切换，对性能有较大影响</strong>。</p>
<p><strong>synchronized是天然的一个可重入锁。</strong></p>
<h5 id="Monitor-管程-监视器"><a href="#Monitor-管程-监视器" class="headerlink" title="Monitor(管程/监视器)"></a>Monitor(管程/监视器)</h5><p>Monitor，直译为“监视器”，而操作系统领域一般翻译为“管程”。<br><strong>管程是指管理共享变量以及对共享变量操作的过程，让它们支持并发。</strong><br>在Java 1.5之前，Java语言提供的唯一并发语言就是管程，Java 1.5之后提供的SDK并发包也是以管程为基础的。除了Java之外，C/C++、C#等高级语言也都是支持管程的。<br><strong>synchronized关键字和wait()、notify()、notifyAll()这三个方法是Java中实现管程技术的组成部分。</strong></p>
<h5 id="MESA模型-Java核心锁实现原理"><a href="#MESA模型-Java核心锁实现原理" class="headerlink" title="MESA模型(Java核心锁实现原理)"></a>MESA模型(Java核心锁实现原理)</h5><p>在管程的发展史上，先后出现过三种不同的管程模型，分别是Hasen模型、Hoare模型和MESA模型。现在正在广泛使用的是MESA模型<br><img data-src="181e5700/MEAS%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="MEAS管程模型"></p>
<h5 id="精简MESA模型"><a href="#精简MESA模型" class="headerlink" title="精简MESA模型"></a>精简MESA模型</h5><p>Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了<strong>精简</strong>。<br>MESA模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。模型如下图所示：<br><img data-src="181e5700/%E7%B2%BE%E7%AE%80MESA%E6%A8%A1%E5%9E%8B.png" alt="精简MESA模型"></p>
<h5 id="Monitor机制在Java中的实现"><a href="#Monitor机制在Java中的实现" class="headerlink" title="Monitor机制在Java中的实现"></a>Monitor机制在Java中的实现</h5><p>了解数据结构中有三个结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObjectMonitor::ObjectMonitor</span></span><br><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>; <span class="comment">//对象头 markOop</span></span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>; <span class="comment">// 锁的重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>; <span class="comment">//存储锁对象</span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">// 标识拥有该monitor的线程（当前获取锁的线程）</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 等待线程（调用wait）组成的双向循环链表，_WaitSet是第一个节点</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ; <span class="comment">//多线程竞争锁会先存到这个单向链表中 （FILO栈结构）</span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//存放在进入或重新进入时被阻塞(blocked)的线程 (也是存竞争锁失败的线程)</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>分别注意： <strong>WaitSet、cxq、EntryList这三个结构</strong><br>这三个结构协作来对锁场景使用情况如下图流程所示，解释竞争顺序：<br><img data-src="181e5700/Java%E4%B8%AD%E7%9A%84Monitor%E6%9C%BA%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Java中的Monitor机制执行流程"><br>解释起来：<br>在获取锁时，是将当前线程插入到cxq的头部，而释放锁时，默认策略（QMode=0）是：如果EntryList为空，则将cxq中的元素按原有顺序插入到EntryList，并唤醒第一个线程，也就是当EntryList为空时，是后来的线程先获取锁；<strong>EntryList不为空，直接从_EntryList中唤醒线程。</strong><br><strong>synchronized的锁竞争顺序概括就是：</strong>在竞争相同资源情况下，如果有wait线程，则该线程会被优先唤醒；反之，就是按照先进后出（FILO）的规则来。</p>
<h5 id="锁在对象内存布局"><a href="#锁在对象内存布局" class="headerlink" title="锁在对象内存布局"></a>锁在对象内存布局</h5><p>Hotspot虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</strong>。</p>
<ul>
<li><strong>对象头</strong>：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象才有）等。</li>
<li><strong>实例数据</strong>：存放类的属性数据信息，包括父类的属性信息；</li>
<li><strong>对齐填充</strong>：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</li>
</ul>
<p>概括对象在内存中占用字节数（64位，默认开启压缩指针）：</p>
<ul>
<li>对象头：8字节</li>
<li>元数据指针：4字节</li>
<li>数组对象（如果有）：4字节</li>
<li>实例数据：按具体数据类型来分配</li>
<li>对齐填充位：按最后8的整数倍来，缺多少补多少。<br><img data-src="181e5700/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%88%86%E5%B8%83.png" alt="对象头内存占用分布示意图"></li>
</ul>
<h5 id="锁对象状态转换"><a href="#锁对象状态转换" class="headerlink" title="锁对象状态转换"></a>锁对象状态转换</h5><p><img data-src="181e5700/%E9%94%81%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="锁对象状态转换示意图"></p>
<h5 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h5><ul>
<li>偏向锁：某些场景不存在竞争，此时锁偏向某个线程，后续该线程进入同步块的时候，则不会产生加锁/释放锁的性能开销。例如StringBuffer。</li>
<li>轻量级锁：线程之间存在轻微的竞争，线程交替执行，临界区简单不复杂，可以快速执行，通过CAS获取锁，失败膨胀（升级）为重量级锁。轻量级锁没有自旋场景。</li>
<li>重量级锁：多线程竞争激烈的场景，膨胀期间会通过创建一个Monitor对象来处理竞争条件。</li>
</ul>
<p><strong>这三个锁切换示意图，通过图例中的标注，可以看出各种锁是如何切换的</strong>：<br><img data-src="181e5700/%E4%BC%98%E5%8C%96%E9%94%81%E5%88%87%E6%8D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="优化锁切换示意图"></p>
<p>这里面有几个点：</p>
<ol>
<li><strong>偏向锁到无锁之间的偏向锁撤销</strong>：例如调用hashcode方法就会产生，原因是：偏向锁对象头中无法存hashcode，而无锁可以。再次看看对象头的分布图：</li>
</ol>
<p><strong>注意看无锁和偏向锁之间的差异</strong><br><img data-src="181e5700/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" alt="对象头内存分布"><br>2. <strong>为什么轻量级锁可以解锁成无锁状态</strong>：原因是，轻量级锁在创建栈中的记录时，会将无锁的markword拷贝到栈数据中，因此解锁的时候之间还原即可。<br>3. </p>
<h6 id="一段锁偏移的代码"><a href="#一段锁偏移的代码" class="headerlink" title="一段锁偏移的代码"></a>一段锁偏移的代码</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockEscalationDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Object</span>()).toPrintable());</span><br><span class="line">        <span class="comment">//HotSpot 虚拟机在启动后有个 4s 的延迟才会对每个新建的对象开启偏向锁模式</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 思考： 如果对象调用了hashCode,还会开启偏向锁模式吗</span></span><br><span class="line">        <span class="comment">//obj.hashCode();</span></span><br><span class="line">        log.info(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(Thread.currentThread().getName() + <span class="string">&quot;开始执行。。。\n&quot;</span></span><br><span class="line">                        + ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    <span class="comment">// 思考：偏向锁执行过程中，调用hashcode会发生什么？</span></span><br><span class="line">                    <span class="comment">//obj.hashCode();</span></span><br><span class="line"><span class="comment">//                    //obj.notify();</span></span><br><span class="line"><span class="comment">////                    try &#123;</span></span><br><span class="line"><span class="comment">////                        obj.wait(50);</span></span><br><span class="line"><span class="comment">////                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">////                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">////                    &#125;</span></span><br><span class="line"></span><br><span class="line">                    log.info(Thread.currentThread().getName() + <span class="string">&quot;获取锁执行中。。。\n&quot;</span></span><br><span class="line">                            + ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(Thread.currentThread().getName() + <span class="string">&quot;释放锁。。。\n&quot;</span></span><br><span class="line">                        + ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//控制线程竞争时机</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(Thread.currentThread().getName() + <span class="string">&quot;开始执行。。。\n&quot;</span></span><br><span class="line">                        + ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">                    log.info(Thread.currentThread().getName() + <span class="string">&quot;获取锁执行中。。。\n&quot;</span></span><br><span class="line">                            + ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(Thread.currentThread().getName() + <span class="string">&quot;释放锁。。。\n&quot;</span></span><br><span class="line">                        + ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(Thread.currentThread().getName() + <span class="string">&quot;开始执行。。。\n&quot;</span></span><br><span class="line">                        + ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">                    log.info(Thread.currentThread().getName() + <span class="string">&quot;获取锁执行中。。。\n&quot;</span></span><br><span class="line">                            + ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(Thread.currentThread().getName() + <span class="string">&quot;释放锁。。。\n&quot;</span></span><br><span class="line">                        + ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        log.info(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="synchronized锁的高级优化"><a href="#synchronized锁的高级优化" class="headerlink" title="synchronized锁的高级优化"></a>synchronized锁的高级优化</h5><h6 id="偏向锁批量重偏向-amp-批量撤销"><a href="#偏向锁批量重偏向-amp-批量撤销" class="headerlink" title="偏向锁批量重偏向&amp;批量撤销"></a>偏向锁批量重偏向&amp;批量撤销</h6><p>从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，<strong>所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</strong><br>应用场景：</p>
<ul>
<li><strong>批量重偏向（bulk rebias）机制是为了解决</strong>：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。</li>
<li><strong>批量撤销（bulk revoke）机制是为了解决：</strong>在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</li>
</ul>
<p>概括：</p>
<ol>
<li><strong>批量重偏向和批量撤销是针对类的优化，和对象无关。</strong></li>
<li><strong>偏向锁重偏向一次之后不可再次重偏向。</strong></li>
<li><strong>当某个类已经触发批量撤销机制后，JVM会默认当前类产生了严重的问题，剥夺了该类的新实例对象使用偏向锁的权利</strong></li>
</ol>
<h6 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h6><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能。</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<p>注意：<strong>自旋的目的是为了减少线程挂起的次数，尽量避免直接挂起线程（挂起操作涉及系统调用，存在用户态和内核态切换，这才是重量级锁最大的开销）</strong></p>
<h6 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h6><p>假设一系列的连续操作都会<strong>对同一个对象反复加锁及解锁，甚至加锁操作是出现在循环体中的</strong>，即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果JVM检测到有一连串零碎的操作都是对同一对象的加锁，将会扩大加锁同步的范围（即锁粗化）到整个操作序列的外部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">()</span> &#123;</span><br><span class="line">	buffer.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot; bbb&quot;</span>).append(<span class="string">&quot; ccc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码每次调用 buffer.append 方法都需要加锁和解锁，如果JVM检测到有一连串的对同一个对象加锁和解锁的操作，<strong>就会将其合并成一次范围更大的加锁和解锁操作</strong>，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。</p>
<h6 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h6><p>锁消除即删除不必要的加锁操作。锁消除是Java虚拟机在JIT编译期间，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间。<br>StringBuffer的append是个同步方法，但是append方法中的 StringBuffer </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockEliminationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁粗化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">()</span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot; bbb&quot;</span>).append(<span class="string">&quot; ccc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁消除</span></span><br><span class="line"><span class="comment">     * -XX:+EliminateLocks 开启锁消除(jdk8默认开启）</span></span><br><span class="line"><span class="comment">     * -XX:-EliminateLocks 关闭锁消除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer.append(str1).append(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">LockEliminationTest</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockEliminationTest</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            demo.append(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属于一个局部变量，不可能从该方法中逃逸出去，因此其实这过程是线程安全的，可以将锁消除。<br>测试结果：开启锁消除：1903 ms；关闭锁消除：2833 ms</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><p>java.util.concurrent包中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这些行为的抽象就是基于<strong>AbstractQueuedSynchronizer（简称AQS）</strong>实现的，AQS是一个抽象同步框架，可以用来实现一个依赖状态的同步器。<br>JDK中提供的大多数的同步器如Lock, Latch, Barrier等，都是基于AQS框架来实现的：</p>
<ul>
<li>一般是通过一个内部类Sync继承 AQS</li>
<li>将同步器所有调用都映射到Sync对应的方法<h5 id="AQS相关特点"><a href="#AQS相关特点" class="headerlink" title="AQS相关特点"></a>AQS相关特点</h5>5大特性：</li>
<li>阻塞等待队列</li>
<li>共享/独占</li>
<li>公平/非公平</li>
<li>可重入</li>
<li>允许中断</li>
</ul>
<p>AQS内部维护的属性 <code>volatile int state</code> 解释：state表示资源的可用状态。<br><strong>访问该state有三种方式</strong></p>
<ol>
<li>getState()</li>
<li>setState()</li>
<li>compareAndSetState()</li>
</ol>
<p>AQS定义两种资源共享方式：</p>
<ol>
<li><strong>Exclusive-独占</strong>：只有一个线程能执行，如ReentrantLock</li>
<li><strong>Share-共享</strong>：多个线程可以同时执行，如Semaphore/CountDownLatch</li>
</ol>
<p>AQS定义两种队列（MESA实现）:</p>
<ol>
<li><strong>同步等待队列</strong>： 主要用于维护获取锁失败时入队的线程</li>
<li><strong>条件等待队列</strong>： 调用<strong>await()**的时候会释放锁，然后线程会加入到条件队列，调用</strong>signal()**唤醒的时候会把条件队列中的线程节点移动到同步队列中，等待再次获得锁</li>
</ol>
<p>AQS 定义了5个队列中节点状态（竞争失败后进行处理的内容，在队列节点Node中实现的）：</p>
<ol>
<li><strong>初始化状态</strong>：值为0，，表示当前节点在sync队列中，等待着获取锁。</li>
<li><strong>CANCELLED</strong>：值为1，表示当前的线程被取消；</li>
<li><strong>SIGNAL</strong>：值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</li>
<li><strong>CONDITION</strong>：值为-2，表示当前节点在等待condition，也就是在condition队列中；</li>
<li><strong>PROPAGATE</strong>：值为-3，表示当前场景下后续的acquireShared能够得以执行；</li>
</ol>
<p>不同的自定义同步器竞争共享资源的方式也不同。<br>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。<br><strong>自定义同步器实现时主要实现以下几种方法：</strong></p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<h5 id="同步等待队列"><a href="#同步等待队列" class="headerlink" title="同步等待队列"></a>同步等待队列</h5><p>AQS当中的同步等待队列也称CLH队列，CLH队列是Craig、Landin、Hagersten三人发明的一种基于双向链表数据结构的队列，是FIFO先进先出线程等待队列。<br>Java中的CLH队列是原CLH队列的一个变种，<strong>线程由原自旋机制改为阻塞机制。</strong><br>AQS 依赖CLH同步队列来完成同步状态的管理：</p>
<ul>
<li>当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程</li>
<li>当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</li>
<li>通过signal或signalAll将条件队列中的节点转移到同步队列。（由条件队列转化为同步队列）<br><img data-src="181e5700/AQS-%E5%90%8C%E6%AD%A5%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97.png" alt="AQS-同步等待队列"></li>
</ul>
<h5 id="条件等待队列"><a href="#条件等待队列" class="headerlink" title="条件等待队列"></a>条件等待队列</h5><p>AQS中条件队列是使用单向链表保存的，用nextWaiter来连接：</p>
<ul>
<li>调用await方法阻塞线程；</li>
<li>当前线程存在于同步队列的头结点，调用await方法进行阻塞（从同步队列转化到条件队列）</li>
</ul>
<h4 id="Condition接口详解"><a href="#Condition接口详解" class="headerlink" title="Condition接口详解"></a>Condition接口详解</h4><p><img data-src="181e5700/structure_of_condition.png" alt="Condition接口"></p>
<ul>
<li>调用<strong>Condition#await</strong>方法会释放当前持有的锁，然后<strong>阻塞当前线程</strong>，同时向Condition队列尾部添加一个节点，所以调用Condition#await方法的时候必须持有锁。</li>
<li>调用<strong>Condition#signal</strong>方法会将Condition队列的首节点移动到阻塞队列尾部，然后唤醒因调用Condition#await方法而阻塞的线程(唤醒之后这个线程就可以去竞争锁了)，所以调用Condition#signal方法的时候必须持有锁，持有锁的线程唤醒被因调用Condition#await方法而阻塞的线程。</li>
</ul>
<p><strong>Condition结合ReentrantLock，在阻塞队列中使用的非常多。</strong></p>
<h4 id="ReentrantLock-独占锁"><a href="#ReentrantLock-独占锁" class="headerlink" title="ReentrantLock(独占锁)"></a>ReentrantLock(独占锁)</h4><p>ReentrantLock是一种基于AQS框架的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能<strong>类似于synchronized是一种互斥锁，可以保证线程安全。</strong><br>相对于 synchronized， ReentrantLock具备如下特点：</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间：一定时间内是否能够获取锁</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
<li>与 synchronized 一样，都支持可重入</li>
</ul>
<h5 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h5><ul>
<li>synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</li>
<li>synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过ReentrantLock#isLocked判断；</li>
<li>synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li>
<li>synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的；</li>
<li>在发生异常时synchronized会自动释放锁，而ReentrantLock需要开发者在finally块中显示释放锁；</li>
<li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等 待指定时长的获取，更加灵活；</li>
<li>synchronized在特定的情况下对于已经在等待的线程是后来的线程先获得锁（cqx队列），而ReentrantLock对于已经在等待的线程是先来的线程先获得锁；</li>
</ul>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p><strong>使用场景特别要注意的</strong>：一定要处理好异常情况，即释放锁的时候不能出现因为异常而导致释放锁失败的情况。</p>
<ul>
<li><strong>可中断</strong>：线程协作时的一个典型用法，在A线程中调用lockInterruptibly()后，在B线程中调用interrupt()时会影响A线程中的后续执行逻辑，直接抛出异常。</li>
<li><strong>超时失败</strong>：tryLock中传入时间参数</li>
<li><strong>公平锁</strong>：默认是非公平的，创建的时候传入ture标志的时候创建的就是公平锁。默认非公平的原因是效率高。</li>
</ul>
<h5 id="相关源码实现"><a href="#相关源码实现" class="headerlink" title="相关源码实现"></a>相关源码实现</h5><ol>
<li>ReentrantLock加锁解锁的逻辑</li>
<li>公平和非公平，可重入锁的实现</li>
<li>线程竞争锁失败入队阻塞逻辑和获取锁的线程释放锁唤醒阻塞线程竞争锁的逻辑实现（设计的精髓：并发场景下入队和出队操作）。</li>
</ol>
<p>一段debug代码：<br>很简单，就是3个线程对一个total变量进行累加操作，中间通过ReentrantLock来进行独占</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugReentrantLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 加锁 下面一行设置断点</span></span><br><span class="line">                <span class="comment">// 在idea中将断点模式设置为thread（下同），方便对指定线程执行操作</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 临界区代码，下面一行设置断点</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        total++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 解锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;summary result is:[&#123;&#125;]&quot;</span>, total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中在IDEA中设置Thread模式断点如下图所示（在断点上鼠标右键）：<br><img data-src="181e5700/IDEAThread%E6%96%AD%E7%82%B9%E6%A8%A1%E5%BC%8F.png" alt="IDEAThread断点模式"><br>结合这个调试程序单独拆解里面的步骤：<br>3个线程的名字，假设分别叫Thread1、2、3，用于下文标记</p>
<h6 id="1-初始化ReentrantLock对象"><a href="#1-初始化ReentrantLock对象" class="headerlink" title="1. 初始化ReentrantLock对象"></a>1. 初始化ReentrantLock对象</h6><p>这里需要结合ReentrantLock的相关代码结构才好看后面的流程<br>首先关注一下ReentrantLock跟本程序调用相关的结构：<br><img data-src="181e5700/ReentrantLock%E7%BB%93%E6%9E%841.png" alt="ReentrantLock结构1"><br>这里面：</p>
<ul>
<li>Sync内置抽象类继承了AbstractQueuedSynchronizer，是ReentrantLock锁的同步控制基础（核心结构）。分为公平和非公平版本（内部类NonfairSync和FairSync）。使用 AQS 状态来表示锁定的保持次数。</li>
<li>看看AbstractQueuedSynchronizer：这里面定义了所有基于AQS实现的锁机制的公共方法类，跟这个debug程序相关的，需要知道：<ul>
<li>AbstractQueuedSynchronizer静态初始化了几个内部变量，用于后续CAS同步锁，其中有个属性：<strong>volatile int state用于标记同步状态的，默认初始化为0</strong>。</li>
<li>定义了一个静态内部类：<code>java.util.concurrent.locks.AbstractQueuedSynchronizer.Node</code>，这个类定义了等待队列节点，参考CLH，并扩展为双向指针链表（独占模式下是，共享模式退化成单链表结构）。具体直接可以看该类的文档注释。</li>
<li>Node结构中有几个重要的属性结构，为后续等待队列的结构变动，线程的等待/唤醒服务：<ul>
<li>volatile int waitStatus：节点的等待状态，有5种值，在默认的独占模式（EXCLUSIVE）下，值用只用到了1种，即-1（SIGNAL指示后继线程需要取消停放），加上默认的0，只有2种。</li>
<li>volatile Node prev：双向链表前驱节点</li>
<li>volatile Node next：双向链表后继节点</li>
<li>volatile Thread thread：当前等待线程</li>
</ul>
</li>
<li>AbstractQueuedSynchronizer父类：AbstractOwnableSynchronizer内持有一个对象<code>transient Thread exclusiveOwnerThread</code>，用于在独占模式下标记同步的当前线程。</li>
<li>其它方法结构，后续时序图中碰到再单独解释</li>
</ul>
</li>
<li>NonfairSync内部类继承Sync并实现了lock方法，是非公平锁的同步对象</li>
<li>ReentrantLock默认构造函数实现的是：NonfairSync</li>
</ul>
<h6 id="2-1-Thread1调用ReentrantLock-lock"><a href="#2-1-Thread1调用ReentrantLock-lock" class="headerlink" title="2.1 Thread1调用ReentrantLock.lock()"></a>2.1 Thread1调用ReentrantLock.lock()</h6><p>对应代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment"> * acquire on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时序图如下，不是特别复杂：</p>
<pre>
<code class="mermaid">
sequenceDiagram
actor User
User -&gt;&gt; NonfairSync : lock
activate NonfairSync
NonfairSync -&gt;&gt; AbstractQueuedSynchronizer : CAS对AQS抽象类的stateOffset操作compareAndSetState(0,1)
activate AbstractQueuedSynchronizer
AbstractQueuedSynchronizer --&gt;&gt; NonfairSync : #32; 
deactivate AbstractQueuedSynchronizer
alt 判断上述compareAndSetState(0, 1)结果
NonfairSync -&gt;&gt; Thread : 调用currentThread()设置exclusiveOwnerThread&#x3D;currentThread
activate Thread
Thread --&gt;&gt; NonfairSync : #32; 
deactivate Thread
else 
NonfairSync -&gt;&gt; AbstractQueuedSynchronizer : 独占模式尝试获取锁acquire(1)
activate AbstractQueuedSynchronizer
AbstractQueuedSynchronizer --&gt;&gt; NonfairSync : #32; 
deactivate AbstractQueuedSynchronizer
end
deactivate NonfairSync
</code>
</pre>

<h6 id="2-2-Thread1获取到锁"><a href="#2-2-Thread1获取到锁" class="headerlink" title="2.2 Thread1获取到锁"></a>2.2 Thread1获取到锁</h6><p>此时Thread1的ReentrantLock.state=1</p>
<h6 id="3-Thread2调用lock方法"><a href="#3-Thread2调用lock方法" class="headerlink" title="3. Thread2调用lock方法"></a>3. Thread2调用lock方法</h6><p>这时候调用compareAndSetState(0, 1)的CAS操作，肯定是返回失败的。走到调用acquire(1)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">	<span class="comment">// 这一行调用了三个方法：tryAcquire(arg)-尝试获取锁</span></span><br><span class="line">	<span class="comment">// addWaiter(Node.EXCLUSIVE) - 首次调用构建双向队列</span></span><br><span class="line">	<span class="comment">// acquireQueued(Node) - 入队列</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        	<span class="comment">// 调用复位中断标记位</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 首次调用为假，后续再次调用时本质就是尾插法</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队列</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            	<span class="comment">// 首次调用先初始化表head节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 再次调用会调用尾插法入队列</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireQueued</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// 注意这里有个自旋操作，这个是后续阻塞队列种的中断线程重新获取锁的关键</span></span><br><span class="line">            	<span class="comment">// 本例子Thread2第一次进入这里时，获取的p是head节点</span></span><br><span class="line">            	<span class="comment">// 自旋后Thread2第二次进入，同样为false</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            	<span class="comment">// Thread2第一次执行判断： p == head为真，tryAcquire(arg)再次获取锁为假</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                	<span class="comment">// 新唤起的线程获取锁成功之后，要清除当前队列的head节点，并更新当前node为head节点。</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Thread2第一次执行下面判断条件，shouldParkAfterFailedAcquire返回false</span></span><br><span class="line">                <span class="comment">// Thread2第二次执行，shouldParkAfterFailedAcquire为true，开始执行parkAndCheckInterrupt()，挂起成功返回true</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#shouldParkAfterFailedAcquire</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="comment">// Thread2首次进入时：ws=0</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// Thread2首次进入时：通过CAS将waitStatus=-1</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#parkAndCheckInterrupt</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// Thread2 进入这里执行后，Thread2线程状态WAIT，开始阻塞</span></span><br><span class="line">		<span class="comment">// park里面会有识别中断标志位，以便后续唤醒操作</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 清除中断，为了后续自旋加锁逻辑</span></span><br><span class="line">        <span class="comment">// 后续需要恢复，在acquire方法里面的：selfInterrupt()</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">// 获取当前state状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="comment">// 如果是0，表示可以获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            	<span class="comment">// 比较当前线程是不是锁持有线程，用来标记可重入次数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-Thread3调用lock方法"><a href="#4-Thread3调用lock方法" class="headerlink" title="4. Thread3调用lock方法"></a>4. Thread3调用lock方法</h6><p>同第3步一样，上锁失败完了，入队调用park进入阻塞。</p>
<h6 id="5-Thread1调用unlock方法"><a href="#5-Thread1调用unlock方法" class="headerlink" title="5. Thread1调用unlock方法"></a>5. Thread1调用unlock方法</h6><p>直接调用relase方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#release</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// tryRelease就是设置state=0和重置exclusiveOwnerThread=null</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#unparkSuccessor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">// 清除head节点中的等待信号</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        	<span class="comment">// 这里调用unpark唤醒线程，传入的参数是node节点中暂存的thread线程</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="5-1-唤醒Thread2线程"><a href="#5-1-唤醒Thread2线程" class="headerlink" title="5.1. 唤醒Thread2线程"></a>5.1. 唤醒Thread2线程</h6><p>上面代码里面注释已经标注</p>
<h6 id="5-2-Thread2再次尝试获取锁"><a href="#5-2-Thread2再次尝试获取锁" class="headerlink" title="5.2. Thread2再次尝试获取锁"></a>5.2. Thread2再次尝试获取锁</h6><h6 id="5-3-Thread2加锁成功"><a href="#5-3-Thread2加锁成功" class="headerlink" title="5.3. Thread2加锁成功"></a>5.3. Thread2加锁成功</h6><h6 id="5-3-调整内部链表结构"><a href="#5-3-调整内部链表结构" class="headerlink" title="5.3. 调整内部链表结构"></a>5.3. 调整内部链表结构</h6><h6 id="总结-整体流程"><a href="#总结-整体流程" class="headerlink" title="总结-整体流程"></a>总结-整体流程</h6><p>调用流程大致如下：<br><em>PS：整整画了我2小时 :(</em><br><img data-src="181e5700/ReentrantLock%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="完整调用流程"></p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p><strong>Semaphore，俗称信号量，它是操作系统中PV操作的原语在java的实现</strong>，它也是基于AbstractQueuedSynchronizer实现的。<br>Semaphore的功能非常强大：<br>大小为1的信号量就类似于互斥锁，通过同时只能有一个线程获取信号量实现；<br>大小为n（n&gt;0）的信号量可以实现限流的功能，它可以实现只能有n个线程同时获取信号量。<br><img data-src="181e5700/Semaphore%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Semaphore示意图"></p>
<h5 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException <span class="comment">// 表示阻塞并获取许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> <span class="comment">// 在没有许可的情况下会立即返回 false，要获取许可的线程不会阻塞</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> <span class="comment">// 释放许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">availablePermits</span><span class="params">()</span> <span class="comment">// 返回此信号量中当前可用的许可证数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getQueueLength</span><span class="params">()</span> <span class="comment">// 返回正在等待获取许可证的线程数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span> <span class="comment">// 是否有线程正在等待获取许可证</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reducePermits</span><span class="params">(<span class="type">int</span> reduction)</span> <span class="comment">// 减少 reduction 个许可证</span></span><br><span class="line"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title function_">getQueuedThreads</span><span class="params">()</span> <span class="comment">// 返回所有等待获取许可证的线程集合</span></span><br></pre></td></tr></table></figure>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>一个简单的限流示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现一个同时只能处理5个请求的限流器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span></span><br><span class="line">            (<span class="number">10</span>, <span class="number">50</span>, <span class="number">60</span>,</span><br><span class="line">                    TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exec</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//占用1个资源</span></span><br><span class="line">            semaphore.acquire(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//TODO  模拟业务执行</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;:执行exec方法&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放一个资源</span></span><br><span class="line">            semaphore.release(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">// 模拟请求以10个/s的速度</span></span><br><span class="line">            executor.execute(() -&gt; exec());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>跟ReentrantLock处理队列的方式相同（都是在AQS抽象类里面实现的），区别在于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.Semaphore#acquire(int)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">permits</span> &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireSharedInterruptibly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">// 先尝试获取锁，如果返回的是负数，就执行</span></span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.Semaphore.Sync#nonfairTryAcquireShared</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            	<span class="comment">// 初始化Semaphore的时候，构造器传入的资源数将赋值给state，这里取出来</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires; <span class="comment">// 计算剩余资源数</span></span><br><span class="line">                <span class="comment">// 大于0，通过CAS交换；反之直接返回负数的结果</span></span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>共享模式下跟独占模式的队列操作不一样的核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#doAcquireSharedInterruptibly</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 这里通过addWaiter初始化的Node节点模式是Node.SHARED</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取资源失败之后，这里就开始准备阻塞和进行阻塞两个动作。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>释放资源，重新累加state的同时需要唤醒队列线程</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch（闭锁）是一个<strong>同步协助类，允许一个或多个线程等待，直到其他线程完成操作集</strong>。<br>CountDownLatch使用给定的计数值（count）初始化。<br>await方法会阻塞直到当前的计数值（count）由于countDown方法的调用达到0，count为0之后所有等待的线程都会被释放，并且随后对await方法的调用都会立即返回。<br><strong>这是一个一次性现象：count不会被重置。</strong><br>如果你需要一个<strong>重置count的版本</strong>，那么请<strong>考虑使用CyclicBarrier</strong>。<br><img data-src="181e5700/CountDownLatch%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="CountDownLatch示意图"></p>
<h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><p>CountDownLatch一般用作多线程倒计时计数器，强制它们等待其他一组（CountDownLatch的初始化决定）任务执行完成</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>底层基于 AbstractQueuedSynchronizer 实现：<br>CountDownLatch 构造函数中<strong>指定的count直接赋给AQS的state</strong>；每次countDown()则都是release(1)减1，最后减到0时unpark阻塞线程；这一步是由最后一个执行countdown方法的线程执行的。<br>而调用await()方法时，当前线程就会判断state属性是否为0，如果为0，则继续往下执行，如果不为0，则使当前线程进入等待状态，直到某个线程将state属性置为0，其就会唤醒在await()方法中等待的线程。</p>
<h5 id="CountDownLatch与Thread-join的区别"><a href="#CountDownLatch与Thread-join的区别" class="headerlink" title="CountDownLatch与Thread.join的区别"></a>CountDownLatch与Thread.join的区别</h5><ul>
<li>CountDownLatch的作用就是<strong>允许一个或多个线程等待</strong>其他线程完成操作，看起来有点类似join() 方法，但其提供了比 join() 更加灵活的API。</li>
<li>CountDownLatch<strong>可以手动控制</strong>在n个线程里调用n次countDown()方法使计数器进行减一操作，也可以在一个线程里调用n次执行减一操作。</li>
<li>而 join() 的实现原理是不停检查join线程是否存活，如果<strong>join 线程存活则让当前线程永远等待</strong>。所以两者之间相对来说还是CountDownLatch使用起来较为灵活。<h5 id="CountDownLatch与CyclicBarrier的区别"><a href="#CountDownLatch与CyclicBarrier的区别" class="headerlink" title="CountDownLatch与CyclicBarrier的区别"></a>CountDownLatch与CyclicBarrier的区别</h5></li>
<li>CountDownLatch的计数器只能使用一次，而<strong>CyclicBarrier的计数器可以使用reset()方法重置</strong>。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CyclicBarrier还提供getNumberWaiting(可以获得CyclicBarrier阻塞的线程数量)、isBroken(用来知道阻塞的线程是否被中断)等方法。</li>
<li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。</li>
<li>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同:<ul>
<li>CountDownLatch一般用于一个或多个线程，等待其他线程执行完任务后，再执行。</li>
<li>CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。</li>
</ul>
</li>
<li>CyclicBarrier 还可以提供一个 barrierAction，<strong>合并多线程计算结果</strong>。</li>
<li><strong>CyclicBarrier是通过ReentrantLock的”独占锁”和Conditon来实现一组线程的阻塞唤醒的，而CountDownLatch则是通过AQS的“共享锁”实现</strong></li>
</ul>
<h4 id="CyclicBarrie"><a href="#CyclicBarrie" class="headerlink" title="CyclicBarrie"></a>CyclicBarrie</h4><p>字面意思回环栅栏，通过它可以实现<strong>让一组线程等待至某个状态（屏障点）之后再全部同时执行</strong>。叫做回环是因为当所有等待线程都被释放以后，<strong>CyclicBarrier可以被重用</strong>。<br>原始计数变量存在副本parties属性中，调用重置方法之后会还原该值。<br><img data-src="181e5700/CyclicBarrie%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="CyclicBarrie示意图"></p>
<h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><p>一个合并计算的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栅栏与闭锁的关键区别在于，所有的线程必须同时到达栅栏位置，才能继续执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存每个学生的平均成绩</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            result += map.get(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;三人平均成绩为:&quot;</span> + (result / <span class="number">3</span>) + <span class="string">&quot;分&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//获取学生平均成绩</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">40</span> + <span class="number">60</span>);</span><br><span class="line">                    map.put(Thread.currentThread().getName(), score);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;同学的平均成绩为：&quot;</span> + score);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//执行完运行await(),等待所有学生平均成绩都计算完毕</span></span><br><span class="line">                        cb.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrierTest2</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrierTest2</span>();</span><br><span class="line">        cb.count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一段等待就绪示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个小的“人满发车”场景的demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(); <span class="comment">// 计数标识选手序号</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">5</span>, <span class="number">5</span>, <span class="number">1000</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">                (r) -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;第&quot;</span> + counter.addAndGet(<span class="number">1</span>) + <span class="string">&quot;号 &quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cbInitSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(cbInitSize,</span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;===========裁判：比赛开始===========&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cbInitSize * <span class="number">4</span>; i++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(<span class="keyword">new</span> <span class="title class_">Runner</span>(cyclicBarrier));</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Runner</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Runner</span><span class="params">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sleepMills</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">1000</span>);</span><br><span class="line">                Thread.sleep(sleepMills);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 选手已就位, 准备共用时:&quot;</span> + sleepMills + <span class="string">&quot; ms&quot;</span> + <span class="string">&quot;, 准备完成序号:&quot;</span> + cyclicBarrier.getNumberWaiting());</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h5><p>使用了Condition作为条件队列原语：调用Condition.await()进行阻塞，入队操作。<br>这里面会有一个条件队列转同步队列后再唤醒的机制：<br>用ReentrantLock锁条件队列阻塞过程，在阻塞过程中，转同步队列后，条件队列释放锁后续同步队列唤醒、拿锁、执行（AQS的for循环自旋）<br>核心代码就下面这段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 注意这里的 ReentrantLock</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                        command.run(); <span class="comment">// 条件满足后，执行run方法</span></span><br><span class="line">                    ranAction = <span class="literal">true</span>;</span><br><span class="line">                    nextGeneration(); <span class="comment">// 进入下一个屏障区间，并调用singalAll()唤醒所有线程（有点复杂）</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await(); <span class="comment">// 这个地方会进行阻塞，等后续唤醒后再执行</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	<span class="comment">// 注意这里的unlock()</span></span><br><span class="line">        	<span class="comment">// 当最后一个条件队列计数完成，等待唤醒的时候，</span></span><br><span class="line">        	<span class="comment">// 当前所在的线程调用unlock，由于再次之前调用signalAll()方法的时候，已经完成了条件队列节点向同步队列节点传输转换的动作。</span></span><br><span class="line">        	<span class="comment">// 所以这时候调用unlock会唤醒后续节点的线程</span></span><br><span class="line">        	<span class="comment">// 同样的，后续被唤醒的线程也会走到这里，继续“传递”似的唤醒后续同步队列的节点，如此往复，直到同步队列节点全部被唤醒。</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// java.util.concurrent.CyclicBarrier#nextGeneration</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// signal completion of last generation</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">        <span class="comment">// set up next generation</span></span><br><span class="line">        count = parties;</span><br><span class="line">        generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>唤醒逻辑中实现了队列转换的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#doSignalAll</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 这个地方可以琢磨一下，为什么不用while而是用do-while</span></span><br><span class="line">    <span class="comment">// 原因在于，如果是首次进入的是，第一次调用transferForSignal，只是做了条件队列节点向同步队列传输的动作</span></span><br><span class="line">    <span class="comment">// 与此同时会初始化同步队列的结构，但是并不会唤醒。</span></span><br><span class="line">    <span class="comment">// 此时尾循环的判断就起到作用，为真的时候，会再次进入循环调用transferForSignal入队。</span></span><br><span class="line">    <span class="comment">// 直到 (first != null) 为假跳出循环</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#transferForSignal</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="comment">// 核心其实在于NODE节点设计的巧妙，通过不同的状态位，巧妙的在这里转换过去</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">         * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock(读写锁)"></a>ReentrantReadWriteLock(读写锁)</h4><p>现实中有这样一种场景：<strong>对共享资源有读和写的操作，且写操作没有读操作那么频繁（读多写少）</strong>。<br>在<strong>没有写操作</strong>的时候，多个线程同时读一个资源没有任何问题，所以应该<strong>允许多个线程同时读取</strong>共享资源（读读可以并发）；<br>但是如果<strong>一个线程想去写</strong>这些共享资源，<strong>就不应该允许其他线程对该资源进行读和写操作了</strong>（<em>读写，写读，写写互斥</em>）。<br>在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p>
<p>针对这种场景，JAVA的并发包提供了读写锁ReentrantReadWriteLock，它内部，维护了一对相关的锁，一个用于只读操作，称为读锁；一个用于写入操作，称为写锁: </p>
<ul>
<li>线程进入读锁的前提条件:<ul>
<li>没有其他线程的写锁</li>
<li>没有写请求或者，有写请求但调用线程和持有锁的线程是同一个。</li>
</ul>
</li>
<li>线程进入写锁的前提条件：<ul>
<li>没有其他线程的读锁</li>
<li>没有其他线程的写锁</li>
</ul>
</li>
</ul>
<h5 id="读写锁的三个重要特性"><a href="#读写锁的三个重要特性" class="headerlink" title="读写锁的三个重要特性"></a>读写锁的三个重要特性</h5><ul>
<li><strong>公平选择性</strong>：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</li>
<li><strong>可重入</strong>：读锁和写锁都支持线程重入。以读写线程为例：读线程获取读锁后，能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁。</li>
<li><strong>锁降级</strong>：遵循获取写锁、再获取读锁最后释放写锁的次序，写锁能够降级成为读锁。<h5 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h5><img data-src="181e5700/structure_of_ReentrantReadWriteLock.jpg" alt="读写锁类结构"><br>相比其它锁，共有的两个公平非公平同步结构之外，还多了两个单独实现Lock接口的锁模块。<br>两个锁本质是通过state状态的高低位是否为0来判断是否有读锁/写锁，其中：写锁实现就是独占锁；读锁实现就是共享锁实现。<br><img data-src="181e5700/ReentrantReadWrite%E9%94%81%E5%B7%A5%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ReentrantReadWrite锁工作示意图"><br>采用“按位切割使用”的方式来维护这个变量，高16为表示读，低16为表示写：</li>
<li>写状态，等于 S &amp; 0x0000FFFF（将高 16 位全部抹去）。 当写状态加1，等于S+1.</li>
<li>读状态，等于 S &gt;&gt;&gt; 16 (无符号补 0 右移 16 位)。当读状态加1，等于S+（1&lt;&lt;16）,也就是S+0x00010000</li>
</ul>
<p>根据状态的划分能得出一个推论：<strong>S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</strong><br><img data-src="181e5700/%E8%AF%BB%E5%86%99%E9%94%81%E9%AB%98%E4%BD%8E%E4%BD%8D.jpg" alt="读写锁高低位"></p>
<h5 id="读写锁使用"><a href="#读写锁使用" class="headerlink" title="读写锁使用"></a>读写锁使用</h5><p>一个经典的使用场景就是缓存，读多写少。</p>
<h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><p><strong>锁降级指的是写锁降级成为读锁。</strong><br><strong>如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。</strong><br><strong>降级的目的是为了内存可见性问题</strong>。<br>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。锁降级可以帮助我们拿到当前线程修改后的结果而不被其他线程所破坏，防止更新丢失。</p>
<h2 id="并发编程相关"><a href="#并发编程相关" class="headerlink" title="并发编程相关"></a>并发编程相关</h2><h3 id="阻塞队列相关"><a href="#阻塞队列相关" class="headerlink" title="阻塞队列相关"></a>阻塞队列相关</h3><p>BlockingQueue 继承了 Queue 接口，是队列的一种。Queue 和 BlockingQueue 都是在 Java5 中加入的。阻塞队列（BlockingQueue）是<strong>一个在队列基础上又支持了两个附加操作的队列</strong>，常用解耦。<br>两个附加操作:</p>
<ul>
<li>支持阻塞的插入方法put: 队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li>支持阻塞的移除方法take: 队列空时，获取元素的线程会等待队列变为非空</li>
</ul>
<h4 id="BlockingQueue常用方法示例"><a href="#BlockingQueue常用方法示例" class="headerlink" title="BlockingQueue常用方法示例"></a>BlockingQueue常用方法示例</h4><p>当队列满了无法添加元素，或者是队列空了无法移除元素时：</p>
<ol>
<li>抛出异常：add、remove、element</li>
<li>返回结果但不抛出异常：offer、poll、peek</li>
<li>阻塞：put、take</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th align="center">抛出异常</th>
<th align="center">返回特定值</th>
<th align="center">阻塞</th>
<th align="center">阻塞特定时间</th>
</tr>
</thead>
<tbody><tr>
<td>入队</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center">put(e)</td>
<td align="center">offer(e, time, unit)</td>
</tr>
<tr>
<td>出队</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(time, unit)</td>
</tr>
<tr>
<td>获取队首元素</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
</tr>
</tbody></table>
<h4 id="阻塞队列特性"><a href="#阻塞队列特性" class="headerlink" title="阻塞队列特性"></a>阻塞队列特性</h4><p>阻塞队列区别于其他类型的队列的<strong>最主要的特点就是“阻塞”</strong>这两个字：阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。实现阻塞<strong>最重要的两个方法是 take 方法和 put 方法。</strong></p>
<h5 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h5><p>ake 方法的功能是获取并移除队列的头结点，通常在队列里有数据的时候是可以正常移除的。可是一旦执行 take 方法的时候，队列里无数据，则阻塞，直到队列里有数据。一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据。<br><img data-src="181e5700/take%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B.jpg" alt="take方法示例"></p>
<h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>put 方法插入元素时，如果队列没有满，那就和普通的插入一样是正常的插入，但是如果队列已满，那么就无法继续插入，则阻塞，直到队列里有了空闲空间。如果后续队列有了空闲空间，比如消费者消费了一个元素，那么此时队列就会解除阻塞状态，并把需要添加的数据添加到队列中。<br><img data-src="181e5700/put%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B.jpg" alt="put方法示例"></p>
<h4 id="常见的阻塞队列"><a href="#常见的阻塞队列" class="headerlink" title="常见的阻塞队列"></a>常见的阻塞队列</h4><table>
<thead>
<tr>
<th>队列</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td align="center">基于数组结构实现的一个有界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td align="center">基于链表结构实现的一个有界阻塞队列</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td align="center">支持按优先级排序的无界阻塞队列</td>
</tr>
<tr>
<td>DelayQueue</td>
<td align="center">基于优先级队列（PriorityBlockingQueue）实现的无界阻塞队列</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td align="center">不存储元素的阻塞队列</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td align="center">基于链表结构实现的一个无界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td align="center">基于链表结构实现的一个双端阻塞队列</td>
</tr>
</tbody></table>
<p><img data-src="181e5700/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%80%E8%A7%88.jpg" alt="阻塞队列一览"><br><a href="https://www.processon.com/view/link/6724421b7f2523247300baf9?cid=6724363c61fdee7d75fa9b4f">https://www.processon.com/view/link/6724421b7f2523247300baf9?cid=6724363c61fdee7d75fa9b4f</a></p>
<h3 id="Future相关"><a href="#Future相关" class="headerlink" title="Future相关"></a>Future相关</h3><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。<br>Future相关的几个核心方法：</p>
<ul>
<li>boolean cancel (boolean mayInterruptIfRunning) 取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束</li>
<li>boolean isCancelled () 任务是否已经取消，任务正常完成前将其取消，则返回true</li>
<li>boolean isDone () 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true</li>
<li>V get () throws InterruptedException, ExecutionException 等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常，ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException</li>
<li>V get (long timeout, TimeUnit unit) throws InterruptedException,ExecutionException, TimeoutException 同上面的get功能一样，多了设置超时时间。参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计算超时，将抛出TimeoutException</li>
</ul>
<h4 id="Future使用注意事项"><a href="#Future使用注意事项" class="headerlink" title="Future使用注意事项"></a>Future使用注意事项</h4><ul>
<li>当 for 循环批量获取 Future 的结果时容易 block，get 方法调用时应使用 timeout限制</li>
<li>Future 的生命周期不能后退。一旦完成了任务，它就永久停在了“已完成”的状态，不能从头再来</li>
</ul>
<h4 id="Future的局限性"><a href="#Future的局限性" class="headerlink" title="Future的局限性"></a>Future的局限性</h4><p>从本质上说，Future表示一个异步计算的结果。<strong>它提供了isDone()来检测计算是否已经完成，并且在计算结束后，可以通过get()方法来获取计算结果。</strong><br>在异步计算中，Future确实是个非常优秀的接口。但是，它的本身也确实存在着许多限制：</p>
<ul>
<li><strong>并发执行多任务</strong>：Future只提供了get()方法来获取结果，并且是阻塞的。所以，除了等待你别无他法；</li>
<li><strong>无法对多个任务进行链式调用</strong>：如果你希望在计算任务完成后执行特定动作，比如发邮件，但Future却没有提供这样的能力；</li>
<li><strong>无法组合多个任务</strong>：如果你运行了10个任务，并期望在它们全部执行结束后执行特定动作，那么在Future中这是无能为力的；</li>
<li><strong>没有异常处理</strong>：Future接口中没有关于异常处理的方法；</li>
</ul>
<h4 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h4><p>Callable+Future 可以实现多个task并行执行，但是如果遇到前面的task执行较慢时需要阻塞等待前面的task执行完后面task才能取得结果。<strong>而CompletionService的主要功能就是一边生成任务,一边获取任务的返回值。</strong>让两件事分开执行,任务之间不会互相阻塞，可以实现先执行完的先取结果，不再依赖任务顺序了。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>内部通过阻塞队列+FutureTask：<strong>实现了任务先完成可优先获取到</strong>，即结果按照完成先后顺序排序，先进先出的阻塞队列，用于保存已经执行完成的Future，通过调用它的take方法或poll方法可以获取到一个已经执行完成的Future，进而通过调用Future接口实现类的get方法获取最终的结果</p>
<h5 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li><strong>当需要批量提交异步任务的时候建议你使用CompletionService</strong>：CompletionService将线程池Executor和阻塞队列BlockingQueue的功能融合在了一起，能够让批量异步任务的管理更简单。</li>
<li><strong>CompletionService能够让异步任务的执行结果有序化</strong>：先执行完的先进入阻塞队列，利用这个特性，你可以轻松实现后续处理的有序性，避免无谓的等待，同时还可以快速实现诸如Forking Cluster这样的需求。</li>
<li><strong>线程池隔离</strong>：CompletionService支持自己创建线程池，这种隔离性能避免几个特别耗时的任务拖垮整个应用的风险。</li>
</ul>
<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p>CompletableFuture是Future接口的扩展和增强。CompletableFuture实现了Future接口，并在此基础上进行了丰富地扩展，完美地弥补了Future上述的种种问题。更为重要的是，<strong>CompletableFuture实现了对任务的编排能力</strong>。<br>借助这项能力，我们<strong>可以轻松地组织不同任务的运行顺序、规则以及方式</strong>。从某种程度上说，这项能力是它的核心能力。而在以往，虽然通过CountDownLatch等工具类也可以实现任务的编排，但需要复杂的逻辑处理，不仅耗费精力且难以维护。</p>
<h5 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h5><h6 id="描述依赖关系"><a href="#描述依赖关系" class="headerlink" title="描述依赖关系"></a>描述依赖关系</h6><ol>
<li>thenApply() 把前面异步任务的结果，交给后面的Function</li>
<li>thenCompose()用来连接两个有依赖关系的任务，结果由第二个任务返回<h6 id="描述and聚合关系"><a href="#描述and聚合关系" class="headerlink" title="描述and聚合关系"></a>描述and聚合关系</h6></li>
<li>thenCombine:任务合并，有返回值</li>
<li>thenAccepetBoth:两个任务执行完成后，将结果交给thenAccepetBoth消耗，无返回值。</li>
<li>runAfterBoth:两个任务都执行完成后，执行下一步操作（Runnable）。<h6 id="描述or聚合关系"><a href="#描述or聚合关系" class="headerlink" title="描述or聚合关系"></a>描述or聚合关系</h6></li>
<li>applyToEither:两个任务谁执行的快，就使用那一个结果，有返回值。</li>
<li>acceptEither: 两个任务谁执行的快，就消耗那一个结果，无返回值。</li>
<li>runAfterEither: 任意一个任务执行完成，进行下一步操作(Runnable)。<h6 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h6>CompletableFuture类自己也提供了anyOf()和allOf()用于支持多个CompletableFuture并行执行</li>
</ol>
<h3 id="Disruptor原理剖析"><a href="#Disruptor原理剖析" class="headerlink" title="Disruptor原理剖析"></a>Disruptor原理剖析</h3><p>Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）。</p>
<h4 id="juc并发类存在的问题"><a href="#juc并发类存在的问题" class="headerlink" title="juc并发类存在的问题"></a>juc并发类存在的问题</h4><ul>
<li>juc下的队列<strong>大部分采用加ReentrantLock锁</strong>方式保证线程安全。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列。</li>
<li>加锁的方式通常会严重影响性能。线程会因为竞争不到锁而被挂起，等待其他线程释放锁而唤醒，这个过程存在很大的开销，而且存在死锁的隐患。</li>
<li>有界队列通常采用数组实现。但是采用数组实现又会引发另外一个问题false sharing(伪共享)。</li>
</ul>
<h4 id="Disruptor的设计方案"><a href="#Disruptor的设计方案" class="headerlink" title="Disruptor的设计方案"></a>Disruptor的设计方案</h4><p>Disruptor通过以下设计来解决队列速度慢的问题：</p>
<ul>
<li><strong>环形数组结构</strong>：为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好（空间局<br>部性原理）。</li>
<li><strong>元素位置定位：</strong> 数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</li>
<li><strong>无锁设计：</strong> 每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</li>
<li><strong>利用缓存行填充解决了伪共享的问题</strong></li>
<li><strong>实现了基于事件驱动的生产者消费者模型（观察者模式）</strong>：消费者时刻关注着队列里有没有消息，一旦有新消息产生，消费者线程就会立刻把它消费</li>
</ul>
<h5 id="RingBuffer数据结构"><a href="#RingBuffer数据结构" class="headerlink" title="RingBuffer数据结构"></a>RingBuffer数据结构</h5><p>使用RingBuffer来作为队列的数据结构，RingBuffer就是一个可自定义大小的环形数组。除数组外还有一个序列号(sequence)，用以指向下一个可用的元素，供生产者与消费者使用。<br>原理如下图所示：<br><img data-src="181e5700/RingBuffer%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="RingBuffer结构示意图"><br>其中：</p>
<ul>
<li><strong>Disruptor要求设置数组长度为2的n次幂。</strong>在知道索引(index)下标的情况下，存与取数组上的元素时间复杂度只有O(1)，而这个index我们可以通过序列号与数组的长度取模来计算得出，index=sequence % entries.length。也可以用位运算来计算效率更高，此时array.length必须是2的幂次方，<strong>index=sequece&amp;(entries.length-1)</strong></li>
<li>当所有位置都放满了，再放下一个时，就会把0号位置覆盖掉</li>
</ul>
<p>当出现数据覆盖的时候，Disruptor会执行一个策略，Disruptor提供了多种策略：</p>
<ul>
<li><strong>BlockingWaitStrategy策略，常见且默认的等待策略</strong>，当这个队列里满了，<strong>不执行覆盖，而是阻塞等待</strong>。使用ReentrantLock+Condition实现阻塞，最节省cpu，但高并发场景下性能最差。适合CPU资源紧缺，吞吐量和延迟并不重要的场景</li>
<li><strong>SleepingWaitStrategy策略，会在循环中不断等待数据</strong>。先进行自旋等待如果不成功，则使用Thread.yield()让出CPU,并最终使用LockSupport.parkNanos(1L)进行线程休眠，以确保不占用太多的CPU资源。因此这个策略会产生比较高的平均延时。<strong>典型的应用场景就是异步日志</strong>。</li>
<li><strong>YieldingWaitStrategy策略，这个策略用于低延时的场合</strong>。消费者线程会不断循环监控缓冲区变化，在循环内部使用Thread.yield()让出CPU给别的线程执行时间。如果需要一个高性能的系统，并且对延时比较有严格的要求，可以考虑这种策略。个高性能的系统，并且对延时比较有严格的要求，可以考虑这种策略。</li>
<li><strong>BusySpinWaitStrategy策略: 采用死循环，消费者线程会尽最大努力监控缓冲区的变化</strong>。对延时非常苛刻的场景使用，cpu核数必须大于消费者线程数量。推荐在线程绑定到固定的CPU的场景下使用</li>
</ul>
<h5 id="使用代码示例"><a href="#使用代码示例" class="headerlink" title="使用代码示例"></a>使用代码示例</h5><p>参考：<a href="https://github.com/nimbusking/CoreJavaSample/tree/main/src/main/java/cc/nimbusk/corejava/concurent/disruptor">https://github.com/nimbusking/CoreJavaSample/tree/main/src/main/java/cc/nimbusk/corejava/concurent/disruptor</a></p>
<h2 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h2><h3 id="终止线程的设计模式"><a href="#终止线程的设计模式" class="headerlink" title="终止线程的设计模式"></a>终止线程的设计模式</h3><p><em>思考：在一个线程 T1 中如何正确安全的终止线程 T2？</em><br><strong>错误思路1：使用线程对象的 stop() 方法停止线程</strong><br>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁， 其它线程将永远无法获取锁 。<br><strong>错误思路2：使用 System.exit(int) 方法停止线程</strong><br>目的仅是停止一个线程，但这种做法会让整个程序都停止正确思路：利用Java线程的中断机制</p>
<h3 id="Two-phase-Termination（两阶段终止）模式"><a href="#Two-phase-Termination（两阶段终止）模式" class="headerlink" title="Two-phase Termination（两阶段终止）模式"></a>Two-phase Termination（两阶段终止）模式</h3><p><strong>优雅的终止线程</strong><br><strong>将终止过程分成两个阶段</strong>：其中第一个阶段主要是线程 T1 向线程 T2发送终止指令，而第二阶段则是线程 T2响应终止指令。<br>Java 线程进入终止状态的<strong>前提是线程进入 RUNNABLE 状态</strong>，而利用java线程中断机制的<strong>interrupt() 方法</strong>，可以让线程从休眠状态转换到RUNNABLE 状态。<br>RUNNABLE 状态转换到终止状态，优雅的方式是让 Java 线程自己执行完 run() 方法，所以一般我们采用的方法是设置一个标志位，然后线程会在合适的时机检查这个标志位，如果发现符合终止条件，则自动退出run() 方法。</p>
<h4 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><ul>
<li>一个是仅检查终止标志位是不够的，因为线程的状态可能处于休眠态；</li>
<li>另一个是仅检查线程的中断状态也是不够的，因为我们依赖的第三方类库很可能没有正确处理中断异常，例如第三方类库在捕获到 Thread.sleep() 方法抛出的中断异常后，没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。所以我们<strong>可以自定义线程的终止标志位用于终止线程</strong>。<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4></li>
</ul>
<ol>
<li>安全地终止线程，比如释放该释放的资源</li>
<li>要确保终止处理逻辑在线程结束之前一定会执行时，可使用该方法</li>
</ol>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorProxy2</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//采集线程</span></span><br><span class="line">    Thread rptThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程终止标志位</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">terminated</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动采集功能</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不允许同时启动多个采集线程</span></span><br><span class="line">        <span class="keyword">if</span> (started) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">        rptThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; !terminated) &#123;</span><br><span class="line">                <span class="comment">//省略采集、回传实现</span></span><br><span class="line">                report();</span><br><span class="line">                <span class="comment">//每隔两秒钟采集、回传一次数据</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 重新设置线程中断状态，</span></span><br><span class="line">                    <span class="comment">// 如果这里不采用第二个标志位terminated的话，这里一定要手动还原中断标志位，否则会挑不出循环</span></span><br><span class="line">                    <span class="comment">// 因为Thread.sleep方法调用后，会清除中断标志位，清除后isInterrupted方法调用永远返回false</span></span><br><span class="line">                    <span class="comment">//Thread.currentThread().interrupt();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行到此处说明线程马上终止</span></span><br><span class="line">            started = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        rptThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">report</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;采集数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止采集功能</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置中断标志位</span></span><br><span class="line">        terminated = <span class="literal">true</span>;</span><br><span class="line">        rptThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MonitorProxy2</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonitorProxy2</span>();</span><br><span class="line">        monitor.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        monitor.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="避免共享的设计模式"><a href="#避免共享的设计模式" class="headerlink" title="避免共享的设计模式"></a>避免共享的设计模式</h3><p>Immutability模式，Copy-on-Write模式，Thread-Specific Storage模式<strong>本质上都是为了避免共享</strong>。</p>
<ul>
<li>使用时需要注意Immutability模式的属性的不可变性</li>
<li>Copy-on-Write模式需要注意拷贝的性能问题</li>
<li>Thread-Specific Storage模式需要注意异步执行问题。<h4 id="Immutability模式"><a href="#Immutability模式" class="headerlink" title="Immutability模式"></a>Immutability模式</h4>“多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，<strong>如果只有读，而没有写，是没有并发问题的</strong>。解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。<br>所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。</li>
</ul>
<h5 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h5><p>将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了。更严格的做法是这个类本身也是 final 的，也就是不允许继承。</p>
<h4 id="Copy-on-Write模式"><a href="#Copy-on-Write模式" class="headerlink" title="Copy-on-Write模式"></a>Copy-on-Write模式</h4><p>Java 里 String 在实现 replace() 方法的时候，并没有更改原字符串里面 value[]数组的内容，而是创建了一个新字符串，这种方法在解决不可变对象的修改问题时经常用到。它本质上是一种 Copy-on-Write 方法。所谓 Copy-on-Write，经常被缩写为 <em>COW</em> 或者 <em>CoW</em>，顾名思义就是<strong>写时复制</strong>。<br>不可变对象的写操作往往都是使用 Copy-on-Write 方法解决的，当然 Copy-on-Write 的应用领域并不局限于 Immutability 模式。<br><strong>Copy-on-Write 缺点就是消耗内存</strong>，每次修改都需要复制一个新的对象出来，好在随着自动垃圾回收（GC）算法的成熟以及硬件的发展，这种内存消耗已经渐渐可以接受了。所以在实际工作中，如果写操作非常少（读多写少的场景），可以尝试使用 Copy-on-Write。</p>
<h5 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h5><p>在Java中，<strong>CopyOnWriteArrayList</strong> 和 <strong>CopyOnWriteArraySet</strong> 这两个 Copy-on-Write容器，它们背后的设计思想就是 Copy-on-Write；通过 Copy-on-Write 这两个容器实现的读操作是无锁的，由于无锁，所以将读操作的性能发挥到了极致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.CopyOnWriteArrayList#add(int, E)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">// 这段CopyOnWriteArrayList中心中的代码，就是用了一个ReentrantLock独占锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index+</span><br><span class="line">                                                    <span class="string">&quot;, Size: &quot;</span>+len);</span><br><span class="line">            Object[] newElements;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index;</span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 扩容</span></span><br><span class="line">                newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 拷贝</span></span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                                 numMoved);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新增</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Copy-on-Write 在操作系统领域也有广泛的应用。类 Unix 的操作系统中创建进程的 API是 fork()，传统的 fork() 函数会创建父进程的一个完整副本，例如父进程的地址空间现在用到了 1G 的内存，那么 fork() 子进程的时候要复制父进程整个进程的地址空间（占有 1G 内存）给子进程，这个过程是很耗时的。<br>而<strong>Linux 中fork() 子进程的时候，并不复制整个进程的地址空间</strong>，而是让父子进程共享同一个地址空间；只用在父进程或者子进程需要写入的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。<br>Copy-on-Write 最大的应用领域还是在函数式编程领域。函数式编程的基础是不可变性（Immutability），所以函数式编程里面所有的修改操作都需要 Copy-on-Write 来解决。<br>像一些RPC框架还有服务注册中心（<em>例如阿里的nacos</em>），也会利用Copy-on-Write设计思想维护服务路由表。路由表是典型的读多写少，而且路由表对数据的一致性要求并不高，一个服务提供方从上线到反馈到客户端的路由表里，即便有 5 秒钟延迟，很多时候也都是能接受的。</p>
<h3 id="Thread-Specific-Storage-模式"><a href="#Thread-Specific-Storage-模式" class="headerlink" title="Thread-Specific Storage 模式"></a>Thread-Specific Storage 模式</h3><p>Thread-Specific Storage（线程本地存储） 模式是一种即使只有一个入口，也会在内部为每个线程分配特有的存储空间的模式。在 Java 标准类库中，<strong>ThreadLocal 类实现了该模式</strong>。<br><strong>线程本地存储模式本质上是一种避免共享的方案</strong>，由于没有共享，所以自然也就没有并发问题。如果你需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。<br>避免共享有两种方案，<strong>一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式</strong>。<br>这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，<strong>所以不存在频繁创建对象</strong>的问题。</p>
<h3 id="多线程版本的if模式"><a href="#多线程版本的if模式" class="headerlink" title="多线程版本的if模式"></a>多线程版本的if模式</h3><p>Guarded Suspension模式和Balking模式属于多线程版本的if模式</p>
<ul>
<li>Guarded Suspension模式需要注意性能。</li>
<li>Balking模式需要注意竞态问题。上面的MonitorProxy2代码里的start变量就是这种模式的写法。<h4 id="Guarded-Suspension模式"><a href="#Guarded-Suspension模式" class="headerlink" title="Guarded Suspension模式"></a>Guarded Suspension模式</h4>Guarded Suspension 模式是<strong>通过让线程等待来保护实例的安全性</strong>，即<strong>守护-挂起模式</strong>。在多线程开发中，常常为了提高应用程序的并发性，会将一个任务分解为多个子任务交给多个线程并行执行，而多个线程之间相互协作时，<em>仍然会存在一个线程需要等待另外的线程完成后继续下一步操作</em>。而Guarded Suspension模式可以帮助我们解决上述的等待问题。</li>
</ul>
<p>Guarded Suspension 模式允许多个线程对实例资源进行访问，但是实例资源需要对资源的分配做出管理。</p>
<p>Guarded Suspension 模式也常被称作 Guarded Wait 模式、Spin Lock 模式（因为使用了 while 循环去等待），它还有一个更形象的非官方名字：<strong>多线程版本的 if</strong>。</p>
<h5 id="实现场景"><a href="#实现场景" class="headerlink" title="实现场景"></a>实现场景</h5><ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们<strong>关联同一个 GuardedObject</strong></li>
<li>如果有结果不断从一个线程到另一个线程那么<strong>可以使用消息队列</strong></li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到<strong>同步模式</strong></li>
<li>等待唤醒机制的规范实现。此模式依赖于Java线程的阻塞唤醒机制：<ul>
<li><p>sychronized + wait/notify/notifyAll</p>
</li>
<li><p>reentrantLock + Condition(await/singal/singalAll)</p>
</li>
<li><p>cas+park/unpark</p>
<h5 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h5></li>
</ul>
</li>
<li>多线程环境下多个线程访问相同实例资源，从实例资源中获得资源并处理；</li>
<li>实例资源需要管理自身拥有的资源，并对请求线程的请求作出允许与否的判断；</li>
</ul>
<h4 id="Balking模式"><a href="#Balking模式" class="headerlink" title="Balking模式"></a>Balking模式</h4><p>Balking是“退缩不前”的意思。<strong>如果现在不适合执行这个操作，或者没必要执行这个操作，就停止处理，直接返回。</strong>当流程的执行顺序依赖于某个共享变量的场景，可以归纳为多线程if模式。Balking 模式常用于一个线程发现另一个线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。<br><strong>Balking模式和Guarded Suspension模式一样，存在守护条件，如果守护条件不满足，则中断处理</strong>；这与Guarded Suspension模式不同，Guarded Suspension模式在守护条件不满足的时候会一直等待至可以运行。</p>
<h5 id="实现场景-1"><a href="#实现场景-1" class="headerlink" title="实现场景"></a>实现场景</h5><ul>
<li>锁机制 （synchronized reentrantLock）</li>
<li>CAS</li>
<li>对于共享变量不要求原子性的场景，可以使用volatile</li>
</ul>
<h5 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li>sychronized轻量级锁膨胀逻辑， 只需要一个线程膨胀获取monitor对象</li>
<li>DCL单例实现</li>
<li>服务组件的初始化</li>
</ul>
<h3 id="多线程分工模式"><a href="#多线程分工模式" class="headerlink" title="多线程分工模式"></a>多线程分工模式</h3><p>Thread-Per-Message 模式、Worker Thread 模式和生产者 - 消费者模式属于多线程分工模式。</p>
<ul>
<li>Thread-Per-Message 模式需要注意线程的创建，销毁以及是否会导致OOM。</li>
<li>Worker Thread 模式需要注意死锁问题，提交的任务之间不要有依赖性。</li>
<li>生产者 - 消费者模式可以直接使用线程池来实现<h4 id="Thread-Per-Message-模式"><a href="#Thread-Per-Message-模式" class="headerlink" title="Thread-Per-Message 模式"></a>Thread-Per-Message 模式</h4>Thread-Per-Message 模式就是为每个任务分配一个独立的线程，这是一种最简单的分工方法。<h5 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h5>Thread-Per-Message 模式的<strong>一个最经典的应用场景是网络编程里服务端的实现</strong>，服务端为每个客户端请求创建一个独立的线程，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。</li>
</ul>
<p>Thread-Per-Message 模式作为一种最简单的分工方案，Java 中使用会存在性能缺陷。<strong>在Java 中的线程是一个重量级的对象，创建成本很高</strong>，一方面创建线程比较耗时，另一方面线程占用的内存也比较大。所以为每个请求创建一个新的线程并不适合高并发场景。为了解决这个缺点，Java 并发包里提供了线程池等工具类。</p>
<h4 id="Worker-Thread模式"><a href="#Worker-Thread模式" class="headerlink" title="Worker Thread模式"></a>Worker Thread模式</h4><p>要想有效避免线程的频繁创建、销毁以及 OOM 问题，就不得不提 Java 领域使用最多的Worker Thread 模式</p>
<h5 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h5><p>Worker Thread 模式能避免线程频繁创建、销毁的问题，而且能够限制线程的最大数量。<strong>Java 语言里可以直接使用线程池来实现</strong> Worker Thread 模式，线程池是一个非常基础和优秀的工具类，甚至有些大厂的编码规范都不允许用 new Thread() 来创建线程，必须使用线程池。</p>
<h4 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者 - 消费者模式"></a>生产者 - 消费者模式</h4><p>生产者 - 消费者模式的核心是：<strong>一个任务队列，生产者线程生产任务，并将任务添加到任务队列中，而消费者线程从任务队列中获取任务并执行</strong>。<br><img data-src="181e5700/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="生产者消费者模式"></p>
<h5 id="模式优点"><a href="#模式优点" class="headerlink" title="模式优点"></a>模式优点</h5><ol>
<li><strong>支持异步处理</strong><br>例子：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式，如下图所示：<br><img data-src="181e5700/2024-11-02_160057.jpg" alt="传统模式"><br>引入消息队列后：<br><img data-src="181e5700/2024-11-02_160137.jpg" alt="引入消息队列后"></li>
</ol>
<ol start="2">
<li><p><strong>解耦</strong><br>场景：用户下单后，订单系统需要通知库存系统扣减库存。<br><img data-src="181e5700/2024-11-02_160219.jpg" alt="解耦"></p>
</li>
<li><p><strong>可以消除生产者生产与消费者消费之间速度差异（削峰填谷）</strong><br>例如：<br><img data-src="181e5700/2024-11-02_160251.jpg" alt="速度差异的处理"></p>
</li>
</ol>
<h5 id="过饱问题解决方案"><a href="#过饱问题解决方案" class="headerlink" title="过饱问题解决方案"></a>过饱问题解决方案</h5><p>在实际生产项目中会有些极端的情况，导致生产者/消费者模式可能出现过饱的问题。<strong>单位时间内，生产者生产的速度大于消费者消费的速度，导致任务不断堆积到阻塞队列中，队列堆满只是时间问题</strong>。<br>通常处理的方案：</p>
<ul>
<li>消费者机器扩容，增加消费能力</li>
<li>适当的增加队列容量，提升冗余能力</li>
<li>生产者限流：降低生产者速度</li>
</ul>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>并发原理</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存分配策略与垃圾收集</title>
    <url>/post/d16864e6.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看过部分机构的教学视频，针对这部分内容，仍然觉得是《深入理解Java虚拟机 第三版》（下文简述：该书）一书中解释的更为系统，更为条理。<br><strong>先惭愧一番，笔者在2020年第一次阅读该书的时候，曾经做过一次读书笔记</strong>，<a href="https://nimbik.cc/post/d7ba81a7">链接在这</a>。时隔几年之后，再次看当年写的，那叫什么玩意儿？纯粹的一个书籍摘录？完全没有思考，现在能回忆起来，可能当时跟着书里面敲过几个案例而已。然而，最搞笑的事情是，我竟然忘了自己做过这种蠢事了。直到最近重新捡起JVM的时候，才看到之前写的文章。<br><strong>这里纯当给众看官一个笑话吧，一个赤裸裸的反面教材</strong></p>
<span id="more"></span>
<p>回到标题，以该书第三章标题作为本篇的标题，也是我们熟悉JVM原理最终调优需要解决的问题，就是如何让这两件事更优雅的去工作。<br>再次写，梳理好思路，形成自己的东西吧。</p>
<h3 id="关于该书的阅读感受"><a href="#关于该书的阅读感受" class="headerlink" title="关于该书的阅读感受"></a>关于该书的阅读感受</h3><p>首先，公认的（包括我在内），这本书是<strong>国内</strong>最好的、系统的介绍JVM的书籍（直到2024年了，依旧没有发现与之媲美的）。<br>再来，笔者阅读过第二版与第三版，如果你还没有，直接入手第三版即可，第三版中增加了很多关于JDK8之后的JVM的介绍与比较，是值得看的。<br>该书，更多的要当一本JVM手册书去看，时不时的要去翻翻，才能有更多的体会。<strong>建议不要妄想一下子从头到尾啃完，这个难度非常大，至少我是没有这个水平</strong>。<br>再来说一个问题，周老师的这本书的章节排版上，讲实话读一遍两遍（可能还没读完，读一半的那种），你可能会有一个感觉，<strong>读到后面忘掉前面</strong>。我仔细想了一下，为啥会有这个感觉？<br>我的体会是，<strong>书中大量地方其实是穿插介绍的，并没有走总分这条线下来</strong>。作者在书中前言也提到：</p>
<blockquote>
<p>该书前言节选：<br>本书一共分为五个部分：走进Java、自动内存管理、虚拟机执行子系统、程序编译与代码优化、高校并发。各个部分之间基本上是相互独立的，没有必然的前后依赖关系，读者可以从任何一个感兴趣的专题开始阅读，但是各个部分各个章节间则有先后顺序。</p>
</blockquote>
<p>正因为如此，所以有个问题就是：<strong>如果你在阅读，需要你自己形成一个总分的脉络，来理解JVM的底层，这样才能助于记忆。</strong> 不然两天不摸，你可能就忘了。</p>
<h4 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h4><p>既然如此，我在翻过3-4遍该书之后，有个新的认识，这里分享出来一个可以参考的阅读顺序。<br><strong>注：</strong> 这里的阅读顺序更多的是侧重运行时的原理，该书的主体脉络也是如此。至于编译原理【惭愧，大学学的编译原理课程早就还给老师了】相关的，该书中介绍的篇幅其实是相对少的，在第10章和第11章有所介绍。毕竟我们老生常谈的JVM调优，更多侧重的是运行时的优【解】啊，不是编译的优化。所以这部分，我也不作细节阐述。</p>
<ol>
<li><strong>JVM内存模型相关</strong>：这部分死磕，一个字都别拉下的那种，而且必须熟记于心，因为这是所有的JVM后续工作的基础。<strong>对应该书，第2.2小节。</strong></li>
<li><strong>对象的创建过程</strong>：解释如何创建及内存布局相关，<strong>对应该书，第2.3节</strong><br> 2.1. <strong>类加载器及对象的加载过程</strong>：<strong>对应书中第7章</strong>，包括双亲委派模型等。</li>
<li><strong>再次细致的熟悉栈帧结构</strong>：第8.2小节</li>
<li><strong>对象内存分配与回收策略</strong>：对应该书，第3.8小节。</li>
<li><strong>垃圾收集算法理论</strong>：对应该书，第3.2、3.3、3.4小节</li>
<li><strong>垃圾收集器相关</strong>：对应该书，第3.5、3.6小节<br> 6.1. 第3.7小节，如何选择合适的垃圾收集器</li>
<li><strong>调优命令与工具</strong>：第4章，JVM命令行及可视化工具</li>
<li><strong>调优案例分析与实战</strong>：第5章全篇，不要在意书中提到的例子是不是跟你工作有关，重点体会作者调优的思路，以及理解为什么要这样做即可。</li>
<li><strong>剩下的内容</strong>：这部分，我个人觉得，看你兴趣翻阅看即可。<br> 9.1. 第1章的背景，了解了解Java的发展历程；<br> 9.2. 第6章，类文件结构，这部分了解，了解之后可能对类加载过程更深刻一点，完全不用背；<br> 9.3. 第8章其余小节，了解字节码执行引擎其余的细节，比如动态类型支持的原理；<br> 9.4. 第10、11章，这部分就跟编译原理相关了，第11.4.3小节，逃逸分析可以了解；<br> 9.5. 第12、13章，这部分介绍JVM在处理并发程序时的一些原理，特别是第12.3小节，Java内存模型（JMM）值得一看。<br> 9.6. 其余边角，不一一例举。</li>
</ol>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>这部分内容参考，另外一篇文章：<a href="https://nimbik.cc/post/6377921b">JVM内存模型</a></p>
<h2 id="内存分配与垃圾收集"><a href="#内存分配与垃圾收集" class="headerlink" title="内存分配与垃圾收集"></a>内存分配与垃圾收集</h2><p>阐述从分配到垃圾收集过程中的细节</p>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p><strong>注：</strong> 这部分非常重要，只有充分理解了一个对象在内存中的分配的过程，在遇到JVM性能调优的问题的时候，再结合具体的垃圾收集器的工作的表现，才有明确的思路去进行参数优化。<br>否则的话，你虽然看到譬如gc信息的时候，你看到了是这样的，但是不知道为什么会造成这样，间接的你不会直到可能存在的代码问题，更别谈参数调优了。<br><img data-src="d16864e6/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="对象内存分配示意图"></p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p><strong>注：</strong> 书中关于这部分描述，在第11章，第11.4.3小节中有详细阐述。<strong>目的就是通过逃逸分析手段，来判断对象是否可以分配或者间接引用栈上内存，而不分配在堆上。这部分隶属于编译优化的技术。</strong><br><strong>逃逸分析基本原理</strong>：分析对象动态作用域，当一个对象在方法里面被定义之后，它可能被外部方法所引用，例如作为调用参数传递到其它方法中，这种称为<strong>方法逃逸</strong>；甚至可能被外部线程访问到，譬如赋值给可以在其它线程中访问的实例变量，这种成为<strong>线程逃逸</strong>。<br><strong>从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度</strong>。<br>如果逃逸程度比较低（除线程逃逸之外的），可以用下面几个方法来优化对象实例的分配：</p>
<ul>
<li><strong>栈上分配（Stack Allocations）</strong>：直接在栈上分配，减轻垃圾收集器的压力，随着栈销毁而销毁。<br>  <strong>注</strong>：目前HotSpot里面没有做这项优化。</li>
<li><strong>标量替换（Scalar Replacement）</strong>：标量是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就称之为<strong>标量</strong>。反之称之为，<strong>聚合量</strong>。<br>  如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称之为<strong>标量替换</strong>。对逃逸程度要求更高，不允许方法逃逸之外的情况产生。</li>
<li><strong>同步消除（Synchronization Elimination）</strong>：如果变量不会逃出线程，自然变量的读写不会出现竞争，对这个变量实施的同步措施也可以安全的被消除。<br>笔者在本地JDK1.8环境中的默认JVM参数发现，目前1.8.0版本，关于逃逸分析（**-XX:+DoEscapeAnalysis<strong>）及标量替换（</strong>-XX:+EliminateAllocations<strong>）和同步消除（</strong>-XX:+EliminateLocks**）两个关联参数是默认打开的。</li>
</ul>
<h4 id="在Eden区分配"><a href="#在Eden区分配" class="headerlink" title="在Eden区分配"></a>在Eden区分配</h4><p>大多数情况下，对象在新生代中 Eden 区分配。当 <strong>Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC</strong>。<br>大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，让eden区尽量的大，survivor区够用即可，<br>JVM默认有这个参数 <strong>-XX:+UseAdaptiveSizePolicy</strong>(1.8默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数 <strong>-XX:-UseAdaptiveSizePolicy</strong></p>
<p>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现无法存入Survior空间，所以只好把新生代的<strong>对象提前转移到老年代</strong>中去，老年代上的空间如果足够存放，所以不会出现Full GC</p>
<h5 id="Minor-GC与Full-GC不同"><a href="#Minor-GC与Full-GC不同" class="headerlink" title="Minor GC与Full GC不同"></a>Minor GC与Full GC不同</h5><ul>
<li><strong>Minor GC/Young GC</strong>：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li><strong>Major GC/Full GC</strong>：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。</li>
</ul>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 <strong>-XX:PretenureSizeThreshold</strong> 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，<strong>这个参数只在 Serial 和ParNew两个收集器下有效。</strong></p>
<h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给<strong>每个对象一个对象年龄（Age）计数器</strong>。这个存储在对象头中。<br>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <strong>-XX:MaxTenuringThreshold</strong> 来设置。</p>
<h4 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h4><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(<strong>-XX:TargetSurvivorRatio</strong>可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以直接进入老年代了。<br>例如Survivor区域里现在有一批对象，<strong>年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%**，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，</strong>尽早进入老年代**。对象动态年龄判断机制一般是在minor gc之后触发的。</p>
<h4 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a>老年代空间分配担保机制</h4><p><strong>年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间</strong><br>如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)就会看一个 <strong>-XX:-HandlePromotionFailure</strong> (jdk1.8默认就设置了)的参数是否设置了如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。<br>如果上一步结果是<strong>小于或者之前说的参数没有设置</strong>，那么就会触发一次Full GC，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生”OOM”<br>当然，如果Minor GC之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发Full GC，Full GC完之后如果还是没有空间放Minor GC之后的存活对象，则也会发生“OOM”<br><img data-src="d16864e6/%E8%80%81%E5%B9%B4%E4%BB%A3%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E6%B5%81%E7%A8%8B.png" alt="老年代空间分配担保流程"></p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>这部分重点搞清楚下面几个问题：</p>
<ul>
<li>什么对象判定为活着的？</li>
<li>无用对象怎么回收？</li>
<li>节点扫描的细节</li>
<li>垃圾收集器相关细节</li>
</ul>
<p><strong>注：</strong>核心的思想，在明确什么对象能回收之后，怎么更好、更快的收集。后面HostSpot回收算法实现细节里面诞生的种种算法实现场景，就是慢慢的优化各种回收扫描时的问题而诞生的。</p>
<h4 id="对象存活判定法则"><a href="#对象存活判定法则" class="headerlink" title="对象存活判定法则"></a>对象存活判定法则</h4><h5 id="引用计数法（Reference-Couting）"><a href="#引用计数法（Reference-Couting）" class="headerlink" title="引用计数法（Reference Couting）"></a>引用计数法（Reference Couting）</h5><p>经典的说法：对象中添加一个引用计数器，每当有一个地方引用它时，计数器加一；当引用失效时，计数器值减一；任何计数器为零的对象就是不可能再被使用的。<br>主流的Java虚拟机没有选用引用计数法来管理内存，主要原因：这个看似简单的算法有很多例外情况需要考虑，<strong>必须要配合大量额外的处理才能保证正确的工作</strong>，譬如单纯的引用计数就很难解决两个对象循环引用的问题。</p>
<h5 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h5><p>基本原理： 通过一系列称为“GC Roots”的根对象作为起始点集，从这些点开始，根据引用向下搜索，搜索过程所走的路径称之为“引用链”（Reference Chain），如果<strong>某个对象到GC Roots间没有任何引用链</strong>（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者说（图论）从GC Roots到这个对象不可达时，则证明此对象时不可能再引用的。</p>
<p>Java技术体系中，可固定作为GC Roots对象包括以下几种类型：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量。</li>
<li>在方法区中 类静态属性 引用的对象，譬如Java类的引用类型静态变量</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。<h5 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h5>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为 强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）、和 虚引用（Phantom Reference） 这4种，这4种引用强度依次逐渐减弱。</li>
<li><strong>强引用</strong>是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li>
<li><strong>软引用</strong>是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了<code>SoftReference</code>类来实现软引用。</li>
<li><strong>弱引用</strong>也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了<code>WeakReference</code>类来实现弱引用。</li>
<li><strong>虚引用</strong>也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。 在JDK 1.2版之后提供了<code>PhantomReference</code>类来实现虚引用。<h5 id="关于finalize方法"><a href="#关于finalize方法" class="headerlink" title="关于finalize方法"></a>关于finalize方法</h5>要真正宣告一个对象死亡，至少要经历两次标记的过程：</li>
<li>如果对象在进行可达性分析后发现<em>没有与GC Roots相连接</em>的引用链，那他将会被第一次标记</li>
<li>随后进行一次筛选，筛选的条件是次对象是是否必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“<strong>没有必要执行</strong>”。</li>
<li><strong>正因为虚拟机的这种判定规则，所以不建议通过finalize试图“挽救”对象</strong></li>
</ul>
<h5 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h5><p>《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集器。<br>方法区的垃圾收集主要回收两个部分： <strong>废弃的常量和不再使用的类型</strong><br><strong>注：</strong>方法区通常能回收的对象都比较少，回收程度都比较低，正因为如此，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的压力。JDK8中常用的CMS垃圾收集器，参数：<code>-XX:+CMSClassUnloadingEnabled</code>，默认已经开了。</p>
<ul>
<li>回收废弃常量与回收Java堆中的对象非常相似，如果<strong>没有任何字符串对象引用常量池中的常量</strong>，且虚拟机中也没有其它地方引用这个字面量。如果此时发生内存回收，而且垃圾收集器判定必要的话，则这个常量会被回收。</li>
<li>判定一个类型是否属于“<strong>不再被使用的类</strong>”的条件就比较苛刻，需要<strong>同时满足下面三个条件</strong>：<ul>
<li><strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例</li>
<li><strong>加载该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的</li>
<li>该类<strong>对应的java.lang.Class对象没有被任何地方引用</strong>，无法再任何地方通过反射访问该类。<h4 id="垃圾收集算法理论"><a href="#垃圾收集算法理论" class="headerlink" title="垃圾收集算法理论"></a>垃圾收集算法理论</h4>垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类。用于前者在目前主流JMV中均未涉及，这里研究的都是追踪式垃圾收集。</li>
</ul>
</li>
</ul>
<p><strong>注：</strong>书中提到了一本可以说是工人的系统介绍GC原理的第一的一本书，很有意思：《The Garbage Collection Handbook》，有兴趣的可以找来看看，有中译版本。</p>
<h5 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h5><p>目前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计的。<br><strong>注：</strong>书中有一个标注，值得注意的时候，在最新的几款垃圾收集器，都倾向于面向全区域收集设计的思维，或者可以支持全区域不分代收集的工作模式。<br>这个是有两个分代假说：</p>
<ol>
<li><strong>弱分代假说（Weak Generational Hypothesis ）</strong>：绝大多数对象都是朝生夕灭的。</li>
<li><strong>强分代假说（String Generational Hypothesis）</strong>：熬过越多次垃圾收集过程的对象就越难以消亡。<br>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：<strong>收集器应该将Java堆划分出不同的区域，然后将回收对象一句其年龄（年龄即对象熬过垃圾收集的过程的次数）分配到不同的区域之中存储。</strong><br>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了 “Minor GC”“Major GC”“Full GC” 这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——<strong>因而发展出了 “标记-复制算法”“标记-清除算法”“标记-整理算法” 等针对性的垃圾收集算法。</strong></li>
</ol>
<p><strong>注：</strong>这是目前主流垃圾收集算法诞生的背景。</p>
<p>通常意义下，直接可以按照不同内存区域中的对象，直接回收，但是往往存在一个明显的困难： <strong>对象不是孤立的，对象之间会存在跨代引用</strong>，为了解决这个问题，就需要对分代收集理论添加<strong>第三条经验法则</strong>：<br>3) <strong>跨代引用假说（Intergenrational Reference Hypothesis）</strong>：跨代引用相对于同代引用来说仅占极少数。<br>这其实是可根据前两条假说逻辑推理出一个隐含推论：<em>存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡</em>。举个例子：如果某个新生代对象存在跨代引用，由于老年代对象难以小王，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长晋升到老年代中，这是跨代引用自然就消除了。</p>
<p>根据第三条假说，诞生了一个对后面HotSpot回收算法实现的重要设定：<em>不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用</em>，只需在<strong>新生代上建立一个全局的数据结构（称之为“记忆集”，Remembered Set）</strong>，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。<br>作用就是：此后当发生MinorGC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots扫描。虽然维护会增加一定开销，但是相比扫描整个老年代来说，还是划算的。</p>
<h5 id="关于GC名词的统一定义"><a href="#关于GC名词的统一定义" class="headerlink" title="关于GC名词的统一定义"></a>关于GC名词的统一定义</h5><ul>
<li><strong>部分收集（Partial GC）</strong>：指 目标不是完整收集整个Java堆的垃圾收集，其中又分为<ul>
<li><strong>新生代收集（Minor GC/Young GC）</strong>：指目标只是新生代的垃圾收集。</li>
<li><strong>老年代收集（Major GC/Old GC）</strong>：指目标只是老年代的垃圾收集。 目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li><strong>混合收集（Mixed GC）</strong>：指目标是 收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为</li>
</ul>
</li>
<li><strong>整堆收集（Full GC）</strong>：收集整个Java堆和方法区的垃圾收集<h5 id="标记-清除（Mark-Sweep）"><a href="#标记-清除（Mark-Sweep）" class="headerlink" title="标记-清除（Mark-Sweep）"></a>标记-清除（Mark-Sweep）</h5>算法分为 <strong>“标记”和“清除” 两个阶段</strong>：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。<br>该算法主要的两个问题：</li>
<li>第一个是<strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须 进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li>
<li>第二个是 <strong>内存空间的碎片化问题</strong>，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br><img data-src="d16864e6/mark-sweep.png" alt="标记清除算法示意图"><h5 id="标记-复制（Mark-Copy）"><a href="#标记-复制（Mark-Copy）" class="headerlink" title="标记-复制（Mark-Copy）"></a>标记-复制（Mark-Copy）</h5>面对对标记清除算法对大对象回收效率慢的问题，提出 <strong>“半区复制”（Semispace Copying）</strong> 的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br><img data-src="d16864e6/mark-copy.png" alt="标记复制算法示意图"></li>
</ul>
<p><strong>虽然实现简单，运行高效，但是存在一个问题：可用内存缩小了一半，空间浪费过多。</strong><br>该算法的改进，也是主流垃圾收集器所采用的新生代收集算法：<strong>Appel式回收</strong>（1989年，Andrew Appel提出的改进）：<br>Appel式回收的具体做法是：<strong>把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor</strong>。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），<strong>只有一个Survivor空间，即10%的新生代是会被“浪费”的。</strong><br><strong>注：</strong>冥冥之中，这何尝不是一种2:8法则呢。<br><strong>特例：</strong> Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行<strong>分配担保（Handle Promotion）</strong>，即前文中的老年代空间担保。</p>
<h5 id="标记-整理（Mark-Compact）"><a href="#标记-整理（Mark-Compact）" class="headerlink" title="标记-整理（Mark-Compact）"></a>标记-整理（Mark-Compact）</h5><p><strong>诞生背景</strong>：标记-复制算法在<strong>对象存活率较高时就要进行较多的复制操作，效率将会降低</strong>。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以<strong>在老年代一般不能直接选用这种算法。</strong><br>1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤<strong>不是直接对可回收对象进行清理</strong>，而是<strong>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</strong><br><img data-src="d16864e6/mark-compact.png" alt="标记整理算法示意图"></p>
<h5 id="三个回收算法之间的羁绊（总结）"><a href="#三个回收算法之间的羁绊（总结）" class="headerlink" title="三个回收算法之间的羁绊（总结）"></a>三个回收算法之间的羁绊（总结）</h5><p>两个羁绊：</p>
<ul>
<li><strong>如果移动存活对象</strong>，尤其是在老年代这种每次回收都有大量对象存活区域，<strong>移动存活对象</strong>并更新所有引用这些对象的地方将会是一种<strong>极为负重的操作</strong>，而且这种<strong>对象移动操作必须全程暂停用户应用程序</strong>（<strong>注：</strong>因为如果你不暂停，新的对象进来，前面标记等待移动的还有啥用，达不到清除的效果）才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World”（简称：STW）</li>
<li><strong>如果不移动对象</strong>，像标记清理算法那样，那样就会产生大量的<strong>内存碎片化问题</strong>。<br>基于上面两个问题考虑，一些垃圾收集器都是有侧重点的，例如关注吞吐量的Parallel Scavenge收集器是基于标记整理的，而关注延时的CMS收集器则是基于标记清除的。<br>这里面有个“和稀泥”的佼佼者，也是目前使用JDK8场景下，依旧主流的使用的垃圾收集器CMS。CMS则是暂时允许碎片化存在，多数就使用标记-清除，只有当碎片化达到一定程度时，使用标记-整理一次性获得比较连续的空间。</li>
</ul>
<p><strong>注：</strong>看到这里你就会发现，其实垃圾收集器的一步一步演进，都是有迹可循的。把握住每个算法的优缺点，结合后续GC的实现，就会看的更明白了。</p>
<h4 id="HotSpot回收算法实现细节"><a href="#HotSpot回收算法实现细节" class="headerlink" title="HotSpot回收算法实现细节"></a>HotSpot回收算法实现细节</h4><p><strong>注：</strong>这部分都非常底层，底层到本质都是C/C++代码，我这里只列出要点，不针对性的剖析实现细节，一方面确实不是那么懂，再来看底层HotSpot源码还是很有压力的。但是记住，这下面几个实现细节的诞生的原因，以及相互之间的影响，就足以为理解后面诞生的垃圾收集器很有帮助了。</p>
<h5 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h5><p><strong>注：</strong>一切垃圾收集的开始，先要解决根节点问题。<br>固定可作为GC Roots的节点主要在<strong>全局性的引用</strong>（例如常量或类静态属性）与<strong>执行上下文</strong>（例如栈帧中的本地变量表）中，若要逐个检查以这里为起源的引用肯定得消耗不少时间（注：加上STW问题，雪上加霜）。<br>迄今为止，所有收集器在根节点枚举这一步骤时都是必须<strong>暂停用户线程</strong>的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。<strong>但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</strong>。这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，<em>若这点不能满足的话，分析结果准确性也就无法保证</em>。这是导致垃圾收集过程<strong>必须停顿所有用户线程</strong>的<strong>其中一个重要原因</strong>，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CM S、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。<br>具体在<strong>HotSpot中的做法是</strong>：<br>使用一组称为<strong>OopMap</strong>的数据结构 来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（书中第11章）过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，<em>并不需要真正一个不漏地从方法区等GC Roots开始查找。</em></p>
<h5 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h5><p>前面提到的<strong>OopMap存在一个问题</strong>： 可能导致引用关系变化，或者说<strong>导致OopMap内容变化的指令非常多</strong>，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的<strong>空间成本</strong>就会变得无法忍受的<strong>高昂</strong>。<br><strong>改进方案</strong>：实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“<strong>特定的位置</strong>”记录了这些信息，这些位置被称为<strong>安全点（Safepoint）</strong>。<br><strong>安全点设定标准：</strong>安全点位置的选取基本上是以“<strong>是否具有让程序长时间执行的特征</strong>”为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，“<strong>长时间执行”的最明显特征就是 指令序列的复用</strong>，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
<p>对于安全点，另外一个需要考虑的问题是，<strong>如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点</strong>，然后停顿下来。这里有两种方案可供选择：<strong>抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</strong></p>
<ul>
<li><strong>抢先式中断：</strong>在垃圾收集发生时，系统首先把所有用户线程全部中断，直到跑到安全点。现在几乎没有虚拟机采用这种中断方式。</li>
<li><strong>主动式中断</strong>：当垃圾收集器需要中断线程的时候，不对线程直接操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。</li>
</ul>
<h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。<br>但是，程序“不执行”的时候呢？所谓的程序不执行就是<strong>没有分配处理器时间</strong>，典型的场景便是用户线程<strong>处于Sleep状态或者Blocked状态</strong>，这时候 线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。 对于这种情况，就必须引入<strong>安全区域（Safe Region）</strong>来解决。<br><strong>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化</strong>，因此，<strong>在这个区域中任意地方开始垃圾收集都是安全的</strong>。我们也可以把<strong>安全区域看作被扩展拉伸了的安全点</strong>。</p>
<h5 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h5><p><strong>分代收集理论时：</strong>了为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。<br><strong>记忆集本质</strong>是一种用于<strong>记录从非收集区域指向收集区域的指针集合的抽象数据结构</strong>（C++代码）。<br><strong>问题在于</strong>：这种记录全部含跨代引用对象的实现方案，无论是空间占用还是<strong>维护成本都相当高昂</strong>。而在垃圾收集的场景中，收集器<strong>只需要</strong>通过记忆集<strong>判断出某一块</strong>非收集区域是否存在有指向了收集区域的<strong>指针</strong>就可以了，<strong>并不需要了解</strong>这些跨代指针的<strong>全部细节。</strong><br>所以设计者们就给这些场景设定了记忆集的精度：</p>
<ul>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>其中，<strong>第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是目前最常用的一种记忆集实现形式</strong>。(底层就是一个字节数组)<br><strong>记忆集是一种抽象，而卡表就是其中的一种具体实现</strong><br><strong>卡表的工作原理</strong>：字节数组的每个元素都对应着标识的内存区域中的一块特定大小的内存块，这些内存块被称之为“卡页”。一个卡页的内存中通常包含不止一个对象，<strong>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1</strong>，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。<br><img data-src="d16864e6/card-table_with_card-page.png" alt="卡表与卡页对应示意图"></p>
<h5 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h5><p><strong>遗留的问题</strong>：已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但<strong>还没有解决卡表元素如何维护的问题</strong>，例如它们何时变脏、谁来把它们变脏等。<br>在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。这里与并发场景下的“内存屏障”是不一样的。<br>写屏障可以看作在虚拟机层面<strong>对“引用类型字段赋值”这个动作的AOP切面</strong>，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。<br><strong>新的问题：</strong>卡表在高并发场景下面临着“伪共享”（False Sharing）问题。关于伪共享：伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。<br><strong>注：</strong>伪共享问题，隶属操作系统层面的CPU缓存一致问题范畴，可以参考博客园这篇文章介绍，比较全面：<a href="https://www.cnblogs.com/kukuxjx/p/17474226.html">https://www.cnblogs.com/kukuxjx/p/17474226.html</a><br>在JDK7之后，引入了一个新的参数“**-XX:+UseCondCardMark**”来决定是否开启卡表更新条件判断。当开启时，更新卡表前会增加一条判断的开销，来避免伪共享问题。这个参数JDK8中默认是关闭的。</p>
<h5 id="并发可达性分析"><a href="#并发可达性分析" class="headerlink" title="并发可达性分析"></a>并发可达性分析</h5><h6 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h6><p>想解决或者降低用户线程的停顿，就要先搞清楚<strong>为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？</strong>为了能解释清楚这个问题，我们引入<strong>三色标记（Tri-color Marking）</strong>作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li><strong>白色</strong>：<strong>表示对象尚未被垃圾收集器访问过</strong>。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li><strong>黑色</strong>：<strong>表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过</strong>。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li><strong>灰色</strong>：表示对象已经被垃圾收集器访问过，但这个对象上<strong>至少存在一个引用还没有被扫描过</strong>。</li>
</ul>
<p>用户线程与收集器并发运行可能会产生的两个后果：</p>
<ol>
<li>把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。</li>
<li>把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误</li>
</ol>
<p><strong>注</strong>：书中列了一个图，因为都是黑白的，看的不是特别清除，我这里重新画了一下，并做了一些标记。原始参考是引用了Aleksey Shipilev在DEVOXX 2017上的主题演讲，这个演讲油管有原始的，B站有UP搬运并加了字幕，<a href="https://www.bilibili.com/video/BV1mL4y1j78p/?spm_id_from=333.337.search-card.all.click&vd_source=1568f4ca7dfe468df4258e571170b468">超链</a>。我也参考并更正了图的颜色。<br><img data-src="d16864e6/%E5%B9%B6%E5%8F%91%E5%87%BA%E7%8E%B0%E5%AF%B9%E8%B1%A1%E6%B6%88%E5%A4%B1%E9%97%AE%E9%A2%98%E7%A4%BA%E6%84%8F.png" alt="并发出现对象消失问题示意"><br><strong>当且仅当以下两个条件同时满足</strong>时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用<br>因此，我们要解决并发扫描时的对象消失问题，<strong>只需破坏这两个条件的任意一个即可</strong>。由此分别产生了两种解决方案：<strong>增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）</strong>。</li>
<li>增量更新简化理解：黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象</li>
<li>原始快照简化理解：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</li>
</ul>
<p>以上无论是对引用关系记录的插入还是删除，<strong>虚拟机的记录操作都是通过写屏障实现的</strong>。在HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，<strong>CM S是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现</strong>。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>参考另外一篇博客：<a href="https://nimbik.cc/posts/e4c87989">垃圾收集器</a></p>
<h2 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h2><h3 id="JDK提供的"><a href="#JDK提供的" class="headerlink" title="JDK提供的"></a>JDK提供的</h3><h3 id="堆分析工具MAT"><a href="#堆分析工具MAT" class="headerlink" title="堆分析工具MAT"></a>堆分析工具MAT</h3><h3 id="阿里Arthas"><a href="#阿里Arthas" class="headerlink" title="阿里Arthas"></a>阿里Arthas</h3><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h2 id="调优实战"><a href="#调优实战" class="headerlink" title="调优实战"></a>调优实战</h2><h2 id="其它细节"><a href="#其它细节" class="headerlink" title="其它细节"></a>其它细节</h2><h3 id="Java的发展历程"><a href="#Java的发展历程" class="headerlink" title="Java的发展历程"></a>Java的发展历程</h3><h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><h3 id="节码执行引擎"><a href="#节码执行引擎" class="headerlink" title="节码执行引擎"></a>节码执行引擎</h3><h3 id="Java层面的编译原理"><a href="#Java层面的编译原理" class="headerlink" title="Java层面的编译原理"></a>Java层面的编译原理</h3><h3 id="高性能并发场景"><a href="#高性能并发场景" class="headerlink" title="高性能并发场景"></a>高性能并发场景</h3><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><h4 id="Java线程与协程"><a href="#Java线程与协程" class="headerlink" title="Java线程与协程"></a>Java线程与协程</h4>]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>周志明</tag>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL一揪到底</title>
    <url>/post/109c2b6b.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>汇总罗列MySQL点点滴滴</p>
<h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><p>点点翻翻了下面这些，各有特点，各有所长属于是</p>
<ul>
<li>《MySQL是怎样运行的 从根儿上理解MySQL》：白话“啰嗦”，但是容易理解</li>
<li>《MySQL技术内幕 InnoDB存储引擎 第2版 》：章节脉络很清楚，偏向InnoDB源码的，可作为补充看，非DBA不值得长时间深挖。</li>
<li>《高性能MySQL》：宝典，整体介绍全面，对MySQL整体脉络看的比较清楚</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/">官网手册(5.7版本)</a>：这没得说，最全的。PS：英语读的累的用Google Translate页面翻译，专业名词翻译的可读性较高。</li>
</ul>
<h3 id="2024年11月份更新"><a href="#2024年11月份更新" class="headerlink" title="2024年11月份更新"></a>2024年11月份更新</h3><ul>
<li>结合《MySQL技术内幕 InnoDB存储引擎》等书/官方文档作为细节知识点补充，完善本2年前的博客。</li>
<li>对原有知识重点部分加粗，补充若干图片辅助理解</li>
<li>删除部分废话</li>
</ul>
<span id="more"></span>

<h2 id="InnoDB特性"><a href="#InnoDB特性" class="headerlink" title="InnoDB特性"></a>InnoDB特性</h2><h3 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h3><p>这里面分为两个部分</p>
<h4 id="Insert-Buffe"><a href="#Insert-Buffe" class="headerlink" title="Insert Buffe"></a>Insert Buffe</h4><p>Insert Buffer和数据页一样，也是物理页的一个组成部分。<br>InnoDB开创性设计了Insert Buffer，对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入一个Insert Buffer对象中。<br>数据库这个非聚集的索引已经插到叶子节点，而实际并没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer和辅助索引叶子节点的merge操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。<br>Insert Buffer使用需要有两个条件：</p>
<ul>
<li>索引是二级缩影</li>
<li>索引不是唯一的<br>可以通过show engin innodb status\G来查看当前InnoDB引擎状态，<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE HASH INDEX</span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: size <span class="number">1</span>, <span class="keyword">free</span> list len <span class="number">0</span>, seg size <span class="number">2</span>, <span class="number">0</span> merges</span><br><span class="line">merged operations:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded operations:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">34673</span>, node heap has <span class="number">0</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">34673</span>, node heap has <span class="number">2</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">34673</span>, node heap has <span class="number">0</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">34673</span>, node heap has <span class="number">1</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">34673</span>, node heap has <span class="number">1</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">34673</span>, node heap has <span class="number">0</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">34673</span>, node heap has <span class="number">1</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">34673</span>, node heap has <span class="number">1</span> buffer(s)</span><br><span class="line"><span class="number">0.00</span> hash searches<span class="operator">/</span>s, <span class="number">0.00</span> non<span class="operator">-</span>hash searches<span class="operator">/</span>s</span><br></pre></td></tr></table></figure>
<h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4>从InnoDB 1.0.x版本开始引入了Change Buffer，可以看作为是Insert Buffer的升级。对DML操作（I\D\U）都进行缓冲，分别细分为：Insert Buffer、Delete Buffer、Purge Buffer。</li>
</ul>
<h3 id="两次写（Double-Write）"><a href="#两次写（Double-Write）" class="headerlink" title="两次写（Double Write）"></a>两次写（Double Write）</h3><p>Insert Buffer带给InnoDB是性能上的提升，double write则是带给InnoDB的是<strong>数据页的可靠性</strong>。<br>在应用(apply)重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来进行还原，再进行重做，这个就是Double Write。<br><img data-src="109c2b6b/innodb_doublewrite%E6%9E%B6%E6%9E%84.jpg" alt="innodb_doublewrite架构"></p>
<h3 id="自适应哈希索引（Adaptive-Hash-Index）"><a href="#自适应哈希索引（Adaptive-Hash-Index）" class="headerlink" title="自适应哈希索引（Adaptive Hash Index）"></a>自适应哈希索引（Adaptive Hash Index）</h3><p>InnoDB会监控表上各个索引页的查询，如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，这个就称之为自适应哈希索引。<br>具体的后文中有介绍。</p>
<h3 id="异步IO（Async-IO）"><a href="#异步IO（Async-IO）" class="headerlink" title="异步IO（Async IO）"></a>异步IO（Async IO）</h3><p>为了提高磁盘操作性能，当前的数据库系统都是采用异步IO的方式来处理磁盘操作，InnoDB也是如此。</p>
<h3 id="刷新邻接页（Flush-Neighbor-Page）"><a href="#刷新邻接页（Flush-Neighbor-Page）" class="headerlink" title="刷新邻接页（Flush Neighbor Page）"></a>刷新邻接页（Flush Neighbor Page）</h3><p>其工作原理为：当刷新一个脏页时，InnoDB会检测该页所在区(extent)的所有页，如果时脏页，那么一起刷新。这样通过AIO可以将多个IO写入操作合并成一个IO操作，这个工作机制在传统机械磁盘有着显著优势，固态硬盘这个优势不明显。<br>从InnoDB 1.2.x版本开始，可以通过参数<strong>innodb_flush_neighbors</strong>来控制这个特性的开关。</p>
<h2 id="InnoDB架构"><a href="#InnoDB架构" class="headerlink" title="InnoDB架构"></a>InnoDB架构</h2><p>补充一张5.7版本InnoDB的整体架构图<br><img data-src="109c2b6b/InnoDBStructure.jpg" alt="InnoDB Structure"><br>模块解释：</p>
<ul>
<li>从整体上看（从os page cache分）：<ul>
<li>上半部分是实例层，存放在内存里</li>
<li>下半部分是物理层，存放在文件系统中</li>
</ul>
</li>
<li>从各个功能上看：<ul>
<li><strong>master thread</strong>：负责调度其它各个线程，包含主循环（Loop）(1s和10s)、后台循环（Background Loop）、刷新循环（Flush Loop）、暂停循环（Suspend Loop）<ul>
<li>1秒操作：<ul>
<li>日志缓冲刷新到磁盘（会总是操作，即使事务还没有提交）</li>
<li>最多可能刷100个新脏页到磁盘</li>
<li>执行合并，改变插入缓冲的操作</li>
<li>若当前没有用户活动，可能切换到后台循环等</li>
</ul>
</li>
<li>10秒操作：<ul>
<li>刷新可能最多100个脏页到磁盘</li>
<li>合并至多5个Change Buffer（总是）</li>
<li>日志缓冲刷新到磁盘（总是）</li>
<li>删除无用的undo页（总是）</li>
<li>刷新100个或者10个脏页到磁盘（总是）产生一个检查点（总是）等</li>
</ul>
</li>
</ul>
</li>
<li><strong>buf dump thread</strong>：负责把buffer pool中的内容dump到物理文件中，以便快速热加载。</li>
<li><strong>page cleaner thread</strong>：负责把buffer pool中的脏页刷新到磁盘（5.7版本后才有，之前都是交给主线程完成的）</li>
<li><strong>purge thread</strong>：负责将不再使用的undo日志进行回收</li>
<li><strong>read thread</strong>：处理用户的读请求，并负责将数据页从磁盘上读出来</li>
<li><strong>write thread</strong>：负责数据页从缓冲区写出到磁盘</li>
<li><strong>redo log thread</strong>：负责把日志缓冲中的内容刷新到redo log文件中</li>
<li><strong>Insert Buffer Thread</strong>：负责把insert buffer中的内容刷新到磁盘</li>
<li><strong>Buffer Pool内容</strong>：数据和索引页、undo页、insert buffer页、自适应哈希页、数据字典和锁信息</li>
<li><strong>Addtional Memory Pool</strong>：已经废弃</li>
<li><strong>redo log buffer</strong>：存储数据修改所产生的redo log</li>
<li><strong>double write buffer</strong>：双写所需要的</li>
</ul>
</li>
</ul>
<h3 id="InnoDB行记录存储结构"><a href="#InnoDB行记录存储结构" class="headerlink" title="InnoDB行记录存储结构"></a>InnoDB行记录存储结构</h3><p><img data-src="109c2b6b/innodb%E8%A1%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="innodb行存储结构示意图"></p>
<h4 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h4><p>有两大块组成：</p>
<ul>
<li>记录的额外信息<ul>
<li>边长字段长度列表</li>
<li>NULL值列表</li>
<li>记录头信息</li>
</ul>
</li>
<li>记录的真实数据<ul>
<li>(隐藏列)DB_ROW_ID: 行ID，唯一标识一条记录；<strong>非必须存在</strong><ul>
<li>(隐藏列)DB_TRX_ID: 事务ID；一定存在</li>
<li>(隐藏列)DB_ROLL_PTR: 回滚指针；一定存在</li>
<li>列1的值</li>
<li>列2的值</li>
<li>等等<h5 id="CHAR-M-列的存储格式"><a href="#CHAR-M-列的存储格式" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h5><h5 id="溢出列"><a href="#溢出列" class="headerlink" title="溢出列"></a>溢出列</h5>当出现溢出列时，即当前列用于存储的数据长度，超出当前InnoDB存储页大小之后，<strong>用【溢出页地址】来存储剩余下一页地址</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="DYNAMIC行格式"><a href="#DYNAMIC行格式" class="headerlink" title="DYNAMIC行格式"></a>DYNAMIC行格式</h4><p>跟COMPACT基本类似，只是在溢出页处存储的数据的不一样</p>
<h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>官方释义这种存放记录的页为索引（INDEX）页</p>
<h4 id="结构一览"><a href="#结构一览" class="headerlink" title="结构一览"></a>结构一览</h4><p><img data-src="109c2b6b/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="InnoDB数据页结构示意图"><br>其中每个结构的功能如下图所示：<br><img data-src="109c2b6b/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.jpg" alt="InnoDB数据页结构"></p>
<h4 id="记录在页中的存储过程"><a href="#记录在页中的存储过程" class="headerlink" title="记录在页中的存储过程"></a>记录在页中的存储过程</h4><p>在页的7 个组成部分中，我们自己存储的记录会按照指定的行格式存储到UserRecords 部分。在一开始生成页的时候，其实并没有UserRecords部分，每当插入一条记录时，都会从FreeSpace部分申请一个记录大小的控件，并将这个空间划分到UserRecords部分。当用完之后，就是需要新申请一个页继续存储。</p>
<h4 id="记录头中的信息"><a href="#记录头中的信息" class="headerlink" title="记录头中的信息"></a>记录头中的信息</h4><p>先来一个存储示意图：<br><img data-src="109c2b6b/Compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Compact行格式示意图"><br>对照每个记录头属性含义：<br><img data-src="109c2b6b/%E6%95%B0%E6%8D%AE%E9%A1%B5%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%8F%8F%E8%BF%B0.jpg" alt="数据页记录头信息的属性及描述"><br>结合UserRecords的一个存储示例示意图来仔细看看每个标志位的含义（省略了一些列）：<br><img data-src="109c2b6b/UserRecords%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="UserRecords中的存储结构Demo示意图"><br>其中</p>
<ul>
<li><strong>deleted_flag：</strong>只是用于标记当前记录是否是删除状态，真是数据行记录还是存储在这里。<strong>之所以不从磁盘上移除，是因为如果移除之后，还需要在磁盘上重新排列其它数据，频繁的删除的话，会极大的带来性能消耗。</strong>所有的删除记录会单独组成一个垃圾链表（<em>这个过程牵扯到undo日志</em>）</li>
<li><strong>min_rec_flag：</strong>B+树每层非叶子节点中的最小的目录项记录都会添加该标记。</li>
<li><strong>n_owned：</strong>用于标识当前页目录分组中所包含的行记录数量（包含两个头尾虚拟记录本身）。PS：<em>这个过程具体看下一个小节，页目录创建过程。</em></li>
<li><strong>heap_no：</strong>看上面的Demo示意图，4条记录的heap_no分别是2、3、4、5，少了0和1。InnoDB在申请页空间初始化的时候，会创建两条伪记录（有的称之为虚拟记录）。<strong>一条代表页面中的最小记录（Infimum记录），另一条代表页面中的最大记录（Supremum记录）</strong>。<ul>
<li>这两个记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定单词组成的（2组一共占用固定26字节）：<br><img data-src="109c2b6b/%E8%99%9A%E6%8B%9F%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="虚拟记录结构示意图"><br>由于Infimum和Supremum这两条记录是InnoDB默认创建的记录，为了与用户记录区分，会单独存储，如下图所示：<br><img data-src="109c2b6b/%E8%99%9A%E6%8B%9F%E8%AE%B0%E5%BD%95%E5%AD%98%E6%94%BE%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="虚拟记录存放示意图"></li>
<li>如果在删除数据的时候，这个heap_no短时间内是不会变的。结合前面的deleted_flag标志位，当有新增数据来的时候，<strong>会复用当前这行记录的空间的</strong>。</li>
</ul>
</li>
<li><strong>next_record：</strong>非常重要的一个属性，<strong>表示从当前记录的真实数据到下一条巨鹿的真实数据的距离</strong>。<ul>
<li>如果为<strong>正数</strong>：说明当前记录的下一条记录在当前记录的<strong>后面</strong>；</li>
<li>如果为<strong>负数</strong>：说明当前记录的下一条记录在当前记录的<strong>前面</strong>。</li>
</ul>
<em>结合next_record，我们再把Demo结构示意图更新一下：</em><br><img data-src="109c2b6b/%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E6%9B%BF%E4%BB%A3next_record%E6%8C%87%E9%92%88.jpg" alt="使用箭头替代next_record指针"><br>这个设计，刚刚好向左就是记录头信息，向右读取就是真实数据。在某些场景下，可以使记录考前的字段和他们对应的字段长度信息在内存中靠的更近，这<strong>可能会提高缓存的命中率</strong>。</li>
</ul>
<h4 id="Page-Directory-页目录-不确定"><a href="#Page-Directory-页目录-不确定" class="headerlink" title="Page Directory(页目录-不确定)"></a>Page Directory(页目录-不确定)</h4><p><strong>本质上，先要知道设计目录页的目的</strong>：是为了解决在一个数据页中的记录（单向链表组成的）如何快速定位数据位置并访问。<em>你就类比你去图书馆借书的流程，是不是先要去检索书录，完了找到对于书架，再去找对应编号所在范围，然后以此寻找直至找到对应的书，页目录的工作原理就是这样的。</em></p>
<p>先看一下页目录创建的大致流程：</p>
<ol>
<li>将所有正常记录（包括Infimum和Supremum两个，但不包括已经移除到垃圾链表中的记录）划分几个组</li>
<li>每个组的最后一条记录的头信息中的n_owned属性表示该当前组内共有几条记录</li>
<li>将每个组中最后一条记录在页面中的地址偏移量（这个记录的真实数据与页面中第0个字节之间的距离）单独提取出来，按顺序存储到靠近页尾部的地方。这个地方就是Page Directory(页目录)。页目录中的这些<strong>地址偏移量称之为槽（slot）</strong>，每个槽占用2字节。页目录就是由多个槽组成。</li>
</ol>
<p><em>看个例子：</em><br>比如当前表有6条记录，InnoDB分成2组，第一组只有一条Infimum记录，第二组是剩余的5跳记录。2个组，就对应有俩个槽，每个槽中存放每个组中最大的那条记录在页面中的地址偏移量，如下图所示：<br><img data-src="109c2b6b/%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%AE%B0%E5%BD%95%E6%8E%92%E5%88%97%E6%96%B9%E5%BC%8F.jpg" alt="页目录记录排列方式"><br>其中需要注意的是：</p>
<ul>
<li>图中页目录俩槽里面的数字，就标识当前组的记录所在页中的地址偏移量。112就代表Supremum记录偏移112字节</li>
<li>两个n_owned值就分别代表当前分组的记录数量</li>
</ul>
<p>此时我们简化一下，用箭头来示意一下，如下图所示：<br><img data-src="109c2b6b/%E7%94%A8%E7%AE%AD%E5%A4%B4%E6%9B%BF%E4%BB%A3%E6%A7%BD%E4%B8%AD%E6%95%B0%E5%AD%97%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="用箭头替代槽中数字示意图"></p>
<h5 id="分组依据"><a href="#分组依据" class="headerlink" title="分组依据"></a>分组依据</h5><p>InnoDB对每个分组的记录条数是有规定的：对于<strong>Infimum记录所在的分组只能有1条记录，Supremum记录所在的分组拥有的记录条数只能在1<del>8条之间，剩下的分组记录条数范围只能是在4</del>8条之间。</strong><br>PS：你可能问为什么要这样做？<em>有说法是说跟概率学中的泊松分布有关。</em>，具体不懂。。。</p>
<p><strong>分组的步骤大致如下</strong>：</p>
<ol>
<li>初始情况下，一个数据页中只有Infimum记录和Supremum记录2条，分别属于两个组，对于页目录中也只有2槽，分别代表Infimum记录和Spuremum记录在页面中的地址偏移量。</li>
<li>之后每插入一条记录，都会从页目录中<strong>找到对应记录的主键值比待插入记录的主键值大并且差值最小的槽</strong>(从本质上来说，槽是一个组内最大的那条记录在页面中的地址偏移量，通过槽可以快速找到对应的记录的主键值) .然后把该糟对应的记录的n_owned值加1，表示本组内又添加了一条记录， 直到该组中的记录数等于8个。</li>
<li>当一个组中的记录数等于8后，再插入一条记录时，会将组中的记录拆分成两个组，其中一个组中为4条记录，另一个是5条记录。这个拆分过程会在页目录中新增一个槽， 记录这个新增分组中最大的那条记录的偏移量。</li>
</ol>
<p><strong>在一个数据页中查找指定主键值的记录，过程分为两步：</strong></p>
<ol>
<li>通过<strong>二分法</strong>确定该记录所在分组对应的槽，然后找到该槽所在分组中主键值最小的那条记录。</li>
<li>通过记录的next record 属性遍历该槽所在的组中的各个记录。</li>
</ol>
<h4 id="Page-Header-页头部-56字节"><a href="#Page-Header-页头部-56字节" class="headerlink" title="Page Header(页头部-56字节)"></a>Page Header(页头部-56字节)</h4><p>存储在数据页中的记录的状态信息，如数据页中存放了多少条记录、Free Space在页面中的地址偏移量、页目录中存储了多少个槽等。<br><img data-src="109c2b6b/PageHeader%E7%9A%84%E7%BB%93%E6%9E%84%E5%8F%8A%E6%8F%8F%E8%BF%B0.jpg" alt="PageHeader的结构及描述"></p>
<h4 id="File-Header-文件头-38字节"><a href="#File-Header-文件头-38字节" class="headerlink" title="File Header(文件头-38字节)"></a>File Header(文件头-38字节)</h4><p>存储各个类型的页信息（共有信息），其中就包含索引页（FIL_PAGE_INDEX），固定38字节<br><img data-src="109c2b6b/FileHeader%E7%9A%84%E7%BB%93%E6%9E%84%E5%8F%8A%E6%8F%8F%E8%BF%B0.jpg" alt="FileHeader的结构及描述"></p>
<ul>
<li>FIL_PAGE_SPACE_OR_CHKSUM：页面校验和（跟文件尾中的保持对应）</li>
<li>FIL_PAGE_OFFSET：就理解是每个页拥有的单独的页号</li>
<li>FIL_PAGE_TYPE：当前页的类型。</li>
<li>FIL_PAGE_PREV和FIL_PAGE_NEXT：数据页的前驱和后继指针，不同数据页是通过双向链表关联的。</li>
</ul>
<p>页类型的分类：<br>| 类型名称        | 十六进制           | 描述  |<br>| ————- |:————-:|:————-:|<br>|  FIL_PAGE_TYPE_ALLOCATED      | 0x0000 | 最新分配，还未使用 |<br>| FIL_PAGE_UNDO_LOG      | 0x0002      |   undo日志页 |<br>| FIL_PAGE_INODE     | 0x0003      |   存储段信息 |<br>| FIL_PAGE_IBUF_FREE_LIST      | 0x0004      |   Change Buffer空闲列表 |<br>| FIL_PAGE_IBUF_BITMAP      | 0x0005      |  Change Buffer的一些属性  |<br>| FIL_PAGE_TYPE_SYS      | 0x0006      |   存储一些系统数据 |<br>| FIL_PAGE_TYPE_TRX_SYS      | 0x0007      |   事务系统数据 |<br>| FIL_PAGE_TYPE_FSP_HDR      | 0x0008      |   表空间头部信息 |<br>| FIL_PAGE_TYPE_XDES      | 0x0009      |   存储区的一些属性 |<br>| FIL_PAGE_TYPE_BLOB      | 0x000A      |   溢出页 |<br>| FIL_PAGE_INDEX      | 0x45BF      |   索引页，也就是我们所说的数据页 |</p>
<h4 id="File-Trailer-文件尾-8字节"><a href="#File-Trailer-文件尾-8字节" class="headerlink" title="File Trailer(文件尾-8字节)"></a>File Trailer(文件尾-8字节)</h4><p>这部分8字节组成，主要处理页一致性，前4字节代表页的<strong>校验和</strong>，后4字节代表页面被修改时对应的LSN的后4字节，正常情况下与File Header中的FIL_PAGE_LSN的后4字节相同。这部分也用来校验页的完整性</p>
<h3 id="InnoDB的Buffer-Pool"><a href="#InnoDB的Buffer-Pool" class="headerlink" title="InnoDB的Buffer Pool"></a>InnoDB的Buffer Pool</h3><h4 id="啥是Buffer-Pool"><a href="#啥是Buffer-Pool" class="headerlink" title="啥是Buffer Pool"></a>啥是Buffer Pool</h4><p>在开始学习InnoDB存储结构的时候，我们就知道，MySQL的存储的数据按照数据页的方式存储到磁盘上的。但是，我们访问的时候，不可能时刻访问磁盘（效率巨低）。此时我们要改善访问过程怎么办呢？MySQL的设计者们，就通过引入缓存的概念，来优化从磁盘加载数据的过程。在MySQL中这部分缓存就称之为buffer Pool(缓冲池)。</p>
<p>在MySQL中默认的大小是128MB，可以通过查看系统变量查看：<code>show variables like &#39;%buffer_pool_size%&#39;;</code></p>
<h4 id="Buffer-Pool的组成"><a href="#Buffer-Pool的组成" class="headerlink" title="Buffer Pool的组成"></a>Buffer Pool的组成</h4><p>首先要知道，缓冲池是MySQL向操作系统内存申请的一块连续的内存存储空间（为啥要连续，翻看介绍InnoDB的存储结构的相关章节）。缓冲池中为每一个缓冲页（就是数据页，为了和正常的数据页区分，这里称之为缓冲页）都设置了一个控制块，每个控制块中包含了，如表空间编号、页号、缓冲页所在的缓冲池的地址、链表节点信息等等。对于的内存空间，看起来像下面这样：<br><img data-src="109c2b6b/BuferPool%E5%AF%B9%E4%BA%8E%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="BuferPool对于的内存空间示意图"><br>中间的碎片就会，当加载好的缓冲页并为其分配好控制块信息之后，剩下来的空间，就是碎片信息。当然，也可能刚好就够了，没有碎片。</p>
<h4 id="Free链表管理"><a href="#Free链表管理" class="headerlink" title="Free链表管理"></a>Free链表管理</h4><p>先来想一个问题，现在要将磁盘中的数据页读到缓冲池中的缓冲页中去，我们怎么知道哪个缓冲页的是空闲的？这里使用到的是一个Free链表。我们假设当前这个Buffer Pool中可容纳的缓冲页的数量是n，那么增加了free链表（一个双向链表）的效果图，如下所示：<br><img data-src="109c2b6b/BufferPool%E4%B8%AD%E7%9A%84free%E9%93%BE%E8%A1%A8%E6%95%88%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="BufferPool中的free链表效果示意图"><br>注意看这个双向链表，有个头节点，<strong>这里面存放了这个链表的收尾地址和节点数量等信息</strong>。注意这块节点存储，并不在缓冲池申请的内存区域中。</p>
<p>有了这个节点，读取存放的时候，就容易了，从头往后读，拿到空闲的缓冲页后，填上对应的控制块信息并从free链表中移除该节点，就表明这个缓冲页已经被使用了。</p>
<h4 id="缓冲页的哈希表"><a href="#缓冲页的哈希表" class="headerlink" title="缓冲页的哈希表"></a>缓冲页的哈希表</h4><p>大体上总结：通过建立表<strong>空间号+页号</strong>的Key，把缓冲页的控制块信息作为Value，建立一个哈希表，就可以快速访问了。<br>实际上就是：哈希索引（下文有详细说明）</p>
<h4 id="flush链表的管理"><a href="#flush链表的管理" class="headerlink" title="flush链表的管理"></a>flush链表的管理</h4><p>如果我修改了缓冲池中的某个缓冲页的数据，如果此时数据还没回写到磁盘上，那么<strong>此时数据就与磁盘上的数据不一致</strong>了，这样的缓冲页也称之为<strong>脏页（dirty page）</strong>。当然，你说我更新完，立马回写到磁盘上行不行？行，但是这不又回到我们为啥要加缓冲区的问题上了么？所以，在围绕磁盘读写IO上，MySQL设计者们真的是下足了功夫。<br>这时候，如果我们不立马更新到磁盘上，那么后面如果要更新到磁盘上的时候，我们又怎么知道哪个页是脏页呢？<br>不得不新开一组链表来维护这些信息，而维护脏页的链表就称之为flush链表。结构就略了，跟上面的free链表一样的玩法。</p>
<p>等等，似乎还有一个问题，什么时候刷新？这个后面会介绍</p>
<h4 id="LRU链表的管理"><a href="#LRU链表的管理" class="headerlink" title="LRU链表的管理"></a>LRU链表的管理</h4><p>没错，正如这个小节标题所示，这个算法就是大学数据结构、操作系统等课程中提到的，最常用的一种页面置换算法，这不MySQL这里也用到了。<br>在介绍InnoDB是怎么用LRU算法之前，先考虑个最基本的问题，缓冲池大小是固定的，势必有用完的时候。用完之后，我们势必要考虑淘汰哪个页的问题，我们这里就用到一个LRU链表，来按最近最少使用的原则去淘汰缓冲页。</p>
<h5 id="简单的LRU链表"><a href="#简单的LRU链表" class="headerlink" title="简单的LRU链表"></a>简单的LRU链表</h5><p>正如上述所述，我们可以用一个简单的LRU链表来管理这些页，当需要访问某个页时，可以按照下面的方式处理LRU链表：</p>
<ul>
<li><strong>如果该页不在Buffer Pool中</strong>， 在把该页从磁盘加载到Buffer Pool中的缓冲页时，就把该缓冲页对应的控制块作为节点<strong>塞到LRU链表的头部</strong>；</li>
<li>如果该页<strong>已经被加载到Buffer Pool中</strong>， 则直接把该页对应的<strong>控制块移动到LRU链表的头部</strong>。<h5 id="划分区域的LRU链表"><a href="#划分区域的LRU链表" class="headerlink" title="划分区域的LRU链表"></a>划分区域的LRU链表</h5>这里又会有两个场景的问题：</li>
<li>MySQL<strong>预读功能（read ahead）</strong>会影响缓冲页的命中率，也就是预读进去的内容，不是我们访问所需的，那么势必又要从磁盘去加载。</li>
<li>一不小心全表扫描了，<strong>有非常多的使用频率偏低的页</strong>被同时加载到Buffer Pool中，会把那些使用频率非常高的页从BufferPool中淘汰。<br>针对这两种场景，InnoDB的设计者，则将LRU链表分成了下面两块区域：</li>
<li>一部分存储使用<strong>频率非常高的缓冲页</strong>，这一部分链表也称为<strong>热数据</strong>，或者称之为young区域</li>
<li>另一部分存储使用<strong>频率不高的缓冲页</strong>，这部分链表也称为<strong>冷数据</strong>，或者称之为old区域。<br><img data-src="109c2b6b/LRU%E9%93%BE%E8%A1%A8%E5%88%86%E5%8C%BA%E5%9F%9F%E7%AE%A1%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="LRU链表分区域管理示意图"><br>InnoDB按照一定比例来划分这两个区域，默认情况下old区域占整个LRU链表的37%。可以通过<code>innodb_old_blocks_pct</code>来修改<h6 id="预读不被访问的优化"><a href="#预读不被访问的优化" class="headerlink" title="预读不被访问的优化"></a>预读不被访问的优化</h6>通过利用上面提到的两个链表的分区，把预读的放到old区域头部，这样如果不被访问，逐步淘汰也不影响热数据。<h6 id="全表扫描时的优化"><a href="#全表扫描时的优化" class="headerlink" title="全表扫描时的优化"></a>全表扫描时的优化</h6>在对某个处于old区域的缓冲页进行第一次访问的时候，就在它对应的控制块中记录这个访问时间。如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，这个页面就不会从old区域移动到yongg区域的头部。这个时间间隔通过 <code>innodb_old_blocks_time</code> 控制。<h6 id="一些其它的优化"><a href="#一些其它的优化" class="headerlink" title="一些其它的优化"></a>一些其它的优化</h6>对于热数据区，InnoDB通过只有被访问的缓冲页位于<strong>young区域 1/4的后面</strong>的时候，才会被移动到LRU链表的头部。这样就可以降低调整LRU链表的频率。<h5 id="其它的一些链表"><a href="#其它的一些链表" class="headerlink" title="其它的一些链表"></a>其它的一些链表</h5>【了解】针对其它类型的数据页的时候延申出来的用于管理Buffer Pool的链表</li>
</ul>
<h4 id="刷新脏页到磁盘"><a href="#刷新脏页到磁盘" class="headerlink" title="刷新脏页到磁盘"></a>刷新脏页到磁盘</h4><p>了解一个原理两种形式：MySQL后台有<strong>专门负责的线程（可以翻到文章开始的那个InnoDB架构图，看看这个线程在哪里）</strong>每隔一段时间就把脏页刷新到磁盘，<br>刷新的方式主要有两种：</p>
<ul>
<li>从LRU链表的冷数据中刷新一部分到磁盘</li>
<li>从flush链表中刷新一部分页面到磁盘</li>
</ul>
<h4 id="关于多个缓冲池"><a href="#关于多个缓冲池" class="headerlink" title="关于多个缓冲池"></a>关于多个缓冲池</h4><p>MySQL可以通过配置系统参数，来指定BufferPool的实例数，因为在多线程的访问环境下，如果只有单一的缓冲池，每次操作的时候，都要加锁处理，所以势必影响效率。<br>通过系统参数 <code>innodb_buffer_pool_instances</code> 来设置</p>
<h2 id="InnoDB索引相关"><a href="#InnoDB索引相关" class="headerlink" title="InnoDB索引相关"></a>InnoDB索引相关</h2><p>整体上MySQL的索引总结：</p>
<ul>
<li><strong>从数据结构上来分</strong>：B+树索引、哈希索引、以及全文(FullText)索引和R-Tree索引（用于对GIS数据类型创建SPATIAL索引）</li>
<li><strong>从物理存储角度</strong>：聚簇索引、非聚簇索引</li>
<li><strong>从逻辑角度</strong>：主键索引、普通索引、或者单列索引、多列索引、唯一索引，非唯一索引</li>
</ul>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>数据页组成的几个部分：</p>
<ul>
<li>各个数据页组成一个双向链表</li>
<li>每个数据页中的记录按照主键值的从小到大的顺序组成一个单向链表</li>
</ul>
<p><img data-src="109c2b6b/%E9%A1%B5%E5%92%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E5%85%B3%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="页和记录的关系示意图"></p>
<h4 id="没有索引时的查找"><a href="#没有索引时的查找" class="headerlink" title="没有索引时的查找"></a>没有索引时的查找</h4><h5 id="在一个页中查找"><a href="#在一个页中查找" class="headerlink" title="在一个页中查找"></a>在一个页中查找</h5><p>这个好理解，要么按照有主键的方式查找，要么从Infimum从头遍历</p>
<h5 id="在很多页中查找"><a href="#在很多页中查找" class="headerlink" title="在很多页中查找"></a>在很多页中查找</h5><p>分为两个步骤：</p>
<ul>
<li>定位到记录所在的页</li>
<li>从所在的页内查找相应的记录</li>
</ul>
<p>索引的目的时什么呢？就是优化第一个步骤的，即怎么快速定位到记录所在的页，会极大的影响查询速度。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>【备注】在书中，介绍这个索引的时候，先通过构建一个最简单的索引、再结合简单索引带来的问题，引出B+树的概念。这个介绍较为复杂的概念的时候，还是挺有意思的，循序渐进。</p>
<p>真正的用户数据存放在B+树的根节点（InnoDB中标记为第0层），其余层均为索引页，即在记录头中的<code>record_type=1</code> 目录项记录</p>
<h5 id="聚簇索引（Clustered-Index）"><a href="#聚簇索引（Clustered-Index）" class="headerlink" title="聚簇索引（Clustered Index）"></a>聚簇索引（Clustered Index）</h5><p>B+树索引的特点（这里不是介绍B+树数据结构的特定）：</p>
<ul>
<li>使用记录主键值的大小进行记录和页的排序：<ul>
<li>页的构成</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表</li>
<li>存放目录项的页分为不同层级，在同一层级中的页也是根据页中的目录项记录的主键大小顺序排成一个双向链表</li>
</ul>
</li>
<li>B+树的叶子节点存储的时完整的用户记录。</li>
</ul>
<h5 id="二级索引（Secondary-Index）"><a href="#二级索引（Secondary-Index）" class="headerlink" title="二级索引（Secondary Index）"></a>二级索引（Secondary Index）</h5><p>聚簇索引的特定是：只能搜索条件是<strong>主键</strong>时才能发挥作用。如果遇到其它列查询条件，提升的办法就是按照指定列再建一个B+树索引（简单场景，实际要复杂）</p>
<p>这样的B+树索引与聚簇索引的不同：</p>
<ul>
<li>使用指定列的大小记录进行记录和页的排序：<ul>
<li>页：按照指定列的大小顺序排成一个单向链表</li>
<li>各个存放用户记录的页也是根据页中记录的指定列大小顺序排成一个双向链表</li>
<li>存放目录项记录的页分为不同的层级，在同一层级中的页也是根据页中目录项记录的指定列大小顺序排成一个双向链表.</li>
</ul>
</li>
<li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是指<strong>定列+主键</strong>这两个列的值.</li>
<li>目录项记录中<strong>不再是主键+页号</strong>的搭配， 而变成了<strong>指定列+页号</strong>的搭配</li>
</ul>
<p><img data-src="109c2b6b/%E6%96%B0%E5%BB%BA%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="新建二级索引示意图"></p>
<p>这里牵扯到一个<strong>回表</strong>的概念：例如上图所示，我们在检索一个数据项（通过非主键查询）的时候，而最终的B+树节点存储的是指定列和主键信息，而完整的数据项信息，还要通过这个主键再去查询聚簇索引，这个过程就称之为回表。</p>
<p>为啥要回表？如果按照聚簇索引概念，B+树存放完整的数据页信息，那么意味着，每建立一个非主键索引，都要完整的存储一份数据页信息，这样的空间会非常大。</p>
<h5 id="联合索引（Compound-Index）"><a href="#联合索引（Compound-Index）" class="headerlink" title="联合索引（Compound Index）"></a>联合索引（Compound Index）</h5><p>同时以多个列的大小作为排序规则，本质依旧是一个二级索引，只不过是按照多列的大小为排序规则，依次进行排序建立数据页。</p>
<h5 id="InnoDB中B-树索引的注意事项"><a href="#InnoDB中B-树索引的注意事项" class="headerlink" title="InnoDB中B+树索引的注意事项"></a>InnoDB中B+树索引的注意事项</h5><h6 id="根页面固定"><a href="#根页面固定" class="headerlink" title="根页面固定"></a>根页面固定</h6><p>一个B+树索引的根节点自创建时，就不会再移动（页号不会再变化）</p>
<h6 id="内节点中的目录项记录的唯一性"><a href="#内节点中的目录项记录的唯一性" class="headerlink" title="内节点中的目录项记录的唯一性"></a>内节点中的目录项记录的唯一性</h6><p>为了让新插入的记录能找到自己处于哪个页中，二级索引的内节点的目录项记录实际上有3个部分组成：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<h6 id="一个页面至少容纳2条记录"><a href="#一个页面至少容纳2条记录" class="headerlink" title="一个页面至少容纳2条记录"></a>一个页面至少容纳2条记录</h6><h5 id="MyISAM中的索引方案简介"><a href="#MyISAM中的索引方案简介" class="headerlink" title="MyISAM中的索引方案简介"></a>MyISAM中的索引方案简介</h5><p>MyISAM的索引是和数据分开存储的，如下图存储空间示意图所示：</p>
<p><img data-src="109c2b6b/MyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%86%8D%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt="MyISAM存储引擎再存储空间中的表示"></p>
<p>使用MyISAM存储引擎的表会把索引信息单独存到另外一个文件中（称之为索引文件）。MyISAM会为表的主键单独创建一个索引，只不过再索引的叶子节点存储的不是完整的用户记录，<strong>而是主键值与行号的组合</strong>。也就是先通过索引找到对应的行号，再用行号去数据文件中找到完整的记录。</p>
<p>侧面说明，MyISAM查询都要进行一次回表操作，也就是说在MyISAM中建立的索引相当于全是二级索引！</p>
<p>书中一句总结：<strong>InnoDB中的“索引即数据，数据即索引”，而在MyISAM中确是“索引是索引，数据是数据”</strong></p>
<h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p><strong>自适应哈希索引（Adaptive Hash Index, AHI）</strong>的诞生为了更快的对缓冲池中的B+数页进行查找，InnoDB会监控对表上各个索引页的查询，如果观察到建立哈希索引可以带来速度上的提升（热点索引），则建立哈希索引。<br>在InnoDB中使用哈希算法来对字典进行查找，其冲突机制采用链表的方式，哈希函数采用除法散列【<strong>h(k) = k mod m</strong>】的方式。<br>对于缓冲池页的哈希表来说，在缓冲池中的Page页都有一个chain指针，它指向相同哈希函数值的页。<br>而对于除法散列，m的取值略大于2倍的缓冲池页数量的质数。例如：当前<strong>innodb_buffer_pool_size</strong>的大小为10M，则共有640个16KB的页。对于缓冲池页内存的哈希表来说，就需要分配640 x 2 = 1280个hash槽，但是由于1280不是质数，需要取一个比1280略大的质数，应该就是1399，所以启动的时候会分配1399个槽的哈希表，用来哈希查询所在缓冲池中的页。</p>
<h4 id="Hash索引问题"><a href="#Hash索引问题" class="headerlink" title="Hash索引问题"></a>Hash索引问题</h4><ul>
<li>不支持范围索引查询，只能支持等值索引查询<h4 id="InnoDB缓冲页查找下标"><a href="#InnoDB缓冲页查找下标" class="headerlink" title="InnoDB缓冲页查找下标"></a>InnoDB缓冲页查找下标</h4>InnoDB的表空间都一个space_id，用户所要查询的应该是某个表空间的某个连续的16KB的页，即偏移量offset。InnoDB将space_id左移20位，然后加上这个space_id和offset，即关键字 <code>K=space_id&lt;&lt;20 + space_id + offset</code>，然后再通过除法散列到各个槽中去查询。<br>如下图所示，我的服务器中的mysql的hash index状态：<br><img data-src="109c2b6b/innodb_hash_index_status.jpg" alt="服务器AHI状态"></li>
</ul>
<h3 id="InnoDB的全局索引"><a href="#InnoDB的全局索引" class="headerlink" title="InnoDB的全局索引"></a>InnoDB的全局索引</h3><p>5.6版本之后InnoDB存储引擎开始支持全文索引，<strong>5.7版本之后通过使用ngram插件</strong>开始支持中文。<em>之前仅支持英文，因为是通过空格作为分词的分隔符，对于中文来说是不合适的</em><br>MySQL允许在char、varchar、text类型上建立全文索引<br>TODO</p>
<h3 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h3><ul>
<li>每个索引都对应一裸B+ 树. B+ 树分为好多层， 最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+ 树的叶子节点， 所有目录项记录都存储在内节点。</li>
<li>InnoDB 存储引擎会自动为主键建立聚簇索引(如果没有显式指定主键或者没有声明不允许<br>存储NUUL的UNIQUE 键，它会自动添加主键) ， 聚簇索引的叶子节点包含完整的用户记录。</li>
<li>我们可以为感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列和主键组成·如果想通过二级索引查找完整的用户记录，需要执行目表操作， 也就是在通过二级索引找到主键值之后，再到聚簇索引中查找完整的用户记录</li>
<li>B+ 树中的每层节点都<strong>按照索引列的值从小到大</strong>的顺序排序组成了双向链表，而且每个页内的记录(无论是用户记录还是目录项记录)都按照索引列的值从小到大的顺序形成了一个单向链表。<br>如果是联合索引， 则页面和记录<strong>先按照索引列中前面的列</strong>的值排序: 如果该列的值相同，<strong>再按照索引列中后面的列的值排序</strong>。<br>比如， 我们对列c2 和c3建立了联合索引idx_c2_c3(c2，c3，那么该索引中的页面和记录就先按照c2 列的值进行排序;如果c2 列的值相同， 再按照c3 列的值排序.<br>贴一个图（<em>注意看里面节点的排序规则</em>）：<br><img data-src="109c2b6b/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="联合索引排序结构示意图"></li>
<li>通过索引查找记录时，是从B+ 树的根节点开始一层一层向下搜索的.由于每个页面(无论是内节点页面还是叶子节点页面〉中的记录都划分成了若干个组， 每个组中索引列值最大的记录在页内的偏移量会被当作槽依次存放在页目录中(当然， 规定Supremum 记录比任何用户记录都大) ，因此可以在页目录中通过二分法快速定位到索引列等于某个值的记录.</li>
</ul>
<h4 id="索引使用的代价"><a href="#索引使用的代价" class="headerlink" title="索引使用的代价"></a>索引使用的代价</h4><ul>
<li><strong>空间代价</strong>：数据量庞大的表中，索引占据的存储空间是不容小觑的</li>
<li><strong>时间上代价</strong>：<ul>
<li>B+树本身的维护，需要耗费性能，对页面进行分裂、回收动作等</li>
<li>如果多索引，往往你的查询语句可能需要跨索引查询，索引多了可能会导致成本分析时间过长，从而影响查询语句性能</li>
</ul>
</li>
</ul>
<h4 id="应用B-树索引"><a href="#应用B-树索引" class="headerlink" title="应用B+树索引"></a>应用B+树索引</h4><p>这个章节其实就是阐述命中索引与索引命中失效的场景。这个章节里面，介绍了结果，细微的地方还是少了一点介绍，比如为什么 <code>key1 like &#39;%suf&#39;</code>形成的扫描区间是(-∞，+∞)呢？</p>
<p>关于全表扫描，这是一个非常可怕（性能角度）的方案，但是也是一种万能执行的方案，所有查询都能执行。</p>
<p>联合索引为什么会遵从最左原则？书中分析的几个联合索引查询的场景，其实有答案的，就是因为构成联合索引的B+树就是按照创建时从左到右的数据，来构建内节点的。</p>
<h4 id="更好的创建和使用索引（三星索引）"><a href="#更好的创建和使用索引（三星索引）" class="headerlink" title="更好的创建和使用索引（三星索引）"></a>更好的创建和使用索引（三星索引）</h4><p>三星索引是评判索引设计的一个比较好的准则：</p>
<ul>
<li>索引将相关的记录放到一起则获得<strong>一星</strong>；</li>
<li>如果索引中的数据顺序和查找中的排列顺序一致则获得<strong>二星（排序星）</strong></li>
<li>如果索引中的列包含了查询中需要的全部列则获得<strong>三星（宽索引星）</strong></li>
</ul>
<h5 id="细分要点"><a href="#细分要点" class="headerlink" title="细分要点"></a>细分要点</h5><ul>
<li>只为用于搜索、排序或分组的列创建索引</li>
<li>考虑索引列中不重复值的格式</li>
<li>索引列的类型尽量小</li>
<li>为列前缀建立索引：【备注】这种确实还没怎么遇到过，不过是一种形式，字符串的前几位作为索引</li>
<li>覆盖索引：彻底减少回表带来的操作，可以在返回列中只包含索引列，这样就无需回表了。</li>
<li>让索引列以列名的形式在搜索条件中单独出现：这种就是索引失效的场景，结合最左原则</li>
<li>主键聚簇索引列一定要自增：很好理解，因为要排序，所以减少不必要的数据页的分配操作，自增</li>
<li>避免建立冗余索引</li>
</ul>
<h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><h3 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h3><h4 id="数据目录的结构"><a href="#数据目录的结构" class="headerlink" title="数据目录的结构"></a>数据目录的结构</h4><p>除了我们创建的数据库、表、视图和触发器等用户数据·除了这些用户数据，为了让程序更好地运行. MySQL 也会创建一些额外的数据。</p>
<h5 id="数据库在文件系统中的表示"><a href="#数据库在文件系统中的表示" class="headerlink" title="数据库在文件系统中的表示"></a>数据库在文件系统中的表示</h5><p>当我们新建一个数据库的时候，MySQL会帮我们做两件事：</p>
<ul>
<li>在数据目录下创建一个与数据库名同名的子目录(或者说是文件夹)</li>
<li>在与该数据库名同名的子目录下创建一个名为<code>db.opt</code> 的文件.这个文件中包含了该数据库的一些属性，比如该数据库的字符集和比较规则。<h4 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h4>每个表的信息可以分为两种：</li>
<li>表结构定义</li>
<li>表中的数据<br>MySQL中定义了一个<code>表名.frm</code>的格式的文件，作为表结构的定义<br>关于数据，则在不同的存储引擎下，结构时不同的<h4 id="InnoDB如何存储表数据"><a href="#InnoDB如何存储表数据" class="headerlink" title="InnoDB如何存储表数据"></a>InnoDB如何存储表数据</h4>InnoDB的设计者提出了表空间（table space）或者文件空间（file space）的概念。</li>
<li><strong>系统表空间（system tablesapce）</strong><br>这个系统表空间可以对应文件系统上一个或多个实际的文件。在默认情况下，lnnoDB 会在数据目录下创建一个名为<code>ibdata1</code> ，大小为12MB 的文件，这个文件就是对应的系统表空间在文件系统上的表示。这个文件是自扩展文件，如果不够用时会自动扩展。</li>
<li><strong>独立表空间（file-per-table tablespace）</strong><br>在MySQL 5.6.6 以及之后的版本中，InnoDB 不再默认把各个袤的数据存储到系统表空间中，而是为每一个表建立一个独立表空间。也就是说，我们创建了多少个表，就有多少个独立表空间。在使用独立表空间来存储表数据时， 会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，其文件名和表名相同，只不过添加了一个<code>.ibd</code> 扩展名。</li>
<li>其它类型表空间<br>还有比如通用表空间（general tablesapce）、undo表空间（undo tablesapce）、临时表空间（temporary tablesapce）等<h4 id="MyISAM是如何存储表数据"><a href="#MyISAM是如何存储表数据" class="headerlink" title="MyISAM是如何存储表数据"></a>MyISAM是如何存储表数据</h4>结合之前的介绍，“索引是索引，数据是数据”的概念。MyISAM的分别对索引和数据创建了：<code>.MYD</code>和<code>.MYI</code>两个文件<h4 id="其它文件"><a href="#其它文件" class="headerlink" title="其它文件"></a>其它文件</h4>还包含：</li>
<li><strong>服务器进程文件：</strong>每运行一个MySQL 服务器程序，都意味着启动一个进程. MySQL服务器会把自己的进程ID 写入到这个文件中。</li>
<li><strong>服务器日志文件：</strong>服务器运行期间，会产生各种各样的日志，错误日志、二进制日志、redo 日志等。</li>
<li><strong>SSL 和RSA 证书与密钥文件：</strong>主要是为了客户端和服务器安全通信而创建的一些文件。</li>
</ul>
<h3 id="InnoDB的表空间"><a href="#InnoDB的表空间" class="headerlink" title="InnoDB的表空间"></a>InnoDB的表空间</h3><p>先来预览一下：<br><img data-src="109c2b6b/InnoDB%E8%A1%A8%E7%A9%BA%E9%97%B4%E9%80%BB%E8%BE%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="InnoDB表空间逻辑示意图"></p>
<h4 id="常用的页面类型（回顾）"><a href="#常用的页面类型（回顾）" class="headerlink" title="常用的页面类型（回顾）"></a>常用的页面类型（回顾）</h4><p><strong>InnoDB是以页为单位管理存储空间的。我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以B+树的形式保存到表空间中，而B+树的节点就是数据页。</strong><br><img data-src="109c2b6b/%E5%B8%B8%E7%94%A8%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%B1%BB%E5%9E%8B.jpg" alt="常用的页面类型"><br>所有类型数据页共有部分：<code>File Header</code>与<code>File Trailer</code>其中关于Header的：<br><img data-src="109c2b6b/FileHeader%E7%9A%84%E5%90%84%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.jpg" alt="FileHeader的各个组成部分"></p>
<h4 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h4><p>InnoDB支持多种类型的表空间，我们重点关注独立表空间和系统表空间。<br>然而需要抓住一个主线：<strong>后面的一大堆乱七八糟的结构，都是为了一件事：尽可能的减少随机IO，但是又不想让数据量少的表浪费空间。</strong></p>
<h5 id="关于区（extent）"><a href="#关于区（extent）" class="headerlink" title="关于区（extent）"></a>关于区（extent）</h5><p>为了更好的管理页，InnoDB设计了区（extent）的概念<br>对于16KB的页来说，连续的64个页就是一个区(extent)，一个区默认占用1MB空间。<br>表空间被划分为许多连续的区，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页面类型是固定的。<br>从结构定义上来看，为啥又要有区？<br><strong>就是为了在物理位置上连续的64个页，来尽可能的减少随机I/O（机械磁盘的磁头重新定位，SSD的寻址）</strong></p>
<h5 id="关于段（segment）"><a href="#关于段（segment）" class="headerlink" title="关于段（segment）"></a>关于段（segment）</h5><p><strong>问题：</strong>我们在使用B+数执行查询时知识在扫描叶子节点记录，如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请的区里面，那么扫描跟从头到位扫描有啥区别？<br>在InnoDB中，<strong>为了区分B+树的叶子节点与非叶子节点的存储，存放叶子和非叶子节点的数据，称之为一个段。</strong>也就是说，一个索引会生成两个段，一个叶子节点段和一个非叶子节点段。<br>在这个过程中，如果对于较小的表，也严格用这套规则，势必会浪费空间。针对小表，提出碎片（fragment）的概念，一个碎片区中的页属于段A，有些属于段B，有些页甚至不属于任何段。<strong>碎片区直属于表空间， 并不属于任何一个段。</strong></p>
<h5 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h5><p>区大致分为4中类型，或者说是4中状态（State），如下图所示：<br><img data-src="109c2b6b/%E5%8C%BA%E7%9A%844%E7%A7%8D%E7%8A%B6%E6%80%81.jpg" alt="区的4种状态"><br>分别释义为：</p>
<ul>
<li><strong>空闲的区</strong>：现在还没有用到这个区中的任何页面。</li>
<li><strong>有剩余空闲页面的碎片区</strong>：表示碎片区中还有可被分配的空闲页面。</li>
<li><strong>没有剩余空闲页面的碎片区</strong>：表示碎片区中的所有页面都被分配使用，没有空闲页面。</li>
<li><strong>附属于某个段的区</strong>：我们知道，每一个索引都可以分为叶子节点段和非叶子节点段。除此之外，lnnoDB还会另外定义一些特殊用途的段，当这些段中的数据量很大时，将<strong>使用区作为基本的分配单位</strong>（也就是提级的道理），这些区中的页面完全用于存储该段中的数据(而碎片区可以存储属于不同段的数据).</li>
</ul>
<p>【备注】MySQL怎样运行一书中提到了一个比喻，很形象（看过亮剑的肯定立马能懂bushi）：如果把表空间比作一个集团军，段就相当于师，区就相当于团。一般来说，团都是隶属于某个师，就像是处于FSEG 的区全都隶属于某个段；而处于FREE、FREE FRAG 以及FULL_FRAG 这3 种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p>
<h6 id="关于XDES-Entry结构"><a href="#关于XDES-Entry结构" class="headerlink" title="关于XDES Entry结构"></a>关于XDES Entry结构</h6><p><strong>为了方便管理这些区，设计了一个XDES(Extent Descriptor) Entry的结构</strong>，结构示意图如下图所示：<br><img data-src="109c2b6b/XDES_Entry%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="XDES Entry结构示意图"><br>每个段中的区对应的XDES Entry 结构建立了3 个链表：</p>
<ul>
<li><strong>FREE链表</strong>：同一个段中， 所有页面都是空闲页面的区对应的XDES Entry 结构会被加入到这个链表中。注意， 这与直属于表空间的FREE 链袭区别开了，此处的FREE 链表是附属于某个段的链表。</li>
<li><strong>NOT FULL链表</strong>：同一个段中， 仍有空闲页面的区对应的XDES Entry结构会被加入到这个链表中。</li>
<li><strong>FULL链表</strong>：同一个段中，己经没有空闲页面的区对应的 XDES Entry 结构会被加入的这个链表中。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (</span><br><span class="line">	C1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    c2 VARCAHR(<span class="number">100</span>),</span><br><span class="line">    C3 VARCAHR(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (C1),</span><br><span class="line">    KEY IDX_C2(C2)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<p>拿上面这个建表语句为例，表t共有两个索引：一个聚簇索引和一个二级索引。</p>
<ul>
<li>所以这个表共有<strong>4个段（叶子节点和非叶子节点各一个）</strong>，每个段都会维护上述的3个链表，总共<strong>12个链表</strong>。</li>
<li>再加上前文说到的3个直属于表空间的3个链表，</li>
<li>整个独立表空间<strong>共需要维护15个链表</strong>。<br>所以计算公式是：<strong>维护的XDES Entry链表个数 = 索引个数 * 2 * 3 + 3</strong></li>
</ul>
<h6 id="链表基节点"><a href="#链表基节点" class="headerlink" title="链表基节点"></a>链表基节点</h6><p>前面的一大堆链表，怎么找到某个链表呢？为<strong>了解决快速寻找某个链表的头尾节点问题，设计了一个链表基节点的概念（List Base Node）</strong>，结构示意图如下图所示：<br><img data-src="109c2b6b/ListBaseNode%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ListBaseNode的结构示意图"></p>
<h5 id="段的结构"><a href="#段的结构" class="headerlink" title="段的结构"></a>段的结构</h5><p>逻辑上的概念，由若干个零散的页面以及一些完整的区组成。定义了一个INODE Entry结构，示意图如下图所示：<br><img data-src="109c2b6b/INODEEntry%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="INODEEntry结构示意图"></p>
<h5 id="各个类型页的存储的细节"><a href="#各个类型页的存储的细节" class="headerlink" title="各个类型页的存储的细节"></a>各个类型页的存储的细节</h5><p>对前面的各个逻辑概念底层到底存储在表空间什么地方做了一层详细的介绍</p>
<h6 id="FSP-HDR类型"><a href="#FSP-HDR类型" class="headerlink" title="FSP_HDR类型"></a>FSP_HDR类型</h6><p>第一个组的第一个页面，也是表空间的第一个页面， 页号为0，结构示意图如下图所示：</p>
<p><img data-src="109c2b6b/FSP_HDR%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="FSP_HDR类型的页结构示意图"></p>
<p>组成的部分含义如下表所示：</p>
<p><img data-src="109c2b6b/FSP_HDR%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E5%90%AB%E4%B9%89.jpg" alt="FSP_HDR类型的页面组成部分含义"></p>
<p>其中：</p>
<ul>
<li>File Space Header部分：用于存储表空间的整体属性，如表空间ID、表空间拥有的页面数等。</li>
</ul>
<p>![File Space Header结构属性及简单描述](109c2b6b/File Space Header结构属性及简单描述.jpg)</p>
<ul>
<li>XDES Entry部分：紧挨着File Space Header部分的就是XDES Entry 部分了。XDES Entry 就存储在表空间的第一个页面中。一个XDES Entry 结构的大小是40 字节，由于一个页面的大小有限， 只能存放数量有限的XDES Entry 结构， 所以我们才把256 个区划分成一组。<h6 id="XDES类型"><a href="#XDES类型" class="headerlink" title="XDES类型"></a>XDES类型</h6></li>
</ul>
<p>与FSP_HDR类型非常相似，区别不同的是，无需记录表空间的整体属性，如下图所示：</p>
<p><img data-src="109c2b6b/XDES%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="XDES类型的页结构示意图"></p>
<h6 id="IBUF-BITMAP类型"><a href="#IBUF-BITMAP类型" class="headerlink" title="IBUF_BITMAP类型"></a>IBUF_BITMAP类型</h6><p>这种类型的页中记录一些有关Change Buffer的东西。一个对于Insert以及Update和Delete过程中，产生的随机IO问题，进行优化的一个方案。书中没有过多介绍，先知道有这么个结构，本质还是一棵B+树。</p>
<h6 id="INODE类型"><a href="#INODE类型" class="headerlink" title="INODE类型"></a>INODE类型</h6><p>INODE类型的页就是为了存储INODE Entry结构存在的，结构示意图如下托所示：</p>
<p><img data-src="109c2b6b/INODE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="INODE结构类型示意图"></p>
<p>INODE类型具体节点释义如下图所示：</p>
<p><img data-src="109c2b6b/INODE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E.jpg" alt="INODE类型的页面组成结构说明"></p>
<p>其中<code>List Node fro INODE Page List</code>，这里面维护了两个链表，具体操作含义同前文中的INODE Entry中维护的3个链表节点类似：</p>
<ul>
<li>SEG_INODES_FULL:</li>
<li>SEG_INODES_FREE:</li>
</ul>
<p>而上面两个链表访问的基节点就是在前文中的<code>FSP_HDR</code>页类型中保存的，这样一来就可以快速访问了。</p>
<h6 id="Segment-Header结构的运用"><a href="#Segment-Header结构的运用" class="headerlink" title="Segment Header结构的运用"></a>Segment Header结构的运用</h6><p>一个索引产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对于一个INODE Entry结构。<strong>怎么知道某个段对应哪个INODE Entry结构呢？</strong></p>
<p><code>PAGE_HEADR</code>中（在前文提到InnoDB中关于数据页【INDEX类型的页】结构时提到的），如下图所示：</p>
<p><img data-src="109c2b6b/PageHeader%E9%83%A8%E5%88%86%E7%9A%84%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%8F%8F%E8%BF%B0.jpg" alt="PageHeader部分的结构及其描述"></p>
<p>这两个类型都占用10字节，而这个两个结构中，都运用了一个叫<code>Segment Header</code>的结构，如下图所示：</p>
<p><img data-src="109c2b6b/SegmentHeader%E7%BB%93%E6%9E%84.jpg" alt="SegmentHeader结构"></p>
<p>其结构对于的描述信息如下图所示：</p>
<p><img data-src="109c2b6b/SegmentHeader%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%8F%8F%E8%BF%B0.jpg" alt="SegmentHeader结构及其描述"></p>
<h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p>系统表空间与独立表空间类似，只不过整个MySQL进程只有一个系统表空间，用来存放一些有关整个系统相关联信息的，所以这个表空间的ID，即SpaceID=0，0号表空间。<br>系统表空间整体结构，如下图所示：<br><img data-src="109c2b6b/%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.jpg" alt="系统表空间结构"><br>可以与前文独立表空间结构比较，发现前三个都是一致的，但是后面几个则是系统表空间所独有的：<br><img data-src="109c2b6b/%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%89%B9%E6%9C%89%E7%9A%84%E9%A1%B5%E9%9D%A2.jpg" alt="系统表空间特有的页面"><br>除了这几个特有的页意外，extend1和extend2两个区，也就是页号从64~191的这128个页面称之为<code>Doublewrite Buffer(双写缓冲区)</code>。（MySQL的一大特性哦，这里登场了）<strong>此时就需要知道一点，这些特有的多数跟事务和多版本控制（MVCC）操作相关即可！细节在后续事务介绍中，还有详细的描述</strong></p>
<h5 id="InnoDB数据字典"><a href="#InnoDB数据字典" class="headerlink" title="InnoDB数据字典"></a>InnoDB数据字典</h5><p>再次回顾一下一条insert语句执行的过程：</p>
<ul>
<li>首先，平时我们通过Insert向MySQL插入的记录称之为用户数据。但是，当我们向MySQL一个表中插入一条用户记录的时候，MySQL先要校验插入语句对应的表是否存在，以及插入的列和表中列是否符合，也就是<strong>语法校验的过程</strong>。</li>
<li>其次，如果语法校验没有问题，还需要知道表的聚簇索引和所有二级索引对于的<strong>根页面是哪个表空间和哪个页面</strong></li>
<li>然后，再把记录插入到对应的B+树中<br>从上述过程就可以知道，除了维护各个B+树所需要的相关信息外，还要很多其他的信息才能运行。</li>
</ul>
<h6 id="保存的额外信息（主要）"><a href="#保存的额外信息（主要）" class="headerlink" title="保存的额外信息（主要）"></a>保存的额外信息（主要）</h6><ul>
<li>某个表属于哪个表空间，表里面有多少列</li>
<li>表对应的每个列的类型是什么</li>
<li>该表有多少个索引，每个索引对应的列是哪几个字段，该索引对应的根页面在哪个表空间里面</li>
<li>该表有哪些外键，外键对应的表有哪些列</li>
<li>某个表空间对应的文件系统上的路径是什么</li>
</ul>
<p>上述信息不仅仅是为了Insert而但是，只是为了更好的管理数据，而不得已存储的额外信息。因此，InnoDB的设计者们，额外的定义了一些列的系统内部表(internal system table)：</p>
<p><img data-src="109c2b6b/%E8%AE%B0%E5%BD%95%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%85%E9%83%A8%E7%B3%BB%E7%BB%9F%E8%A1%A8%E5%8F%8A%E5%85%B6%E6%8F%8F%E8%BF%B0.jpg" alt="记录元数据的内部系统表及其描述"></p>
<p>其中SYS_TABLES, SYS_COLUMNS, SYS_INDEXES, SYS_FIELDS尤为重要，称之为基本系统表（basic_system_tables），下面分别介绍相关信息：</p>
<ol>
<li><strong>SYS_TABLES表</strong><br>表相关的列如下：<br><img data-src="109c2b6b/SYS_TABLES%E8%A1%A8%E7%9A%84%E5%88%97.jpg" alt="SYS_TABLES表的列"><br>SYS_TABLES表有两个索引：</li>
</ol>
<ul>
<li>以NAME为主键的聚簇索引</li>
<li>以ID列建立的二级索引</li>
</ul>
<ol start="2">
<li><p><strong>SYS_COLUMNS表</strong><br><img data-src="109c2b6b/SYS_COLUMNS%E8%A1%A8%E7%9A%84%E5%88%97.jpg" alt="SYS_COLUMNS表的列"><br>该表只有一个索引，即以<code>(TABLE_ID,POS)</code>为联合主键的聚簇索引</p>
</li>
<li><p><strong>SYS_INDEXES表</strong><br><img data-src="109c2b6b/SYS_INDEXES%E8%A1%A8%E7%9A%84%E5%88%97.jpg" alt="SYS_INDEXES表的列"><br>该表也只有一个索引，即以<code>(TABLE_ID,ID)</code>为联合主键的聚簇索引</p>
</li>
<li><p><strong>SYS_FIELDS表</strong><br><img data-src="109c2b6b/SYS_FIELDS%E8%A1%A8%E7%9A%84%E5%88%97.jpg" alt="SYS_FIELDS表的列"><br>该表只有一个索引，即以<code>(INDEX_ID,POS)</code>为联合主键的聚簇索引</p>
</li>
<li><p><strong>Data Dictionary Header页面</strong><br>这个页面非常特殊，页号为7，类型为SYS的页面，这个页面记录的上述等几个表的数据字典信息，其结构如下：<br><img data-src="109c2b6b/%E9%A1%B5%E5%8F%B7%E4%B8%BA7%E7%9A%84%E9%A1%B5%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="页号为7的页的结构示意图"><br>可以看到这个页号有下面几个部分组成：<br><img data-src="109c2b6b/%E9%A1%B5%E5%8F%B7%E4%B8%BA7%E7%9A%84%E9%A1%B5%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E5%8F%8A%E5%85%B6%E6%8F%8F%E8%BF%B0.jpg" alt="页号为7的页的组成部分及其描述"></p>
</li>
</ol>
<p>其中，比较特殊的是，<strong>Data Dictionary Header头部信息</strong>：</p>
<ul>
<li>Max Row ID: 列中隐藏row_id的值来源于这个全局共享的ROW_ID字段</li>
<li>Max Index ID: 全局共享索引ID，每次新建一个索引时，就会将该字段加1</li>
<li>Max Space ID: 道理同上</li>
<li>Mix ID Low(unused)</li>
<li>Root of SYS_TABLES clust index: 表示SYS_TABLES表聚簇索引页的根的页号</li>
<li>Root of SYS_TABLES_IDS sec index: 表示SYS_TABLES表为ID建立的二级索引的根页面的页号</li>
<li>Root of SYS_COLUMNS clust index: 表示SYS_COLUMNS表聚簇索引页的根的页号</li>
<li>Root of SYS_INDEXES clust index:  表示SYS_INDEXES 表聚簇索引页的根的页号</li>
<li>Root of SYS_FILEDS clust index: 表示SYS_FILEDS 表聚簇索引页的根的页号</li>
</ul>
<ol start="6">
<li><strong>information_schema系统数据库</strong><br>这里提供的系统数据库的表，仅仅是可以理解为，设计者为了方便后续排查底层问题时，开发的一个查询入口。真正的系统数据库表，还是那些个SYS类型的页。</li>
</ol>
<h2 id="InnoDB执行原理"><a href="#InnoDB执行原理" class="headerlink" title="InnoDB执行原理"></a>InnoDB执行原理</h2><h3 id="单表访问方法"><a href="#单表访问方法" class="headerlink" title="单表访问方法"></a>单表访问方法</h3><h4 id="关于访问方法"><a href="#关于访问方法" class="headerlink" title="关于访问方法"></a>关于访问方法</h4><p>MySQL设计者把MySQL 执行查询语句的方式称为访问方法(access methond) 或者访问类型<br>单表书中使用的演示表对应的DDL脚本如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> single_table (</span><br><span class="line">	ID <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    common_feild <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">primary</span> key (id),</span><br><span class="line">    key idx_key1(key1),</span><br><span class="line">    <span class="keyword">unique</span> key uk_key2(key2),</span><br><span class="line">    key idx_key3(key3),</span><br><span class="line">    key idx_key_part(key_part1,key_part2,key_part3)</span><br><span class="line">) engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>UTF8;</span><br></pre></td></tr></table></figure>

<p>书中示例插入1W条示例数据，建议读者自行插入，除了主键列外，随机生成。如需要，不妨参考如下一个简易的存储过程，入参就是插入表的条数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `random_insert`(<span class="keyword">in</span> loopCount <span class="type">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">while i <span class="operator">&lt;=</span> loopCount do</span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> single_table(`key1`,`key2`,`key3`,`key_part1`,`key_part2`,`key_part3`,`common_feild`)</span><br><span class="line">    <span class="keyword">values</span>(concat(<span class="string">&#x27;key1-&#x27;</span>, i), i,concat(<span class="string">&#x27;key3-&#x27;</span>, i), concat(<span class="string">&#x27;part1-&#x27;</span>, i), concat(<span class="string">&#x27;part2-&#x27;</span>, i), concat(<span class="string">&#x27;part3-&#x27;</span>, i), concat(<span class="string">&#x27;common_feild-&#x27;</span>, i));</span><br><span class="line">    <span class="keyword">set</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p><strong>通过主键或者唯一二级索引列来定位一条记录的访问方法定义为const</strong> (意思是常数级别的， 代价是可以忽略不计的) 。不过要达到const访问，却有些限制：</p>
<ul>
<li>主键列</li>
<li>唯一二级索引与一个常量(【备注】书中写的是常数，个人觉得这个地方用常量表述更贴切，下同)进行比较</li>
<li>如果主键列和唯一索引是由多个列构成，则需要每个列都与常量比较时才有效（只有对多个列进行等值比较时，才能保证结果唯一，才能起效）</li>
</ul>
<p>书中提到了一个特例，唯一索引与NULL比较，因为唯一索引列并不限制NULL值的数量，所以下述语句是可能有多条记录的，也就是不可以使用const访问方法来执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key2 <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>有时候我们需要将一个普通的二级索引与常量进行比较，如下面的SQL所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>对于这个查询，当然可以通过全表扫描的方式查询，不过也可以通过idx_key1的方式查询，此时的查询步骤可以解释为：</p>
<ul>
<li>此时对于的扫描区间是：[‘abc’, ‘abc’]，这也是一个单点扫描区间。</li>
<li>可以定位到key1=’abc’的第一条记录</li>
<li>沿着记录的单向链表向后扫描，当某条记录不符合’abc’时为止</li>
<li>由于查询的返回列是全部，所以拿到二级索引记录对应的主键ID，再从聚簇索引回表查询拿到所有用户记录（实际进行的过程是，没命中一个记录，就会立即回表进行查询，而不是等待遍历完）</li>
</ul>
<p>因为普通二级索引并不限制值的唯一，所以二级索引的遍历的效率完全取决于扫描区间中命中的记录数量。把这种<strong>搜索条件为二级索引列与常量进行得值比较，形成的扫描区间为单点扫描区间， 采用二级索引来执行查询的访问方法称为ref</strong>。<br>有两个特别的点需要了解：</p>
<ul>
<li>由于二级索引（包含唯一索引）并不限制存储NULL的值，也就是如果通过<code>key IS NULL</code>的形式进行检索的话，所以查询时最多到ref，而非const查询</li>
<li>对于索引列中包含多个列的二级索引来说，只要从索引最左列开始，进行与常量值比较时，就可以进行ref查询。反之，如下面语句：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;god like&#x27;</span> <span class="keyword">and</span> key_part2 <span class="operator">&gt;</span> <span class="string">&#x27;legendary&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这样的查询则无法调用ref进行查询，而是后面提到的：range</p>
<h4 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h4><p>有时， 我们不仅想找出某个二级索引列的值等于某个常量的记录，而且还想把该列中值为NULL的记录也找出来。比如下面这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">or</span> key1 <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>当使用二级索号|而不是全表扫描的方式执行该查询时，对应的扫描区间就是[NULL, NULL]以及[‘abc’， ‘abc’] ，此时执行这种类型的查询所使用的访问方法就称为<strong>ref_or_null</strong>。<br>为什么要单独加个这种操作呢？<strong>其实是因为列值为NULL的记录，会被存放在索引页的最左边。</strong></p>
<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>有时候我们要进行复杂条件查询的时候，例如下面这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key2 <span class="keyword">in</span> (<span class="number">1438</span>, <span class="number">6238</span>) <span class="keyword">or</span> (key2 <span class="operator">&gt;=</span> <span class="number">38</span> <span class="keyword">and</span> key2 <span class="operator">&lt;=</span> <span class="number">79</span>);</span><br></pre></td></tr></table></figure>

<p>如果仅使用idx_key2进行查询，那么此时的对应的扫描区间就是：[1438, 1438] 、[6328 ,6328] 以及[38 , 79]。此时则把**”使用索引执行查询时， 对应的扫描区间为若干个单点扫描区间或者范围扫描区间”<strong>的访问方法称为</strong>range**。有两种例外要记得：</p>
<ul>
<li>仅包含一个单点扫描区间的访问方法不能称为range访问方法。要看实际情况，可能是const，也可能是ref</li>
<li>扫描区间为(-∞，+∞)的访问方法也不能称为range访问方法。</li>
</ul>
<h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>来看看比较有意思的两个查询场景：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> key_part1,key_part2,key_part3 <span class="keyword">from</span> single_table <span class="keyword">where</span> key_part2<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key_part2<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这两个查询都有个特点，查询条件都是<code>key_part2</code>，该列虽然在二级索引<code>idx_key_part</code>中，但是由于不是最左列，所以无法形成合适的查询范围区间来减少扫描的数量，从而无法使用ref与range查询。但是，第一个查询有如下特点：</p>
<ul>
<li>查询返回列只包含key_part1,key_part2,key_part3这三列，这三列刚好也都在idx_key_part索引中。</li>
<li>搜索条件中，只有key_part2，这列也刚好在该索引中。</li>
</ul>
<p>这个查询过程，可以解释为：也就是说，我们可以直接遍历idx_key_part索引的所有二级索引记录， 针对获取到的每一条二级索引记录，都判断key_part2 = ‘abc’ 条件是否成立。如果成立，就从中读取出key_part1,key_part2,key_part3这3 个列的值并将它们发送给客户端。很显然， 在这种使用idx_key_part索引执行上述查询的情况下，对应的扫描区间就是(-∞ ， +∞ ) 。</p>
<p>但是要知道，虽然扫描区间是针对idx_key_part所有记录，但是遍历索引的代价是要比扫描全部聚簇索引的代价要小得多，MySQL的设计者，把这种<strong>遍历全部二级索引的方法称之为index查询</strong>。<br>【备注】注意，这里笔者贴了一个鲜明的反例，就是第二条查询语句，返回的是所有列，此时查询方法就有天壤之别。究其原因是，本身没有形成有效的查询范围，虽然遍历idx_key_part2全部索引，可以使用index查询。但是，要获取全部数据，所以必定要回表查询，这俩叠加，代价太大，就是性能最差的全表扫描了。不妨，再看看下面3中场景，查询方法又都分别对应什么呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> key_part1 <span class="keyword">from</span> single_table <span class="keyword">where</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> key_part3 <span class="keyword">from</span> single_table <span class="keyword">where</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key_part1<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>关于index查询，还有个特例，当如果添加了”order by 主键“的条件，此时也会走index查询，如下语句所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">order</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure>
<p>【备注】同样，主键我们知道，也会存在联合主键。如果变成联合主键，再添加order by，结果可能又该是什么呢？如果order by的列是联合主键的非最左列，又会怎样？建议你上手试试，巩固一下前面学习的知识。</p>
<h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>这个没什么好说，就是我们老生常谈的全表扫描，对于<strong>InnoDB来说就是扫描全部的聚簇索引记录</strong>。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="二级索引-回表相关"><a href="#二级索引-回表相关" class="headerlink" title="二级索引+回表相关"></a>二级索引+回表相关</h5><p>在实际工作中，往往我们将会遇到查询条件需要多列场景的查询，如下面查询SQL示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span> <span class="keyword">and</span> key2 <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>如果分别用这俩条件分析查询条件，很容易得到结果。但是实际情况，MySQL查询优化器会通过访问表中的少量数据或者直接根据事先生成的统计数据， 来计算[‘abc’ ,’abc’]扫描区间包含多少条记录，再计算(1000, +∞)扫描区间包含多少记录，再根据特定的算法来计算出这两个扫描区间的成本分别是多少。</p>
<p>一般来说， 等值查找比范围查找需要扫描的记录数更少(<strong>也就是ref 访问方法一般比range访问方法好</strong>； 但这并不总是成立， 也有可能在采用ref 方法访问时，相应的索引列为特定值的行数特别多)。假定，优化器最后决定使用idx_key1索引来执行查询，那么这个过程可以描述为下述步骤：</p>
<ul>
<li>先通过idx_key1 对应的B+树定位到扫描区间[‘abc’ ,’abc’]中的第一条二级索引记录。</li>
<li>根据从步骤1中得到的二级索引记录的主键值执行回表操作， 得到完整的用户记录，再检测该记录是否满足key2&gt; 1000 条件。如果满足则将其发送给客户端，否则将其忽略。</li>
<li>再根据该记录所在的单向链表找到下一条二级索引记录，重复步骤2中的操作，直到某条二级索引记录不满足key1 = ‘abc’ 条件为止。</li>
</ul>
<h6 id="关于MRR优化"><a href="#关于MRR优化" class="headerlink" title="关于MRR优化"></a>关于MRR优化</h6><p>MySQL中使用了一种名为Disk-Sweep Multi-Range Read(MRR, 多范围读取)的优化措施，来减少上述场景中的<strong>随机I/O开销</strong>（相比顺序IO性能很慢，基本上差2个数量级都有可能）。更多细节，请参考MySQL官方文档相关说明：<br><a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html">Multi-Range Read Optimization</a><br><strong>传统的回表问题在于</strong>：二级索引所符合的记录数下的主键ID很大程度是随机的（即主键顺序是乱的），那么回表就会带来随机IO的压力。<br><strong>这时候MMR优化概括的原理</strong>：先扫描一定量的二级索引，完了<strong>收集到这块的索引的主键ID后排序好</strong>，完了再到聚簇索引中检索。以此类推。<strong>MMR设计的初衷就是为了减少随机IO的产生。</strong><br>MySQL中是通过变量： <strong>read_rnd_buffer_size</strong> 大小来控制MRR单次处理的范围数。默认：256KB</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 262144 256KB</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;read_rnd_buffer_size&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h5><p>MySQL 在” 一般情况下”只会为单个索引生成扫描区间，但还存在特殊情况. 在这些特殊情况下. MySQL 也可能为多个索引生成扫描区间。MySQL 设计者把这种使用多个索引来完成一次查询的执行方法称为index merge (索引合并）</p>
<h6 id="Intersection索引合并"><a href="#Intersection索引合并" class="headerlink" title="Intersection索引合并"></a>Intersection索引合并</h6><p>比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1<span class="operator">=</span><span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key3<span class="operator">=</span><span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个场景，优化器可能最后会用idx_key1，也可能会用idx_key3（【备注】如果只用其中一个索引，可以想一想最后会是什么方法执行，会是ref么？），当然也可能两者均使用，这时候就会遇到Intersection（交集）索引合并，从字面意义上就能看出来，选取最后的交集出结果，这个过程是这样的：</p>
<ul>
<li>再使用idx_key1扫描区间[‘a’,’a’]的同时，使用idx_key3扫描区间[‘b’,’b’]的记录。</li>
<li>两者结果找出ID列相同的结果（共有的主键结果），再进行ID回表操作，最终返回查询结果。<br>通过上述过程，就可以少很多回表操作。</li>
</ul>
<h6 id="Union索引合并"><a href="#Union索引合并" class="headerlink" title="Union索引合并"></a>Union索引合并</h6><p>从字面意义上，也可以理解，最终是取并集查询的。<br>比如下面一个查询场景：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1<span class="operator">=</span><span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3<span class="operator">=</span><span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>与Intersection不同的是，中间的条件是或了。这时候细节流程就会变成选取两个索引范围中的并集，并且将ID去重后，再进行回表操作。这样就会减少回表的代价。<br>再来看一个复杂一点的，这里就可以先进行交集合并和再进行并集合并查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> (key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">and</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>) <span class="keyword">or</span> (key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>值得注意的是，最后进行的是union(idx_key_part,idx_key1)，还是union(idx_key_part,idx_key3)，还是union(idx_key_part,intersection(idx_key1, idx_key3))这个就要看实际场景了。</p>
<h6 id="sort-union索引合并"><a href="#sort-union索引合并" class="headerlink" title="sort-union索引合并"></a>sort-union索引合并</h6><p>Union 索引合并的使用条件太苛刻，它必须保证从各个索引中扫描到的记录的主键值是有序的。因为要取并集还要去重，如果是乱序的话，并集后去重的代价还是不小的。<br>比如下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table key1 <span class="operator">&lt;</span><span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> key3 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个时候，就无法直接用unoin合并，这时候可以这样操作：</p>
<ul>
<li>先根据key1 &lt;’a’ 条件从idx_key1 二级索引中获取二级索引记录，并将获取到的二级索引记录的主键进行排序。</li>
<li>再根据key3 &gt; ‘z’ 条件从idx_key3 二级索引中获取二级索引记录，并将获取到的二级索引记录的主键值进行排序。</li>
<li>再根据上述排序好的记录，再进行Union合并操作即可。<br>针对这种先排序，后合并的场景，称之为sort-union合并。<br>【备注】这时候，不妨看看下面三种场景，可能最后的结果又是什么？会不会使用sort-union合并呢？如果你一下没有感觉，建议重新翻翻书本第7章的相关概念 :)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> key3 <span class="operator">&lt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key3 <span class="operator">&lt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key3 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">or</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="连接的原理"><a href="#连接的原理" class="headerlink" title="连接的原理"></a>连接的原理</h3><h4 id="关于连接查询"><a href="#关于连接查询" class="headerlink" title="关于连接查询"></a>关于连接查询</h4><p>宽泛的可以概括出，连接就是多张表，按照一定的匹配规则（连接条件，无条件的连接，就是笛卡尔积）形成的一个聚合的查询结果的过程。</p>
<p>本章节中涉及到的两个简单的示例表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- t1表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(m1 <span class="type">int</span>, n1 <span class="type">char</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">-- t2表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(m2 <span class="type">int</span>, n2 <span class="type">char</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<h4 id="连接过程的简介"><a href="#连接过程的简介" class="headerlink" title="连接过程的简介"></a>连接过程的简介</h4><p>【备注】书中从一个简单的连接查询开始作为入口，剖析了一下这个连接查询的过程，值得仔细研读。</p>
<p>先看一个简单的连接查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1, t2 <span class="keyword">where</span> t1.m1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> t1.m1 <span class="operator">=</span> t2.m2 <span class="keyword">and</span> t2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面语句中涉及到了3个查询条件：</p>
<ul>
<li>t1.m1 &gt; 1</li>
<li>t1.m1 = t2.m2</li>
<li>t2.n2 &lt; ‘d’</li>
</ul>
<p>这个连接查询的大致过程：</p>
<ol>
<li><p>首先确定第一个需要查询的表， 这个表称为<strong>驱动表</strong>。怎么确定，其实就是在上面一章中单表查询的场景，在里面选取代价最小的进行查询即可。我们这里假设对t1表全表扫描，执行条件t1.m1&gt;1的判断，取得满足条件的结果，我们假定满足的t1.m1的记录有2条，分别为：2，3。</p>
</li>
<li><p>步骤1中驱动表中得到的记录，都需要到t2表中查找匹配的记录，此时被查询的t2表也称之为<strong>被驱动表</strong>。查询条件中的：<code>t1.m1 = t2.m2</code>就变成了 <code>t2.m2 = 2</code> 或者 <code>t2.m2 = 3</code>，也就是，我们在被驱动表中查询的时候，查找满足下面的条件的记录即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">t2.m2 <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> t2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">OR</span> t2.m2 <span class="operator">=</span> <span class="number">3</span> <span class="keyword">and</span> t2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们可以清楚的看到，被驱动表可能是需要查询多次的。</p>
<p>当然这里只是为了拆解查询过程，实际肯定不是等着驱动表查询记录，然后再进行被驱动表的查询。实际是，驱动表的记录满足之后，会立即去被驱动表中查询满足条件的记录。</p>
</li>
</ol>
<h4 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h4><p>书本中在本小节和后续章节介绍中，使用到的两张表如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">	number <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">5</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    major <span class="type">varchar</span>(<span class="number">30</span>) comment <span class="string">&#x27;专业&#x27;</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (number)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8 comment <span class="string">&#x27;学生信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score(</span><br><span class="line">	number <span class="type">int</span> comment <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">    subject <span class="type">varchar</span>(<span class="number">30</span>) comment <span class="string">&#x27;科目&#x27;</span>,</span><br><span class="line">    score tinyint comment <span class="string">&#x27;成绩&#x27;</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (number, subject)</span><br><span class="line">) engine<span class="operator">=</span>InnoDB charset<span class="operator">=</span>utf8 comment <span class="string">&#x27;学生成绩表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对应的示例数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (number, name, major) <span class="keyword">VALUES</span> (<span class="number">20180101</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;软件学院&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (number, name, major) <span class="keyword">VALUES</span> (<span class="number">20180102</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;计算机科学与工程&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (number, name, major) <span class="keyword">VALUES</span> (<span class="number">20180103</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;计算机科学与工程&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score (number, subject, score) <span class="keyword">VALUES</span> (<span class="number">20180101</span>, <span class="string">&#x27;MySQL是怎样运行的&#x27;</span>, <span class="number">78</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score (number, subject, score) <span class="keyword">VALUES</span> (<span class="number">20180101</span>, <span class="string">&#x27;深入浅出MySQL&#x27;</span>, <span class="number">88</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score (number, subject, score) <span class="keyword">VALUES</span> (<span class="number">20180102</span>, <span class="string">&#x27;MySQL是怎样运行的&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score (number, subject, score) <span class="keyword">VALUES</span> (<span class="number">20180102</span>, <span class="string">&#x27;深入浅出MySQL&#x27;</span>, <span class="number">98</span>);</span><br></pre></td></tr></table></figure>

<p>针对上述流程，我们先考虑一个简单的场景：查询两张表学号相同的的成绩、科目信息，则可以是这样的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.number,s1.name,s2.subject,s2.score <span class="keyword">from</span> student s1, score s2 <span class="keyword">where</span> s1.number <span class="operator">=</span> s2.number;	</span><br></pre></td></tr></table></figure>

<p>查询结果是这样的：</p>
<p><img data-src="109c2b6b/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%AD%89%E5%80%BC%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2.jpg" alt="一个简单的等值关联查询"></p>
<p>但是，我们再仔细看一下，这里面只有两位同学有成绩，明明有三位同学，往往我们也需要查询出缺考的同学的成绩。这个需求的本质查询概念是这样的：<strong>针对驱动表中的每条记录，即使在被驱动表中没有找到与之匹配的记录，也仍然需要把该驱动表记录加入到结果集。为了解决这个问题，就有了内连接和外连接的概念。</strong>:</p>
<ul>
<li>对于<strong>内连接</strong>的两个表，若驱动表中的记录在被驱动表中找不到匹配的记录，则该记录不会加入到最后的结果集。前面提到的连接都是内连接。</li>
<li>对于<strong>外连接</strong>的两个表，即使驱动表中的记录在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</li>
</ul>
<p>在MySQL中，根据驱动表的选取的不同，外连接可以分为两种：</p>
<ul>
<li>左外连接：选取左侧的表作为驱动表</li>
<li>右外连接：选取右侧的表作为驱动表</li>
</ul>
<p>但是，往往我们的实际场景，有时候要把外连接中的驱动表的一些数据返回，有时候又要过滤一些，这时候就要使用过滤条件了，而在外连接中不同的过滤条件效果是不一样的：</p>
<ul>
<li><strong>where</strong>子句中的过滤条件：where子句中的过滤条件就是我们平时见的那种。不论是内连接还是外连接， 凡是不符<br>合WHERE子句中过滤条件的记录都不会被加入到最后的结果集。</li>
<li><strong>on</strong>子句中的过滤条件：对于外连接的驱动表中的记录来说，如果无法在被驱动表中找到匹配ON子句中过滤条件<br>的记录， 那么该驱动表记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充。</li>
</ul>
<p><strong>需要注意的是：</strong>ON子句是传门为”<strong>外连接驱动表中的记录在被驱动表找不到匹配记录时，是否应该把该驱动表记录加入结果集中</strong>“这个场景提出的。所以，如果把ON子句放到内连接中，MySQL会把它像WHERE子句一样对待。也就是说，内连接中的WHERE子句和ON子句是等价的。</p>
<h5 id="左-外-连接语法"><a href="#左-外-连接语法" class="headerlink" title="左(外)连接语法"></a>左(外)连接语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> t2 <span class="keyword">on</span> 连接条件 [<span class="keyword">where</span> 普通过滤条件];</span><br></pre></td></tr></table></figure>

<p>上述场景的连接查询语句就可以写成下面这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.number,s1.name,s2.subject,s2.score <span class="keyword">from</span> student s1 <span class="keyword">left</span> <span class="keyword">join</span> score s2 <span class="keyword">on</span> s1.number <span class="operator">=</span> s2.number;</span><br></pre></td></tr></table></figure>

<p>【备注】这个连接查询的细节就不用多说了，但是希望你注意，下面两种查询的边界条件是完全不一样的，要注意甄别on与where条件成立的时机：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s1.number,s1.name,s2.subject,s2.score <span class="keyword">from</span> student s1 <span class="keyword">left</span> <span class="keyword">join</span> score s2 <span class="keyword">on</span> s1.number <span class="operator">=</span> s2.number <span class="keyword">where</span> s2.score <span class="operator">&gt;</span> <span class="number">80</span>;</span><br><span class="line"><span class="keyword">select</span> s1.number,s1.name,s2.subject,s2.score <span class="keyword">from</span> student s1 <span class="keyword">left</span> <span class="keyword">join</span> score s2 <span class="keyword">on</span> s1.number <span class="operator">=</span> s2.number <span class="keyword">and</span> s2.score <span class="operator">&gt;</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure>

<h5 id="右-外-连接语法"><a href="#右-外-连接语法" class="headerlink" title="右(外)连接语法"></a>右(外)连接语法</h5><p>细节不用赘述，查询的驱动表从左边的表变为右边的表。</p>
<h5 id="内连接语法"><a href="#内连接语法" class="headerlink" title="内连接语法"></a>内连接语法</h5><p><strong>内连接和外连接的根本区别就是在驱动表中的记录不符合ON子句中的连接条件时，内连接不会把该记录加入到最后的结果集中。</strong></p>
<p>其实在内连接中，最简单的语法是在FROM语句后面直接跟上多张表，但是MySQL为内连接提供了多种语法，以t1表、t2表为结果示例。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 [<span class="keyword">inner</span> <span class="operator">|</span> <span class="keyword">cross</span>] <span class="keyword">join</span> t2 [<span class="keyword">on</span> 连接条件] [<span class="keyword">where</span> 普通过滤条件];</span><br></pre></td></tr></table></figure>

<p>换句话说，也就是在MySQL中，下面三种写法是等价的：</p>
<ul>
<li>select * from t1 join t2;</li>
<li>select * from t1 inner join t2;</li>
<li>select * from t1 cross join t2;</li>
</ul>
<h4 id="连接的原理（内部实现）"><a href="#连接的原理（内部实现）" class="headerlink" title="连接的原理（内部实现）"></a>连接的原理（内部实现）</h4><h5 id="嵌套循环连接"><a href="#嵌套循环连接" class="headerlink" title="嵌套循环连接"></a>嵌套循环连接</h5><p>内连接的过程，我们可以概括为下面的两个步骤（重温）：</p>
<ul>
<li>选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。</li>
<li>对上述步骤，查询驱动表得到的结果集中的每一条记录，都分别到被驱动表中查找匹配的记录。</li>
</ul>
<p>【备注】书中贴了一个大图，值得仔细看一下</p>
<p><img data-src="109c2b6b/%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%B5%8C%E5%A5%97%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.jpg" alt="两个表的嵌套连接查询"></p>
<p>如果有3个表，那么上述过程查询的结果集作为新的驱动表，再与第3张表一起，重复上面的过程。其余以此类推。</p>
<p>这个过程就像是一个嵌套的循环，所以这种” 驱动表只访问一次，但被驱动表却可能访问多次，且访问次数取决于对驱动表执行单表查询后的结果集中有多少条记录”的连接执行方式称为<strong>嵌套循环连接（Nested-Loop Join）</strong>，这是最简单也是最笨拙的一种连接查询算法。</p>
<h5 id="使用索引加快连接速度"><a href="#使用索引加快连接速度" class="headerlink" title="使用索引加快连接速度"></a>使用索引加快连接速度</h5><p>【备注】这个过程记住两点：1. 连接查询的条件，如果是索引，是可以加快检索的速度的；2. 连接查询的时候，尽量不要返回所有列，如果能返回索引列就能解决问题，就返回这些信息。这两点步骤的拆解过程，参考关于单表访问过程中的命中过程。</p>
<h5 id="基于块的嵌套循环连接"><a href="#基于块的嵌套循环连接" class="headerlink" title="基于块的嵌套循环连接"></a>基于块的嵌套循环连接</h5><p>在前面的嵌套循环示例中，仅仅几条这个是很简单的。但是如果当表数据量成千上万的时候，势必会牵扯到反复访问磁盘的过程。我们是否可以在把被驱动表中的记录加载到内存时，一次性地与驱动表中的多条记录进行匹配呢？这样就可以大大减少重复从磁盘上加载被驱动表的代价了。提出了一个名为<strong>Join Buffer (连接缓冲区）</strong>的概念。</p>
<p>在执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个Join Buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性地与Join Buffer中的多条驱动表记录进行匹配。由于匹配动作都是在内存中完成，所以大大减少磁盘IO访问的过程。</p>
<p>设计者，把这种基于连接缓冲区的嵌套循环连接称之为 ，<strong>基于块的嵌套循环连接(Block Nested-Loop Join ) 算法</strong>。</p>
<h3 id="基于成本优化"><a href="#基于成本优化" class="headerlink" title="基于成本优化"></a>基于成本优化</h3><h4 id="什么是成本？"><a href="#什么是成本？" class="headerlink" title="什么是成本？"></a>什么是成本？</h4><p>一条查询语句的成本在MySQL中的体现是由两个方面组成的：</p>
<ul>
<li><strong>I/O成本：</strong>我们的表经常使用的MyISAM 、InnoDB 存储引擎都是将数据和索引存储到磁盘上。当查询表中的记录时，需要先把数据或者索引加载到内存中，然后再进行操作。这个从磁盘到内存的加载过程损耗的时间称为I/O成本。</li>
<li><strong>CPU成本：</strong>读取记录以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称为CPU 成本。</li>
</ul>
<p>这里面先要知道两个默认的正对InnoDB存储引擎的<strong>成本常数</strong>：</p>
<ul>
<li>读取一个页面花费的IO成本系数默认是<strong>1.0</strong>：*页面数 * 1.0 + 1.1(微调系数)*</li>
<li>读取以及检测一条记录是否符合搜索条件的CPU成本系数默认是<strong>0.2</strong>：*记录数 * 0.2 + 1.0(微调系数)*<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5></li>
</ul>
<h4 id="单表查询成本"><a href="#单表查询成本" class="headerlink" title="单表查询成本"></a>单表查询成本</h4><p>这里的使用的示例的表，还是前面涉及的<strong>single_table</strong>。</p>
<h5 id="基于成本的优化步骤"><a href="#基于成本的优化步骤" class="headerlink" title="基于成本的优化步骤"></a>基于成本的优化步骤</h5><p>MySQL的优化器会找出所有可以用来执行该语句的方案，并在对比这些方案之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。之后才会调用存储引擎提供的接口真正地执行查，这个过程总结一下就是下面这样：</p>
<ul>
<li>根据搜索条件，找出所有可能使用的索引。</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那个方案。</li>
</ul>
<p>先从一个稍微复杂一点的单表查询语句来说说优化步骤：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span></span><br><span class="line">key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) <span class="keyword">and</span></span><br><span class="line">key2 <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">and</span> key2 <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">and</span></span><br><span class="line">key3 <span class="operator">&gt;</span> key2 <span class="keyword">and</span></span><br><span class="line">key_part1 <span class="keyword">like</span> <span class="string">&#x27;%hello%&#x27;</span> <span class="keyword">and</span></span><br><span class="line">common_feild <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="第一步：根据搜索条件，找出所有可能使用的索引。"><a href="#第一步：根据搜索条件，找出所有可能使用的索引。" class="headerlink" title="第一步：根据搜索条件，找出所有可能使用的索引。"></a>第一步：根据搜索条件，找出所有可能使用的索引。</h6><p>再看看，对于B+树索引来说，只要索引列和常数使用：**=、&lt;=&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;=、&lt;=、BETWEEN 、! = (不等于也可以写成&lt;&gt;)或者LIKE<strong>操作符连接起来，就会产生一个扫描区间（</strong>用LIKE匹配字符串前缀时<strong>，也会产生一个扫描区间）。也就是说，这些条件是都有可能使用到索引的，把一个查询中可能使用到的索引称之为</strong>possible keys**。</p>
<p>来分析分析上述语句中可能使用到索引的场景：</p>
<ul>
<li><strong>key1 IN (‘a’, ‘b’, ‘c’)**：可以使用索引</strong>idx_key1**。</li>
<li><strong>key2 &gt; 10 AND key2 &lt; 1000</strong>：可以使用二级索引<strong>uk_key2</strong>。</li>
<li><strong>key3 &gt; key2</strong>：不能形成有效的查询区间，不能使用索引。</li>
<li>**key_part1 like ‘%hello%’**：没有通过前缀匹配，不能形成有效的查询区间，不能使用索引。</li>
<li>**common_feild = ‘123’**：压根既不是索引列，索引不能使用索引。</li>
</ul>
<p>综上能使用到的索引，就是：idx_key1 和 uk_key2。</p>
<h6 id="第二步：计算全表扫描的代价"><a href="#第二步：计算全表扫描的代价" class="headerlink" title="第二步：计算全表扫描的代价"></a>第二步：计算全表扫描的代价</h6><p>一：MySQL提供了一个查看表状态信息的方法：<code>show table status</code>，如下面信息所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> <span class="string">&#x27;single_table&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: single_table</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: <span class="number">10</span></span><br><span class="line">     Row_format: <span class="keyword">Dynamic</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">10167</span></span><br><span class="line"> Avg_row_length: <span class="number">156</span></span><br><span class="line">    Data_length: <span class="number">1589248</span></span><br><span class="line">Max_data_length: <span class="number">0</span></span><br><span class="line">   Index_length: <span class="number">2457600</span></span><br><span class="line">      Data_free: <span class="number">4194304</span></span><br><span class="line"> Auto_increment: <span class="number">10000</span></span><br><span class="line">    Create_time: <span class="number">2022</span><span class="number">-07</span><span class="number">-19</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">10</span></span><br><span class="line">    Update_time: <span class="number">2022</span><span class="number">-07</span><span class="number">-19</span> <span class="number">20</span>:<span class="number">10</span>:<span class="number">42</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: utf8_general_ci</span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>在计算全表信息的时候，会用到这个状态信息中的两个字段：</p>
<ul>
<li><p><strong>Rows</strong>：表中记录的条数。对于MyISAM是准确值，而对于InnoDB来说是一个估计值。我自己建的表中的记录数是9999条，这里是10167。</p>
</li>
<li><p><strong>Data_length</strong>：表占用的存储字节数。对于MyISAM也是准确值，而对于InnoDB该值相当于聚簇索引存储空间大小，也及由此可以算出聚簇索引的页面数量。<br>~~ Data_length = 聚簇索引的页面数量 * 每个页面大小 ~~<br>~~ 在计算全表扫描的成本的时候，就会用到上面两个值外加上一点附加值最后得出一个最终成本数值。 ~~<br>结合上文提到的计算公式：</p>
</li>
<li><p>Data_length=1589248字节，换算页大小：1589248/16/1024 = 97页</p>
</li>
<li><p>IO成本：97 * 1.0 + 1.1 = 98.1</p>
</li>
<li><p>CPU成本：10167(rows) * 0.2 + 1.0 = 2034.4</p>
</li>
<li><p>最后合计（两成本相加）：98.1 + 2034.4 = <strong>2132.5</strong>，这个就是上面表数据计算出来的全表扫描cost成本</p>
</li>
</ul>
<p><em>PS：2年前的原始表数据已经丢失，这里没办法贴一个trace结果。</em></p>
<h6 id="第三步：计算使用不同索引执行查询的代价"><a href="#第三步：计算使用不同索引执行查询的代价" class="headerlink" title="第三步：计算使用不同索引执行查询的代价"></a>第三步：计算使用不同索引执行查询的代价</h6><p>这个过程，整体可以分为，先从唯一二级索引，再到普通二级索引计算。中间也会涉及，记录数，回表数等相关计算。以及会包括是否需要索引合并的场景。<br><strong>普通二级索引的计算公式如下：</strong></p>
<ul>
<li>IO成本：区间/等值条件数 * 1.0</li>
<li>CPU成本：估算记录数（通过估算页平均记录数和估算页数量乘积） * 0.2 + 0.01(微调系数)</li>
<li>回表成本（一条记录等于一个页数量）：<ul>
<li>IO成本：记录数 * 1.0</li>
<li>CPU成本：记录数 * 0.2（<em>索引比较的时候，这个成本不计算在内；但是最终决策的时候，会纳入计算</em>）</li>
</ul>
</li>
</ul>
<h5 id="基于索引统计数据的成本计算"><a href="#基于索引统计数据的成本计算" class="headerlink" title="基于索引统计数据的成本计算"></a>基于索引统计数据的成本计算</h5><p>有时候在使用索引查询数据的时候，会形成很多单点扫描区间，例如使用IN查询，就会产生。例如下面这个场景：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1 <span class="keyword">in</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, ..., <span class="string">&#x27;azz3&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>由于<code>idx_key1</code>并不是唯一索引，所以这么多单点区间并不能确定到底有多少条记录。而针对众多单点扫描区间的记录来说，往往是通过扫描B+树的区间的最左记录和区间最右记录，然后再通过这两条记录之间有多少记录（少的时候，可以精确算，记录多的时候只能估算）。而，这种<strong>通过二级索引的区间范围来计算某个扫描区间内的记录数的方法，称之为index dive</strong>。</p>
<p>这里也有个问题，就是什么时候使用index dive来计算？加入单点区间很多很多，都通过index dive很显然不现实。所以，MySQL是通过一个系统参数来设定阈值的，你可以通过如下的查询语句来查看这个参数值，默认是200。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%dive%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> eq_range_index_dive_limit <span class="operator">|</span> <span class="number">200</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>如果超过这个阈值，则需要通过<strong>系统索引统计数据</strong>来进行估算。可以通过：**show index from [表名]**，来查询这些统计数据，如下所示，就是我在我本地机器的统计结果信息：</p>
<p><img data-src="109c2b6b/%E8%A1%A8%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF.jpg" alt="表索引统计信息"></p>
<p>每个列的具体含义，如下图所示：<br><img data-src="109c2b6b/%E8%A1%A8%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E5%88%97%E5%90%AB%E4%B9%89%E4%BF%A1%E6%81%AF.jpg" alt="表索引统计列含义信息"></p>
<p>那么上文中提到的通过索引统计数据来估算记录数是怎么做的呢？用到上述结果中的两个值：</p>
<ul>
<li>使用SHOW TABLE STATUS 语句显示出来的Rows值：</li>
<li>使用SHOW INDEX 语句显示出来的Cardinality属性：</li>
</ul>
<p>一个值的重复次数大约等于Rows除以Cardinality值，用我们上述的示例，就是：10167 / 9999 ≈ 1条，也就是单点区间只有1条记录。假如上面的IN查询语句形成的单点区间有20000个，那么最后的记录数估算就是：20000 * 1(上述算的的重复个数) = 20000条记录。虽然简单，但是由于选取的两个数据本来就是不准的，所以这种场景实际执行效率可能并不是这样的。</p>
<h4 id="连接查询的成本"><a href="#连接查询的成本" class="headerlink" title="连接查询的成本"></a>连接查询的成本</h4><h5 id="条件过滤（condition-filtering）"><a href="#条件过滤（condition-filtering）" class="headerlink" title="条件过滤（condition filtering）"></a>条件过滤（condition filtering）</h5><p>对于两张表的连接查询来说，它的查询成本由两个部分组成：</p>
<ul>
<li><strong>单词查询驱动表的成本</strong></li>
<li><strong>多次查询被驱动表的成本</strong></li>
</ul>
<p>我们把查询驱动表后得到的记录称之为<strong>驱动表的扇出（fanout）</strong>(【备注】在MySQL 8中对这块有巨大的提升优化：<a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-waits-current-table.html)%E3%80%82">https://dev.mysql.com/doc/refman/8.0/en/performance-schema-events-waits-current-table.html)。</a></p>
<p>在实际查询过程中，往往会通过关联条件的过程中，进行数据量猜测**，把这个猜测的过程称之为条件过滤(Condition Filtering)**。这个过程可能使用到索引、也可能使用到统计数据等等。</p>
<p>【备注】书中有提到这个猜测的规则，叫启发式(heuristic)规则。这项优化技术，似乎在多表查询中均有涉及。有兴趣的可以看看这本书籍中的介绍：<a href="https://apprize.best/data/mysql/14.html">https://apprize.best/data/mysql/14.html</a></p>
<h5 id="两表连接成本分析"><a href="#两表连接成本分析" class="headerlink" title="两表连接成本分析"></a>两表连接成本分析</h5><p>连接查询的总成本计算公式是这样的：<br>*<em>连接查询总成本 = 单词访问驱动表的成本 + 驱动表扇出值 * 单次访问被驱动表的成本*</em></p>
<h3 id="InnoDB统计数据是如何收集的"><a href="#InnoDB统计数据是如何收集的" class="headerlink" title="InnoDB统计数据是如何收集的"></a>InnoDB统计数据是如何收集的</h3><h4 id="统计数据的存储方式"><a href="#统计数据的存储方式" class="headerlink" title="统计数据的存储方式"></a>统计数据的存储方式</h4><p>知道一件事：InnoDB针对统计数据提供了两种存储方式：永久性存储统计数据和非永久性地存储统计数据。提供了系统变量：innodb_stats_persistent来控制。</p>
<h4 id="innodb-table-status"><a href="#innodb-table-status" class="headerlink" title="innodb_table_status"></a>innodb_table_status</h4><p><img data-src="109c2b6b/innodb_table_status%E8%A1%A8%E4%B8%AD%E5%90%84%E4%B8%AA%E5%88%97%E7%9A%84%E7%94%A8%E9%80%94.jpg" alt="innodb_table_status表中各个列的用途"></p>
<h4 id="innodb-index-status"><a href="#innodb-index-status" class="headerlink" title="innodb_index_status"></a>innodb_index_status</h4><p><img data-src="109c2b6b/innodb_index_status%E5%90%84%E4%B8%AA%E5%88%97%E7%9A%84%E7%94%A8%E9%80%94.jpg" alt="innodb_index_status各个列的用途"></p>
<h3 id="基于规则的优化"><a href="#基于规则的优化" class="headerlink" title="基于规则的优化"></a>基于规则的优化</h3><h4 id="子查询形式"><a href="#子查询形式" class="headerlink" title="子查询形式"></a>子查询形式</h4><p>一般子查询有两种展现形式：</p>
<ul>
<li>一种在SELECT子句中</li>
<li>一种在FROM子句中：这种往往在FROM后面会带上子查询的别名，这种别名也称之为派生表</li>
<li>在WHERE或ON子句的表达式中</li>
</ul>
<h4 id="子查询的过程"><a href="#子查询的过程" class="headerlink" title="子查询的过程"></a>子查询的过程</h4><p>TODO</p>
<h3 id="EXPLAIN详解"><a href="#EXPLAIN详解" class="headerlink" title="EXPLAIN详解"></a>EXPLAIN详解</h3><p>【备注】explain是在我们工作中经常要关注的一个工具，为了写出更高效的语句，通常往往要借助MySQL的explain工具进行语句分析，看看执行器是不是高效的运作了。</p>
<p><img data-src="109c2b6b/explain%E8%AF%AD%E5%8F%A5%E4%B8%AD%E8%BE%93%E5%87%BA%E7%9A%84%E5%90%84%E4%B8%AA%E5%88%97%E7%9A%84%E5%90%AB%E4%B9%89.jpg" alt="explain语句中输出的各个列的含义"></p>
<h4 id="执行计划输出中的各列详解"><a href="#执行计划输出中的各列详解" class="headerlink" title="执行计划输出中的各列详解"></a>执行计划输出中的各列详解</h4><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>EXPLALN语句输出的每条记录都对应着某个单表的访问方法， 该条记录的table列代表该表的表名。</p>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>查询语句中每出现一个SELECT关键字， 设计MySQL的大叔就会为它分配一个唯一的地值， 这个id值就是EXPLAN时输出的第一列。</p>
<p>普通连接查询中，即使有多个select，ID分配的也是相同的。但是如果包含子查询的场景，则会内外顺序进行区分，例如下面查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1 <span class="keyword">in</span> (<span class="keyword">select</span> key1 <span class="keyword">from</span> single_table2) <span class="keyword">or</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>         <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> single_table  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> idx_key3      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10167</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> SUBQUERY    <span class="operator">|</span> single_table2 <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">9923</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>



<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p><img data-src="109c2b6b/select_type%E5%8F%96%E5%80%BC.jpg" alt="select_type取值"></p>
<p>分别都来看看每个类型的含义：</p>
<ul>
<li>SIMPLE：查询语句中不包含UNION 或者子查询的查询都算作SIMPLE类型；连接查询的select_type也是SIMPLE。</li>
<li>PRIMARY：对于包含UNION 、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边那个查询的select_type 值就是PRlMARY。</li>
<li>UNION：对于包含UNION 或者UNION ALL的大查询来说，它是由几个小查询组成的；其中<strong>除了最左边</strong>的那个小查询以外，<strong>其余小查询的select_type值就是UNION</strong>。</li>
<li>UNION RESULT：MySQL选择使用临时表来完成UNION查询的去重工作，<strong>针对该临时表的查询的select_type就是UNION RESULT</strong>。</li>
<li>SUBQUERY：如果包含子查询的查询语句<strong>不能够</strong>转为对应的<strong>半连接</strong>形式，并且该子查询是不相关子查询，而且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个SELECT关键字代表的那个查询的select_type就是SUBQUERY。</li>
<li>DEPENDANENT SUBQUERY：如果包含子查询的查询语句不能够转为对应的半连接形式， 并且该子查询被查询优化器转换为相关子查询的形式，则该子查询的第一个SELECT关键字代表的那个查询的select_type就是DEPENDENT SUBQUERY。</li>
<li>DEPENDANENT UNION：在包含UNION 或者UNION ALL 的大查询中，如果各个小查询部依赖于外层查询，则除了最左边的那个小查询之外，其余小查询的select_type 的值就是DEPENDENT UNlON。</li>
<li>DERIVED：包含派生表的查询中，如果是以物化派生表的方式执行查询。</li>
<li>MATERIALIZED：当查询优化器在执行包含子查询的语句时，选择将予查询物化之后与外层查询进行连接查询。</li>
</ul>
<h5 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h5><p>这个mysql的分区表的含义，标记的是分区表的编号，即这个查询扫描过的分区表</p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>单表的查询方式，前面也有提到过一些。完整的有：system 、const、eq_ref、ref、fulltext、ref_or_null 、index_range 、index_subquery、range、index、ALL。</p>
<ul>
<li>system：当表中只有一条记录并且该表使用的存储引攀(比如MyISAM 、MEMORY )的统计数据是精确的， 那么对该表的访问方法就是system。当然如果换成InnoDB，即使就是一条记录，这个也是会成ALL的。</li>
<li>const：根据<strong>主键</strong>或者<strong>唯一索引列</strong>与<strong>常量进行等值匹配</strong>的时候</li>
<li>eq_ref：执行连接查询时，如果被驱动表是通过主键或者不允许存储NULL值的唯一二级索引列等值匹配的方式进行访问的(如果该主键或者不允许存储NULL值的唯一二级索引是联合索引，则所有的索引列都必须进行等值比较) ，则对该被驱动袤的访问方法就是eq_ref。</li>
<li>ref：当通过普通的二级索引列与常值进行等值匹配的方式来查询某个表时</li>
<li>fulltext：全文索引</li>
<li>ref_or_null：当对普通二二级索引列进行等值匹配且该索引列的值也可以是NULL 值时</li>
<li>index_range：一般情况下只会为单个索引生成扫描区间</li>
<li>unique_subquery：类似于两表连接中被驱动表的eq_ref访问方法，unique_subquery针对的是一些包含肘子查询的查询语句。如果查询优化器决定将IN子查询转换为EXISTS子查询， 而且子查询在转换之后可以使用主键或者不允许存储NULL值的唯一二级索引进行等值匹配。如下面执行所示：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table s1 <span class="keyword">where</span> common_feild <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> single_table2 s2 <span class="keyword">where</span> s1.common_feild <span class="operator">=</span> s2.common_feild) <span class="keyword">or</span> s1.key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type            <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>             <span class="operator">|</span> idx_key3      <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10167</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> unique_subquery <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> func <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">2</span> warnings (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>index_subquery：与unique_subquery类似，只不过访问子查询中的表时使用的时普通的索引。</li>
<li>range：如果使用泵’引获取某些单点扫描区间的记录，那么就可能使用到range访问方法。</li>
<li>index：当可以使用索引覆盖，但需要扫描全部的索引记录时。通常往往出现在联合索引中，返回列是联合索引中的一列，查询条件也是联合索引中的一列，但是查询条件不能形成有效的扫描区间，所以只能全量扫描索引了。</li>
<li>ALL：全表扫描</li>
</ul>
<h5 id="possible-key和key"><a href="#possible-key和key" class="headerlink" title="possible_key和key"></a>possible_key和key</h5><p>possible keys 列表示在某个查询语句中，对某个表执行单表查询的时候可能用到的索引有哪些；key则表示实际用到的索引。</p>
<h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>例如下面这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table s1 <span class="keyword">where</span> s1.key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> s1.key1 <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>执行计划是这样的：</p>
<p><img data-src="109c2b6b/%E5%85%B3%E4%BA%8Ekey_len%E7%9A%84%E4%B8%80%E5%88%99%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.jpg" alt="关于key_len的一则执行计划"></p>
<p>根据我们经验得出，这个扫描区间就是(‘a’, ‘b’)，有时候我们想通过执行计划判断出形成的扫描区间是什么，此时key_len字段就有用处了。MySQL的设计者们，为边界条件中包含的列位于了一个key_len的值，我们看到上述语句的key_len是303，303是怎么来的呢？</p>
<p>对于key_len值，是由下面3个部分组成的：</p>
<ol>
<li>该列的实际数据最多占用的存储空间的长度。对于固定的长度的，如INT的，就是4个字节；对于变长的，例如varchar(100)，在UTF8字符集下最多就是300字节，而在utf8mb4下，就是400.</li>
<li>如果该列可以存储NULL值，<strong>则key_len在上述基础之上再加1</strong>。</li>
<li>对于变长类型的列来说，都会有2个字节的空间来存储该变列的实际数据占用的存储空间长度，key_len的值在原先的基础上还要加2。（【备注】如果对这个有疑问的，看看前面的存储结构）</li>
</ol>
<p>所以上面我们执行的语句的执行计划的key_len是303是这么来的：<code>key_len = 100 * 3 + 1 + 2</code></p>
<h5 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h5><p>当访问方法是const、eq_ref、ref、ref_or_null 、unique_subquery、index_ subquery 中的其中一个时， ref列展示的就是与索引列进行等值匹配的东西是啥。</p>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>在查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表该表的估计行数.如果使用索引来执行查询，执行计划的rows列就代表预计扫描的索引记录数。</p>
<h5 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h5><p>一句话概括，可以用于来评估当前表执行计划中，总共命中扫描数(rows) 与 其余查询条件估计范围(filtered)可以预测出最终结果数。例如下面的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">inner</span> <span class="keyword">join</span> single_table2 <span class="keyword">on</span> single_table.key1 <span class="operator">=</span> single_table2.key1 <span class="keyword">where</span> single_table.common_feild <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+------+---------------+----------+---------+------------------------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>         <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                    <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+------+---------------+----------+---------+------------------------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> single_table  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                   <span class="operator">|</span> <span class="number">10167</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> single_table2 <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> test.single_table.key1 <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+------+---------------+----------+---------+------------------------+-------+----------+-------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>分析一下就是：以single_table为驱动表，用的是idx_key1索引，满足条件的记录是10167条。而filtered就是满足其余条件（这里指common_feild=’a’）所占的比例，这里是10%。就意味着，10167条数据中有10%的记录满足<code>common_feild=&#39;a&#39;</code>。</p>
<h5 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h5><p>顾名思义， Extra 列是用来说明一些额外信息的， 我们可以通过这些额外信息来更准确地理解MySQL到底如何执行给定的查询语句。</p>
<h3 id="optimizer-trace的神奇功效"><a href="#optimizer-trace的神奇功效" class="headerlink" title="optimizer trace的神奇功效"></a>optimizer trace的神奇功效</h3><p>【备注】这张值得仔细研究，往往你通过explain分析了SQL语句的执行计划，只知其一，但是你并不一定了解其中为什么这么选择了。经验丰富的老手，可能会通过以往的经验，告诉你为什么这里用了这个索引，为什么没有命中，为什么效率比较差什么的。但是，通常情况下，要怎么来分析呢？MySQL（特别注意：5.6版本以后才有这个功能）提供了一个非常有意思的机制，就是optimizer trace。通过这个玩意儿，你就能很清楚的值得，优化器优化执行的步骤是怎样的。所以，在研究学习阶段，建议你可以把这个功能打开，完了仔细研究学习一哈。</p>
<h4 id="关于optimizer-trace"><a href="#关于optimizer-trace" class="headerlink" title="关于optimizer trace"></a>关于optimizer trace</h4><p>通过如下语句可以看当前MySQL的optimizer trace的配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;optimizer_trace&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> optimizer_trace <span class="operator">|</span> enabled<span class="operator">=</span>off,one_line<span class="operator">=</span>off <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+--------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>默认情况下enabled=off，也就是关闭的。one_line就算了，结果一行输出，我们又不是程序，一行太难看了。<br>通过:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_trace <span class="operator">=</span> <span class="string">&#x27;enabled=on&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>来打开这个功能。<br>optimizer trace表分别有4列：</p>
<ul>
<li>query：输入的查询语句</li>
<li>trace：优化过程的JSON格式文本</li>
<li>missing_bytes_beyond_max_mem_size：在执行计划的生成过程中可能会输出很多内容，如果超过某个限制，多余的文本将不会显示。</li>
<li>insufficient_privileges：表示是否有权限查看执行计划的生成过程， 默认值是0. 表示有权限查看执行计划的生成过程；只有某些特殊情况下，它的值才是1 .我们暂时不关心这个字段的值。</li>
</ul>
<h5 id="使用optimizer-trace的过程"><a href="#使用optimizer-trace的过程" class="headerlink" title="使用optimizer trace的过程"></a>使用optimizer trace的过程</h5><ol>
<li>打开optimizer trace：打开方式上文介绍了</li>
<li>输入自己的查询语句（也可以是执行计划）</li>
<li>从optimizer_trace表中查看上一个查询的过程优化：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace；</span><br></pre></td></tr></table></figure></li>
<li>可能还要观察其他语句执行的优化过程：重复2、3两步。</li>
<li>当停止查看语句的优化过程时，把optimizer_trace功能关闭<br>这里贴一个示例SQL，供后续分析使用：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span></span><br><span class="line">key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span></span><br><span class="line">key2 <span class="operator">&lt;</span> <span class="number">1000000</span> <span class="keyword">and</span></span><br><span class="line">key3 <span class="keyword">in</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) <span class="keyword">and</span></span><br><span class="line">common_feild <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>【备注】如果是随机插入字符串的，按照这个条件改造几条数据。</p>
<h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>【备注】这个过程会很长，请耐心看看，建议你直接copy到一个JSON格式化工具中，方便查看。下述步骤，结合书中的介绍，以及自己的造的数据相关，在你的数据库中，可能执行结果并不是这样，这个要具体场景具体分析，理解其中的步骤含义即可。</p>
<p><strong>注意：</strong>如果你要自己执行，通过命令行的方式连接到你的MySQL服务器上执行，我在我windows机器上，用的社区版的MySQL安装大礼包中，自带的MySQL 5.7 Command Line Client执行的（本质就是命令行，就是省去了第一步的连接过程，运行输入个密码就行了）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;join_preparation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>	<span class="comment">// prepare阶段</span></span><br><span class="line">                <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;IN_uses_bisection&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="comment">// 展开后的查询</span></span><br><span class="line">                        <span class="attr">&quot;expanded_query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/* select#1 */ select `single_table`.`ID` AS `ID`,`single_table`.`key1` AS `key1`,`single_table`.`key2` AS `key2`,`single_table`.`key3` AS `key3`,`single_table`.`key_part1` AS `key_part1`,`single_table`.`key_part2` AS `key_part2`,`single_table`.`key_part3` AS `key_part3`,`single_table`.`common_feild` AS `common_feild` from `single_table` where ((`single_table`.`key1` &gt; &#x27;a&#x27;) and (`single_table`.`key2` &lt; 1000000) and (`single_table`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`single_table`.`common_feild` = &#x27;abc&#x27;))&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span> <span class="comment">/* steps */</span></span><br><span class="line">            <span class="punctuation">&#125;</span> <span class="comment">/* join_preparation */</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;join_optimization&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>	<span class="comment">// optimize阶段</span></span><br><span class="line">                <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;condition_processing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>	<span class="comment">// 处理搜索条件</span></span><br><span class="line">                            <span class="attr">&quot;condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WHERE&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                            <span class="comment">// 原始搜索条件</span></span><br><span class="line">                            <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;((`single_table`.`key1` &gt; &#x27;a&#x27;) and (`single_table`.`key2` &lt; 1000000) and (`single_table`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`single_table`.`common_feild` = &#x27;abc&#x27;))&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                            <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="comment">// 等值传递条件</span></span><br><span class="line">                                    <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;equality_propagation&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                    <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;((`single_table`.`key1` &gt; &#x27;a&#x27;) and (`single_table`.`key2` &lt; 1000000) and (`single_table`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`single_table`.`common_feild` = &#x27;abc&#x27;))&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="comment">// 常量传值条件</span></span><br><span class="line">                                    <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;constant_propagation&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                    <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;((`single_table`.`key1` &gt; &#x27;a&#x27;) and (`single_table`.`key2` &lt; 1000000) and (`single_table`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`single_table`.`common_feild` = &#x27;abc&#x27;))&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="comment">// 去除没用的条件</span></span><br><span class="line">                                    <span class="attr">&quot;transformation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;trivial_condition_removal&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                    <span class="attr">&quot;resulting_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;((`single_table`.`key1` &gt; &#x27;a&#x27;) and (`single_table`.`key2` &lt; 1000000) and (`single_table`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`single_table`.`common_feild` = &#x27;abc&#x27;))&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">]</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="comment">// 替换虚拟生成列</span></span><br><span class="line">                        <span class="attr">&quot;substitute_generated_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="comment">// 表的依赖信息</span></span><br><span class="line">                        <span class="attr">&quot;table_dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                            <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`single_table`&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;row_may_be_null&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;map_bit&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;depends_on_map_bits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;ref_optimizer_key_uses&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="comment">// 预估不同单表访问方法的访问成本</span></span><br><span class="line">                        <span class="attr">&quot;rows_estimation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                            <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`single_table`&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;range_analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;table_scan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>	<span class="comment">// 全表扫描的行数及成本</span></span><br><span class="line">                                        <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">10112</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">2121.5</span></span><br><span class="line">                                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                    <span class="comment">// 可能使用到的索引</span></span><br><span class="line">                                    <span class="attr">&quot;potential_range_indexes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                        <span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRIMARY&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;not_applicable&quot;</span>	<span class="comment">// PRIMARY不可用</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uk_key2&quot;</span><span class="punctuation">,</span> 	<span class="comment">// uk_key2可能被使用</span></span><br><span class="line">                                            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                <span class="string">&quot;key2&quot;</span></span><br><span class="line">                                            <span class="punctuation">]</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key1&quot;</span><span class="punctuation">,</span> 	<span class="comment">// idx_key1可能被使用</span></span><br><span class="line">                                            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>	<span class="comment">// 键值部分，侧面也就说明了，非聚簇索引的存储结构</span></span><br><span class="line">                                                <span class="string">&quot;key1&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="string">&quot;ID&quot;</span></span><br><span class="line">                                            <span class="punctuation">]</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key3&quot;</span><span class="punctuation">,</span> 	<span class="comment">// idx_key3可能被使用</span></span><br><span class="line">                                            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                <span class="string">&quot;key3&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="string">&quot;ID&quot;</span></span><br><span class="line">                                            <span class="punctuation">]</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key_part&quot;</span><span class="punctuation">,</span> 	<span class="comment">// idx_key_part不可用</span></span><br><span class="line">                                            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;not_applicable&quot;</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span></span><br><span class="line">                                    <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">                                    <span class="attr">&quot;setup_range_conditions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">                                    <span class="attr">&quot;group_index_range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;not_group_by_or_distinct&quot;</span></span><br><span class="line">                                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                    <span class="comment">// 分析各个可能使用索引的成本</span></span><br><span class="line">                                    <span class="attr">&quot;analyzing_range_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;range_scan_alternatives&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                            <span class="punctuation">&#123;</span></span><br><span class="line">                                                <span class="comment">// 使用uk_key2的成本分析</span></span><br><span class="line">                                                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uk_key2&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="comment">// 使用uk_key2的扫描区间</span></span><br><span class="line">                                                <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                    <span class="string">&quot;NULL &lt; key2 &lt; 1000000&quot;</span></span><br><span class="line">                                                <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> 	<span class="comment">// 是否使用index dive</span></span><br><span class="line">                                                <span class="attr">&quot;rowid_ordered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> 	<span class="comment">// 使用该索引获取的记录是否按照主键排序</span></span><br><span class="line">                                                <span class="attr">&quot;using_mrr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> 		<span class="comment">// 是否使用MRR</span></span><br><span class="line">                                                <span class="attr">&quot;index_only&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> 		<span class="comment">// 是否是覆盖索引</span></span><br><span class="line">                                                <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">,</span> 		<span class="comment">// 使用该索引获取的记录条数</span></span><br><span class="line">                                                <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">12001</span><span class="punctuation">,</span> 		<span class="comment">// 使用该索引的成本(为啥是这个，翻翻前面的介绍)</span></span><br><span class="line">                                                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> 	<span class="comment">// 是否选择该索引</span></span><br><span class="line">                                                <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cost&quot;</span>		<span class="comment">// 不选择的原因，成本太大</span></span><br><span class="line">                                            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="punctuation">&#123;</span></span><br><span class="line">                                                <span class="comment">// 含义同上</span></span><br><span class="line">                                                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key1&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                    <span class="string">&quot;a &lt; key1&quot;</span></span><br><span class="line">                                                <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;rowid_ordered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;using_mrr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;index_only&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">5056</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">6068.2</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cost&quot;</span></span><br><span class="line">                                            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="punctuation">&#123;</span></span><br><span class="line">                                                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key3&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                    <span class="string">&quot;a &lt;= key3 &lt;= a&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                                    <span class="string">&quot;b &lt;= key3 &lt;= b&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                                    <span class="string">&quot;c &lt;= key3 &lt;= c&quot;</span></span><br><span class="line">                                                <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;rowid_ordered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;using_mrr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;index_only&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">6.61</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// 选择该索引</span></span><br><span class="line">                                            <span class="punctuation">&#125;</span></span><br><span class="line">                                        <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="comment">// 分析使用索引合并的成本</span></span><br><span class="line">                                        <span class="attr">&quot;analyzing_roworder_intersect&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;usable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;cause&quot;</span><span class="punctuation">:</span> <span class="string">&quot;too_few_roworder_scans&quot;</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span></span><br><span class="line">                                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                    <span class="comment">// 对于上述单表访问查询的最优访问方法</span></span><br><span class="line">                                    <span class="attr">&quot;chosen_range_access_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;range_access_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range_scan&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key3&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;ranges&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                                <span class="string">&quot;a &lt;= key3 &lt;= a&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="string">&quot;b &lt;= key3 &lt;= b&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                                <span class="string">&quot;c &lt;= key3 &lt;= c&quot;</span></span><br><span class="line">                                            <span class="punctuation">]</span></span><br><span class="line">                                        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">6.61</span><span class="punctuation">,</span> </span><br><span class="line">                                        <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                                    <span class="punctuation">&#125;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="comment">// 分析各种可能的执行计划</span></span><br><span class="line">                        <span class="comment">// （对于多表查询，可能有很多种不同的方案：单表查询的方案上面分析的就是，直接选取idx_key3就行）</span></span><br><span class="line">                        <span class="attr">&quot;considered_execution_plans&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                            <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;plan_prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`single_table`&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;best_access_path&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;considered_access_paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                        <span class="punctuation">&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;rows_to_scan&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;range_details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                                <span class="attr">&quot;used_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_key3&quot;</span></span><br><span class="line">                                            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;resulting_rows&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;cost&quot;</span><span class="punctuation">:</span> <span class="number">7.21</span><span class="punctuation">,</span> </span><br><span class="line">                                            <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                                        <span class="punctuation">&#125;</span></span><br><span class="line">                                    <span class="punctuation">]</span></span><br><span class="line">                                <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;condition_filtering_pct&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;rows_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;cost_for_plan&quot;</span><span class="punctuation">:</span> <span class="number">7.21</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;chosen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="comment">// 尝试给查询添加一些其它的查询条件（这个语句没啥好尝试的，最后其实跟我们写的一样）</span></span><br><span class="line">                        <span class="attr">&quot;attaching_conditions_to_tables&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;original_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;((`single_table`.`key1` &gt; &#x27;a&#x27;) and (`single_table`.`key2` &lt; 1000000) and (`single_table`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`single_table`.`common_feild` = &#x27;abc&#x27;))&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                            <span class="attr">&quot;attached_conditions_computation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">                            <span class="attr">&quot;attached_conditions_summary&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`single_table`&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                    <span class="attr">&quot;attached&quot;</span><span class="punctuation">:</span> <span class="string">&quot;((`single_table`.`key1` &gt; &#x27;a&#x27;) and (`single_table`.`key2` &lt; 1000000) and (`single_table`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`single_table`.`common_feild` = &#x27;abc&#x27;))&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">]</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="comment">// 执行计划微调</span></span><br><span class="line">                        <span class="attr">&quot;refine_plan&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                            <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;`single_table`&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                                <span class="attr">&quot;pushed_index_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`single_table`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;))&quot;</span><span class="punctuation">,</span> 	<span class="comment">// 注意这块，是前面代价分析过程最后选取的最优代价形成的最终有效条件</span></span><br><span class="line">                                <span class="attr">&quot;table_condition_attached&quot;</span><span class="punctuation">:</span> <span class="string">&quot;((`single_table`.`key1` &gt; &#x27;a&#x27;) and (`single_table`.`key2` &lt; 1000000) and (`single_table`.`common_feild` = &#x27;abc&#x27;))&quot;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="comment">// 执行阶段</span></span><br><span class="line">            <span class="attr">&quot;join_execution&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;select#&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;steps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>后面还有两列，分别都是0，说明一：没有因为优化过程文本太多而丢弃的文本。说明二：权限字段也是0，这部分就略去不展示了。<br>虽然很多，但是还是非常有规律可循的，我们来总结一下：</p>
<ul>
<li>prepare阶段</li>
<li>optimize阶段</li>
<li>execute阶段<br>而对于单表查询阶段：<strong>主要关注的是optimize阶段的row_estimation过程</strong><br>对于多表连接查询来说：<strong>我们主要关注的是considered_execution_plans过程</strong></li>
</ul>
<h2 id="InnoDB事务相关"><a href="#InnoDB事务相关" class="headerlink" title="InnoDB事务相关"></a>InnoDB事务相关</h2><h3 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h3><h4 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h4><p>事务的4个特性：A（Atomicity）、C（Consistency）、I（Isolation）、D（Durability）</p>
<ul>
<li>原子性：</li>
<li>一致性：</li>
<li>隔离性：</li>
<li>持久性：<br>为了把需要这个四个特性的一个或者多个数据库操作称之为事务（transaction）</li>
</ul>
<p>根据这些操作所执行的不同阶段把事务大致划分成下面几个状态：</p>
<ul>
<li><strong>活动的(active)**：事务对应的数据库操作正在执行过程中时，我们就说该事务处于</strong>活动的状态**。</li>
<li><strong>部分提交的（partially committed）</strong>：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处于<strong>部分提交</strong>的状态。</li>
<li><strong>失败的（failed）</strong>：当事务处于活动的状态或者部分提交的状态时，可能遇到了某些错误(数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行， 或者入为停止了当前事务的执行， 我们就说该事务处于<strong>失败</strong>的状态。</li>
<li><strong>中止的（aborted）</strong>：如果事务执行了半截而变为失败的状态，需要撤销失败事务对当前数据库造成的影响，也就是<strong>回滚</strong>操作。当回滚操作执行完毕后，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处于<strong>中止的状态</strong>。</li>
<li><strong>提交的（committed）</strong>：当一个处于部分提交的状态的事务将修改过的数据都刷新到磁盘中之后，我们就可以说该事务处于<strong>提交的状态</strong>。<br><img data-src="109c2b6b/%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg" alt="事务状态转换图"><h4 id="MySQL中的事务表现"><a href="#MySQL中的事务表现" class="headerlink" title="MySQL中的事务表现"></a>MySQL中的事务表现</h4>【备注】先要明白一点，目前只有InnoDB和NDB（分布式），这两种存储引擎，才支持事务。<br>在InnoDB中，知道几种语法，一般我们很少直接通过手工命令方式来执行事务，在正常业务代码中，都会通过数据库连接中间件来统一管理事务。</li>
</ul>
<h3 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h3><h4 id="redo日志概念"><a href="#redo日志概念" class="headerlink" title="redo日志概念"></a>redo日志概念</h4><p>【备注】关于redo日志概念部分很好理解，在缓冲池那节，我们提到过，在更新了缓冲页还没有刷新磁盘的时候，如果出现问题，这个中间过程是可能会导致数据不一致的。再来上节中提到的事务操作，我们怎么保证持久性，即使碰到数据库崩溃的场景，我们依旧能恢复崩溃前的状态？<br>MySQL的设计者们，通过一种类似于记录操作流水的方式来做的持久性的。<br><strong>因为在系统因崩溃而重启时严要按照上述内容所记录的步骤重新更新数据页，所以上述内容也称为重做日志(redo log) 。</strong><br>记住redo log的两个特点：</p>
<ul>
<li>redo日志占用空间非常小</li>
<li>redo日志顺序写入磁盘的：在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是顺序写入磁盘的。<h4 id="redo日志格式"><a href="#redo日志格式" class="headerlink" title="redo日志格式"></a>redo日志格式</h4><img data-src="109c2b6b/redo%E6%97%A5%E5%BF%97%E9%80%9A%E7%94%A8%E7%BB%93%E6%9E%84.jpg" alt="redo日志通用结构"><br>其中：</li>
<li>type：redo日志类型</li>
<li>spaceID：表空间ID</li>
<li>page number：页号</li>
<li>data：这条redo日志的具体内容</li>
</ul>
<h3 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h3><p>事务的原子性告诉我们，要么做，要么统一不做，所以每当要对一条记录进行修改的时候（insert、delete、update）：</p>
<ul>
<li>在<strong>插入一条</strong>记录时，至少要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好了;</li>
<li>在<strong>删除一条</strong>记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。</li>
<li>在<strong>修改一条</strong>记录时，至少要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值就好了。<br>这些为了回滚而记录的东西称为撤销日志(undo log)，称之为undo日志。<h4 id="事务ID"><a href="#事务ID" class="headerlink" title="事务ID"></a>事务ID</h4>一个事务剋以是一个只读事务，也可以是一个读写事务。<br>只有在事务对表中的记录进待改动（增删改）时才会为这个事务分配一个唯一的事务id。<h4 id="事务ID的生成"><a href="#事务ID的生成" class="headerlink" title="事务ID的生成"></a>事务ID的生成</h4>与隐藏列row_id基本类似：</li>
<li>服务器会在内存中维护一个全局变量，每当需要为某个事务分配事务id时，就会把变量的值当作事务id分配给该事务，并且把变量自增1。</li>
<li>每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间中页号为5的页面中一个名为Max_Trx_ID的属性中，这个属性占用8字节存储空间。</li>
<li>当系统下一次重新启动时，会将这个属性加载到内存中，将该值加上256之后赋值给前面提到的全局变量（加值的原因是上次关机时，该全局变量的值可能大于磁盘页面中的Max Trx ID属性）。<h4 id="trx-id隐藏列"><a href="#trx-id隐藏列" class="headerlink" title="trx_id隐藏列"></a>trx_id隐藏列</h4>InnoDB记录行格式的时候，聚簇索引的记录会完整保存用户数据以外，还会自动添加名为trx_id、roll_pointer的隐藏列。<br>trx_id就是对聚簇索引记录进行改动的语句所在的事务对应的事务id。<br>roll_pointer：是指向一条undo日志地址的指针，由7个字节组成，共包含4个属性<br><img data-src="109c2b6b/roll_pointer%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="roll_pointer结构示意图"><h4 id="undo日志格式"><a href="#undo日志格式" class="headerlink" title="undo日志格式"></a>undo日志格式</h4>不同的操作日志格式是不一样的<br>TODO</li>
</ul>
<h3 id="事务隔离级别和MVCC"><a href="#事务隔离级别和MVCC" class="headerlink" title="事务隔离级别和MVCC"></a>事务隔离级别和MVCC</h3><p>虽然数据库管理系统可以通过redo日志、undo日志这些手段来保证<strong>事务的原子性</strong>。但是，如果出现了并发场景，即不同的客户端、不同时间前后分别对同一数据主题进行操作，就可能带来问题。<br>比如，A账户向B账户前后发起了两笔转账，这两笔事务操作，假设称之为T1、T2。起始账户A有11元，账户B有2元，共计13元。<br>且看下图：<br><img data-src="109c2b6b/T1%E5%92%8CT2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg" alt="T1和T2的执行顺序"><br>但是执行完之后，这两账户总额变成了18元了。在这个场景下的事务一致性的要求是“参与转账的账户的总余额保持不变”，而在上面这个场景过程中，很显然不满足一致性要求。<br>这就要求我们使用某种手段？虽制让这些事务按照顺序一个一个单独地执行， 或者最终执行的效果和单独执行一样。也就七是说我们希望让这些事务” 隔离”地执行，互不干涉，这也就是<strong>事务的隔离性</strong>。<br>这里使用到的示例表，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> hero (</span><br><span class="line">	number <span class="type">int</span>, <span class="comment">-- 这里主键id设置为number，主要是书中为了和后文种的事务id相区分而已</span></span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">primary</span> key(number)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>PS：要解决事务并发执行，这里可以回想到JUC下面的一堆操作了，针对读读、读写、写读、写写产生的互斥一致性问题，多数是怎么解决的。</p>
<h4 id="事务并发执行时遇到的一致性问题"><a href="#事务并发执行时遇到的一致性问题" class="headerlink" title="事务并发执行时遇到的一致性问题"></a>事务并发执行时遇到的一致性问题</h4><h5 id="脏写（Dirty-Write）"><a href="#脏写（Dirty-Write）" class="headerlink" title="脏写（Dirty Write）"></a>脏写（Dirty Write）</h5><p><strong>如果一个事务修改了另一个未提交的事务修改过的数据，这就意味着出现了脏写的现象。</strong></p>
<h5 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h5><p><strong>如果一个事务读到了另一个未提交事务修改过的数据，就意味着发生了脏读现象。</strong></p>
<h5 id="不可重复读（Non-Repeatable-Read）"><a href="#不可重复读（Non-Repeatable-Read）" class="headerlink" title="不可重复读（Non-Repeatable Read）"></a>不可重复读（Non-Repeatable Read）</h5><p><strong>如果一个事务修改了另一个未提交事务读取的数据， 就意味着发生了不可重复读现象，</strong>或者叫模糊读(Fuzzy Read) 现象。</p>
<h5 id="幻读-Phantom-ˈfan-t-əm"><a href="#幻读-Phantom-ˈfan-t-əm" class="headerlink" title="幻读(Phantom, /ˈfan(t)əm/)"></a>幻读(Phantom, /ˈfan(t)əm/)</h5><p>如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入一些了符合那些搜索条件的记录(这里的写入可以指INSERT、DELETE、UPDATE 操作) ，就意味着发生了幻读现象<br>【备注】在书中补充说明了在MySQL场景下，幻读的现象：对于MySQL 来说，幻读强调的就是一个事务在按照某个相同的搜索条件多次读取记录时，在后读取时读到了之前没有读到的记录。这个<strong>后读取到的之前没有读到的记录</strong>可以是由别的事务执行INSERT 语句插入的，也可能是别的事务执行了更新记录键值的UPDATE语句而插入的。</p>
<h4 id="SQL标准中的4种隔离级别"><a href="#SQL标准中的4种隔离级别" class="headerlink" title="SQL标准中的4种隔离级别"></a>SQL标准中的4种隔离级别</h4><p>我们按照可能导致一致性问题的严重性给这些现象排一下序：<code>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</code><br>SQL标准中，根据上面4个不同的严重程度，设立了4个隔离级别，以“舍弃一部分隔离性来换取一部分性能”，具体如下4种：</p>
<ul>
<li><strong>READ UNCOMMITTED：未提交读</strong></li>
<li><strong>READ COMMITTED：已提交读</strong></li>
<li><strong>REPEATABLE READ：可重复读</strong></li>
<li><strong>SERIALIZABLE：可串行化</strong><br><img data-src="109c2b6b/SQL%E6%A0%87%E5%87%86%E4%B8%AD%E8%A7%84%E5%AE%9A%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E7%9A%84%E7%8E%B0%E8%B1%A1.jpg" alt="SQL标准中规定的并发事务执行过程中可能发生的现象"><br>【备注】书中还提到了一个延申的知识点，SQL92标准中没有定义脏写的现象，在95年发表的论文《A critique of ANSI SQL isolation levels》中阐述了更为细致的事务隔离级别，如丢失更新、读偏斜、写偏斜等，有兴趣的可以直接戳连接下载该PDF文档阅读一番。 [A critique of ANSI SQL isolation levels.pdf](109c2b6b\A critique of ANSI SQL isolation levels.pdf) <h4 id="MySQL中支持的4种隔离级别"><a href="#MySQL中支持的4种隔离级别" class="headerlink" title="MySQL中支持的4种隔离级别"></a>MySQL中支持的4种隔离级别</h4>MySQL 虽然支持4种隔离级别， 但与SQL标准中规定的各级隔离级别允许发生的现象却有些出入，MySQL在REPEATABLE READ隔离级别下，<strong>可以很大程度上禁止幻读现象的发生</strong>(关于如何禁止会在后文详细说明)。</li>
</ul>
<p><strong>MySQL的默认隔离级别是REPEATABLE READ。</strong></p>
<h4 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h4><p>对于使用InnoDB存储引擎的表来说， 它的聚簇索引记录中都包含下面这两个必要的隐藏列（row_id 并不是必要的; 在创建的表中有主键时，或者有不允许为NULL的UNIQUE键时，都不会包含row_id列)：</p>
<ul>
<li><strong>trx_id</strong>：一个事务每次对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li>
<li><strong>roll_pointer</strong>：每次对某条聚簇索引记录进行改动时， 都会把旧的版本写入到undo日志种。这个隐藏列就相当于一个指针，可以通过它找到该记录修改前的信息。<br>假设，此时hero表（DDL上文贴出了）中有一条数据，如下图所示：<br><img data-src="109c2b6b/mvcc%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE.jpg" alt="mvcc示例数据"><br>假设插入该记录的<strong>事务id(trx_id)为80</strong>，那么此条记录的示意图如下图所示：<br><img data-src="109c2b6b/mvcc%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="mvcc示例数据结构示意图"><br>假设之后两个事务id分别为100、200的事务对这条记录进行update操作，操作流程如下图所示：<br><img data-src="109c2b6b/transaction_sample_update1.jpg" alt="update操作流程"><br>由于每对记录进行一次改动，都会记录一条undo日志。每条undo日志也都有一条roll_pointer属性，通过这个属性可以将这些undo日志串联成一个链表，所以现在的情况就如下图所示：<br><img data-src="109c2b6b/%E4%BA%8B%E5%8A%A1%E7%89%88%E6%9C%AC%E9%93%BE%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="undo日志串成一个链表"><br>【备注】<em>这里只是为了方便清楚看到结构，所以每条undo日志都会有country列，实际上由于我们这个例子中并没有对该列进行过update操作，所以实际是对应的undo日志中并没有该列数据的。</em><br>在每次更新该记录后，都会将旧值放到一条undo 日志中(就算是该记录的一个旧版本)。随着更新次数的增多，所有的版体都会<strong>被roll_pointer属性连接成一个链表</strong>， 这个链表称为<strong>版本链</strong>。版本链的头节点就是当前记录的最新值。另外，<strong>每个版本中还包含生成该版本时对应的事务id</strong>。这个很重要，后面就<strong>会用这个记录的版本链来控制并发事务访问相同时的行为</strong>，我们<strong>把这种机制称之为多版本并发控制（Multi-Version Concurrency Control, MVCC）</strong>。<h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5>再来看看，针对4种事务隔离级别场景，我们怎么用版本链中的事务版本信息来满足隔离性的要求：</li>
<li>READ UNCOMMITTED：由于可以允许读到未提交事务修改过的记录，所以<strong>直接读取记录的最新版本</strong>就行了。</li>
<li>SERIALIZABLE：MySQL是通过<strong>加锁</strong>的方式来实现的</li>
<li>READ COMMITTED和REPEATABLE READ，都要<strong>保证读到以及提交的事务的修改记录</strong>。换到版本链的场景就是，需要判断版本链中的哪个版本是当前事务可见的。<strong>换句话说，也只有这俩场景需要通过MVCC来控制</strong>。</li>
</ul>
<p>针对上面的问题，提出ReadView（也称为：“一致性视图”）的概念。ReadView里面主要包含4个重要的内容：</p>
<ul>
<li><strong>m_ids</strong>：在生成ReadView时，当前系统中活跃的读写事务的事务id列表。</li>
<li><strong>min_trx_id</strong>：在生成ReadView时，当前系统中活跃的读写事务中最小的事务id; 也就是m_ids中的最小值。</li>
<li><strong>max_trx_id</strong>：在生成ReadView时，系统应该分配给下一个事务的事务id值。<br>【备注】注意一下，这里的max_trx_id不是m_ids里面的id最大值。而是预分配给下一个事务的id。比如现在有事务id分别为1、2、3，3号事务提交之后，此时m_ids里面是1、2。此时min_trx_id=1，而max_trx_id应该是4（下一个事务来的id）。</li>
<li><strong>creator_trx_id</strong>：生成该ReadView的事务的事务id。</li>
</ul>
<p>有了这个ReadView后，在访问某条记录时， 只需要按照下面的步骤来判断记录的某个版本是否可见。</p>
<ul>
<li>如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id ，属性值大于或等于ReadView 中的max_trx_id值， 表明生成该版本的事务在当前事务生成ReadVìew后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的min_trx_id 和max_trx_id之间，则需要判断trx_id属性值是否在m_ids列表中。如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可能被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该原本可以被访问。<br>如果某个版本的事务的数据对当前事务不可见，那就顺着版本链找到下一个版本数据，并继续执行上面的步骤来判断记录的可见性；以此类推，直到版本链中的最后一个版本。如果记录的最后一个版本也不可见，就意味着该条记录对当前事务完全不可见，查询结果就不包含该记录。<br>上述判断过程，可以通过下面这个流程图来直观的看：<br><img data-src="109c2b6b/mcvv%E7%89%88%E6%9C%AC%E9%93%BE%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B.jpg" alt="mcvv版本链迭代过程"><h5 id="已提交读与可重复读的差异"><a href="#已提交读与可重复读的差异" class="headerlink" title="已提交读与可重复读的差异"></a>已提交读与可重复读的差异</h5>这两个最大的区别就是：<strong>生成的ReadView的时机不同</strong>。</li>
<li>READ COMMITTED：每次<strong>读取数据前</strong>都生成一个ReadView</li>
<li>REPEATEABLE READ：只在<strong>第一次读取数据</strong>时生成一个ReadView。这个也就解决了脏读问题。<br><del>【备注】由上面两个生成ReadView的时机不同，所以也就诞生的，为什么这两者关于“不可重复读”的场景的差异。因为，READ COMMITTED每次读取都生成ReadView，在这期间发生事务变更的话，你读取的时候不知道之前发生了什么的，因此之前的事务是有可能已经改变了数据。但是，REPEATEABLE READ，只在第一次读取时生成，保留了当前时刻的状态，因此不管你中间（m_ids列表中的事务）发生了什么，REPEATEABLE READ事务是肯定能够发现的。这就是两者为什么出现的差异。</del><br>我们再看看这张图：<br><img data-src="109c2b6b/SQL%E6%A0%87%E5%87%86%E4%B8%AD%E8%A7%84%E5%AE%9A%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E7%9A%84%E7%8E%B0%E8%B1%A1.jpg" alt="SQL标准中规定的并发事务执行过程中可能发生的现象"><br>再来解释一下为什么这种MVCC控制局面下，能够产生上面的效果</li>
<li>首先READ COMMITTED为啥能避免脏读，不能避免不可重复读嘞？每次都生成ReadView，新事务来直接比较就行了，所以怎么可能读到当前创建这个ReadView的事务还未提交的数据呢？</li>
<li>其次REPEATEABLE READ，脏读就不说了，人家第一次读的时候就记录了原始快照信息了，肯定能解决。为啥能解决不可重复读呢？因为保留了当前时刻的状态，因此不管你中间（m_ids列表中的事务）发生了什么，REPEATEABLE READ事务是肯定能够发现的，通过上面那个流程图比较场景。</li>
</ul>
<p>还有个问题，<strong>即便有了MVCC，是如何还能再次产生幻读的？</strong>答案是能的。<br>我们来举个场景，依旧拿上面的那个hero表来举例子，我们用默认的REPEATEABLE READ隔离级别来举例：<br><img data-src="109c2b6b/mvcc%E4%B8%8B%E5%B9%BB%E8%AF%BB%E5%9C%BA%E6%99%AF.jpg" alt="mvcc下幻读场景"></p>
<ul>
<li>100号的事务，开启事务并查询了第一次，只有一条记录。</li>
<li>此时200号的事务立马开启新事务的同时，在时间编号4的位置插入了一条number=2的记录后，<em>立马提交</em>；</li>
<li>此时100号，后续查询后，调用了一个update语句，这个语句在100号事务自己来看，应该是不存在的，但是更新成功了</li>
<li>100号事务在时间编号8的位置查询的时候，发现查到了2条记录。此时就发生了幻读。<br>我们再结合上述ReadView产生的时机，这个场景的幻读为啥解决不了。<br>因为，200号事务调用insert的时候，是会影响当前的ReadView，但是人家立马提交了，在m_ids中已经不存在了啊。结合上面的那个流程图，出现的场景就在最下面的判断的时机，如下图所示：<br><img data-src="109c2b6b/mvcc%E4%B8%8B%E5%B9%BB%E8%AF%BB%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0.jpg" alt="mvcc下幻读产生原因"></li>
</ul>
<p>那么怎么避免呢？需要用到后面的锁的知识了。<br>在此之前还有个小问题，普通二级索引下mvc怎么工作的？</p>
<h5 id="二级索引与MVCC"><a href="#二级索引与MVCC" class="headerlink" title="二级索引与MVCC"></a>二级索引与MVCC</h5><p>前面的知识知道，只有聚簇索引中才有trx_id和roll_pointer隐藏列。如果某个查询使用的是二级索引来执行查询的，是如何判断可见性的呢？<br><strong>答案是利用到在数据页中Page Header中的一个属性：PAGE_MAX_TRX_ID，作为判断是否需要回表寻找原始ReadView</strong>（回到文章上面那个表格截图看看）<br>这个过程大致是这样的：</p>
<ol>
<li>每当对该页面中的记录执行增删改操作的时候，如果执行该操作事务的trx_id大于PAGE_MAX_TRX_ID，就会把PAGE_MAX_TRX_ID值设置为执行该操作事务的事务id。当select语句访问某个二级索引记录的时候，首先会看一下对应的ReadView的min_trx_id是否大于该页面的PAGE_MAX_TRX_ID。如果是，说明该页面中的所有记录都对该ReadView可见；否则就进行下面一步；</li>
<li>利用二级索引记录中的主键值进行回表操作，得到对应的聚簇索引记录后再按照前面的方式找到对该ReadView可见的第一个版本，然后判断该版本中想要的二级索引列值是否利用该二级索引查询时的值相同。如果是，就把这条记录发送给其它客户端（如果WHERE自子句中还有其它查询条件还要继续判断），否则就跳过该记录。</li>
</ol>
<h4 id="与purge操作"><a href="#与purge操作" class="headerlink" title="与purge操作"></a>与purge操作</h4><p>知道一个概念，InnoDB会把当前系统中所有的ReadView按照创建时间形成了一个链表。当执行purge操作的时候（有个专门的后台线程，文章最开始的架构图中有介绍），就把当前系统中最早生成的ReadView给取出来。经过一系列比较后（在这个过程中如果包含delete mark操作而产生的undo日志），会将对应的undo日志记录给彻底删除。<br>总结就是：<strong>当前系统中，如果最早生成的ReadView不再访问undo日志以及打了删除标记的记录，则可以通过purge操作将他们清除。</strong></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>MySQL中的锁处理，完全可以联想JUC中的处理，有很多共通性。</p>
<h4 id="解决并发事务带来问题的两种方式"><a href="#解决并发事务带来问题的两种方式" class="headerlink" title="解决并发事务带来问题的两种方式"></a>解决并发事务带来问题的两种方式</h4><p>并发事务带来的访问问题，大致分为下面三类：</p>
<ul>
<li><strong>读 - 读情况</strong>：并发事务相继读取相同的记录。读取操作本身不会对记录产生任何影响，所以允许这种情况产生。</li>
<li><strong>写 - 写情况</strong>：并发事务相继对相同的记录进行改动。</li>
<li><strong>读 - 写或写 - 读情况</strong>：也就是一个事务进行读取操作，另一个事务进行改动操作。<h5 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a>写-写情况</h5>写写情况下会发生脏写情况，任何一种隔离级别都不允许这种情况发生。在多个未提交事务叶继对一条记录迸行改动时， 需要让它们排队执行。这个排队的过程其实是通过为<strong>该记录加锁对实现</strong>的。<br><img data-src="109c2b6b/%E9%94%81%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%B0%E5%BD%95%E5%85%B3%E8%81%94.jpg" alt="锁结构与记录关联"><h5 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h5>怎么避免脏读、不可重复读、幻读这些现象呢？有两种可选方案：</li>
<li>方案1：读操作使用MVCC，写操作进行加锁。<br>解释起来，普通的select语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行select操作时，都会生成一个ReadView。ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象。在REPEATABLE READ隔离级别下，一个事务在执行过程中只有一次执行select操作才产生一个ReadView，之后的select都是复用这个ReadView，这样也就避免了不可重复读和一定程度的幻读现象。</li>
<li>方案2：读、写都进行加锁</li>
</ul>
<p>幻读现象的产生是词为某个事务读取了符合某些搜索条件的记录， 之后别的事务又插入了符合相同搜索条件的新记录， 导致该事务再次读取相同搜索条件的记录时，可以读到别的事务插入的新记录， 这些新插入的记录就称为幻影记录。采用加锁的方式避免，幻读现象就有那么一点点麻烦，因为<strong>当前事务在第一次读取记录时那些幻影记录并不存在</strong>， 所以在<strong>读取的时候加锁就有点尴尬</strong>了一一因为我们并不知道给谁加锁。<br>如果采用MVCC方式，读-写操作彼此并不冲突，性能更高；如果采用加锁的方式，读-写彼此需要阻塞运行，从而影响性能。</p>
<h4 id="一致性读"><a href="#一致性读" class="headerlink" title="一致性读"></a>一致性读</h4><p><strong>事务利用MVCC进行的读取操作称之为一致性读（Consistent Read），或者一致性无锁读（有的资料也称之为快照读）。</strong><br>所有普通的select语句（plain select）在READ COMMITTED和REPEATABLE READ隔离级别下都算是一致性读，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.id <span class="operator">=</span> t2.id;</span><br></pre></td></tr></table></figure>
<p>一致性读并不会对表中的任何记录进行加锁操作，其它事务可以自由地对表中的记录进行改动。</p>
<h4 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h4><h5 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h5><p>PS：哎？这里就跟JUC高度吻合了，哈哈哈</p>
<ul>
<li>共享锁（Shared lock）：简称S锁，在事务要读取一条记录时，需要先获取该记录的S锁。</li>
<li>独占锁（Exclusive Lock）：简称X锁，在事务改动一条记录时，需要先获取该记录的X锁。<h5 id="锁定读的语义"><a href="#锁定读的语义" class="headerlink" title="锁定读的语义"></a>锁定读的语义</h5>前面说的，采用加锁的方式避免脏读、不可重复读、幻读这些现象，在读取一条记录的时候获取该记录的S锁。<br>其实这不是严谨的，有时候我们想在读取记录时就获取记录的X锁，从而禁止别的事务读写该记录。<strong>我们把这种读取记录前就为该记录加锁的读取方式称之为锁定读（Locking Read）</strong>。MySQL提供了下面两种特殊的select语句格式来支持锁定读。</li>
<li>对读取记录加S锁<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>
如果当前事务执行了该语句，那么它会读取到的记录加S锁，这样可以允许别的事务继续或许这些记录的S锁，但是不能获取这些记录的X锁。如果别的记录想要获取这些记录的X锁（select for update或者直接想要修改这语句时），那么就会被阻塞，直到当前记录提交之后将这些记录上的S锁释放掉。</li>
<li>对读取记录加X锁<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
这个锁一加，就不允许别的事务做任何操作了，即允许获得S锁，也不允许获得X锁，只能阻塞等待。<h5 id="写操作-解释锁在写操作中的应用"><a href="#写操作-解释锁在写操作中的应用" class="headerlink" title="写操作(解释锁在写操作中的应用)"></a>写操作(解释锁在写操作中的应用)</h5>平常所用到的写操作无非时IUD操作这三种：</li>
<li>DELETE：对一条记录执行Delete操作的过程其实是先在B+树中定位到这条记录的位置，然后获取这条记录的X锁，最后在执行delete mark操作。</li>
<li>UPDATE：对一条记录进行update操作时分为下面3中情况<ul>
<li>如果未修改该记录的键值并且被更新的列所占用的存储空间在修改前后未发生变化，则先在B+树中定位到这条记录的位置，然后再获取记录的X锁，最后在原记录的位置进行修改操作。</li>
<li>如果未修改记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+树中定位到这条记录的位置，然后获取记录的X锁，之后将该记录彻底删除掉（把记录彻底移除到垃圾链表中），最后再插入一条新记录。</li>
<li>如果修改了该记录的键值，则相当于再原纪录上执行delete操作之后再来一条insert操作，加锁的操作就按照delete和insert的规则进行了</li>
</ul>
</li>
<li>INSERT：一般情况下，新插入的一条记录<strong>受隐式锁保护</strong>，不需要在内存中为其生成对应的锁结构。</li>
</ul>
<h5 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h5><p><strong>前面提到的锁都是针对记录的，可以称其为行级锁或者行锁。</strong><br>对一条记录加行锁，影响的也只是这条记录而已，我们就说这个行锁的粒度比较细。其实一个事务也可以在表级别进行加锁，自然就称之为表级锁或者表锁。<br>给表加的锁也可以分为共享锁和独占锁：</p>
<ul>
<li>如果一个事务给表加S锁，那么：<ul>
<li>别的事务<strong>可以</strong>继续获得该表的S锁</li>
<li>别的事务<strong>可以</strong>继续获得该表中的某些记录的S锁</li>
<li>别的事务<strong>不可以</strong>继续获得该表的X锁</li>
<li>别的事务<strong>不可以</strong>继续获得该表中某些记录的X锁</li>
</ul>
</li>
<li>如果一个事务给表加X锁（独占这个表），那么：<ul>
<li><p>别的事务<strong>不可以</strong>继续获得该表的S锁</p>
</li>
<li><p>别的事务<strong>不可以</strong>继续获得该表中的某些记录的S锁</p>
</li>
<li><p>别的事务<strong>不可以</strong>继续获得该表的X锁</p>
</li>
<li><p>别的事务<strong>不可以</strong>继续获得该表中某些记录的X锁</p>
<p>这时候有个问题，当一个表已经有表锁的情况下，我们怎么知道有没有行记录有行锁？<br>InnoDB提出了一种称之为意向锁（Intention Lock）的东西：</p>
</li>
</ul>
</li>
<li>意向共享锁（Intention Shared Lock）：简称IS锁，当事务准备在某条记录上加S锁的时候，先在表级别上加一个IS锁。</li>
<li>意向独占锁（Intention Exclusive Lock）：简称IX锁，当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。<br>总结就是：<strong>IS锁、IX锁是表级锁，它们的提出仅仅是为了在之后加表级别的S锁和X锁时，可以快速判断表中的记录是否被上锁</strong>，以免用遍历的方式来查看表中没有上锁的记录。<br>看一下各个表级别的各种锁的兼容性：<br><img data-src="109c2b6b/%E8%A1%A8%E7%BA%A7%E5%88%AB%E9%94%81%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7.jpg" alt="表级别锁的兼容性"></li>
</ul>
<h3 id="InnoDB中的锁"><a href="#InnoDB中的锁" class="headerlink" title="InnoDB中的锁"></a>InnoDB中的锁</h3><p>InnoDB存储引擎即支持表级锁，也支持行级锁。表级锁，一般我们开发中显示使用用的少，具体看看行级锁</p>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>了解几个场景的表级锁</p>
<ul>
<li>表级别的AUTO-INC锁：就是给主键字段加上AUTO_INCREMENT属性，当插入数据的时候，系统会自动给这个属性进行递增赋值。<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4>InnoDB中的行锁花样很多，换句话说，即使对同一条记录加行锁，如果记录的类型不同，起到的功效也是不同的。<br>TODO<h5 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h5><h5 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h5><h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><h5 id="Insert-Intention-Lock"><a href="#Insert-Intention-Lock" class="headerlink" title="Insert Intention Lock"></a>Insert Intention Lock</h5><h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><h4 id="语句加锁分析"><a href="#语句加锁分析" class="headerlink" title="语句加锁分析"></a>语句加锁分析</h4><h5 id="普通的select语句"><a href="#普通的select语句" class="headerlink" title="普通的select语句"></a>普通的select语句</h5>不同隔离级别下，普通的select语句具有不同的表现：</li>
<li>在READ UNCOMMITTED下，不加锁，直接读取记录的最新版本；可能出现脏读、不可重复读和幻读现象</li>
<li>在READ COMMITTED下，不加锁；在每次执行普通的select语句都会生成一个ReadView，避免脏读现象</li>
<li>在REPEATABLE READ下，不加锁；</li>
<li>在SERIALIZABLE下，需要分两种情况讨论：<ul>
<li>在autocommit=0(禁用自动提交)，普通的select语句会被转换成select…lock in share mode这样的语句。也就是读取记录前需要先获得记录的S锁。</li>
<li>在autocommit=1时，普通的select不会加锁，知识利用mvcc生成一个ReadView记录。为啥不加锁呢？因为启动自动提交的意味着一个事务中只能包含一条语句，执行一条语句哪里来的问题？<h5 id="锁定读的语句"><a href="#锁定读的语句" class="headerlink" title="锁定读的语句"></a>锁定读的语句</h5>四种情况：</li>
</ul>
</li>
<li>select … lock in share mode</li>
<li>select … for update</li>
<li>update …</li>
<li>delete …</li>
</ul>
<p>TODO</p>
<h2 id="MySQL的一些其它特性"><a href="#MySQL的一些其它特性" class="headerlink" title="MySQL的一些其它特性"></a>MySQL的一些其它特性</h2><p>前面众多主要围绕InnoDB的，这里罗列一些跟MySQL高级特性相关的知识，有些在笔者之前工作中是大量使用的</p>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>TODO</p>
<h3 id="分布式-XA-事务"><a href="#分布式-XA-事务" class="headerlink" title="分布式(XA)事务"></a>分布式(XA)事务</h3><p>TODO</p>
<h3 id="复制相关"><a href="#复制相关" class="headerlink" title="复制相关"></a>复制相关</h3>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>细磕Spring点滴</title>
    <url>/post/f5eb228d.html</url>
    <content><![CDATA[<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><h3 id="SpringBean生命周期"><a href="#SpringBean生命周期" class="headerlink" title="SpringBean生命周期"></a>SpringBean生命周期</h3><p>大体分为5个大的步骤，如下图所示：<br><img data-src="f5eb228d/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="SpringBean生命周期"></p>
<h3 id="一些杂项问题"><a href="#一些杂项问题" class="headerlink" title="一些杂项问题"></a>一些杂项问题</h3><h4 id="构造器注入和Setter注入"><a href="#构造器注入和Setter注入" class="headerlink" title="构造器注入和Setter注入"></a>构造器注入和Setter注入</h4><p><strong>构造器注入</strong>：通过构造器的参数注入相关依赖对象<br><strong>Setter注入</strong>：通过 Setter 方法注入依赖对象，也可以理解为字段注入<br>对于两种注入方式的看法：</p>
<ul>
<li><strong>构造器注入可以避免一些尴尬的问题</strong>，比如说状态不确定性地被修改，在初始化该对象时才会注入依赖对象，一定程度上保证了 Bean 初始化后就是不变的对象，这样对于我们的程序和维护性都会带来更多的便利；</li>
<li><strong>构造器注入不允许出现循环依赖</strong>，因为它要求被注入的对象都是成熟态，保证能够实例化，而 <strong>Setter 注入或字段注入没有这样的要求</strong>；</li>
<li><strong>构造器注入可以保证依赖的对象能够有序的被注入</strong>，而 Setter注入或字段注入底层是通过反射机制进行注入，无法完全保证注入的顺序；</li>
<li><strong>如果构造器注入出现比较多的依赖</strong>导致代码不够优雅，我们应该<strong>考虑自身代码的设计是否存在问题</strong>，是否需要重构代码结构。</li>
</ul>
<p>除了上面的注入方式外，Spring 还提供了接口回调注入，通过实现 Aware 接口（例如 BeanNameAware、ApplicationContextAware）可以注入相关对象，Spring 在初始化这类 Bean 时会调用其 setXxx 方法注入对象，例如注入 beanName、ApplicationContext等。</p>
<h4 id="Spring内建的Bean作用域"><a href="#Spring内建的Bean作用域" class="headerlink" title="Spring内建的Bean作用域"></a>Spring内建的Bean作用域</h4><table>
<thead>
<tr>
<th>来源</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td align="center">默认 Spring Bean 作用域，一个 BeanFactory 有且仅有一个实例</td>
</tr>
<tr>
<td>prototype</td>
<td align="center">原型作用域，每次依赖查找和依赖注入生成新 Bean 对象</td>
</tr>
<tr>
<td>request</td>
<td align="center">将 Spring Bean 存储在 ServletRequest 上下文中</td>
</tr>
<tr>
<td>session</td>
<td align="center">将 Spring Bean 存储在 HttpSession 中</td>
</tr>
<tr>
<td>application</td>
<td align="center">将 Spring Bean 存储在 ServletContext 中</td>
</tr>
</tbody></table>
<h4 id="BeanPostProcessor与BeanFactoryPostProcessor的区别"><a href="#BeanPostProcessor与BeanFactoryPostProcessor的区别" class="headerlink" title="BeanPostProcessor与BeanFactoryPostProcessor的区别"></a>BeanPostProcessor与BeanFactoryPostProcessor的区别</h4><ul>
<li>BeanPostProcessor 提供 Spring Bean <strong>初始化前和初始化后的生命周期回调</strong>，允许对关心的 Bean 进行扩展，甚至是替换，其相关子类也提供 Spring Bean 生命周期中其他阶段的回调。</li>
<li>BeanFactoryPostProcessor 提供 Spring <strong>BeanFactory（底层 IoC 容器）的生命周期的回调</strong>，用于扩展 BeanFactory（实际为 ConfigurableListableBeanFactory），BeanFactoryPostProcessor 必须由 Spring ApplicationContext 执行，BeanFactory 无法与其直接交互。</li>
</ul>
<h4 id="如何基于-Extensible-XML-authoring-扩展-Spring-XML-元素"><a href="#如何基于-Extensible-XML-authoring-扩展-Spring-XML-元素" class="headerlink" title="如何基于 Extensible XML authoring 扩展 Spring XML 元素"></a>如何基于 Extensible XML authoring 扩展 Spring XML 元素</h4><p>对Spring XML扩展</p>
<ol>
<li><strong>编写 XML Schema 文件（XSD 文件）</strong>：定义 XML 结构</li>
<li><strong>自定义 NamespaceHandler 实现</strong>：定义命名空间的处理器</li>
<li><strong>自定义 BeanDefinitionParser 实现</strong>：绑定命名空间下不同的 XML 元素与其对应的解析器</li>
<li><strong>注册 XML 扩展（META-INF/spring.handlers 文件）</strong>：命名空间与命名空间处理器的映射</li>
<li><strong>编写 Spring Schema 资源映射文件（META-INF/spring.schemas 文件）</strong>：XML Schema 文件通常定义为网络的形式，在无网的情况下无法访问，所以一般在本地的也有一个 XSD 文件，可通过编写 spring.schemas 文件，将网络形式的 XSD 文件与本地的 XSD 文件进行映射，这样会优先从本地获取对应的 XSD 文件<br>Mybatis 对 Spring 的集成项目中的 <code>&lt;mybatis:scan /&gt; </code>标签就是这样实现的，可以参考：NamespaceHandler、MapperScannerBeanDefinitionParser、XSD 等文件</li>
</ol>
<h4 id="简述-Spring-事件机制原理"><a href="#简述-Spring-事件机制原理" class="headerlink" title="简述 Spring 事件机制原理"></a>简述 Spring 事件机制原理</h4><p>一个典型的观察者模式的应用<br>在Spring中实现，首先主要有以下几个角色：</p>
<ul>
<li><strong>Spring 事件</strong> - org.springframework.context.ApplicationEvent，实现了 java.util.EventListener 接口</li>
<li><strong>Spring 事件监听器</strong> - org.springframework.context.ApplicationListener，实现了 java.util.EventObject 类</li>
<li><strong>Spring 事件发布器</strong> - org.springframework.context.ApplicationEventPublisher</li>
<li><strong>Spring 事件广播器</strong> - org.springframework.context.event.ApplicationEventMulticaster<br>Spring有4个内建的事件：</li>
<li>ContextRefreshedEvent：Spring 应用上下文就绪事件</li>
<li>ContextStartedEvent：Spring 应用上下文启动事件</li>
<li>ContextStoppedEvent：Spring 应用上下文停止事件</li>
<li>ContextClosedEvent：Spring 应用上下文关闭事件</li>
</ul>
<p>Spring 应用上下文就是一个 ApplicationEventPublisher 事件发布器，其内部有一个 ApplicationEventMulticaster 事件广播器（被观察者），里面保存了所有的 ApplicationListener 事件监听器（观察者）。<br>Spring 应用上下文发布一个事件后会通过 ApplicationEventMulticaster 事件广播器进行广播，能够处理该事件类型的 ApplicationListener 事件监听器则进行处理。</p>
<h4 id="EventListener的工作原理"><a href="#EventListener的工作原理" class="headerlink" title="@EventListener的工作原理"></a>@EventListener的工作原理</h4><p><strong>@EventListener 用于标注在方法上面，该方法则可以用来处理 Spring 的相关事件。</strong><br>Spring 内部有一个处理器 EventListenerMethodProcessor，它实现了 SmartInitializingSingleton 接口，在所有的 Bean（不是抽象、单例模式、不是懒加载方式）初始化后，Spring 会再次遍历所有初始化好的单例 Bean 对象时会执行该处理器对该 Bean 进行处理。在 EventListenerMethodProcessor 中会对标注了 @EventListener 注解的方法进行解析，如果符合条件则生成一个 ApplicationListener 事件监听器并注册。</p>
<h4 id="Spring-提供的注解"><a href="#Spring-提供的注解" class="headerlink" title="Spring 提供的注解"></a>Spring 提供的注解</h4><p>大致分为5类：</p>
<ol>
<li><p>Spring 模式注解</p>
<table>
<thead>
<tr>
<th>Spring 注解</th>
<th align="center">场景说明</th>
<th align="center">起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Repository</td>
<td align="center">数据仓储模式注解</td>
<td align="center">2.0</td>
</tr>
<tr>
<td>@Component</td>
<td align="center">通用组件模式注解</td>
<td align="center">2.5</td>
</tr>
<tr>
<td>@Service</td>
<td align="center">服务模式注解</td>
<td align="center">2.5</td>
</tr>
<tr>
<td>@Controller</td>
<td align="center">Web 控制器模式注解</td>
<td align="center">2.5</td>
</tr>
<tr>
<td>@Configuration</td>
<td align="center">配置类模式注解</td>
<td align="center">3.0</td>
</tr>
</tbody></table>
</li>
<li><p>装配注解</p>
<table>
<thead>
<tr>
<th>Spring 注解</th>
<th align="center">场景说明</th>
<th align="center">起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@ImportResource</td>
<td align="center">替换 XML 元素 <import></td>
<td align="center">2.5</td>
</tr>
<tr>
<td>@Import</td>
<td align="center">导入 Configuration 类</td>
<td align="center">2.5</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td align="center">扫描指定 package 下标注 Spring 模式注解的类</td>
<td align="center">3.1</td>
</tr>
</tbody></table>
</li>
<li><p>依赖注入注解</p>
<table>
<thead>
<tr>
<th>Spring 注解</th>
<th align="center">场景说明</th>
<th align="center">起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td align="center">Bean 依赖注入，支持多中依赖查找方式</td>
<td align="center">2.5</td>
</tr>
<tr>
<td>@Qualifier</td>
<td align="center">细粒度的 @Autowired 依赖查找</td>
<td align="center">2.5</td>
</tr>
</tbody></table>
</li>
<li><p>@Enable 模块驱动</p>
<table>
<thead>
<tr>
<th>Spring 注解</th>
<th align="center">场景说明</th>
<th align="center">起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@EnableWebMvc</td>
<td align="center">启动整个 Web MVC 模块</td>
<td align="center">3.1</td>
</tr>
<tr>
<td>@EnableTransactionManagement</td>
<td align="center">启动整个事务管理模块</td>
<td align="center">3.1</td>
</tr>
<tr>
<td>@EnableCaching</td>
<td align="center">启动整个缓存模块</td>
<td align="center">3.1</td>
</tr>
<tr>
<td>@EnableAsync</td>
<td align="center">启动整个异步处理模块</td>
<td align="center">3.1</td>
</tr>
</tbody></table>
</li>
</ol>
<p>@Enable 模块驱动是以 @Enable 为前缀的注解驱动编程模型。所谓“模块”是指具备相同领域的功能组件集合，组合所形成一个独立的单元。比如 Web MVC 模块、AspectJ 代理模块、Caching（缓存）模块、JMX（Java 管理扩展）模块、Async（异步处理）模块等。<br><strong>这类注解底层原理就是通过 @Import 注解导入相关类（Configuration Class、 ImportSelector 接口实现、ImportBeanDefinitionRegistrar 接口实现），来实现引入某个模块或功能。</strong></p>
<ol start="5">
<li>条件注解<table>
<thead>
<tr>
<th>Spring 注解</th>
<th align="center">场景说明</th>
<th align="center">起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Conditional</td>
<td align="center">条件限定，引入某个 Bean</td>
<td align="center">4.0</td>
</tr>
<tr>
<td>@Profile</td>
<td align="center">从 Spring 4.0 开始，@Profile 基于 @Conditional 实现，限定 Bean 的 Spring 应用环境</td>
<td align="center">4.0</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h2 id="Spring其它相关"><a href="#Spring其它相关" class="headerlink" title="Spring其它相关"></a>Spring其它相关</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring全家桶</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8函数式编程原理剖析</title>
    <url>/post/4a0d265b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>Java函数式编程</tag>
        <tag>Java Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>精读阿里Java开发手册</title>
    <url>/post/10fbed60.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>意在一方面知道有这个建议的同时，尽可能了解背后为什么要这么设定的原理。梳理、整理记录于此。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>阿里开发手册1.3.1</tag>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty学习实录</title>
    <url>/post/65d26b16.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于IO模型的一些概念，在Tomcat文章中有所介绍：<a href="https://nimbusk.cc/post/2f453177">Tomcat学习实录</a><br>这篇围绕netty以及关于hotspot和linux底层epoll原理做学习记录</p>
<span id="more"></span>


<h2 id="Java中的NIO多路复用-ServerSocketChannel"><a href="#Java中的NIO多路复用-ServerSocketChannel" class="headerlink" title="Java中的NIO多路复用-ServerSocketChannel"></a>Java中的NIO多路复用-ServerSocketChannel</h2><p>服务端使用最多的模型，在Java层面使用的是SocketChannel。<br>一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioSelectorServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建NIO ServerSocketChannel,与BIO的serverSocket类似</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 非阻塞模式accept方法不会阻塞，否则会阻塞</span></span><br><span class="line">            <span class="comment">// NIO的非阻塞是由操作系统内部实现的，底层调用了linux内核的accept函数</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="keyword">if</span> (socketChannel != <span class="literal">null</span>) &#123; <span class="comment">// 如果有客户端进行连接</span></span><br><span class="line">                System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                <span class="comment">// 设置SocketChannel为非阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 保存客户端连接在List中</span></span><br><span class="line">                channelList.add(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历连接进行数据读取</span></span><br><span class="line">            Iterator&lt;SocketChannel&gt; iterator = channelList.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                <span class="comment">// 非阻塞模式read方法不会阻塞，否则会阻塞</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sc.read(byteBuffer);</span><br><span class="line">                <span class="comment">// 如果有数据，把数据打印出来</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123; <span class="comment">// 如果客户端断开，把socket从集合中去掉</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是典型的Java场景使用NIO完成通信的服务端代码，对应的NIO有三大核心组件：Channel(通道)， Buffer(缓冲区)，Selector(多路复用器)</p>
<ul>
<li>channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组</li>
<li>channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理</li>
<li>NIO 的 Buffer 和 channel 都是既可以读也可以写</li>
</ul>
<p>对应通讯示意图如下图所示：<br><img data-src="65d26b16/JDK-NIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="JDK-NIO通信模型"><br>NIO底层在JDK1.4版本是用linux的内核函数select()或poll()来实现，selector每次都会轮询所有的sockchannel看下哪个channel有读写事件，有的话就处理，没有就继续遍历。<br><strong>JDK1.5开始引入了epoll基于事件响应机制来优化NIO。</strong></p>
<h3 id="底层流程细节"><a href="#底层流程细节" class="headerlink" title="底层流程细节"></a>底层流程细节</h3><p>NioSelectorServer代码里如下几个方法非常重要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector.open() <span class="comment">//创建多路复用器</span></span><br><span class="line">socketChannel.register() <span class="comment">//将channel注册到多路复用器上</span></span><br><span class="line">selector.select() <span class="comment">//阻塞等待需要处理的事件发生</span></span><br></pre></td></tr></table></figure>
<p>从Hotspot与Linux内核函数级别来理解下，大体对应主要工作流程如下：<br><img data-src="65d26b16/%E5%BA%95%E5%B1%82%E6%B5%81%E7%A8%8B.jpg" alt="底层流程"></p>
<p><strong>总结：</strong>NIO整个调用流程就是Java调用了操作系统的内核函数来创建Socket，获取到Socket的文件描述符，再创建一个Selector对象，对应操作系统的Epoll描述符。<br>将获取到的Socket连接的文件描述符的事件绑定到Selector对应的Epoll文件描述符上，进行事件的异步通知，这样就实现了使用一条线程，并且不需要太多的无效的遍历，将事件处理交给了操作系统内核(操作系统中断程序实现)，大大提高了效率。</p>
<h2 id="Linux下的epoll函数"><a href="#Linux下的epoll函数" class="headerlink" title="Linux下的epoll函数"></a>Linux下的epoll函数</h2><p>I/O多路复用底层主要用的Linux 内核函数（select，poll，epoll）来实现，windows不支持epoll实现，windows底层是基于winsock2的select函数实现的(不开源)<br><img data-src="65d26b16/linux-pool-epoll.png" alt="linux-pool-epoll比较"></p>
<h2 id="Netty使用"><a href="#Netty使用" class="headerlink" title="Netty使用"></a>Netty使用</h2><h3 id="一个聊天室Demo"><a href="#一个聊天室Demo" class="headerlink" title="一个聊天室Demo"></a>一个聊天室Demo</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建两个线程组bossGroup和workerGroup, 含有的子线程NioEventLoop的个数默认为cpu核数的两倍</span></span><br><span class="line">        <span class="comment">// bossGroup只是处理连接请求 ,真正的和客户端业务处理，会交给workerGroup完成</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">//使用链式编程来配置参数</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    <span class="comment">// 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的,所以同一时间只能处理一个客户端连接。</span></span><br><span class="line">                    <span class="comment">// 多个客户端同时来的时候,服务端将不能处理的客户端连接请求放在队列中等待处理</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<span class="comment">//创建通道初始化对象，设置初始化参数</span></span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            <span class="comment">//对workerGroup的SocketChannel设置处理器，注意这个加入的与编解码器的顺序</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChatServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;chat server start。。&quot;</span>);</span><br><span class="line">            <span class="comment">//绑定一个端口并且同步, 生成了一个ChannelFuture异步对象，通过isDone()等方法可以判断异步事件的执行情况</span></span><br><span class="line">            <span class="comment">//启动服务器(并绑定端口)，bind是异步操作，sync方法是等待异步操作执行完毕</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">cf</span> <span class="operator">=</span> bootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;caught exception: &quot;</span> + cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ChannelGroup</span> <span class="variable">channelGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[client] &quot;</span> + channel.remoteAddress() + <span class="string">&quot; is connected! &quot;</span> + sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">        System.out.println(<span class="string">&quot;server log: [client]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; is connected! \r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[client] &quot;</span> + channel.remoteAddress() + <span class="string">&quot; is disconnected!\r\n&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;server log: [client]&quot;</span> + channel.remoteAddress() + <span class="string">&quot; is disconnected! \r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        channelGroup.forEach(ch -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != channel) &#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[client] &quot;</span> + channel.remoteAddress() + <span class="string">&quot; send msg: &quot;</span> + msg + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[myself] send msg: &quot;</span> + msg + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">// 使用 NioSocketChannel 作为客户端的通道实现</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            <span class="comment">//加入处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChatClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;client client start&quot;</span>);</span><br><span class="line">            <span class="comment">//启动客户端去连接服务器端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>).sync();</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;client connect success! &quot;</span> + channel.localAddress());</span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line"><span class="comment">//            channel.closeFuture().sync();</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;caught exception....&quot;</span> + cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>这里穿插一下关于响应式编程中（Doug Lea）提到的关于主从Reactor模型的含义：<br><strong>其实完全可以看作一种多级缓存的概念，增加了一道缓冲，以免造成单一线程池压力【对比上文中的nio程序】</strong><br><img data-src="65d26b16/mutil_reactors.png" alt="multi_reactors"></p>
<p>看上面的例子中的服务端实现，new了两个netty的<code>NioEventLoopGroup</code>，就是这种思想。<br><strong>当然，延申出来可以做成“一主多从”，即多个从Reactor模型</strong></p>
<p>概况起来，netty的工作架构示意图：<br><img data-src="65d26b16/netty-reactor%E5%B7%A5%E4%BD%9C%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="netty-reactor工作架构图"></p>
<h3 id="Netty核心功能"><a href="#Netty核心功能" class="headerlink" title="Netty核心功能"></a>Netty核心功能</h3><h4 id="编解码机制"><a href="#编解码机制" class="headerlink" title="编解码机制"></a>编解码机制</h4><p>当你通过Netty发送或者接受一个消息的时候，就将会发生一次数据转换：<strong>入站消息会被解码：从字节转换为另一种格式（比如java对象）；如果是出站消息，它会被编码成字节。</strong><br>Netty提供了一系列实用的编码解码器，他们都实现了<strong>ChannelInboundHadnler</strong>或者<strong>ChannelOutboundHandler</strong>接口。在这些类中，channelRead方法已经被重写了。以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，它将调用由已知解码器所提供的decode()方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler。<br>Netty提供了很多编解码器，比如编解码字符串的StringEncoder和StringDecoder，编解码对象的ObjectEncoder和ObjectDecoder等。<br><strong>注：</strong>不同方向的编解码器是有规律注册（继承了Outbound/Inboundhandler）好的，出站编码，入站解码。<br>下方图为Channle工作示意图：<br><img data-src="65d26b16/netty-channel.png" alt="netty-channel"></p>
<h5 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h5><p>ChannelHandler充当了处理入站和出站数据的应用程序逻辑容器。<br>例如，实现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据随后会被你的应用程序的业务逻辑处理。<br>当你要给连接的客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。你的业务逻辑通常写在一个或者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不过它是用来处理出站数据的。</p>
<h5 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h5><p>ChannelPipeline提供了ChannelHandler链的容器。<br>以客户端应用程序为例，如果事件的运动方向是从服务端到客户端的，那么我们称<strong>这些事件为出站的</strong>，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler(ChannelOutboundHandler调用是从tail到head方向逐个调用每个handler的逻辑)，并被这些Handler处理；<br><strong>反之则称为入站的</strong>，入站只调用pipeline里的ChannelInboundHandler逻辑(ChannelInboundHandler调用是从head到tail方向逐个调用每个handler的逻辑)。</p>
<h4 id="粘包拆包方案"><a href="#粘包拆包方案" class="headerlink" title="粘包拆包方案"></a>粘包拆包方案</h4><p>TCP是一个流协议，就是没有界限的一长串二进制数据。<br>TCP作为传输层协议并不不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的<strong>TCP粘包和拆包</strong>问题。<strong>面向流的通信是无消息保护边界的。</strong><br>如下图所示，client发了两个数据包D1和D2，但是server端可能会收到如下几种情况的数据：<br><img data-src="65d26b16/TCP%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85%E7%A4%BA%E6%84%8F.png" alt="TCP粘包-拆包示意"><br>常用的解决方案：</p>
<ol>
<li><strong>消息定长度</strong>，传输的数据大小固定长度，例如每段的长度固定为100字节，如果不够空位补空格</li>
<li>在<strong>数据包尾部添加特殊分隔符</strong>，比如下划线，中划线等，这种方法简单易行，但选择分隔符的时候一定要注意每条数据的内部一定不能出现分隔符。</li>
<li><strong>发送长度</strong>：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。<br>在netty中提供了下面三种解码器来处理：</li>
</ol>
<ul>
<li>LineBasedFrameDecoder （回车换行分包）</li>
<li>DelimiterBasedFrameDecoder （特殊分隔符分包）</li>
<li>FixedLengthFrameDecoder （固定长度报文来分包）<br>以DelimiterBasedFrameDecoder为例，在IDEA中查看类继承图谱：<br><img data-src="65d26b16/DelimiterBasedFrameDecoder%E7%BB%A7%E6%89%BF%E5%9B%BE%E8%B0%B1.png" alt="DelimiterBasedFrameDecoder继承图谱"></li>
</ul>
<p><strong>继承了来自一个抽象类：ByteToMessageDecoder</strong>，归纳有两组抽象类：</p>
<ul>
<li>ByteToMessageDecoder/MessageToByteEncoder</li>
<li>MessageToMessageDecoder/MessageToMessageEncoder<br>这两组抽象类，抽象了关于解码器的众多细节，由这两组抽象类衍生的，netty实现了非常多的解码器组件，如下图所示（4.1.35版本，后续版本的netty将code包单独独立出pom依赖分支，不再柔和在一个包里面了，注意一下）：<br><img data-src="65d26b16/netty-codec-package.png" alt="netty-codec-package"></li>
</ul>
<h4 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h4><p>IdleStateHandler</p>
<h4 id="断线重连机制"><a href="#断线重连机制" class="headerlink" title="断线重连机制"></a>断线重连机制</h4><h3 id="Netty核心源码"><a href="#Netty核心源码" class="headerlink" title="Netty核心源码"></a>Netty核心源码</h3>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
        <tag>IO多路复用</tag>
        <tag>网络通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat学习实录</title>
    <url>/post/2f453177.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Tomcat的设计思路，整体架构，设计精髓</li>
<li>Tomcat的线程模型详解及其调优</li>
<li>Tomcat的类加载机制和热加载部署的实现原理</li>
</ul>
<span id="more"></span>

<h2 id="Tomcat架构相关"><a href="#Tomcat架构相关" class="headerlink" title="Tomcat架构相关"></a>Tomcat架构相关</h2><p><strong>Tomcat核心： Http服务器+Servlet容器</strong><br><img data-src="2f453177/Tomcat%E8%AF%B7%E6%B1%82%E8%B0%83%E7%94%A8%E9%93%BE.png" alt="Tomcat请求调用链"><br>Tomcat架构模型<br><img data-src="2f453177/Tomcat%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="Tomcat架构模型"></p>
<p><strong>Tomcat 要实现 2 个核心功能：</strong></p>
<ul>
<li>处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。</li>
<li>加载和管理 Servlet，以及具体处理 Request 请求。<br>因此 Tomcat 设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。连接器负责对外交流，容器负责内部处理。</li>
</ul>
<h3 id="Tomcat核心组件"><a href="#Tomcat核心组件" class="headerlink" title="Tomcat核心组件"></a>Tomcat核心组件</h3><h4 id="Server组件"><a href="#Server组件" class="headerlink" title="Server组件"></a>Server组件</h4><p>指的就是整个 Tomcat 服务器，包含多组服务（Service），负责管理和启动各个Service，同时监听 8005 端口发过来的 shutdown 命令，用于关闭整个容器 。</p>
<h4 id="Service组件"><a href="#Service组件" class="headerlink" title="Service组件"></a>Service组件</h4><p>每个 Service 组件都包含了若干用于接收客户端消息的 Connector 组件和处理请求的Engine 组件。 Service 组件还包含了若干 Executor 组件，每个 Executor 都是一个线程池，它可以为 Service 内所有组件提供线程池执行任务。<br><img data-src="2f453177/Service%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Service组件架构示意图"></p>
<h5 id="为什么这么设计？"><a href="#为什么这么设计？" class="headerlink" title="为什么这么设计？"></a>为什么这么设计？</h5><p>Tomcat 为了实现支持多种 I/O 模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门，<strong>但是单独的连接器或者容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作 Service 组件。</strong><br>Service 本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。Tomcat 内可能有多个Service，这样的设计也是出于灵活性的考虑。<strong>通过在 Tomcat 中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</strong></p>
<h4 id="Connector组件"><a href="#Connector组件" class="headerlink" title="Connector组件"></a>Connector组件</h4><p>连接器对 Servlet 容器屏蔽了不同的应用层协议及 I/O 模型，无论是 HTTP 还是AJP，在容器中获取到的都是一个标准的 ServletRequest 对象。连接器需要实现的功能：</p>
<ul>
<li>监听网络端口。</li>
<li>接受网络连接请求。</li>
<li>读取请求网络字节流。</li>
<li>根据具体应用层协议（HTTP/AJP）解析字节流，生成统一的 Tomcat Request对象。</li>
<li>将 Tomcat Request 对象转成标准的 ServletRequest。</li>
<li>调用 Servlet 容器，得到 ServletResponse。</li>
<li>将 ServletResponse 转成 Tomcat Response 对象。</li>
<li>将 Tomcat Response 转成网络字节流。</li>
<li>将响应字节流写回给浏览器。</li>
</ul>
<p><strong>连接器需要完成 3 个$\color{red}{高内聚}$的功能：</strong></p>
<ul>
<li>网络通信。</li>
<li>应用层协议解析。</li>
<li>Tomcat Request/Response 与 ServletRequest/ServletResponse 的转化。</li>
</ul>
<p><strong>分别对应的三个功能来实现这3个功能：</strong></p>
<ul>
<li>EndPoint 负责提供字节流给 Processor；</li>
<li>Processor 负责提供 Tomcat Request 对象给 Adapter；</li>
<li>Adapter 负责提供 ServletRequest 对象给容器。</li>
</ul>
<h4 id="ProtocalHandle组件"><a href="#ProtocalHandle组件" class="headerlink" title="ProtocalHandle组件"></a>ProtocalHandle组件</h4><p><img data-src="2f453177/ProtocalHandler%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ProtocalHandler架构示意图"></p>
<h2 id="Tomcat线程模型相关"><a href="#Tomcat线程模型相关" class="headerlink" title="Tomcat线程模型相关"></a>Tomcat线程模型相关</h2><h3 id="主题要点"><a href="#主题要点" class="headerlink" title="主题要点"></a>主题要点</h3><ul>
<li>理解IO模型的本质：是为了解决什么问题，为什么会有不同的IO模型设计，重点理解IO模型中的IO多路复用和异步IO</li>
<li>主从Reactor多线程模型在Tomcat中的实现</li>
</ul>
<h3 id="关于阻塞唤醒"><a href="#关于阻塞唤醒" class="headerlink" title="关于阻塞唤醒"></a>关于阻塞唤醒</h3><p><img data-src="2f453177/linux%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="linux线程阻塞示意图"><br>阻塞的本质就是将进程的task_struct移出运行队列，添加到等待队列，并且将进程的状态的置为TASK_UNINTERRUPTIBLE或者TASK_INTERRUPTIBLE，重新触发一次 CPU调度让出 CPU</p>
<h3 id="IO模型下的异步-同步，阻塞-非阻塞问题"><a href="#IO模型下的异步-同步，阻塞-非阻塞问题" class="headerlink" title="IO模型下的异步/同步，阻塞/非阻塞问题"></a>IO模型下的异步/同步，阻塞/非阻塞问题</h3><p><strong>I/O 模型是为了解决内存和外部设备速度差异的问题。<br>我们平时说的阻塞或非阻塞是指应用程序在发起 I/O 操作时，是立即返回还是等待。<br>而同步和异步，是指应用程序在与内核通信时，数据从内核空间到应用空间的拷贝，是由内核主动发起还是由应用程序来触发。</strong><br>如果是需要应用程序主动再次发起，那就是同步；反之，由内核空间自己将数据拷贝到用户进程缓冲区，那就是异步；</p>
<h4 id="Socket-Read系统调用过程"><a href="#Socket-Read系统调用过程" class="headerlink" title="Socket Read系统调用过程"></a>Socket Read系统调用过程</h4><p>通过一个例子来理解，以Linux操作系统为例，一次socket read 系统调用的过程：</p>
<ul>
<li>首先 CPU 在用户态执行应用程序的代码，访问进程虚拟地址空间的用户空间；</li>
<li>read 系统调用时 CPU 从用户态切换到内核态，执行内核代码，内核检测到Socket 上的数据未就绪时，将进程的task_struct结构体从运行队列中移到等待队列，并触发一次 CPU 调度，这时进程会让出 CPU；</li>
<li>当网卡数据到达时，内核将数据从内核空间拷贝到用户空间的 Buffer，接着将进程的task_struct结构体重新移到运行队列，这样进程就有机会重新获得 CPU 时间片，系统调用返回，CPU 又从内核态切换到用户态，访问用户空间的数据。</li>
</ul>
<p><strong>总结</strong>：<br>当用户线程发起 I/O 调用后，网络数据读取操作会经历两个步骤：</p>
<ol>
<li><strong>用户线程等待内核将数据从网卡拷贝到内核空间。（数据准备阶段）</strong></li>
<li><strong>内核将数据从内核空间拷贝到用户空间（应用进程的缓冲区）。</strong></li>
</ol>
<p><strong>各种 I/O 模型的区别就是：它们实现这两个步骤的方式是不一样的。也就是对这两个步骤的优化过程</strong><br><img data-src="2f453177/IO%E8%B0%83%E7%94%A8%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="IO调用用户态和内核态数据交换示意图"></p>
<h3 id="Unix-Linux-下的5种IO模型"><a href="#Unix-Linux-下的5种IO模型" class="headerlink" title="Unix(Linux)下的5种IO模型"></a>Unix(Linux)下的5种IO模型</h3><p>Linux 系统下的 I/O 模型有 5 种：</p>
<ol>
<li>同步阻塞I/O（bloking I/O）</li>
<li>同步非阻塞I/O（non-blocking I/O）</li>
<li>I/O多路复用（multiplexing I/O）</li>
<li>信号驱动式I/O（signal-driven I/O）(<em>不常用</em>)</li>
<li>异步I/O（asynchronous I/O）</li>
</ol>
<p><img data-src="2f453177/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB.png" alt="同步阻塞IO模型分类"><br>各种IO模型行为的差异对比示意图：<br><img data-src="2f453177/%E5%90%84%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E8%A1%8C%E4%B8%BA%E5%B7%AE%E5%BC%82.png" alt="各种IO模型行为差异"></p>
<p>一个非常简单的在Java中实现的BIO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BioServer</span> &#123;</span><br><span class="line">	<span class="comment">// 数据准备和数据读取阶段两步阻塞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动服务，绑定8080端口</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;开启服务&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;等待客户端建立连接&quot;</span>);</span><br><span class="line">                <span class="comment">// 监听8080端口，获取客户端连接</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">//阻塞</span></span><br><span class="line">                System.out.println(<span class="string">&quot;建立连接：&quot;</span>+socket);</span><br><span class="line">                <span class="comment">// 用线程池，模拟多连接场景，否则会一直阻塞（BIO的缺点）</span></span><br><span class="line">                executorService.submit(()-&gt;&#123;</span><br><span class="line">                    <span class="comment">//TODO 业务处理</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler(socket);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//TODO 资源回收</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            System.out.println(<span class="string">&quot;等待读取数据&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socket.getInputStream().read(bytes); <span class="comment">// 阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(read !=-<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;读取客户端发送的数据：&quot;</span> +</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, read));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Tomcat实现的IO模型"><a href="#Tomcat实现的IO模型" class="headerlink" title="Tomcat实现的IO模型"></a>Tomcat实现的IO模型</h3><table>
<thead>
<tr>
<th>IO模型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BIO（JIoEndpoint）</td>
<td>同步阻塞式IO，即Tomcat使用传统的java.io进行操作。该模式下每个请求都会创建一个线程，对性能开销大，不适合高并发场景。优点是稳定，适合连接数目小且固定架构。</td>
</tr>
<tr>
<td>NIO（NioEndpoint）</td>
<td>同步非阻塞式IO，jdk1.4 之后实现的新IO。该模式基于多路复用选择器监测连接状态再同步通知线程处理，从而达到非阻塞的目的。比传统BIO能更好的支持并发性能。Tomcat 8.0之后默认采用该模式。NIO方式适用于连接数目多且连接比较短（轻操作） 的架构， 比如聊天服务器， 弹幕系统， 服务器间通讯，编程比较复杂</td>
</tr>
<tr>
<td>AIO (Nio2Endpoint)</td>
<td>异步非阻塞式IO，jdk1.7后之支持 。与nio不同在于不需要多路复用选择器，而是请求处理线程执行完成进行回调通知，继续执行后续操作。Tomcat 8之后支持。一般适用于连接数较多且连接时间较长的应用</td>
</tr>
<tr>
<td>APR（AprEndpoint）</td>
<td>全称是 Apache Portable Runtime/Apache可移植运行库)，是ApacheHTTP服务器的支持库。AprEndpoint 是通过 JNI 调用 APR 本地库而实现非阻塞 I/O 的。使用需要编译安装APR 库</td>
</tr>
</tbody></table>
<p>注意： Linux 内核没有很完善地支持异步 I/O 模型，因此 JVM 并没有采用原生的 Linux 异步 I/O，而是在应用层面通过 epoll 模拟了异步 I/O 模型。因此在 Linux 平台上，JavaNIO 和 Java NIO.2 底层都是通过 epoll 来实现的，但是 Java NIO 更加简单高效。</p>
<h3 id="Tomcat对线程池的扩展"><a href="#Tomcat对线程池的扩展" class="headerlink" title="Tomcat对线程池的扩展"></a>Tomcat对线程池的扩展</h3><p>Tomcat的线程池管理线程的时候，首次遇到投放失败的时候，会有一个重新向阻塞队列里面投放的过程。<br>由于自己定义了一个TaskQueue（继承LinkedBlockingQueue）,这里面对offer方法重写了就遇到了一个很有意思的问题：<br>对于原生的Java线程池定义的阻塞队列，当前线程池核心队列满的同时小于最大线程的时候，<strong>是不会创建非核心线程的，是直接往队列里面丢</strong>。<br>而在tomcat重新的offer方法里面，<strong>这种情况会直接返回false，让其放入队列失败，进而直接去创建非核心线程去了。</strong><br>贴上两段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 代码位置：org.apache.tomcat.util.threads.ThreadPoolExecutor#executeInternal</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment">     * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment">     * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment">     * the task is handled by the current &#123;<span class="doctag">@link</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment">     *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) &#123;</span><br><span class="line">                reject(command);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>)) &#123;</span><br><span class="line">            reject(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>TaskQueue的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码位置 org.apache.tomcat.util.threads.TaskQueue#offer</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line">      <span class="comment">//we can&#x27;t do any checks</span></span><br><span class="line">        <span class="keyword">if</span> (parent==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//we are maxed out on threads, simply queue the object</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSizeNoLock() == parent.getMaximumPoolSize()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//we have idle threads, just add it to the queue</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getSubmittedCount() &lt;= parent.getPoolSizeNoLock()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if we have less threads than maximum force creation of a new thread</span></span><br><span class="line">        <span class="comment">// 注意看这里</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSizeNoLock() &lt; parent.getMaximumPoolSize()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if we reached here, we need to add it to the queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程上下文加载器"><a href="#线程上下文加载器" class="headerlink" title="线程上下文加载器"></a>线程上下文加载器</h3><p>在 JVM 的实现中有一条隐含的规则，<strong>默认情况下，如果一个类由类加载器 A 加载，那么这个类的依赖类也是由相同的类加载器加载。</strong></p>
<p>Tomcat 为每个 Web 应用创建一个 WebAppClassLoarder 类加载器，并在启动Web 应用的线程里设置线程上下文加载器，这样 Spring 在启动时就将线程上下文加载器取出来，用来加载 Bean。</p>
<p><strong>线程上下文加载器是一种类加载器传递机制</strong>，因为这个类加载器保存在线程私有数据里，只要是同一个线程，一旦设置了线程上下文加载器，在线程后续执行过程中就能把这个类加载器取出来用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接取出对应线程的类加载器，取出来用即可</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>
<p>线程上下文加载器不仅仅可以用在 Tomcat 和 Spring 类加载的场景里，核心框架类需要加载具体实现类时都可以用到它，比如我们熟悉的 JDBC 就是通过上下文类加载器来加载不同的数据库驱动的。</p>
<h2 id="Tomcat热加载与热部署"><a href="#Tomcat热加载与热部署" class="headerlink" title="Tomcat热加载与热部署"></a>Tomcat热加载与热部署</h2><p>在项目开发过程中，经常要改动Java/JSP 文件，但是又不想重新启动Tomcat，有两种方式:热加载和热部署。热部署表示重新部署应⽤，它的执⾏主体是Host。 热加载表示重新加载class，它的执⾏主体是Context。</p>
<p><strong>思考：Tomcat 是如何用后台线程来实现热加载和热部署的？</strong></p>
<h3 id="Tomcat开启后台线程执行周期性任务"><a href="#Tomcat开启后台线程执行周期性任务" class="headerlink" title="Tomcat开启后台线程执行周期性任务"></a>Tomcat开启后台线程执行周期性任务</h3><p>Tomcat 通过开启后台线程ContainerBase.ContainerBackgroundProcessor，使得各个层次的容器组件都有机会完成一些周期性任务。我们在实际工作中，往往也需要执行一些周期性的任务，比如监控程序周期性拉取系统的健康状态，就可以借鉴这种设计。</p>
<p>Tomcat9 是通过 <code>ScheduledThreadPoolExecutor</code> 来开启后台线程的，它除了具有线程池的功能，还能够执行周期性的任务</p>
<h2 id="Tomcat调优"><a href="#Tomcat调优" class="headerlink" title="Tomcat调优"></a>Tomcat调优</h2><h3 id="Tomcat-的关键指标"><a href="#Tomcat-的关键指标" class="headerlink" title="Tomcat 的关键指标"></a>Tomcat 的关键指标</h3><p>Tomcat 的关键指标有<strong>吞吐量、响应时间、错误数、线程池、CPU 以及 JVM 内存。</strong><br>前三个指标是我们最关心的业务指标，Tomcat 作为服务器，就是要能够又快有好地处理请求，因此吞吐量要大、响应时间要短，并且错误数要少。<br>后面三个指标是跟系统资源有关的，当某个资源出现瓶颈就会影响前面的业务指标，比如线程池中的线程数量不足会影响吞吐量和响应时间；但是线程数太多会耗费大量 CPU，也会影响吞吐量；当内存不足时会触发频繁地 GC，耗费 CPU，最后也会反映到业务指标上来。</p>
<h3 id="Tomcat线程池的并发调优"><a href="#Tomcat线程池的并发调优" class="headerlink" title="Tomcat线程池的并发调优"></a>Tomcat线程池的并发调优</h3><p>直接看表格参数即可</p>
<table>
<thead>
<tr>
<th>IO模型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>threadPriority</td>
<td>(int)线程优先级，默认是5</td>
</tr>
<tr>
<td>daemon</td>
<td>(boolean) 是否deamon线程，默认为true</td>
</tr>
<tr>
<td>namePrefix</td>
<td>(String) 线程前缀</td>
</tr>
<tr>
<td>maxThreads</td>
<td>(int) 线程池中的最大线程数，默认是200</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>(int) 最小线程数（线程空闲超过一段时间会被回收），默认是25</td>
</tr>
<tr>
<td>maxldleTime</td>
<td>(int) 线程最大的空闲时间，超过这个时间线程就会回收，直到线程数剩下minSpareThreads个，默认值是一分钟</td>
</tr>
<tr>
<td>maxQueueSize</td>
<td>(int) 线程池中任务队列的最大长度，默认是Integer.MAX_VALUE</td>
</tr>
<tr>
<td>prestartminSpareThreads</td>
<td>(boolean) 是否在线程池启动时就创建minSpareThreads 个线程，默认为false</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Servlet</tag>
        <tag>Catalina</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载过程</title>
    <url>/post/7410cfeb.html</url>
    <content><![CDATA[<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>整体分为7个阶段</p>
<span id="more"></span>
<p><img data-src="7410cfeb/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="类加载整体流程"><br>其中：加载、验证、准备、初始化四个过程确定的，必须按照这个步骤进行，而<strong>解析阶段不一定，有可能要到初始化之后才进行：Java为了支持运行时绑定特性（也称之为动态绑定或者晚期绑定）。</strong></p>
<h3 id="初始化阶段场景"><a href="#初始化阶段场景" class="headerlink" title="初始化阶段场景"></a>初始化阶段场景</h3><p>《Java虚拟机规范》严格约定了下面六种场景必须立即对类进行”初始化“：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有<ul>
<li>使用new关键字实例化对象的时候</li>
<li>读取或者设置一个类型的静态字段（被final修饰、已在编译期把结果放进常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有被初始化，则先要进行初始化</li>
<li>当初始化类的时候，如果发现其父类还没有被初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类</li>
<li>当使用JDK7新加入的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后解析为四个句柄（四个REF打头的，细节略）时，如果这个方法句柄没有被初始化，则要先进行初始化。</li>
<li>当一个接口定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）。</li>
</ol>
<h3 id="类加载的整个过程"><a href="#类加载的整个过程" class="headerlink" title="类加载的整个过程"></a>类加载的整个过程</h3><p>这里说的就是整个类加载的全过程，即：加载、验证、准备、解析和初始化这5个步骤。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段，虚拟机需要完成三个事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据</li>
<li>在内存中生成一个代表这个类<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。<br>类型数据妥善安置在方法区之后，<strong>会在Java堆内存中实例化一个<code>java.lang.Class</code>类的对象</strong>，这个对象将作为程序访问方法区中的类型数据的外部接口。<h4 id="验证（连接第一步）"><a href="#验证（连接第一步）" class="headerlink" title="验证（连接第一步）"></a>验证（连接第一步）</h4>这一阶段的目的时确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。<br>从历史沿袭来看：从JDK7版本之后，验证阶段在《Java虚拟机规范》中才得以充分完善，主要经历下面四个步骤：<h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5>说白了，这个过程是验证第一道门槛，即从读取文件字节流到存储在方法区的验证。如果这一步不过，后面就别谈了，只有这步验证通过，才允许存放在方法区，后续验证步骤直接读方法区内容。<br>可以了解的几种验证场景：</li>
</ol>
<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量的tag标志）</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
<li>……</li>
</ul>
<h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><p>对字节码描述的信息进行语义分析（<strong>注：从编译原理角度，更像是语法分析</strong>），可能包含如下：</p>
<ul>
<li>这个类是否有父类（除了Object类之外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或者接口中的要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不允许的方法重载）</li>
<li>……</li>
</ul>
<h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p><strong>最复杂的一个过程</strong>，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。<br>了解几个场景：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于”在操作栈放置了一个int类型数据，使用时则按long类型来加载本地变量表中“这样的情况</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换总是有效的。（UpCast与DownCast问题）</li>
</ul>
<p><strong>注：</strong>书中还提到了一个离散数学问题：停机问题（Halting Problem）<a href="https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98">维基百科介绍-停机问题</a>。<br>这个问题本质结论，即：不能通过程序准确的检查出程序是否能在有限的时间内结束运行。</p>
<h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><h4 id="准备（连接第二步）"><a href="#准备（连接第二步）" class="headerlink" title="准备（连接第二步）"></a>准备（连接第二步）</h4><h4 id="解析（连接第三步-可能）"><a href="#解析（连接第三步-可能）" class="headerlink" title="解析（连接第三步-可能）"></a>解析（连接第三步-可能）</h4><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4>]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>JVM类加载</tag>
        <tag>双亲委派模型</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM运行配置参数</title>
    <url>/post/b54134d3.html</url>
    <content><![CDATA[<p>参考《深入理解Java虚拟机  第三版》一书中关于启动参数的相关描述表格，并补充了相关日志打印描述参数</p>
<span id="more"></span>

<h3 id="JDK9前后日志参数打印比较"><a href="#JDK9前后日志参数打印比较" class="headerlink" title="JDK9前后日志参数打印比较"></a>JDK9前后日志参数打印比较</h3><h3 id="垃圾收集器相关的常用参数"><a href="#垃圾收集器相关的常用参数" class="headerlink" title="垃圾收集器相关的常用参数"></a>垃圾收集器相关的常用参数</h3><h3 id="JDK1-8-0-202版本全量默认启动参数一览"><a href="#JDK1-8-0-202版本全量默认启动参数一览" class="headerlink" title="JDK1.8.0_202版本全量默认启动参数一览"></a>JDK1.8.0_202版本全量默认启动参数一览</h3><p>这里笔者是在windows系统下预览的，linux可能会有些许不同。版本号：1.8.0_202。<br>读者可以通过在参数中增加：**-XX:+PrintFlagsFinal<strong>来预览你当前程序跑的全量JVM参数设置情况。</strong>竟然高达700多项**。<br>如有需要，可以参考一个网站，<a href="https://jvm-options.tech.xebia.fr/#">查询相关释义</a>（笔者有空更新中文版本），很多部分是非常细节的JVM底层设置了，平时工作中应该不会太遇到那些细节。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;D:\Program Files\Java\jdk1.8.0_202\bin\java.exe&quot; -XX:+PrintFlagsFinal &quot;-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2022.3.3\lib\idea_rt.jar=2293:D:\Program Files\JetBrains\IntelliJ IDEA 2022.3.3\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;D:\Program Files\Java\jdk1.8.0_202\jre\lib\charsets.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\deploy.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\access-bridge-64.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\cldrdata.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\dnsns.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jaccess.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jfxrt.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\localedata.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\nashorn.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunec.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunjce_provider.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunmscapi.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunpkcs11.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\zipfs.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\javaws.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\jce.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\jfr.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\jfxswt.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\jsse.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\management-agent.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\plugin.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\resources.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar;F:\Develop\ideaworkspace\CoreJavaSample\target\classes&quot; cc.nimbusk.HeapOOM</span><br><span class="line">[Global flags]</span><br><span class="line">     intx ActiveProcessorCount                      = -1                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps       = 20                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval          = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                  = 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeThroughPutPolicy              = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveTimeWeight                        = 25                                  &#123;product&#125;</span><br><span class="line">     bool AdjustConcurrency                         = false                               &#123;product&#125;</span><br><span class="line">     bool AggressiveHeap                            = false                               &#123;product&#125;</span><br><span class="line">     bool AggressiveOpts                            = false                               &#123;product&#125;</span><br><span class="line">     intx AliasLevel                                = 3                                   &#123;C2 product&#125;</span><br><span class="line">     bool AlignVector                               = false                               &#123;C2 product&#125;</span><br><span class="line">     intx AllocateInstancePrefetchLines             = 1                                   &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchDistance                  = 192                                 &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchInstr                     = 3                                   &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchLines                     = 4                                   &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchStepSize                  = 64                                  &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchStyle                     = 1                                   &#123;product&#125;</span><br><span class="line">     bool AllowJNIEnvProxy                          = false                               &#123;product&#125;</span><br><span class="line">     bool AllowNonVirtualCalls                      = false                               &#123;product&#125;</span><br><span class="line">     bool AllowParallelDefineClass                  = false                               &#123;product&#125;</span><br><span class="line">     bool AllowUserSignalHandlers                   = false                               &#123;product&#125;</span><br><span class="line">     bool AlwaysActAsServerClassMachine             = false                               &#123;product&#125;</span><br><span class="line">     bool AlwaysCompileLoopMethods                  = false                               &#123;product&#125;</span><br><span class="line">     bool AlwaysLockClassLoader                     = false                               &#123;product&#125;</span><br><span class="line">     bool AlwaysPreTouch                            = false                               &#123;product&#125;</span><br><span class="line">     bool AlwaysRestoreFPU                          = false                               &#123;product&#125;</span><br><span class="line">     bool AlwaysTenure                              = false                               &#123;product&#125;</span><br><span class="line">     bool AssertOnSuspendWaitFailure                = false                               &#123;product&#125;</span><br><span class="line">     bool AssumeMP                                  = false                               &#123;product&#125;</span><br><span class="line">     intx AutoBoxCacheMax                           = 128                                 &#123;C2 product&#125;</span><br><span class="line">    uintx AutoGCSelectPauseMillis                   = 5000                                &#123;product&#125;</span><br><span class="line">     intx BCEATraceLevel                            = 0                                   &#123;product&#125;</span><br><span class="line">     intx BackEdgeThreshold                         = 100000                              &#123;pd product&#125;</span><br><span class="line">     bool BackgroundCompilation                     = true                                &#123;pd product&#125;</span><br><span class="line">    uintx BaseFootPrintEstimate                     = 268435456                           &#123;product&#125;</span><br><span class="line">     intx BiasedLockingBulkRebiasThreshold          = 20                                  &#123;product&#125;</span><br><span class="line">     intx BiasedLockingBulkRevokeThreshold          = 40                                  &#123;product&#125;</span><br><span class="line">     intx BiasedLockingDecayTime                    = 25000                               &#123;product&#125;</span><br><span class="line">     intx BiasedLockingStartupDelay                 = 4000                                &#123;product&#125;</span><br><span class="line">     bool BindGCTaskThreadsToCPUs                   = false                               &#123;product&#125;</span><br><span class="line">     bool BlockLayoutByFrequency                    = true                                &#123;C2 product&#125;</span><br><span class="line">     intx BlockLayoutMinDiamondPercentage           = 20                                  &#123;C2 product&#125;</span><br><span class="line">     bool BlockLayoutRotateLoops                    = true                                &#123;C2 product&#125;</span><br><span class="line">     bool BranchOnRegister                          = false                               &#123;C2 product&#125;</span><br><span class="line">     bool BytecodeVerificationLocal                 = false                               &#123;product&#125;</span><br><span class="line">     bool BytecodeVerificationRemote                = true                                &#123;product&#125;</span><br><span class="line">     bool C1OptimizeVirtualCallProfiling            = true                                &#123;C1 product&#125;</span><br><span class="line">     bool C1ProfileBranches                         = true                                &#123;C1 product&#125;</span><br><span class="line">     bool C1ProfileCalls                            = true                                &#123;C1 product&#125;</span><br><span class="line">     bool C1ProfileCheckcasts                       = true                                &#123;C1 product&#125;</span><br><span class="line">     bool C1ProfileInlinedCalls                     = true                                &#123;C1 product&#125;</span><br><span class="line">     bool C1ProfileVirtualCalls                     = true                                &#123;C1 product&#125;</span><br><span class="line">     bool C1UpdateMethodData                        = true                                &#123;C1 product&#125;</span><br><span class="line">     intx CICompilerCount                          := 15                                  &#123;product&#125;</span><br><span class="line">     bool CICompilerCountPerCPU                     = true                                &#123;product&#125;</span><br><span class="line">     bool CITime                                    = false                               &#123;product&#125;</span><br><span class="line">     bool CMSAbortSemantics                         = false                               &#123;product&#125;</span><br><span class="line">    uintx CMSAbortablePrecleanMinWorkPerIteration   = 100                                 &#123;product&#125;</span><br><span class="line">     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;</span><br><span class="line">    uintx CMSBitMapYieldQuantum                     = 10485760                            &#123;product&#125;</span><br><span class="line">    uintx CMSBootstrapOccupancy                     = 50                                  &#123;product&#125;</span><br><span class="line">     bool CMSClassUnloadingEnabled                  = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSClassUnloadingMaxInterval              = 0                                   &#123;product&#125;</span><br><span class="line">     bool CMSCleanOnEnter                           = true                                &#123;product&#125;</span><br><span class="line">     bool CMSCompactWhenClearAllSoftRefs            = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSConcMarkMultiple                       = 32                                  &#123;product&#125;</span><br><span class="line">     bool CMSConcurrentMTEnabled                    = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSCoordinatorYieldSleepCount             = 10                                  &#123;product&#125;</span><br><span class="line">     bool CMSDumpAtPromotionFailure                 = false                               &#123;product&#125;</span><br><span class="line">     bool CMSEdenChunksRecordAlways                 = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSExpAvgFactor                           = 50                                  &#123;product&#125;</span><br><span class="line">     bool CMSExtrapolateSweep                       = false                               &#123;product&#125;</span><br><span class="line">    uintx CMSFullGCsBeforeCompaction                = 0                                   &#123;product&#125;</span><br><span class="line">    uintx CMSIncrementalDutyCycle                   = 10                                  &#123;product&#125;</span><br><span class="line">    uintx CMSIncrementalDutyCycleMin                = 0                                   &#123;product&#125;</span><br><span class="line">     bool CMSIncrementalMode                        = false                               &#123;product&#125;</span><br><span class="line">    uintx CMSIncrementalOffset                      = 0                                   &#123;product&#125;</span><br><span class="line">     bool CMSIncrementalPacing                      = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSIncrementalSafetyFactor                = 10                                  &#123;product&#125;</span><br><span class="line">    uintx CMSIndexedFreeListReplenish               = 4                                   &#123;product&#125;</span><br><span class="line">     intx CMSInitiatingOccupancyFraction            = -1                                  &#123;product&#125;</span><br><span class="line">    uintx CMSIsTooFullPercentage                    = 98                                  &#123;product&#125;</span><br><span class="line">   double CMSLargeCoalSurplusPercent                = 0.950000                            &#123;product&#125;</span><br><span class="line">   double CMSLargeSplitSurplusPercent               = 1.000000                            &#123;product&#125;</span><br><span class="line">     bool CMSLoopWarn                               = false                               &#123;product&#125;</span><br><span class="line">    uintx CMSMaxAbortablePrecleanLoops              = 0                                   &#123;product&#125;</span><br><span class="line">     intx CMSMaxAbortablePrecleanTime               = 5000                                &#123;product&#125;</span><br><span class="line">    uintx CMSOldPLABMax                             = 1024                                &#123;product&#125;</span><br><span class="line">    uintx CMSOldPLABMin                             = 16                                  &#123;product&#125;</span><br><span class="line">    uintx CMSOldPLABNumRefills                      = 4                                   &#123;product&#125;</span><br><span class="line">    uintx CMSOldPLABReactivityFactor                = 2                                   &#123;product&#125;</span><br><span class="line">     bool CMSOldPLABResizeQuicker                   = false                               &#123;product&#125;</span><br><span class="line">    uintx CMSOldPLABToleranceFactor                 = 4                                   &#123;product&#125;</span><br><span class="line">     bool CMSPLABRecordAlways                       = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSParPromoteBlocksToClaim                = 16                                  &#123;product&#125;</span><br><span class="line">     bool CMSParallelInitialMarkEnabled             = true                                &#123;product&#125;</span><br><span class="line">     bool CMSParallelRemarkEnabled                  = true                                &#123;product&#125;</span><br><span class="line">     bool CMSParallelSurvivorRemarkEnabled          = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSPrecleanDenominator                    = 3                                   &#123;product&#125;</span><br><span class="line">    uintx CMSPrecleanIter                           = 3                                   &#123;product&#125;</span><br><span class="line">    uintx CMSPrecleanNumerator                      = 2                                   &#123;product&#125;</span><br><span class="line">     bool CMSPrecleanRefLists1                      = true                                &#123;product&#125;</span><br><span class="line">     bool CMSPrecleanRefLists2                      = false                               &#123;product&#125;</span><br><span class="line">     bool CMSPrecleanSurvivors1                     = false                               &#123;product&#125;</span><br><span class="line">     bool CMSPrecleanSurvivors2                     = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSPrecleanThreshold                      = 1000                                &#123;product&#125;</span><br><span class="line">     bool CMSPrecleaningEnabled                     = true                                &#123;product&#125;</span><br><span class="line">     bool CMSPrintChunksInDump                      = false                               &#123;product&#125;</span><br><span class="line">     bool CMSPrintEdenSurvivorChunks                = false                               &#123;product&#125;</span><br><span class="line">     bool CMSPrintObjectsInDump                     = false                               &#123;product&#125;</span><br><span class="line">    uintx CMSRemarkVerifyVariant                    = 1                                   &#123;product&#125;</span><br><span class="line">     bool CMSReplenishIntermediate                  = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSRescanMultiple                         = 32                                  &#123;product&#125;</span><br><span class="line">    uintx CMSSamplingGrain                          = 16384                               &#123;product&#125;</span><br><span class="line">     bool CMSScavengeBeforeRemark                   = false                               &#123;product&#125;</span><br><span class="line">    uintx CMSScheduleRemarkEdenPenetration          = 50                                  &#123;product&#125;</span><br><span class="line">    uintx CMSScheduleRemarkEdenSizeThreshold        = 2097152                             &#123;product&#125;</span><br><span class="line">    uintx CMSScheduleRemarkSamplingRatio            = 5                                   &#123;product&#125;</span><br><span class="line">   double CMSSmallCoalSurplusPercent                = 1.050000                            &#123;product&#125;</span><br><span class="line">   double CMSSmallSplitSurplusPercent               = 1.100000                            &#123;product&#125;</span><br><span class="line">     bool CMSSplitIndexedFreeListBlocks             = true                                &#123;product&#125;</span><br><span class="line">     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;</span><br><span class="line">    uintx CMSTriggerRatio                           = 80                                  &#123;product&#125;</span><br><span class="line">     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;</span><br><span class="line">    uintx CMSWorkQueueDrainThreshold                = 10                                  &#123;product&#125;</span><br><span class="line">     bool CMSYield                                  = true                                &#123;product&#125;</span><br><span class="line">    uintx CMSYieldSleepCount                        = 0                                   &#123;product&#125;</span><br><span class="line">    uintx CMSYoungGenPerWorker                      = 67108864                            &#123;pd product&#125;</span><br><span class="line">    uintx CMS_FLSPadding                            = 1                                   &#123;product&#125;</span><br><span class="line">    uintx CMS_FLSWeight                             = 75                                  &#123;product&#125;</span><br><span class="line">    uintx CMS_SweepPadding                          = 1                                   &#123;product&#125;</span><br><span class="line">    uintx CMS_SweepTimerThresholdMillis             = 10                                  &#123;product&#125;</span><br><span class="line">    uintx CMS_SweepWeight                           = 75                                  &#123;product&#125;</span><br><span class="line">     bool CheckEndorsedAndExtDirs                   = false                               &#123;product&#125;</span><br><span class="line">     bool CheckJNICalls                             = false                               &#123;product&#125;</span><br><span class="line">     bool ClassUnloading                            = true                                &#123;product&#125;</span><br><span class="line">     bool ClassUnloadingWithConcurrentMark          = true                                &#123;product&#125;</span><br><span class="line">     intx ClearFPUAtPark                            = 0                                   &#123;product&#125;</span><br><span class="line">     bool ClipInlining                              = true                                &#123;product&#125;</span><br><span class="line">    uintx CodeCacheExpansionSize                    = 65536                               &#123;pd product&#125;</span><br><span class="line">    uintx CodeCacheMinimumFreeSpace                 = 512000                              &#123;product&#125;</span><br><span class="line">     bool CollectGen0First                          = false                               &#123;product&#125;</span><br><span class="line">     bool CompactFields                             = true                                &#123;product&#125;</span><br><span class="line">     intx CompilationPolicyChoice                   = 3                                   &#123;product&#125;</span><br><span class="line">ccstrlist CompileCommand                            =                                     &#123;product&#125;</span><br><span class="line">    ccstr CompileCommandFile                        =                                     &#123;product&#125;</span><br><span class="line">ccstrlist CompileOnly                               =                                     &#123;product&#125;</span><br><span class="line">     intx CompileThreshold                          = 10000                               &#123;pd product&#125;</span><br><span class="line">     bool CompilerThreadHintNoPreempt               = true                                &#123;product&#125;</span><br><span class="line">     intx CompilerThreadPriority                    = -1                                  &#123;product&#125;</span><br><span class="line">     intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class="line">    uintx CompressedClassSpaceSize                  = 1073741824                          &#123;product&#125;</span><br><span class="line">    uintx ConcGCThreads                             = 0                                   &#123;product&#125;</span><br><span class="line">     intx ConditionalMoveLimit                      = 3                                   &#123;C2 pd product&#125;</span><br><span class="line">     intx ContendedPaddingWidth                     = 128                                 &#123;product&#125;</span><br><span class="line">     bool ConvertSleepToYield                       = true                                &#123;pd product&#125;</span><br><span class="line">     bool ConvertYieldToSleep                       = false                               &#123;product&#125;</span><br><span class="line">     bool CrashOnOutOfMemoryError                   = false                               &#123;product&#125;</span><br><span class="line">     bool CreateMinidumpOnCrash                     = false                               &#123;product&#125;</span><br><span class="line">     bool CriticalJNINatives                        = true                                &#123;product&#125;</span><br><span class="line">     bool DTraceAllocProbes                         = false                               &#123;product&#125;</span><br><span class="line">     bool DTraceMethodProbes                        = false                               &#123;product&#125;</span><br><span class="line">     bool DTraceMonitorProbes                       = false                               &#123;product&#125;</span><br><span class="line">     bool Debugging                                 = false                               &#123;product&#125;</span><br><span class="line">    uintx DefaultMaxRAMFraction                     = 4                                   &#123;product&#125;</span><br><span class="line">     intx DefaultThreadPriority                     = -1                                  &#123;product&#125;</span><br><span class="line">     intx DeferPollingPageLoopCount                 = -1                                  &#123;product&#125;</span><br><span class="line">     intx DeferThrSuspendLoopCount                  = 4000                                &#123;product&#125;</span><br><span class="line">     bool DeoptimizeRandom                          = false                               &#123;product&#125;</span><br><span class="line">     bool DisableAttachMechanism                    = false                               &#123;product&#125;</span><br><span class="line">     bool DisableExplicitGC                         = false                               &#123;product&#125;</span><br><span class="line">     bool DisplayVMOutputToStderr                   = false                               &#123;product&#125;</span><br><span class="line">     bool DisplayVMOutputToStdout                   = false                               &#123;product&#125;</span><br><span class="line">     bool DoEscapeAnalysis                          = true                                &#123;C2 product&#125;</span><br><span class="line">     bool DontCompileHugeMethods                    = true                                &#123;product&#125;</span><br><span class="line">     bool DontYieldALot                             = false                               &#123;pd product&#125;</span><br><span class="line">    ccstr DumpLoadedClassList                       =                                     &#123;product&#125;</span><br><span class="line">     bool DumpReplayDataOnError                     = true                                &#123;product&#125;</span><br><span class="line">     bool DumpSharedSpaces                          = false                               &#123;product&#125;</span><br><span class="line">     bool EagerXrunInit                             = false                               &#123;product&#125;</span><br><span class="line">     intx EliminateAllocationArraySizeLimit         = 64                                  &#123;C2 product&#125;</span><br><span class="line">     bool EliminateAllocations                      = true                                &#123;C2 product&#125;</span><br><span class="line">     bool EliminateAutoBox                          = true                                &#123;C2 product&#125;</span><br><span class="line">     bool EliminateLocks                            = true                                &#123;C2 product&#125;</span><br><span class="line">     bool EliminateNestedLocks                      = true                                &#123;C2 product&#125;</span><br><span class="line">     intx EmitSync                                  = 0                                   &#123;product&#125;</span><br><span class="line">     bool EnableContended                           = true                                &#123;product&#125;</span><br><span class="line">     bool EnableResourceManagementTLABCache         = true                                &#123;product&#125;</span><br><span class="line">     bool EnableSharedLookupCache                   = true                                &#123;product&#125;</span><br><span class="line">     bool EnableTracing                             = false                               &#123;product&#125;</span><br><span class="line">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;</span><br><span class="line">    ccstr ErrorFile                                 =                                     &#123;product&#125;</span><br><span class="line">    ccstr ErrorReportServer                         =                                     &#123;product&#125;</span><br><span class="line">   double EscapeAnalysisTimeout                     = 20.000000                           &#123;C2 product&#125;</span><br><span class="line">     bool EstimateArgEscape                         = true                                &#123;product&#125;</span><br><span class="line">     bool ExitOnOutOfMemoryError                    = false                               &#123;product&#125;</span><br><span class="line">     bool ExplicitGCInvokesConcurrent               = false                               &#123;product&#125;</span><br><span class="line">     bool ExplicitGCInvokesConcurrentAndUnloadsClasses  = false                               &#123;product&#125;</span><br><span class="line">     bool ExtendedDTraceProbes                      = false                               &#123;product&#125;</span><br><span class="line">    ccstr ExtraSharedClassListFile                  =                                     &#123;product&#125;</span><br><span class="line">     bool FLSAlwaysCoalesceLarge                    = false                               &#123;product&#125;</span><br><span class="line">    uintx FLSCoalescePolicy                         = 2                                   &#123;product&#125;</span><br><span class="line">   double FLSLargestBlockCoalesceProximity          = 0.990000                            &#123;product&#125;</span><br><span class="line">     bool FailOverToOldVerifier                     = true                                &#123;product&#125;</span><br><span class="line">     bool FastTLABRefill                            = true                                &#123;product&#125;</span><br><span class="line">     intx FenceInstruction                          = 0                                   &#123;ARCH product&#125;</span><br><span class="line">     intx FieldsAllocationStyle                     = 1                                   &#123;product&#125;</span><br><span class="line">     bool FilterSpuriousWakeups                     = true                                &#123;product&#125;</span><br><span class="line">    ccstr FlightRecorderOptions                     =                                     &#123;product&#125;</span><br><span class="line">     bool ForceNUMA                                 = false                               &#123;product&#125;</span><br><span class="line">     bool ForceTimeHighResolution                   = false                               &#123;product&#125;</span><br><span class="line">     intx FreqInlineSize                            = 325                                 &#123;pd product&#125;</span><br><span class="line">   double G1ConcMarkStepDurationMillis              = 10.000000                           &#123;product&#125;</span><br><span class="line">    uintx G1ConcRSHotCardLimit                      = 4                                   &#123;product&#125;</span><br><span class="line">    uintx G1ConcRSLogCacheSize                      = 10                                  &#123;product&#125;</span><br><span class="line">     intx G1ConcRefinementGreenZone                 = 0                                   &#123;product&#125;</span><br><span class="line">     intx G1ConcRefinementRedZone                   = 0                                   &#123;product&#125;</span><br><span class="line">     intx G1ConcRefinementServiceIntervalMillis     = 300                                 &#123;product&#125;</span><br><span class="line">    uintx G1ConcRefinementThreads                   = 0                                   &#123;product&#125;</span><br><span class="line">     intx G1ConcRefinementThresholdStep             = 0                                   &#123;product&#125;</span><br><span class="line">     intx G1ConcRefinementYellowZone                = 0                                   &#123;product&#125;</span><br><span class="line">    uintx G1ConfidencePercent                       = 50                                  &#123;product&#125;</span><br><span class="line">    uintx G1HeapRegionSize                          = 0                                   &#123;product&#125;</span><br><span class="line">    uintx G1HeapWastePercent                        = 5                                   &#123;product&#125;</span><br><span class="line">    uintx G1MixedGCCountTarget                      = 8                                   &#123;product&#125;</span><br><span class="line">     intx G1RSetRegionEntries                       = 0                                   &#123;product&#125;</span><br><span class="line">    uintx G1RSetScanBlockSize                       = 64                                  &#123;product&#125;</span><br><span class="line">     intx G1RSetSparseRegionEntries                 = 0                                   &#123;product&#125;</span><br><span class="line">     intx G1RSetUpdatingPauseTimePercent            = 10                                  &#123;product&#125;</span><br><span class="line">     intx G1RefProcDrainInterval                    = 10                                  &#123;product&#125;</span><br><span class="line">    uintx G1ReservePercent                          = 10                                  &#123;product&#125;</span><br><span class="line">    uintx G1SATBBufferEnqueueingThresholdPercent    = 60                                  &#123;product&#125;</span><br><span class="line">     intx G1SATBBufferSize                          = 1024                                &#123;product&#125;</span><br><span class="line">     intx G1UpdateBufferSize                        = 256                                 &#123;product&#125;</span><br><span class="line">     bool G1UseAdaptiveConcRefinement               = true                                &#123;product&#125;</span><br><span class="line">    uintx GCDrainStackTargetSize                    = 64                                  &#123;product&#125;</span><br><span class="line">    uintx GCHeapFreeLimit                           = 2                                   &#123;product&#125;</span><br><span class="line">    uintx GCLockerEdenExpansionPercent              = 5                                   &#123;product&#125;</span><br><span class="line">     bool GCLockerInvokesConcurrent                 = false                               &#123;product&#125;</span><br><span class="line">    uintx GCLogFileSize                             = 8192                                &#123;product&#125;</span><br><span class="line">    uintx GCPauseIntervalMillis                     = 0                                   &#123;product&#125;</span><br><span class="line">    uintx GCTaskTimeStampEntries                    = 200                                 &#123;product&#125;</span><br><span class="line">    uintx GCTimeLimit                               = 98                                  &#123;product&#125;</span><br><span class="line">    uintx GCTimeRatio                               = 99                                  &#123;product&#125;</span><br><span class="line">    uintx HeapBaseMinAddress                        = 2147483648                          &#123;pd product&#125;</span><br><span class="line">     bool HeapDumpAfterFullGC                       = false                               &#123;manageable&#125;</span><br><span class="line">     bool HeapDumpBeforeFullGC                      = false                               &#123;manageable&#125;</span><br><span class="line">     bool HeapDumpOnOutOfMemoryError                = false                               &#123;manageable&#125;</span><br><span class="line">    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;</span><br><span class="line">    uintx HeapFirstMaximumCompactionCount           = 3                                   &#123;product&#125;</span><br><span class="line">    uintx HeapMaximumCompactionInterval             = 20                                  &#123;product&#125;</span><br><span class="line">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;</span><br><span class="line">     bool IgnoreEmptyClassPaths                     = false                               &#123;product&#125;</span><br><span class="line">     bool IgnoreUnrecognizedVMOptions               = false                               &#123;product&#125;</span><br><span class="line">    uintx IncreaseFirstTierCompileThresholdAt       = 50                                  &#123;product&#125;</span><br><span class="line">     bool IncrementalInline                         = true                                &#123;C2 product&#125;</span><br><span class="line">    uintx InitialBootClassLoaderMetaspaceSize       = 4194304                             &#123;product&#125;</span><br><span class="line">    uintx InitialCodeCacheSize                      = 2555904                             &#123;pd product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := 1069547520                          &#123;product&#125;</span><br><span class="line">    uintx InitialRAMFraction                        = 64                                  &#123;product&#125;</span><br><span class="line">   double InitialRAMPercentage                      = 1.562500                            &#123;product&#125;</span><br><span class="line">    uintx InitialSurvivorRatio                      = 8                                   &#123;product&#125;</span><br><span class="line">    uintx InitialTenuringThreshold                  = 7                                   &#123;product&#125;</span><br><span class="line">    uintx InitiatingHeapOccupancyPercent            = 45                                  &#123;product&#125;</span><br><span class="line">     bool Inline                                    = true                                &#123;product&#125;</span><br><span class="line">    ccstr InlineDataFile                            =                                     &#123;product&#125;</span><br><span class="line">     intx InlineSmallCode                           = 2000                                &#123;pd product&#125;</span><br><span class="line">     bool InlineSynchronizedMethods                 = true                                &#123;C1 product&#125;</span><br><span class="line">     bool InsertMemBarAfterArraycopy                = true                                &#123;C2 product&#125;</span><br><span class="line">     intx InteriorEntryAlignment                    = 16                                  &#123;C2 pd product&#125;</span><br><span class="line">     intx InterpreterProfilePercentage              = 33                                  &#123;product&#125;</span><br><span class="line">     bool JNIDetachReleasesMonitors                 = true                                &#123;product&#125;</span><br><span class="line">     bool JavaMonitorsInStackTrace                  = true                                &#123;product&#125;</span><br><span class="line">     intx JavaPriority10_To_OSPriority              = -1                                  &#123;product&#125;</span><br><span class="line">     intx JavaPriority1_To_OSPriority               = -1                                  &#123;product&#125;</span><br><span class="line">     intx JavaPriority2_To_OSPriority               = -1                                  &#123;product&#125;</span><br><span class="line">     intx JavaPriority3_To_OSPriority               = -1                                  &#123;product&#125;</span><br><span class="line">     intx JavaPriority4_To_OSPriority               = -1                                  &#123;product&#125;</span><br><span class="line">     intx JavaPriority5_To_OSPriority               = -1                                  &#123;product&#125;</span><br><span class="line">     intx JavaPriority6_To_OSPriority               = -1                                  &#123;product&#125;</span><br><span class="line">     intx JavaPriority7_To_OSPriority               = -1                                  &#123;product&#125;</span><br><span class="line">     intx JavaPriority8_To_OSPriority               = -1                                  &#123;product&#125;</span><br><span class="line">     intx JavaPriority9_To_OSPriority               = -1                                  &#123;product&#125;</span><br><span class="line">     bool LIRFillDelaySlots                         = false                               &#123;C1 pd product&#125;</span><br><span class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;</span><br><span class="line">    uintx LargePageSizeInBytes                      = 0                                   &#123;product&#125;</span><br><span class="line">     bool LazyBootClassLoader                       = true                                &#123;product&#125;</span><br><span class="line">     intx LiveNodeCountInliningCutoff               = 40000                               &#123;C2 product&#125;</span><br><span class="line">     bool LogCommercialFeatures                     = false                               &#123;product&#125;</span><br><span class="line">     intx LoopMaxUnroll                             = 16                                  &#123;C2 product&#125;</span><br><span class="line">     intx LoopOptsCount                             = 43                                  &#123;C2 product&#125;</span><br><span class="line">     intx LoopUnrollLimit                           = 60                                  &#123;C2 pd product&#125;</span><br><span class="line">     intx LoopUnrollMin                             = 4                                   &#123;C2 product&#125;</span><br><span class="line">     bool LoopUnswitching                           = true                                &#123;C2 product&#125;</span><br><span class="line">     bool ManagementServer                          = false                               &#123;product&#125;</span><br><span class="line">    uintx MarkStackSize                             = 4194304                             &#123;product&#125;</span><br><span class="line">    uintx MarkStackSizeMax                          = 536870912                           &#123;product&#125;</span><br><span class="line">    uintx MarkSweepAlwaysCompactCount               = 4                                   &#123;product&#125;</span><br><span class="line">    uintx MarkSweepDeadRatio                        = 1                                   &#123;product&#125;</span><br><span class="line">     intx MaxBCEAEstimateLevel                      = 5                                   &#123;product&#125;</span><br><span class="line">     intx MaxBCEAEstimateSize                       = 150                                 &#123;product&#125;</span><br><span class="line">    uintx MaxDirectMemorySize                       = 0                                   &#123;product&#125;</span><br><span class="line">     bool MaxFDLimit                                = true                                &#123;product&#125;</span><br><span class="line">    uintx MaxGCMinorPauseMillis                     = 4294967295                          &#123;product&#125;</span><br><span class="line">    uintx MaxGCPauseMillis                          = 4294967295                          &#123;product&#125;</span><br><span class="line">    uintx MaxHeapFreeRatio                          = 100                                 &#123;manageable&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 4227858432                          &#123;product&#125;</span><br><span class="line">     intx MaxInlineLevel                            = 9                                   &#123;product&#125;</span><br><span class="line">     intx MaxInlineSize                             = 35                                  &#123;product&#125;</span><br><span class="line">     intx MaxJNILocalCapacity                       = 65536                               &#123;product&#125;</span><br><span class="line">     intx MaxJavaStackTraceDepth                    = 1024                                &#123;product&#125;</span><br><span class="line">     intx MaxJumpTableSize                          = 65000                               &#123;C2 product&#125;</span><br><span class="line">     intx MaxJumpTableSparseness                    = 5                                   &#123;C2 product&#125;</span><br><span class="line">     intx MaxLabelRootDepth                         = 1100                                &#123;C2 product&#125;</span><br><span class="line">     intx MaxLoopPad                                = 11                                  &#123;C2 product&#125;</span><br><span class="line">    uintx MaxMetaspaceExpansion                     = 5451776                             &#123;product&#125;</span><br><span class="line">    uintx MaxMetaspaceFreeRatio                     = 70                                  &#123;product&#125;</span><br><span class="line">    uintx MaxMetaspaceSize                          = 4294901760                          &#123;product&#125;</span><br><span class="line">    uintx MaxNewSize                               := 1409286144                          &#123;product&#125;</span><br><span class="line">     intx MaxNodeLimit                              = 75000                               &#123;C2 product&#125;</span><br><span class="line"> uint64_t MaxRAM                                    = 0                                   &#123;pd product&#125;</span><br><span class="line">    uintx MaxRAMFraction                            = 4                                   &#123;product&#125;</span><br><span class="line">   double MaxRAMPercentage                          = 25.000000                           &#123;product&#125;</span><br><span class="line">     intx MaxRecursiveInlineLevel                   = 1                                   &#123;product&#125;</span><br><span class="line">    uintx MaxTenuringThreshold                      = 15                                  &#123;product&#125;</span><br><span class="line">     intx MaxTrivialSize                            = 6                                   &#123;product&#125;</span><br><span class="line">     intx MaxVectorSize                             = 32                                  &#123;C2 product&#125;</span><br><span class="line">    uintx MetaspaceSize                             = 21807104                            &#123;pd product&#125;</span><br><span class="line">     bool MethodFlushing                            = true                                &#123;product&#125;</span><br><span class="line">    uintx MinHeapDeltaBytes                        := 524288                              &#123;product&#125;</span><br><span class="line">    uintx MinHeapFreeRatio                          = 0                                   &#123;manageable&#125;</span><br><span class="line">     intx MinInliningThreshold                      = 250                                 &#123;product&#125;</span><br><span class="line">     intx MinJumpTableSize                          = 10                                  &#123;C2 pd product&#125;</span><br><span class="line">    uintx MinMetaspaceExpansion                     = 339968                              &#123;product&#125;</span><br><span class="line">    uintx MinMetaspaceFreeRatio                     = 40                                  &#123;product&#125;</span><br><span class="line">    uintx MinRAMFraction                            = 2                                   &#123;product&#125;</span><br><span class="line">   double MinRAMPercentage                          = 50.000000                           &#123;product&#125;</span><br><span class="line">    uintx MinSurvivorRatio                          = 3                                   &#123;product&#125;</span><br><span class="line">    uintx MinTLABSize                               = 2048                                &#123;product&#125;</span><br><span class="line">     intx MonitorBound                              = 0                                   &#123;product&#125;</span><br><span class="line">     bool MonitorInUseLists                         = false                               &#123;product&#125;</span><br><span class="line">     intx MultiArrayExpandLimit                     = 6                                   &#123;C2 product&#125;</span><br><span class="line">     bool MustCallLoadClassInternal                 = false                               &#123;product&#125;</span><br><span class="line">    uintx NUMAChunkResizeWeight                     = 20                                  &#123;product&#125;</span><br><span class="line">    uintx NUMAInterleaveGranularity                 = 2097152                             &#123;product&#125;</span><br><span class="line">    uintx NUMAPageScanRate                          = 256                                 &#123;product&#125;</span><br><span class="line">    uintx NUMASpaceResizeRate                       = 1073741824                          &#123;product&#125;</span><br><span class="line">     bool NUMAStats                                 = false                               &#123;product&#125;</span><br><span class="line">    ccstr NativeMemoryTracking                      = off                                 &#123;product&#125;</span><br><span class="line">     bool NeedsDeoptSuspend                         = false                               &#123;pd product&#125;</span><br><span class="line">     bool NeverActAsServerClassMachine              = false                               &#123;pd product&#125;</span><br><span class="line">     bool NeverTenure                               = false                               &#123;product&#125;</span><br><span class="line">    uintx NewRatio                                  = 2                                   &#123;product&#125;</span><br><span class="line">    uintx NewSize                                  := 356515840                           &#123;product&#125;</span><br><span class="line">    uintx NewSizeThreadIncrease                     = 5320                                &#123;pd product&#125;</span><br><span class="line">     intx NmethodSweepActivity                      = 10                                  &#123;product&#125;</span><br><span class="line">     intx NmethodSweepCheckInterval                 = 5                                   &#123;product&#125;</span><br><span class="line">     intx NmethodSweepFraction                      = 16                                  &#123;product&#125;</span><br><span class="line">     intx NodeLimitFudgeFactor                      = 2000                                &#123;C2 product&#125;</span><br><span class="line">    uintx NumberOfGCLogFiles                        = 0                                   &#123;product&#125;</span><br><span class="line">     intx NumberOfLoopInstrToAlign                  = 4                                   &#123;C2 product&#125;</span><br><span class="line">     intx ObjectAlignmentInBytes                    = 8                                   &#123;lp64_product&#125;</span><br><span class="line">    uintx OldPLABSize                               = 1024                                &#123;product&#125;</span><br><span class="line">    uintx OldPLABWeight                             = 50                                  &#123;product&#125;</span><br><span class="line">    uintx OldSize                                  := 713031680                           &#123;product&#125;</span><br><span class="line">     bool OmitStackTraceInFastThrow                 = true                                &#123;product&#125;</span><br><span class="line">ccstrlist OnError                                   =                                     &#123;product&#125;</span><br><span class="line">ccstrlist OnOutOfMemoryError                        =                                     &#123;product&#125;</span><br><span class="line">     intx OnStackReplacePercentage                  = 140                                 &#123;pd product&#125;</span><br><span class="line">     bool OptimizeFill                              = true                                &#123;C2 product&#125;</span><br><span class="line">     bool OptimizePtrCompare                        = true                                &#123;C2 product&#125;</span><br><span class="line">     bool OptimizeStringConcat                      = true                                &#123;C2 product&#125;</span><br><span class="line">     bool OptoBundling                              = false                               &#123;C2 pd product&#125;</span><br><span class="line">     intx OptoLoopAlignment                         = 16                                  &#123;pd product&#125;</span><br><span class="line">     bool OptoScheduling                            = false                               &#123;C2 pd product&#125;</span><br><span class="line">    uintx PLABWeight                                = 75                                  &#123;product&#125;</span><br><span class="line">     bool PSChunkLargeArrays                        = true                                &#123;product&#125;</span><br><span class="line">     intx ParGCArrayScanChunk                       = 50                                  &#123;product&#125;</span><br><span class="line">    uintx ParGCDesiredObjsFromOverflowList          = 20                                  &#123;product&#125;</span><br><span class="line">     bool ParGCTrimOverflow                         = true                                &#123;product&#125;</span><br><span class="line">     bool ParGCUseLocalOverflow                     = false                               &#123;product&#125;</span><br><span class="line">    uintx ParallelGCBufferWastePct                  = 10                                  &#123;product&#125;</span><br><span class="line">    uintx ParallelGCThreads                         = 23                                  &#123;product&#125;</span><br><span class="line">     bool ParallelGCVerbose                         = false                               &#123;product&#125;</span><br><span class="line">    uintx ParallelOldDeadWoodLimiterMean            = 50                                  &#123;product&#125;</span><br><span class="line">    uintx ParallelOldDeadWoodLimiterStdDev          = 80                                  &#123;product&#125;</span><br><span class="line">     bool ParallelRefProcBalancingEnabled           = true                                &#123;product&#125;</span><br><span class="line">     bool ParallelRefProcEnabled                    = false                               &#123;product&#125;</span><br><span class="line">     bool PartialPeelAtUnsignedTests                = true                                &#123;C2 product&#125;</span><br><span class="line">     bool PartialPeelLoop                           = true                                &#123;C2 product&#125;</span><br><span class="line">     intx PartialPeelNewPhiDelta                    = 0                                   &#123;C2 product&#125;</span><br><span class="line">    uintx PausePadding                              = 1                                   &#123;product&#125;</span><br><span class="line">     intx PerBytecodeRecompilationCutoff            = 200                                 &#123;product&#125;</span><br><span class="line">     intx PerBytecodeTrapLimit                      = 4                                   &#123;product&#125;</span><br><span class="line">     intx PerMethodRecompilationCutoff              = 400                                 &#123;product&#125;</span><br><span class="line">     intx PerMethodTrapLimit                        = 100                                 &#123;product&#125;</span><br><span class="line">     bool PerfAllowAtExitRegistration               = false                               &#123;product&#125;</span><br><span class="line">     bool PerfBypassFileSystemCheck                 = false                               &#123;product&#125;</span><br><span class="line">     intx PerfDataMemorySize                        = 32768                               &#123;product&#125;</span><br><span class="line">     intx PerfDataSamplingInterval                  = 50                                  &#123;product&#125;</span><br><span class="line">    ccstr PerfDataSaveFile                          =                                     &#123;product&#125;</span><br><span class="line">     bool PerfDataSaveToFile                        = false                               &#123;product&#125;</span><br><span class="line">     bool PerfDisableSharedMem                      = false                               &#123;product&#125;</span><br><span class="line">     intx PerfMaxStringConstLength                  = 1024                                &#123;product&#125;</span><br><span class="line">     intx PreInflateSpin                            = 10                                  &#123;pd product&#125;</span><br><span class="line">     bool PreferInterpreterNativeStubs              = false                               &#123;pd product&#125;</span><br><span class="line">     intx PrefetchCopyIntervalInBytes               = 576                                 &#123;product&#125;</span><br><span class="line">     intx PrefetchFieldsAhead                       = 1                                   &#123;product&#125;</span><br><span class="line">     intx PrefetchScanIntervalInBytes               = 576                                 &#123;product&#125;</span><br><span class="line">     bool PreserveAllAnnotations                    = false                               &#123;product&#125;</span><br><span class="line">     bool PreserveFramePointer                      = false                               &#123;pd product&#125;</span><br><span class="line">    uintx PretenureSizeThreshold                    = 0                                   &#123;product&#125;</span><br><span class="line">     bool PrintAdaptiveSizePolicy                   = false                               &#123;product&#125;</span><br><span class="line">     bool PrintCMSInitiationStatistics              = false                               &#123;product&#125;</span><br><span class="line">     intx PrintCMSStatistics                        = 0                                   &#123;product&#125;</span><br><span class="line">     bool PrintClassHistogram                       = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintClassHistogramAfterFullGC            = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintClassHistogramBeforeFullGC           = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintCodeCache                            = false                               &#123;product&#125;</span><br><span class="line">     bool PrintCodeCacheOnCompilation               = false                               &#123;product&#125;</span><br><span class="line">     bool PrintCommandLineFlags                     = false                               &#123;product&#125;</span><br><span class="line">     bool PrintCompilation                          = false                               &#123;product&#125;</span><br><span class="line">     bool PrintConcurrentLocks                      = false                               &#123;manageable&#125;</span><br><span class="line">     intx PrintFLSCensus                            = 0                                   &#123;product&#125;</span><br><span class="line">     intx PrintFLSStatistics                        = 0                                   &#123;product&#125;</span><br><span class="line">     bool PrintFlagsFinal                          := true                                &#123;product&#125;</span><br><span class="line">     bool PrintFlagsInitial                         = false                               &#123;product&#125;</span><br><span class="line">     bool PrintGC                                   = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintGCApplicationConcurrentTime          = false                               &#123;product&#125;</span><br><span class="line">     bool PrintGCApplicationStoppedTime             = false                               &#123;product&#125;</span><br><span class="line">     bool PrintGCCause                              = true                                &#123;product&#125;</span><br><span class="line">     bool PrintGCDateStamps                         = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintGCDetails                            = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintGCID                                 = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintGCTaskTimeStamps                     = false                               &#123;product&#125;</span><br><span class="line">     bool PrintGCTimeStamps                         = false                               &#123;manageable&#125;</span><br><span class="line">     bool PrintHeapAtGC                             = false                               &#123;product rw&#125;</span><br><span class="line">     bool PrintHeapAtGCExtended                     = false                               &#123;product rw&#125;</span><br><span class="line">     bool PrintHeapAtSIGBREAK                       = true                                &#123;product&#125;</span><br><span class="line">     bool PrintJNIGCStalls                          = false                               &#123;product&#125;</span><br><span class="line">     bool PrintJNIResolving                         = false                               &#123;product&#125;</span><br><span class="line">     bool PrintOldPLAB                              = false                               &#123;product&#125;</span><br><span class="line">     bool PrintOopAddress                           = false                               &#123;product&#125;</span><br><span class="line">     bool PrintPLAB                                 = false                               &#123;product&#125;</span><br><span class="line">     bool PrintParallelOldGCPhaseTimes              = false                               &#123;product&#125;</span><br><span class="line">     bool PrintPromotionFailure                     = false                               &#123;product&#125;</span><br><span class="line">     bool PrintReferenceGC                          = false                               &#123;product&#125;</span><br><span class="line">     bool PrintSafepointStatistics                  = false                               &#123;product&#125;</span><br><span class="line">     intx PrintSafepointStatisticsCount             = 300                                 &#123;product&#125;</span><br><span class="line">     intx PrintSafepointStatisticsTimeout           = -1                                  &#123;product&#125;</span><br><span class="line">     bool PrintSharedArchiveAndExit                 = false                               &#123;product&#125;</span><br><span class="line">     bool PrintSharedDictionary                     = false                               &#123;product&#125;</span><br><span class="line">     bool PrintSharedSpaces                         = false                               &#123;product&#125;</span><br><span class="line">     bool PrintStringDeduplicationStatistics        = false                               &#123;product&#125;</span><br><span class="line">     bool PrintStringTableStatistics                = false                               &#123;product&#125;</span><br><span class="line">     bool PrintTLAB                                 = false                               &#123;product&#125;</span><br><span class="line">     bool PrintTenuringDistribution                 = false                               &#123;product&#125;</span><br><span class="line">     bool PrintTieredEvents                         = false                               &#123;product&#125;</span><br><span class="line">     bool PrintVMOptions                            = false                               &#123;product&#125;</span><br><span class="line">     bool PrintVMQWaitTime                          = false                               &#123;product&#125;</span><br><span class="line">     bool PrintWarnings                             = true                                &#123;product&#125;</span><br><span class="line">    uintx ProcessDistributionStride                 = 4                                   &#123;product&#125;</span><br><span class="line">     bool ProfileInterpreter                        = true                                &#123;pd product&#125;</span><br><span class="line">     bool ProfileIntervals                          = false                               &#123;product&#125;</span><br><span class="line">     intx ProfileIntervalsTicks                     = 100                                 &#123;product&#125;</span><br><span class="line">     intx ProfileMaturityPercentage                 = 20                                  &#123;product&#125;</span><br><span class="line">     bool ProfileVM                                 = false                               &#123;product&#125;</span><br><span class="line">     bool ProfilerPrintByteCodeStatistics           = false                               &#123;product&#125;</span><br><span class="line">     bool ProfilerRecordPC                          = false                               &#123;product&#125;</span><br><span class="line">    uintx PromotedPadding                           = 3                                   &#123;product&#125;</span><br><span class="line">    uintx QueuedAllocationWarningCount              = 0                                   &#123;product&#125;</span><br><span class="line">    uintx RTMRetryCount                             = 5                                   &#123;ARCH product&#125;</span><br><span class="line">     bool RangeCheckElimination                     = true                                &#123;product&#125;</span><br><span class="line">     intx ReadPrefetchInstr                         = 0                                   &#123;ARCH product&#125;</span><br><span class="line">     bool ReassociateInvariants                     = true                                &#123;C2 product&#125;</span><br><span class="line">     bool ReduceBulkZeroing                         = true                                &#123;C2 product&#125;</span><br><span class="line">     bool ReduceFieldZeroing                        = true                                &#123;C2 product&#125;</span><br><span class="line">     bool ReduceInitialCardMarks                    = true                                &#123;C2 product&#125;</span><br><span class="line">     bool ReduceSignalUsage                         = false                               &#123;product&#125;</span><br><span class="line">     intx RefDiscoveryPolicy                        = 0                                   &#123;product&#125;</span><br><span class="line">     bool ReflectionWrapResolutionErrors            = true                                &#123;product&#125;</span><br><span class="line">     bool RegisterFinalizersAtInit                  = true                                &#123;product&#125;</span><br><span class="line">     bool RelaxAccessControlCheck                   = false                               &#123;product&#125;</span><br><span class="line">    ccstr ReplayDataFile                            =                                     &#123;product&#125;</span><br><span class="line">     bool RequireSharedSpaces                       = false                               &#123;product&#125;</span><br><span class="line">    uintx ReservedCodeCacheSize                     = 251658240                           &#123;pd product&#125;</span><br><span class="line">     bool ResizeOldPLAB                             = true                                &#123;product&#125;</span><br><span class="line">     bool ResizePLAB                                = true                                &#123;product&#125;</span><br><span class="line">     bool ResizeTLAB                                = true                                &#123;pd product&#125;</span><br><span class="line">     bool RestoreMXCSROnJNICalls                    = false                               &#123;product&#125;</span><br><span class="line">     bool RestrictContended                         = true                                &#123;product&#125;</span><br><span class="line">     bool RewriteBytecodes                          = true                                &#123;pd product&#125;</span><br><span class="line">     bool RewriteFrequentPairs                      = true                                &#123;pd product&#125;</span><br><span class="line">     intx SafepointPollOffset                       = 256                                 &#123;C1 pd product&#125;</span><br><span class="line">     intx SafepointSpinBeforeYield                  = 2000                                &#123;product&#125;</span><br><span class="line">     bool SafepointTimeout                          = false                               &#123;product&#125;</span><br><span class="line">     intx SafepointTimeoutDelay                     = 10000                               &#123;product&#125;</span><br><span class="line">     bool ScavengeBeforeFullGC                      = true                                &#123;product&#125;</span><br><span class="line">     intx SelfDestructTimer                         = 0                                   &#123;product&#125;</span><br><span class="line">    uintx SharedBaseAddress                         = 0                                   &#123;product&#125;</span><br><span class="line">    ccstr SharedClassListFile                       =                                     &#123;product&#125;</span><br><span class="line">    uintx SharedMiscCodeSize                        = 122880                              &#123;product&#125;</span><br><span class="line">    uintx SharedMiscDataSize                        = 4194304                             &#123;product&#125;</span><br><span class="line">    uintx SharedReadOnlySize                        = 16777216                            &#123;product&#125;</span><br><span class="line">    uintx SharedReadWriteSize                       = 16777216                            &#123;product&#125;</span><br><span class="line">     bool ShowMessageBoxOnError                     = false                               &#123;product&#125;</span><br><span class="line">     intx SoftRefLRUPolicyMSPerMB                   = 1000                                &#123;product&#125;</span><br><span class="line">     bool SpecialEncodeISOArray                     = true                                &#123;C2 product&#125;</span><br><span class="line">     bool SplitIfBlocks                             = true                                &#123;C2 product&#125;</span><br><span class="line">     intx StackRedPages                             = 1                                   &#123;pd product&#125;</span><br><span class="line">     intx StackShadowPages                          = 6                                   &#123;pd product&#125;</span><br><span class="line">     bool StackTraceInThrowable                     = true                                &#123;product&#125;</span><br><span class="line">     intx StackYellowPages                          = 3                                   &#123;pd product&#125;</span><br><span class="line">     bool StartAttachListener                       = false                               &#123;product&#125;</span><br><span class="line">     intx StarvationMonitorInterval                 = 200                                 &#123;product&#125;</span><br><span class="line">     bool StressLdcRewrite                          = false                               &#123;product&#125;</span><br><span class="line">    uintx StringDeduplicationAgeThreshold           = 3                                   &#123;product&#125;</span><br><span class="line">    uintx StringTableSize                           = 60013                               &#123;product&#125;</span><br><span class="line">     bool SuppressFatalErrorMessage                 = false                               &#123;product&#125;</span><br><span class="line">    uintx SurvivorPadding                           = 3                                   &#123;product&#125;</span><br><span class="line">    uintx SurvivorRatio                             = 8                                   &#123;product&#125;</span><br><span class="line">     intx SuspendRetryCount                         = 50                                  &#123;product&#125;</span><br><span class="line">     intx SuspendRetryDelay                         = 5                                   &#123;product&#125;</span><br><span class="line">     intx SyncFlags                                 = 0                                   &#123;product&#125;</span><br><span class="line">    ccstr SyncKnobs                                 =                                     &#123;product&#125;</span><br><span class="line">     intx SyncVerbose                               = 0                                   &#123;product&#125;</span><br><span class="line">    uintx TLABAllocationWeight                      = 35                                  &#123;product&#125;</span><br><span class="line">    uintx TLABRefillWasteFraction                   = 64                                  &#123;product&#125;</span><br><span class="line">    uintx TLABSize                                  = 0                                   &#123;product&#125;</span><br><span class="line">     bool TLABStats                                 = true                                &#123;product&#125;</span><br><span class="line">    uintx TLABWasteIncrement                        = 4                                   &#123;product&#125;</span><br><span class="line">    uintx TLABWasteTargetPercent                    = 1                                   &#123;product&#125;</span><br><span class="line">    uintx TargetPLABWastePct                        = 10                                  &#123;product&#125;</span><br><span class="line">    uintx TargetSurvivorRatio                       = 50                                  &#123;product&#125;</span><br><span class="line">    uintx TenuredGenerationSizeIncrement            = 20                                  &#123;product&#125;</span><br><span class="line">    uintx TenuredGenerationSizeSupplement           = 80                                  &#123;product&#125;</span><br><span class="line">    uintx TenuredGenerationSizeSupplementDecay      = 2                                   &#123;product&#125;</span><br><span class="line">     intx ThreadPriorityPolicy                      = 0                                   &#123;product&#125;</span><br><span class="line">     bool ThreadPriorityVerbose                     = false                               &#123;product&#125;</span><br><span class="line">    uintx ThreadSafetyMargin                        = 52428800                            &#123;product&#125;</span><br><span class="line">     intx ThreadStackSize                           = 0                                   &#123;pd product&#125;</span><br><span class="line">    uintx ThresholdTolerance                        = 10                                  &#123;product&#125;</span><br><span class="line">     intx Tier0BackedgeNotifyFreqLog                = 10                                  &#123;product&#125;</span><br><span class="line">     intx Tier0InvokeNotifyFreqLog                  = 7                                   &#123;product&#125;</span><br><span class="line">     intx Tier0ProfilingStartPercentage             = 200                                 &#123;product&#125;</span><br><span class="line">     intx Tier23InlineeNotifyFreqLog                = 20                                  &#123;product&#125;</span><br><span class="line">     intx Tier2BackEdgeThreshold                    = 0                                   &#123;product&#125;</span><br><span class="line">     intx Tier2BackedgeNotifyFreqLog                = 14                                  &#123;product&#125;</span><br><span class="line">     intx Tier2CompileThreshold                     = 0                                   &#123;product&#125;</span><br><span class="line">     intx Tier2InvokeNotifyFreqLog                  = 11                                  &#123;product&#125;</span><br><span class="line">     intx Tier3BackEdgeThreshold                    = 60000                               &#123;product&#125;</span><br><span class="line">     intx Tier3BackedgeNotifyFreqLog                = 13                                  &#123;product&#125;</span><br><span class="line">     intx Tier3CompileThreshold                     = 2000                                &#123;product&#125;</span><br><span class="line">     intx Tier3DelayOff                             = 2                                   &#123;product&#125;</span><br><span class="line">     intx Tier3DelayOn                              = 5                                   &#123;product&#125;</span><br><span class="line">     intx Tier3InvocationThreshold                  = 200                                 &#123;product&#125;</span><br><span class="line">     intx Tier3InvokeNotifyFreqLog                  = 10                                  &#123;product&#125;</span><br><span class="line">     intx Tier3LoadFeedback                         = 5                                   &#123;product&#125;</span><br><span class="line">     intx Tier3MinInvocationThreshold               = 100                                 &#123;product&#125;</span><br><span class="line">     intx Tier4BackEdgeThreshold                    = 40000                               &#123;product&#125;</span><br><span class="line">     intx Tier4CompileThreshold                     = 15000                               &#123;product&#125;</span><br><span class="line">     intx Tier4InvocationThreshold                  = 5000                                &#123;product&#125;</span><br><span class="line">     intx Tier4LoadFeedback                         = 3                                   &#123;product&#125;</span><br><span class="line">     intx Tier4MinInvocationThreshold               = 600                                 &#123;product&#125;</span><br><span class="line">     bool TieredCompilation                         = true                                &#123;pd product&#125;</span><br><span class="line">     intx TieredCompileTaskTimeout                  = 50                                  &#123;product&#125;</span><br><span class="line">     intx TieredRateUpdateMaxTime                   = 25                                  &#123;product&#125;</span><br><span class="line">     intx TieredRateUpdateMinTime                   = 1                                   &#123;product&#125;</span><br><span class="line">     intx TieredStopAtLevel                         = 4                                   &#123;product&#125;</span><br><span class="line">     bool TimeLinearScan                            = false                               &#123;C1 product&#125;</span><br><span class="line">     bool TraceBiasedLocking                        = false                               &#123;product&#125;</span><br><span class="line">     bool TraceClassLoading                         = false                               &#123;product rw&#125;</span><br><span class="line">     bool TraceClassLoadingPreorder                 = false                               &#123;product&#125;</span><br><span class="line">     bool TraceClassPaths                           = false                               &#123;product&#125;</span><br><span class="line">     bool TraceClassResolution                      = false                               &#123;product&#125;</span><br><span class="line">     bool TraceClassUnloading                       = false                               &#123;product rw&#125;</span><br><span class="line">     bool TraceDynamicGCThreads                     = false                               &#123;product&#125;</span><br><span class="line">     bool TraceGen0Time                             = false                               &#123;product&#125;</span><br><span class="line">     bool TraceGen1Time                             = false                               &#123;product&#125;</span><br><span class="line">    ccstr TraceJVMTI                                =                                     &#123;product&#125;</span><br><span class="line">     bool TraceLoaderConstraints                    = false                               &#123;product rw&#125;</span><br><span class="line">     bool TraceMetadataHumongousAllocation          = false                               &#123;product&#125;</span><br><span class="line">     bool TraceMonitorInflation                     = false                               &#123;product&#125;</span><br><span class="line">     bool TraceParallelOldGCTasks                   = false                               &#123;product&#125;</span><br><span class="line">     intx TraceRedefineClasses                      = 0                                   &#123;product&#125;</span><br><span class="line">     bool TraceSafepointCleanupTime                 = false                               &#123;product&#125;</span><br><span class="line">     bool TraceSharedLookupCache                    = false                               &#123;product&#125;</span><br><span class="line">     bool TraceSuspendWaitFailures                  = false                               &#123;product&#125;</span><br><span class="line">     intx TrackedInitializationLimit                = 50                                  &#123;C2 product&#125;</span><br><span class="line">     bool TransmitErrorReport                       = false                               &#123;product&#125;</span><br><span class="line">     bool TrapBasedNullChecks                       = false                               &#123;pd product&#125;</span><br><span class="line">     bool TrapBasedRangeChecks                      = false                               &#123;C2 pd product&#125;</span><br><span class="line">     intx TypeProfileArgsLimit                      = 2                                   &#123;product&#125;</span><br><span class="line">    uintx TypeProfileLevel                          = 111                                 &#123;pd product&#125;</span><br><span class="line">     intx TypeProfileMajorReceiverPercent           = 90                                  &#123;C2 product&#125;</span><br><span class="line">     intx TypeProfileParmsLimit                     = 2                                   &#123;product&#125;</span><br><span class="line">     intx TypeProfileWidth                          = 2                                   &#123;product&#125;</span><br><span class="line">     intx UnguardOnExecutionViolation               = 0                                   &#123;product&#125;</span><br><span class="line">     bool UnlinkSymbolsALot                         = false                               &#123;product&#125;</span><br><span class="line">     bool Use486InstrsOnly                          = false                               &#123;ARCH product&#125;</span><br><span class="line">     bool UseAES                                    = true                                &#123;product&#125;</span><br><span class="line">     bool UseAESIntrinsics                          = true                                &#123;product&#125;</span><br><span class="line">     intx UseAVX                                    = 2                                   &#123;ARCH product&#125;</span><br><span class="line">     bool UseAdaptiveGCBoundary                     = false                               &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveGenerationSizePolicyAtMajorCollection  = true                                &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveGenerationSizePolicyAtMinorCollection  = true                                &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveNUMAChunkSizing                = true                                &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizeDecayMajorGCCost           = true                                &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizePolicy                     = true                                &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizePolicyFootprintGoal        = true                                &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizePolicyWithSystemGC         = false                               &#123;product&#125;</span><br><span class="line">     bool UseAddressNop                             = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseAltSigs                                = false                               &#123;product&#125;</span><br><span class="line">     bool UseAutoGCSelectPolicy                     = false                               &#123;product&#125;</span><br><span class="line">     bool UseBMI1Instructions                       = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseBMI2Instructions                       = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseBiasedLocking                          = true                                &#123;product&#125;</span><br><span class="line">     bool UseBimorphicInlining                      = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseBoundThreads                           = true                                &#123;product&#125;</span><br><span class="line">     bool UseCLMUL                                  = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseCMSBestFit                             = true                                &#123;product&#125;</span><br><span class="line">     bool UseCMSCollectionPassing                   = true                                &#123;product&#125;</span><br><span class="line">     bool UseCMSCompactAtFullCollection             = true                                &#123;product&#125;</span><br><span class="line">     bool UseCMSInitiatingOccupancyOnly             = false                               &#123;product&#125;</span><br><span class="line">     bool UseCRC32Intrinsics                        = true                                &#123;product&#125;</span><br><span class="line">     bool UseCodeCacheFlushing                      = true                                &#123;product&#125;</span><br><span class="line">     bool UseCompiler                               = true                                &#123;product&#125;</span><br><span class="line">     bool UseCompilerSafepoints                     = true                                &#123;product&#125;</span><br><span class="line">     bool UseCompressedClassPointers               := true                                &#123;lp64_product&#125;</span><br><span class="line">     bool UseCompressedOops                        := true                                &#123;lp64_product&#125;</span><br><span class="line">     bool UseConcMarkSweepGC                        = false                               &#123;product&#125;</span><br><span class="line">     bool UseCondCardMark                           = false                               &#123;C2 product&#125;</span><br><span class="line">     bool UseCountLeadingZerosInstruction           = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseCountTrailingZerosInstruction          = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseCountedLoopSafepoints                  = false                               &#123;C2 product&#125;</span><br><span class="line">     bool UseCounterDecay                           = true                                &#123;product&#125;</span><br><span class="line">     bool UseDivMod                                 = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseDynamicNumberOfGCThreads               = false                               &#123;product&#125;</span><br><span class="line">     bool UseFPUForSpilling                         = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseFastAccessorMethods                    = false                               &#123;product&#125;</span><br><span class="line">     bool UseFastEmptyMethods                       = false                               &#123;product&#125;</span><br><span class="line">     bool UseFastJNIAccessors                       = true                                &#123;product&#125;</span><br><span class="line">     bool UseFastStosb                              = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseG1GC                                   = false                               &#123;product&#125;</span><br><span class="line">     bool UseGCLogFileRotation                      = false                               &#123;product&#125;</span><br><span class="line">     bool UseGCOverheadLimit                        = true                                &#123;product&#125;</span><br><span class="line">     bool UseGCTaskAffinity                         = false                               &#123;product&#125;</span><br><span class="line">     bool UseHeavyMonitors                          = false                               &#123;product&#125;</span><br><span class="line">     bool UseInlineCaches                           = true                                &#123;product&#125;</span><br><span class="line">     bool UseInterpreter                            = true                                &#123;product&#125;</span><br><span class="line">     bool UseJumpTables                             = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseLWPSynchronization                     = true                                &#123;product&#125;</span><br><span class="line">     bool UseLargePages                             = false                               &#123;pd product&#125;</span><br><span class="line">     bool UseLargePagesInMetaspace                  = false                               &#123;product&#125;</span><br><span class="line">     bool UseLargePagesIndividualAllocation        := false                               &#123;pd product&#125;</span><br><span class="line">     bool UseLockedTracing                          = false                               &#123;product&#125;</span><br><span class="line">     bool UseLoopCounter                            = true                                &#123;product&#125;</span><br><span class="line">     bool UseLoopInvariantCodeMotion                = true                                &#123;C1 product&#125;</span><br><span class="line">     bool UseLoopPredicate                          = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseMathExactIntrinsics                    = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseMaximumCompactionOnSystemGC            = true                                &#123;product&#125;</span><br><span class="line">     bool UseMembar                                 = false                               &#123;pd product&#125;</span><br><span class="line">     bool UseMontgomeryMultiplyIntrinsic            = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseMontgomerySquareIntrinsic              = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseMulAddIntrinsic                        = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseMultiplyToLenIntrinsic                 = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseNUMA                                   = false                               &#123;product&#125;</span><br><span class="line">     bool UseNUMAInterleaving                       = false                               &#123;product&#125;</span><br><span class="line">     bool UseNewLongLShift                          = false                               &#123;ARCH product&#125;</span><br><span class="line">     bool UseOSErrorReporting                       = false                               &#123;pd product&#125;</span><br><span class="line">     bool UseOldInlining                            = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseOnStackReplacement                     = true                                &#123;pd product&#125;</span><br><span class="line">     bool UseOnlyInlinedBimorphic                   = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseOptoBiasInlining                       = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UsePSAdaptiveSurvivorSizePolicy           = true                                &#123;product&#125;</span><br><span class="line">     bool UseParNewGC                               = false                               &#123;product&#125;</span><br><span class="line">     bool UseParallelGC                            := true                                &#123;product&#125;</span><br><span class="line">     bool UseParallelOldGC                          = true                                &#123;product&#125;</span><br><span class="line">     bool UsePerfData                               = true                                &#123;product&#125;</span><br><span class="line">     bool UsePopCountInstruction                    = true                                &#123;product&#125;</span><br><span class="line">     bool UseRDPCForConstantTableBase               = false                               &#123;C2 product&#125;</span><br><span class="line">     bool UseRTMDeopt                               = false                               &#123;ARCH product&#125;</span><br><span class="line">     bool UseRTMLocking                             = false                               &#123;ARCH product&#125;</span><br><span class="line">     bool UseSHA                                    = false                               &#123;product&#125;</span><br><span class="line">     bool UseSHA1Intrinsics                         = false                               &#123;product&#125;</span><br><span class="line">     bool UseSHA256Intrinsics                       = false                               &#123;product&#125;</span><br><span class="line">     bool UseSHA512Intrinsics                       = false                               &#123;product&#125;</span><br><span class="line">     intx UseSSE                                    = 4                                   &#123;product&#125;</span><br><span class="line">     bool UseSSE42Intrinsics                        = true                                &#123;product&#125;</span><br><span class="line">     bool UseSerialGC                               = false                               &#123;product&#125;</span><br><span class="line">     bool UseSharedSpaces                           = false                               &#123;product&#125;</span><br><span class="line">     bool UseSignalChaining                         = true                                &#123;product&#125;</span><br><span class="line">     bool UseSquareToLenIntrinsic                   = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseStoreImmI16                            = false                               &#123;ARCH product&#125;</span><br><span class="line">     bool UseStringDeduplication                    = false                               &#123;product&#125;</span><br><span class="line">     bool UseSuperWord                              = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseTLAB                                   = true                                &#123;pd product&#125;</span><br><span class="line">     bool UseThreadPriorities                       = true                                &#123;pd product&#125;</span><br><span class="line">     bool UseTypeProfile                            = true                                &#123;product&#125;</span><br><span class="line">     bool UseTypeSpeculation                        = true                                &#123;C2 product&#125;</span><br><span class="line">     bool UseUTCFileTimestamp                       = true                                &#123;product&#125;</span><br><span class="line">     bool UseUnalignedLoadStores                    = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseVMInterruptibleIO                      = false                               &#123;product&#125;</span><br><span class="line">     bool UseXMMForArrayCopy                        = true                                &#123;product&#125;</span><br><span class="line">     bool UseXmmI2D                                 = false                               &#123;ARCH product&#125;</span><br><span class="line">     bool UseXmmI2F                                 = false                               &#123;ARCH product&#125;</span><br><span class="line">     bool UseXmmLoadAndClearUpper                   = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseXmmRegToRegMoveAll                     = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool VMThreadHintNoPreempt                     = false                               &#123;product&#125;</span><br><span class="line">     intx VMThreadPriority                          = -1                                  &#123;product&#125;</span><br><span class="line">     intx VMThreadStackSize                         = 0                                   &#123;pd product&#125;</span><br><span class="line">     intx ValueMapInitialSize                       = 11                                  &#123;C1 product&#125;</span><br><span class="line">     intx ValueMapMaxLoopSize                       = 8                                   &#123;C1 product&#125;</span><br><span class="line">     intx ValueSearchLimit                          = 1000                                &#123;C2 product&#125;</span><br><span class="line">     bool VerifyMergedCPBytecodes                   = true                                &#123;product&#125;</span><br><span class="line">     bool VerifySharedSpaces                        = false                               &#123;product&#125;</span><br><span class="line">     intx WorkAroundNPTLTimedWaitHang               = 1                                   &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeIncrement              = 20                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplement             = 80                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplementDecay        = 8                                   &#123;product&#125;</span><br><span class="line">    uintx YoungPLABSize                             = 4096                                &#123;product&#125;</span><br><span class="line">     bool ZeroTLAB                                  = false                               &#123;product&#125;</span><br><span class="line">     intx hashCode                                  = 5                                   &#123;product&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>JVM参数</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾收集器</title>
    <url>/post/e4c87989.html</url>
    <content><![CDATA[<h2 id="相关的算法"><a href="#相关的算法" class="headerlink" title="相关的算法"></a>相关的算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以<strong>根据各个年代的特点选择合适的垃圾收集算法</strong>。<br>比如在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
<span id="more"></span>

<h3 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h3><p><img data-src="e4c87989/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="标记复制算法"></p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个问题：</p>
<ol>
<li>效率问题（如果标记的对象太多，效率不高）</li>
<li>空间问题（标记清楚后会产生大量的不连续的碎片）<br><img data-src="e4c87989/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记-清除算法"><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，<strong>但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动</strong>，然后直接清理掉端边界以外的内存。<br><img data-src="e4c87989/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-整理算法"></li>
</ol>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>目前常见的几种<br><img data-src="e4c87989/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="常见的几种垃圾收集器"><br>没有完美的垃圾收集器，只能做的是，我们根据不同场景实现去选择不同的垃圾收集器场景。</p>
<h3 id="Serial收集器（-XX-UseSerialGC-XX-UseSerialOldGC）"><a href="#Serial收集器（-XX-UseSerialGC-XX-UseSerialOldGC）" class="headerlink" title="Serial收集器（-XX:+UseSerialGC -XX:+UseSerialOldGC）"></a>Serial收集器（-XX:+UseSerialGC -XX:+UseSerialOldGC）</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img data-src="e4c87989/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器"></p>
<h3 id="Parallel-Scavenge收集器（-XX-UseParallelGC-XX-UseParallelOldGC）"><a href="#Parallel-Scavenge收集器（-XX-UseParallelGC-XX-UseParallelOldGC）" class="headerlink" title="Parallel Scavenge收集器（-XX:+UseParallelGC -XX:+UseParallelOldGC）"></a>Parallel Scavenge收集器（-XX:+UseParallelGC -XX:+UseParallelOldGC）</h3><p><img data-src="e4c87989/ParallelScavenge%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParallelScavenge收集器"><br><strong>jdk1.8默认的新生代/老年代的两个收集器</strong></p>
<h3 id="ParNew收集器（-XX-UseParNewGC）"><a href="#ParNew收集器（-XX-UseParNewGC）" class="headerlink" title="ParNew收集器（-XX:UseParNewGC）"></a>ParNew收集器（-XX:UseParNewGC）</h3><p>ParNew收集器其实跟Parallel收集器很类似，区别主要在于它<strong>可以和CMS收集器配合使用。</strong><br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img data-src="e4c87989/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器"></p>
<h3 id="CMS收集器（-XX-UseConcMarkSweepGC）"><a href="#CMS收集器（-XX-UseConcMarkSweepGC）" class="headerlink" title="CMS收集器（+XX:+UseConcMarkSweepGC）"></a>CMS收集器（+XX:+UseConcMarkSweepGC）</h3><p>主要使用在老年代，与ParNew配合在新生代收集使用。<br>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间为目标的收集器</strong>。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面<br>几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ol>
<li><strong>初始标记</strong>：暂停所有的其他线程(STW)，并记录下gc roots<strong>直接能引用的对象</strong>，<strong>速度很快</strong>。</li>
<li><strong>并发标记</strong>：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是<strong>不需要停顿</strong>用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li>
<li><strong>重新标记</strong>：重新标记阶段就是为了<strong>修正并发标记期间</strong>因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到<strong>三色标记</strong>里的增量更新算法做重新标记。</li>
<li><strong>并发清理</strong>：开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理。</li>
<li><strong>并发重置</strong>：重置本次GC过程中的标记数据。<br><img data-src="e4c87989/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"><br>主要优点：并发收集、低停顿<br>几个明显的缺点：</li>
</ol>
<ul>
<li>对CPU资源敏感（和服务抢资源）</li>
<li>无法处理<strong>浮动垃圾</strong>（在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了）</li>
<li>使用的回收算法：标记-清除算法会导致收集结束之后产生大量的空间碎片，可以通过参数：-XX:+UseCMSCompactAtFullCollection可以让JVM在执行完标记清除之后再做整理。</li>
<li>执行过程中的不确定性，会存在上一次垃圾回收还没有执行完，然后垃圾收集又被触发的情况，特别是在并发标记和并发清理阶段会出现。一边回收，一边系统运行，也许没有回收完就再次触发fullgc，也就是“concurrent mode failure”，此时会进入STW，用serial old垃圾收集器来回收。</li>
</ul>
<h4 id="跟CMS相关的核心参数"><a href="#跟CMS相关的核心参数" class="headerlink" title="跟CMS相关的核心参数"></a>跟CMS相关的核心参数</h4><p>这里配合另一篇文章对照看[[启动参数相关]]，特别是JDK9之前和之后的区别，要了解。</p>
<ol>
<li><strong>-XX:+UseConcMarkSweepGC</strong>：启用cms</li>
<li><strong>-XX:ConcGCThreads</strong>：配置并发的GC线程数，有个默认计算公式，根据CPU处理器个数：```<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(处理器核心数量+3)/4</span><br></pre></td></tr></table></figure></li>
<li><strong>-XX:+UseCMSCompactAtFullCollection</strong>：FullGC之后做压缩整理（减少碎片），【JDK 8默认开启，JDK 9开始废弃该参数】</li>
<li><strong>-XX:CMSFullGCsBeforeCompaction</strong>：针对上一个参数的优化，上个参数是解决了碎片问题，但是停顿时间变长了。要求CMS收集器在执行若干次（由参数值决定）不整理空间的FullGC之后，下次进入Full GC之前会先进行碎片整理（默认值为0，代表每次进入Full GC时都会进行碎片整理）【JDK 9之后开始废弃】</li>
<li><strong>-XX:CMSInitiatingOccupancyFraction</strong>: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</li>
<li><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong>：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设<br>定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</li>
<li><strong>-XX:+CMSScavengeBeforeRemark</strong>：在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引<br>用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段</li>
<li><strong>-XX:+CMSParallellnitialMarkEnabled</strong>：表示在初始标记的时候多线程执行，缩短STW</li>
<li><strong>-XX:+CMSParallelRemarkEnabled</strong>：在重新标记的时候多线程执行（默认开启），缩短STW;</li>
</ol>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存模型概要</title>
    <url>/post/6377921b.html</url>
    <content><![CDATA[<p>JVM 从软件层屏蔽不同操作系统在底层硬件与指令的区别</p>
<span id="more"></span>

<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p><strong>注</strong>：这个课程中的一个图，看看即可，里面有很多箭头，不结合视频课程看，是根本不知道怎么回事的。【待补充完善】<br><img data-src="6377921b/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="内存模型示意图"><br>注：这个课程里面，用了一个很简单的死循环示例，结合jvisualm可视化分析工具，观察堆对象分配进行，这个就会很方便的直观的看到各个对象在堆中分配的过程。</p>
<p>STW：暂停用户线程，使GC效率变高 </p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>通过该指示器，来完成诸如：分支、循环、跳转、异常处理、线程恢复等基础功能</strong>。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个<strong>栈帧（stack frame）</strong> 用于存储：<strong>局部变量表、操作数栈、动态链接、方法出口等信息</strong>。<br>每个方法调用直至执行完毕的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈（FIFO）的过程</p>
<p><strong>涉及的异常</strong>：StackOverflow、OutOfMemoryError（HotSpot虚拟机中不存在，旧的Classic虚拟机存在，所以了解即可）</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p><strong>存放数据类型</strong>：存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型（reference类型，引用指针）和returnAddress类型（一条字节码指令地址）<br><strong>数据类型存放标准</strong>：这些数据类型，在局部变量表中的存储空间已局部变量槽（Slot）来表示，其中64位长度的long和double会占用两个变量槽，其余的数据类型只占用一个。<br><strong>内存分配过程</strong>：局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈作用类似，只不过这里存放的是虚拟机使用的本地（Native）方法服务</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此<strong>内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存</strong>。（<em>书中提到的</em>：由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段，这些已经导致了一些微妙的变化，导致Java对象实例都分配在堆上已经不是绝对的了）<br>无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储都只能是对象的实例，<strong>将Java堆细分的目的</strong>：<strong>只是为了更好的回收内存，或者更快地分配内存。</strong><br><strong>涉及异常：OutOfMemoryError</strong></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>用于存储已经被虚拟机加载的：类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong><br><strong>历史沿袭：</strong> JDK7之前，这部分区域还被称之为永久代，在JDK7的时候已经把字符串常量池和静态变量移出。到了JDK8，完全废弃了永久代概念，改用元空间（Metasapce）来实现。<br><strong>涉及异常</strong>：OutOfMemoryError</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池表（Constant Pool Table），用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《java虚拟机规范》中定义的内存区域，但是这部分内存也频繁被使用，而且也有可能导致OutOfMemoryError异常。<br><strong>注：这部分跟NIO直接相关</strong><br>在JDK1.4中引入的NIO（New Input/Ouput）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用来进行操作。这样能在一部分场景中显出提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<h2 id="对象创建流程"><a href="#对象创建流程" class="headerlink" title="对象创建流程"></a>对象创建流程</h2><p>整体流程<br><img data-src="6377921b/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="对象创建整体流程"></p>
<p>大体上可以分为5个步骤：</p>
<ol>
<li>类加载检查：</li>
<li>分配内存</li>
<li>初始化</li>
<li>设置对象头</li>
<li>执行init方法<h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。（<strong>注：这个过程比较复杂</strong>）<br>参考另外一篇文章：<a href="https://nimbik.cc/post/7410cfeb">虚拟机加载机制</a><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。<h5 id="划分内存的方法"><a href="#划分内存的方法" class="headerlink" title="划分内存的方法"></a>划分内存的方法</h5></li>
</ol>
<ul>
<li>“指针碰撞”（Bump the Pointer）(默认用指针碰撞)：如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li>
<li>“空闲列表”（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。<h5 id="解决内存分配并发问题的方法"><a href="#解决内存分配并发问题的方法" class="headerlink" title="解决内存分配并发问题的方法"></a>解决内存分配并发问题的方法</h5></li>
<li>CAS（compare and swap）：虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</li>
<li>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过XX:+/UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启XX:+UseTLAB)，XX:TLABSize 指定TLAB大小。</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。<br>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：<strong>对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。</strong><br><img data-src="6377921b/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E6%95%B4%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="对象头整体示意图"></p>
<p>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br><strong>数组对象与普通对象的内存结构区别在于，数组对象头里面多了一个数组长度</strong><br><img data-src="6377921b/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="数组类型对象头"><br>32位对象头示意图：<br><img data-src="6377921b/32%E4%BD%8D%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="32位对象头示意图"><br>64位对象头示意图：<br><img data-src="6377921b/64%E4%BD%8D%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="64位对象头示意图"></p>
<h4 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h4><p>执行init方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</p>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>JVM内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>达芬奇软件学习记录</title>
    <url>/post/45b9669f.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>记录学习达芬奇软件的相关。不外乎，B站相关UP的教程视频、达芬奇官方视频教程、相关官方图文教程等。<br>记录在该地方，用于后续快速查找。</p>
<span id="more"></span>

<h3 id="媒体面板"><a href="#媒体面板" class="headerlink" title="媒体面板"></a>媒体面板</h3><p>关于智能资源媒体夹的使用，通过增加对元数据的筛选条件，进而进行对素材的管理。入A Roll和B Roll等。</p>
<h3 id="剪辑面板"><a href="#剪辑面板" class="headerlink" title="剪辑面板"></a>剪辑面板</h3><h4 id="插入时间线之前"><a href="#插入时间线之前" class="headerlink" title="插入时间线之前"></a>插入时间线之前</h4><p>关于插入时间线之前，大概率需要浏览素材，进而需要进行标记出入点（<strong>快捷键：I、O</strong>），然后再对相应的素材进行插入时间线。</p>
<h4 id="快速浏览素材（JKL）"><a href="#快速浏览素材（JKL）" class="headerlink" title="快速浏览素材（JKL）"></a>快速浏览素材（JKL）</h4><p>通过在监视器窗口，来快速按<strong>J、K、L</strong>三键，来实现前后播放，暂停的操作，已实现快速浏览素材。<br>组合键：K、J/L，可以实现逐帧正/倒放。</p>
<h4 id="JCut"><a href="#JCut" class="headerlink" title="JCut"></a>JCut</h4><p>通过禁用声音音轨，再对相对应的视频片段进行覆盖操作即可。</p>
<h4 id="快速粗剪"><a href="#快速粗剪" class="headerlink" title="快速粗剪"></a>快速粗剪</h4><p>在媒体面板里，快速浏览素材的同时，可以通过出入点标记之后，选择需要的片段，多个片段直接Ctrl选中之后，直接拖到时间线。</p>
<h4 id="修剪模式（快捷键：T）"><a href="#修剪模式（快捷键：T）" class="headerlink" title="修剪模式（快捷键：T）"></a>修剪模式（快捷键：T）</h4><p>在该模式下面，当修剪视频片段的同时，后面的片段会跟进上来。</p>
<h3 id="调色面板"><a href="#调色面板" class="headerlink" title="调色面板"></a>调色面板</h3><p>检视器窗口：按鼠标中键可以拖拽屏幕，Shift+Z撤销还原。<br>在左侧的画廊，可以添加静帧集，在监视器中对素材右键，添加静帧之后，可以在监视器实时观察调色前后的差异</p>
<h4 id="示波器面板"><a href="#示波器面板" class="headerlink" title="示波器面板"></a>示波器面板</h4><p>在调色前，处理画面光线的时候观察使用，即观察高光和暗部是否需要调整，让画面的高光和暗部尽量接近纯色（纯黑或纯白）</p>
<h5 id="分量示波器"><a href="#分量示波器" class="headerlink" title="分量示波器"></a>分量示波器</h5><p>直观的看红绿蓝三种颜色的亮度情况</p>
<h4 id="节点的属性复制"><a href="#节点的属性复制" class="headerlink" title="节点的属性复制"></a>节点的属性复制</h4><p>通过对某个片段进行静帧片段截取，然后在左上角的画廊中查看静帧，并右键显示节点图之后，就可以看到之前的节点设置信息，之后再对别的节点进行覆盖就可以达到具体节点属性的赋值的动作。<br><img data-src="45b9669f/%E9%9D%99%E5%B8%A7%E8%8A%82%E7%82%B9%E5%A4%8D%E5%88%B6.png" alt="静帧节点复制"></p>
<h4 id="限定器"><a href="#限定器" class="headerlink" title="限定器"></a>限定器</h4><p>通常，如果需要对局部物体颜色进行调整时，就需要通过限定器进行选中，然后对某一类物体色彩进行调整。<br>PS：实际上就是一种通过吸管工具来进行物体定向色彩来创建蒙版的一种工具<br><img data-src="45b9669f/%E9%99%90%E5%AE%9A%E5%99%A8%E9%9D%A2%E6%9D%BF.png" alt="限定器面板"><br>这个面板中，注意右侧的蒙版优化，这里是可以通过对蒙版的噪点进行修复的。</p>
<h4 id="跟踪器"><a href="#跟踪器" class="headerlink" title="跟踪器"></a>跟踪器</h4><p>通过在跟踪器面板的，片段和帧模式下切换，在帧模式下可以控制跟踪器节点，以调整因为复杂场景下跟踪器跟踪失效的问题。</p>
<h3 id="色温和色调"><a href="#色温和色调" class="headerlink" title="色温和色调"></a>色温和色调</h3><p>共同影响了画面的白平衡，处理了两组互补色，即：色温处理的是：<strong>蓝黄</strong>；色调处理的是：<strong>绿品</strong></p>
<h4 id="影片的色彩衔接问题"><a href="#影片的色彩衔接问题" class="headerlink" title="影片的色彩衔接问题"></a>影片的色彩衔接问题</h4><p>处理的是，两个片段或多个片段之间，因为调色某个片段之后，而导致的与其它片段的色彩不衔接问题。<br><img data-src="45b9669f/%E8%89%B2%E5%BD%A9%E8%A1%94%E6%8E%A5%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86.png" alt="色彩衔接问题处理"></p>
<h4 id="白平衡吸管"><a href="#白平衡吸管" class="headerlink" title="白平衡吸管"></a>白平衡吸管</h4><p> 通过该工具可以对画面的白平衡自动进行校准，点击之后，吸取画面上的白色区域即可。
 </p>
]]></content>
      <categories>
        <category>影视后期</category>
      </categories>
      <tags>
        <tag>达芬奇</tag>
        <tag>资源管理</tag>
        <tag>影视后期</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo与GitHub Actions持续集成</title>
    <url>/post/9bb5c5d6.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>以前本博客是借助Travis来进行CI的，配置NodeJs及Hexo环境自动编译等。有兴趣，可以看看，该文章：<a href="https://nimbik.cc/post/e62993b1.html">https://nimbik.cc/post/e62993b1.html</a><br>（也是惭愧，有1年有余没有跟新博客了，导致Travis收费都不知道，今天开始更新的时候，发现远端编译失败了。。。。提示要收费）<br>遂，果断弃之并迁移之GitHub Actions。</p>
<span id="more"></span>

<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>找到本篇文章之前，假设看官您已经对CI相关工作原理已经熟悉了，且对下面的一些使用场景比较熟悉了（原谅我懒，有问题请leave a comment）</p>
<ul>
<li>GitHub的ssh配置过程</li>
<li>Hexo的编译过程</li>
<li>一些简单的Linux shell</li>
</ul>
<h2 id="准备过程"><a href="#准备过程" class="headerlink" title="准备过程"></a>准备过程</h2><p>准备一组新的github的deploy公私钥，通过ssh-keygen生成即可，后面需要用到。</p>
<h2 id="GitHub-Actions配置过程"><a href="#GitHub-Actions配置过程" class="headerlink" title="GitHub Actions配置过程"></a>GitHub Actions配置过程</h2><p>在配置actions脚本的时候，需要在仓库的Settings界面先配置两处东西</p>
<h3 id="仓库Settings界面"><a href="#仓库Settings界面" class="headerlink" title="仓库Settings界面"></a>仓库Settings界面</h3><p>点开你的仓库，点开Settings<br>![仓库Settings](9bb5c5d6/Github Repository Setttings.png)</p>
<p>注意圈出来的两个地方，我们需要先设置一下</p>
<ol>
<li><p>Deploy keys<br> 这个地方，将刚才<em>准备过程</em>中新生成的公钥（id_rsa.pub文件中），不漏的copy上，完了点击右上角的“Add depoly key”之后，在下图中填上，标题随便，Key就是刚才你粘贴的那个公钥内容。<br> <img data-src="9bb5c5d6/AddDeployKeys.png" alt="AddDeployKeys"><br> <strong>注意勾上写权限</strong></p>
</li>
<li><p>Secrets and variables<br> 这个里面主要设置一些变量相关的内容，步骤不多赘述。这里主要是配置一些，在hexo配置文件中使用到的一些变量相关的值，特别是一些插件的client_id，授权密钥相关的敏感信息都可以放在这个里面配置。在后面配置脚本的时候，可以看到在哪里用到。<br> ![secrets and variables](9bb5c5d6/secrets and variables.png)</p>
<p> 其中有一个变量，DEPLOY_KEY是上面生成的私钥（id_rsa文件中），完整复制进去即可。</p>
</li>
</ol>
<h3 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h3><p>这部分不用过多赘述，直接看我的脚本注释里面即可。<br>有两种方式创建脚本，一种通过仓库页面选项卡的上方“Actions选项卡”进行创建；另一种是你直接创建相关的yml文件，路径放在你博客源码仓库页面的：*.github/workflows/xxx.yml* 即可。文件名自定义。</p>
<p>下面是我的脚本内容（包含了若干自己博客所需的hexo插件，你按需更改相关命令即可）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">hexo_blog_audo_deploy</span> <span class="comment"># actions名称，自定义即可</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># 监听分支，注意你的分支名称，特别是github新建的仓库，是main，不是master</span></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">types:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">published</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">检查分支</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">master</span> <span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Node</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&quot;12.x&quot;</span> <span class="comment"># 按需选择你的hexo运行的编译的nodejs版本</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        export TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">        npm install hexo-cli -g --save</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">缓存</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">cache-name:</span> <span class="string">cache-node-modules</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-build-$&#123;&#123;</span> <span class="string">env.cache-name</span> <span class="string">&#125;&#125;-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-build-</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装依赖</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm install hexo-theme-next --save</span></span><br><span class="line"><span class="string">        npm install hexo-deployer-git --save</span></span><br><span class="line"><span class="string">        npm install hexo-generator-searchdb --save</span></span><br><span class="line"><span class="string">        npm install hexo-generator-feed</span></span><br><span class="line"><span class="string">        npm install hexo-wordcount --save</span></span><br><span class="line"><span class="string">        npm install hexo-abbrlink --save</span></span><br><span class="line"><span class="string">        npm install lozad --save</span></span><br><span class="line"><span class="string">        npm uninstall hexo-generator-index --save</span></span><br><span class="line"><span class="string">        npm install hexo-generator-index-pin-top --save</span></span><br><span class="line"><span class="string">        npm install --save</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">处理相关变量</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      	# 先将主题配置文件中的关于gitalk的敏感信息替换成实际在上述settings中配置的，调用方式就是 **secrets.你刚才配置的变量名称**（我使用的next主题，按你实际使用的主题配置更改）</span></span><br><span class="line"><span class="string">        sed -i &#x27;s/GITALK_CLIENT_ID/$&#123;&#123; secrets.GITALK_CLIENT_ID &#125;&#125;/g&#x27; ./_config.next.yml</span></span><br><span class="line"><span class="string">        sed -i &#x27;s/GITALK_CLIENT_SECRET/$&#123;&#123; secrets.GITALK_CLIENT_SECRET &#125;&#125;/g&#x27; ./_config.next.yml</span></span><br><span class="line"><span class="string">        # 处理自定义配置（这里主要是处理一个插件里面的内容，我需要自定义一些玩意儿，所以我这么处理了，你没有这个需求大可删了下面三行）</span></span><br><span class="line"><span class="string">        git clone -b customer_config https://github.com/nimbusking/nimbusking.github.io.git temp</span></span><br><span class="line"><span class="string">        cp -f ./temp/post-meta.njk ./node_modules/hexo-theme-next/layout/_partials/post</span></span><br><span class="line"><span class="string">        rm -rf ./temp</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">配置环境</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span> <span class="comment"># 这里获取仓库提交公钥，后面用到</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;useremail&quot; </span></span><br><span class="line"><span class="string">          git config --global user.name &quot;username&quot;</span></span><br><span class="line"><span class="string">          ssh-keygen -y -f ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">部署</span> <span class="string">Nimbusk博客</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo d</span></span><br></pre></td></tr></table></figure>

<p>没写那么细致，一个简单的actions脚本就完成了，不是特别复杂。<br>更高级的actions语法，需要你参考actions具体教程。</p>
]]></content>
      <categories>
        <category>站点</category>
      </categories>
      <tags>
        <tag>站点</tag>
        <tag>Hexo</tag>
        <tag>Nodejs</tag>
        <tag>GitHub Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper学习</title>
    <url>/post/324f2c0b.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="从Paxos到ZooKeeper"><a href="#从Paxos到ZooKeeper" class="headerlink" title="从Paxos到ZooKeeper"></a>从Paxos到ZooKeeper</h2><span id="more"></span>

<h3 id="第1章-分布式架构"><a href="#第1章-分布式架构" class="headerlink" title="第1章 分布式架构"></a>第1章 分布式架构</h3><h4 id="分布式的特点"><a href="#分布式的特点" class="headerlink" title="分布式的特点"></a>分布式的特点</h4><ul>
<li><strong>分布性</strong>：分布式系统中的多台计算机都会在空间上随意分布。</li>
<li><strong>对等性</strong>：分布式系统中的计算机没有主／从之分， 既没有控制整个系统的主机，也没有被控 制的从机，组成分布式系统的所有计算机节点都是对等的。</li>
<li><strong>并发性</strong>：如果在并发场景下协调好共享资源</li>
<li><strong>缺乏全局时钟</strong>：在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。 </li>
<li><strong>故障总会发生</strong>：组成分布式系统的所有计算机，都有可能发生任何形式的故障。</li>
</ul>
<h4 id="分布式环境的各种问题"><a href="#分布式环境的各种问题" class="headerlink" title="分布式环境的各种问题"></a>分布式环境的各种问题</h4><ul>
<li>通信异常：分布式节点之间需要网络通信，网络通信就带来，比如延迟等异常情况</li>
<li>网络分区：组成分布式系统的所有节点，因为网络异常，导致一部分节点能通信，一部分节点不能通信，这个现象称之为网络分区，俗称为“脑裂”。</li>
<li>三态：分布式系统的每一次请求与响应，存在特有的“三态”，即成功、失败和超时。</li>
<li>节点故障：</li>
</ul>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>分布式事务场景下的数据一致性等问题</p>
<h4 id="关于CAP与BASE"><a href="#关于CAP与BASE" class="headerlink" title="关于CAP与BASE"></a>关于CAP与BASE</h4><p>关于CAP的应用，我们要知道，分布式系统无法同时满足这三个需求的。往往只能满足其中两项，关于这点，在书中有个表格，这里贴出来，需要的时候可以看看缺失其中一项的应用场景是什么：</p>
<p><img data-src="324f2c0b/CAP%E5%AE%9A%E7%90%86%E5%BA%94%E7%94%A8.jpg" alt="CAP定理应用"></p>
<p>另外，在分布式场景下，分区容错性（P）是一定要解决的，不然怎么称之为分布式系统？</p>
<h5 id="关于BASE"><a href="#关于BASE" class="headerlink" title="关于BASE"></a>关于BASE</h5><p>BASE是由Basically Available(基本可用)、Soft state（软状态）和Eventually consistend（最终一致性）这三个短语构成的。</p>
<p>来自EBAY工程师Dan Pritchett在2008年发布的一篇文章中提到的概念，笔者从ACM网站上下载了下来，有需要可以翻阅看看。</p>
<p> [Introduce BASE different with ACID.pdf](324f2c0b\Introduce BASE different with ACID.pdf) </p>
<p>原文文章连接：<a href="https://dl.acm.org/doi/10.1145/1394127.1394128">https://dl.acm.org/doi/10.1145/1394127.1394128</a></p>
<p>【备注】书中介绍了一下ACID背景以及带来的问题，通过引入交易转账的两张小表来阐述怎么做到最终一致性，以及最终一致性的目标。读者可以仔细看看，例子不难，对于理解最终一致性是很有帮助的。</p>
<p>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是：<strong>即使无法做到强一致性(Strong consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。</strong></p>
<p>【备注】关于最终一致性，书中还介绍了五类主要的变种，分别是：</p>
<ul>
<li>因果一致性（Causal consistency）</li>
<li>读己之所写（Read your writes）</li>
<li>会话一致性（Session consistency）</li>
<li>单调读一致性（Monotonic /ˌmänəˈtänik/ read consistency）</li>
<li>单调写一致性（Monotonic write consistency）</li>
</ul>
<h3 id="第2章-一致性协议"><a href="#第2章-一致性协议" class="headerlink" title="第2章 一致性协议"></a>第2章 一致性协议</h3><p>【备注】这个章节中介绍了三种经典的分布式一致性算法，分别是二段提交（2PC, Two-Phase Commit）、三段提交（3PC, Three-Phase Commit）以及大名鼎鼎的Paxos算法。</p>
<p>在介绍二、三段提交算法之前，书中引入了“段式”提交的核心理念：</p>
<p>当一个事务操作需要跨越多个分布式节点的时候， 为了保持事务处理的ACID特性， 就需要引入 一个称为 ＂协调者(Coordinator)” 的组件来统一调度所有分布式节点的执行逻辑， 这些被调度的分布式节点则被称为 “参与者” (Participant)。 <strong>协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。</strong> </p>
<h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>PC, 是Two-Phase Commit的缩写， 即二阶段提交，是计算机网络尤其是在数据库领域内， 为了使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。</p>
<p>【备注】你可能也听过另外一个二段：二段锁（2PL, Two-Phase Locking），这俩个是完全不同的东西哦。二段锁，是解决单机事务中的数据的一致性和隔离性而诞生的。而，二段提交是处理的分布式事务。</p>
<p>二段提交示意图，如下图所示：</p>
<p><img data-src="324f2c0b/%E4%BA%8C%E6%AE%B5%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="二段事务提交示意图"></p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点</strong>：原理简单，实现方便。</p>
<p><strong>缺点</strong>：同步阻塞、单点问题、脑裂、太过保守。</p>
<p>关于缺点：</p>
<ul>
<li><strong>同步阻塞</strong>：在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处千阻塞状态</li>
<li><strong>单点问题</strong>：<strong>协调者</strong>的角色在整个二阶段提交协议中起到了非常重要的作用。 一旦协调者出现问题， 那么整个二阶段提交流程将无法运转， 更为严重的是， 如果协调者是在阶段二中出现问题的话， 那么其他参与者将会一直处于锁定事务资源的状态中， 而无法继续完成事务操作。</li>
<li><strong>数据不一致</strong>：当协调者向所有的参与者发送Commit请求之后， 发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求。 于是， 这部分收到了Commit请求的参与者就会进行事务的提交， 而其他没有收到Commit请求的参与者则无法进行事务提交， 整个分布式系统便出现了数据不一致性现象。</li>
<li><strong>太过保守</strong>：如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务， 这样的策略显得比较保守。 换句话说， 二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。</li>
</ul>
<p>【备注】在书中的这几个缺点的详细描述可以很好的理解二段事务提交的特点，衍生的场景，可以了解一下MySQL中事务是怎么使用二段提交这个特性的。</p>
<p>关于2PC和3PC这两个概念，有兴趣的看官，可以参阅1988年出版，由Philip A. Bernstein等人巨著的，《数据库并发控制理论》（暂译）(<em>CONCURRENCY CONTROL AND RECOVERY IN DATABASE SYSTEMS</em>)一书，该书中系统的阐述了在数据库系统设计过程中，并发场景的种种问题及挑战，其中2PC和3PC在书中的第7章有详细阐述。这本书，同样涵盖了，例如MVCC（熟悉MySQL的一定不陌生），2PL等数据库并发控制理论。</p>
<p>当然如果你还不过瘾，在研究完本篇Zookeeper相关概念之后，可以参考参考，知乎上一位博主总结的关于分布式的台前幕后：<a href="https://zhuanlan.zhihu.com/p/338161857">https://zhuanlan.zhihu.com/p/338161857</a></p>
<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><p>3PC是由2PC演进而来，其过程主要是将二阶段提交协议的“提交事务请求”过程一分为二，形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。</p>
<p>其原理示意图（来自Google）：</p>
<p><img data-src="324f2c0b/%E4%B8%89%E6%AE%B5%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="三段事务提交示意图"></p>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点</strong>：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。</p>
<p><strong>缺点</strong>：参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。</p>
<h4 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h4><p>Paxos算法是莱斯利·兰伯特( <a href="https://en.wikipedia.org/wiki/Leslie_Lamport">Leslie Lamport</a>) （【备注】计算机界的一位巨佬，其在分布式领域的贡献不亚于Dijkstra这些巨佬的贡献，2013年图灵奖获得者）注2 千1990年提出的一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。</p>
<p>Paxos主要解决的问题就是在前面提到的，在分布式系统中，如果出现了诸如机器宕机或网络异常等情况。Paxos算法需要解决的问题就是<strong>如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</strong></p>
<h3 id="第3章-Paxos的工程实践"><a href="#第3章-Paxos的工程实践" class="headerlink" title="第3章 Paxos的工程实践"></a>第3章 Paxos的工程实践</h3><h4 id="关于Chubby"><a href="#关于Chubby" class="headerlink" title="关于Chubby"></a>关于Chubby</h4><p>要知道：Chubby提供了粗粒度的分布式锁服务，开发人员不需要使用复杂的同步协议，而是直接调用Chubby的锁服务接口即可实现分布式系统中多个进程之间粗粒度的同步控制，从而保证了分布式数据的一致性。</p>
<h3 id="第4章-ZooKeeper与Paxos"><a href="#第4章-ZooKeeper与Paxos" class="headerlink" title="第4章 ZooKeeper与Paxos"></a>第4章 ZooKeeper与Paxos</h3><h4 id="初识ZooKeeper"><a href="#初识ZooKeeper" class="headerlink" title="初识ZooKeeper"></a>初识ZooKeeper</h4><p>ZooKeeper的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<p>ZooKeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如现诸如<strong>数据发布／订阅、负载均衡、命名服务、分布式协调／通知、集群管理、Master选举、分布式锁和分布式队列</strong>等功能。ZooKeeper可以保证如下分布式一致性特性：</p>
<ul>
<li><strong>顺序一致性</strong>：从同一个客户端发起的事务请求， 最终将会严格地按照其发起顺序被应用到ZooKeeper中去。</li>
<li><strong>原子性：</strong>所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群所有机器都成功应用了某一个事务， 要么都没有应用。</li>
<li><strong>单一视图（Single System Image）</strong>：无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</li>
<li><strong>可靠性：</strong>一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来， 除非有另一个事务又对其进行了变更。</li>
<li><strong>实时性</strong>：ZooKeeper 仅仅保证在一定的时间段内， 客户端最终一定能够从服务端上读取到最新的数据状态。</li>
</ul>
<h4 id="ZooKeeper的基本概念"><a href="#ZooKeeper的基本概念" class="headerlink" title="ZooKeeper的基本概念"></a>ZooKeeper的基本概念</h4><p>【备注】这里只是介绍的基本概念，详细细节再第7章中会详细介绍</p>
<h5 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h5><p>ZooKeeper不同于传统的Master/Slave模式，将整个集群分为Leader、Follower、Observer三种机器。</p>
<ul>
<li>关于<strong>Leader机器</strong>：ZooKeeper集群中的所有机器通过一个Leader选举过程来选定一台被称为”Leader”的机器，Leader服务器为客户端提供读和写服务。</li>
<li><strong>关于Follower和Observer机器</strong>：Follower和Observer都能够提供读服务，唯一的区别在干，Observer机器不参与Leader选举过程，也不参与写操作的“过半写成功”策略。</li>
</ul>
<h5 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h5><p>客户端启动的时候，首先会与服务器建立一个TCP连接， 从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，同时也能够向ZooKeeper服务器发送请求并接受响应，同时还能够通过该连接<strong>接收来自服务器的Watch事件通知</strong>。</p>
<h5 id="数据节点（Znode）"><a href="#数据节点（Znode）" class="headerlink" title="数据节点（Znode）"></a>数据节点（Znode）</h5><p>这里指的数据节点，是指的ZooKeeper的内存数据结构。在ZooKeeper中，ZNode可以分为持久节点和临时节点两类，其中：</p>
<ul>
<li><strong>持久节点</strong>：指一且这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在ZooKeeper上。</li>
<li><strong>临时节点</strong>：它的生命周期和客户端会话绑定，一且客户端会话失效，那么这个客户端创建的所有临时节点都会被移除</li>
</ul>
<p>数据节点还有另外一个额外的属性，<strong>SEQUENTIAL</strong> <em>/səˈkwen(t)SHəl/</em> ，一旦被标记这个属性，那么这个节点将被创建的时候，会在节点名称后面追加上一个整型数字，这个整型数字是由<strong>父节点维护的一个自增数字</strong>。</p>
<h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><p>每个ZNode，ZooKeeper都会为其维护一个叫作<strong>Stat</strong>的数据结构，Stat中记录了这个ZNode的三个数据版本，分别是<strong>version（当前ZNode的版本）</strong>、cversioo（当前ZNode子节点的版本）和<strong>aversion（当前ZNode的ACL版本）</strong>。</p>
<h5 id="事件监听器（Watcher）"><a href="#事件监听器（Watcher）" class="headerlink" title="事件监听器（Watcher）"></a>事件监听器（Watcher）</h5><p>ZooKeeper允许用户在指定节点上注册一些Watcher, 并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。</p>
<h5 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h5><p>ZooKeeper采用ACL (Access Control Lists)策略来进行权限控制，类似于UNIX文件系统的权限控制。其中ZooKeeper定义了如下5中权限：</p>
<ul>
<li><strong>CREATE</strong>：创建<strong>子节点</strong>权限</li>
<li><strong>READ</strong>：获取节点数据和<strong>子节点</strong>列表的权限</li>
<li><strong>WRITE</strong>：更新节点数据的权限</li>
<li><strong>DELETE</strong>：删除子节点的权限</li>
<li><strong>ADMIN</strong>：设置节点ACL的权限</li>
</ul>
<h4 id="ZooKeeper的ZAB协议"><a href="#ZooKeeper的ZAB协议" class="headerlink" title="ZooKeeper的ZAB协议"></a>ZooKeeper的ZAB协议</h4><h5 id="ZAB协议概述"><a href="#ZAB协议概述" class="headerlink" title="ZAB协议概述"></a>ZAB协议概述</h5><p>要明白一点，ZooKeeper并没有完全采用Paxos算法，而是使用了一种称为**Zookeeper Atomic Broadcast(ZAB，Zookeeper原子消息广播协议)**的协议作为其数据一致性的核心算法。</p>
<p>在ZooKeeper中，<strong>主要依赖ZAB协议来实现分布式数据一致性</strong>，基于该协议，ZooKeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体过程概括如下：</p>
<p><strong>首先：</strong>ZooKeeper使用<strong>一个单一的主进程</strong>来接收并处理客户端的<strong>所有事务请求</strong>，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务Proposal的形式广播到所有的副本进程上去。这个过程的特点是：ZAB协议的这个主备模型架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端大量的井发请求。</p>
<p><strong>其次：</strong>考虑到在分布式环境中，顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更。例如变更C需要依赖变更A和变更B。 这样的依赖关系也对ZAB协议提出了一个要求：<strong>ZAB协议必须能够保证一个全局的变更序列被顺序应用</strong>，也就是说，ZAB协议需要保证如果一个状态变更已经被处理了，那么所有其依赖的状态变更都应该巳经被提前处理掉了。</p>
<p><strong>最后</strong>：考虑到主进程在任何时候都有可能出现崩溃退出或重启现象，因此，ZAB协议还需要做到在当前主进程出现上述异常情况的时候， 依旧能够正常工作。</p>
<p>上述步骤的概述，就是：</p>
<p><em>所有事务请求必须由<strong>一个全局唯一的服务器</strong>来协调处理， 这样的服务器被称为 Leader 服务器， 而余下的其他服务器则成为 Follower 服务器。 Leader 服务器负责将一<strong>个客户端事务请求</strong>转换成<strong>一个事务 Proposal</strong>（提议）， 并将该 Proposal <strong>分发</strong>给集群中所有的Follower 服务器。 之后 Leader服务器需要等待所有 Follower 服务器的反馈， 一旦<strong>超过半数</strong>的 Follower 服务器进行了正确的反馈后， 那么 Leader 就会再次向所有的 Follower 服务器分发 Commit 消息要求其将前一个 Proposal 进行提交。</em></p>
<h5 id="ZAB协议介绍"><a href="#ZAB协议介绍" class="headerlink" title="ZAB协议介绍"></a>ZAB协议介绍</h5><p>ZAB协议包含两个基本的模式，分别是崩溃恢复和消息广播。</p>
<h6 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h6><p>ZAB协议的消息广播过程使用的是一个原子广播协议，*<strong>类似于</strong>一个二阶段提交过程*。针ZAB协议的消息广播过程使用的是对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal, 并将其发送给集群中其余所有的机器， 然后再分别收集各自的选票， 最后进行事务提交，如下图所示：</p>
<p><img data-src="324f2c0b/ZAB%E5%8D%8F%E8%AE%AE%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="ZAB协议消息广播流程示意图"></p>
<p>前文中提到这个过程仅仅是类似于一个2PC过程，但是又与2PC过从不同的是：</p>
<ul>
<li>移除了中断逻辑，所有的Follower服务器要么正常反馈Leader 提出的事务Proposal，要么就抛弃Leader服务器。意味着我们可以在过半的Follower服务器已经反馈Ack之后就开始提交事务Proposal了。当然这个过程是解决不了Leader崩溃的问题的，所以由后面的恢复模式来解决这个问题。</li>
<li>整个消息广播协议是基于具有FFIO特性的TCP协议来进行网络通信的，因此能够很容易地保证消息广播过程中消息接收与发送的顺序性。</li>
</ul>
<h6 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h6><p>崩溃恢复是为了解决Leader节点崩溃或者因为网络原因导致的，失去过半的Follower联系的，就会进入恢复模式。</p>
<p>根本解决的问题是，重新选举的同时，还能很好的通知到整个集群。</p>
<h3 id="第5章-使用ZooKeeper"><a href="#第5章-使用ZooKeeper" class="headerlink" title="第5章 使用ZooKeeper"></a>第5章 使用ZooKeeper</h3><p>【备注】这里还是非常建议，哪怕是照着书本配置，敲一下，提升一下基础印象还是很有必要的。</p>
<h3 id="第6章-ZooKeeper的典型应用场景"><a href="#第6章-ZooKeeper的典型应用场景" class="headerlink" title="第6章 ZooKeeper的典型应用场景"></a>第6章 ZooKeeper的典型应用场景</h3><h3 id="第7章-ZooKeeper技术内幕"><a href="#第7章-ZooKeeper技术内幕" class="headerlink" title="第7章 ZooKeeper技术内幕"></a>第7章 ZooKeeper技术内幕</h3><h3 id="第8章-ZooKeeper运维"><a href="#第8章-ZooKeeper运维" class="headerlink" title="第8章 ZooKeeper运维"></a>第8章 ZooKeeper运维</h3>]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-InnoDB存储引擎</title>
    <url>/post/ff43c837.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这本书介绍的知识点，emm，过于零碎，更像是“翻译”了一下底层设计而已，关于脉络主线等内容，需要花很大力气去啃。因此，本篇文章，我主要记录，我薄弱的地方，比如关于事务、MVCC和锁这块内容。这部分会仔细加注。</p>
<span id="more"></span>




<h2 id="第4章-表"><a href="#第4章-表" class="headerlink" title="第4章 表"></a>第4章 表</h2><h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>InnoDB的表空间（tablespace）由段（segment）、区（extent）、页（page）组成</p>
<p><img data-src="ff43c837/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" alt="InnoDB逻辑存储结构"></p>
<h2 id="第5章-索引与算法"><a href="#第5章-索引与算法" class="headerlink" title="第5章 索引与算法"></a>第5章 索引与算法</h2><h2 id="第6章-锁"><a href="#第6章-锁" class="headerlink" title="第6章 锁"></a>第6章 锁</h2>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Notion使用总结</title>
    <url>/post/4b138f9d.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="开始前的思考"><a href="#开始前的思考" class="headerlink" title="开始前的思考"></a>开始前的思考</h3><p>长久以来，其实接触的笔记软件也有不少，但是鲜有能行程体系的。<br>Notion是去年，经由一个朋友介绍才了解的。</p>
<span id="more"></span>

<p>着实眼睛一亮，但是有个问题</p>
<p><strong>上手似乎有点难！</strong>准确的说是，很好的上手，其实界面相关的，不是那么复杂，尽管是英文界面而已，也就是英文界面而已（官方中午在做，22年3月份就发声明了，但是好像还没有推出）</p>
<p><strong>真正难的是，怎么用好的问题？</strong></p>
<p>早年，尝试过构建个人知识图谱，然而也就停留在使用思维导图的方式，这种呢，非常不便于拓展。仅仅也就是能记录大纲的东西而已，细节的通过超链跳转，非常繁琐。而且，不管那种思维导图软件，呈现的方式还是比较单一的。<br>这就带来一个问题，刚开始可能记录一段时间之后，后面可能就荒废了，没有进一步推进。久而久之…</p>
<h4 id="迟迟没有开始"><a href="#迟迟没有开始" class="headerlink" title="迟迟没有开始"></a>迟迟没有开始</h4><p>去年尝试记录一下，当时记录的场景，就相对有点单纯了，就当来作为随手笔记了，准确的说应该是碎片化的笔记。截取下面一个：</p>
<p><img data-src="4b138f9d/2023-01-07_144708.jpg" alt="截图"></p>
<p>很琐碎的一个事项：去年科目三的时候，实地前的一次网络学习线路探底。<br>这个是一个碎片化的记录。事后发现，这个其实并不能完整的发挥Notion的强大之处。</p>
<h2 id="关于构建"><a href="#关于构建" class="headerlink" title="关于构建"></a>关于构建</h2><p>在最近重新拾起来Notion之后，B站上也有很多UP在分享Notion教程，每个热风格不尽相同，有的整个系统介绍Notion菜单的新手向教程、有的介绍Notion模板的（Notion中的一个功能）、有的就水一下心得什么的。</p>
<p>看了不少，其实有很多不能拎起自己的兴趣，准确的说，是不适合自己。</p>
<p>后来，在参考一位B站UP公开的一个工作区：<a href="https://eryi.love/">https://eryi.love/</a><br>在这里面，其实发现了一些灵感，可能尝试用Notion管理下去的理由：<strong>形成一个自己的个人知识图谱</strong></p>
<p>在上面公开的工作区里面，大概分了下面的几个分类：</p>
<ul>
<li>项目</li>
<li>领域<ul>
<li>公众号运营</li>
<li>B站运营</li>
<li>油管频道</li>
<li>小红书</li>
<li>我的播客</li>
<li>职业规划</li>
</ul>
</li>
<li>资源<ul>
<li>装备清单</li>
<li>我的游戏</li>
<li>我的摄影</li>
<li>观影记录</li>
<li>日常折腾</li>
<li>素材管理</li>
<li>读书笔记</li>
<li>主页管理</li>
</ul>
</li>
<li>归档</li>
</ul>
<p>虽然公开的细节没那么多，但是呢，灵感足够了。<br>所以，这就开始开干下去。</p>
<h2 id="知识库规划"><a href="#知识库规划" class="headerlink" title="知识库规划"></a>知识库规划</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p><strong>记录生活、工作的点点滴滴。</strong><br>就像这个博客的初衷一样，但是博客是一个公开化的，图文倾向更多一点的媒介。<br>Notion当然远不止于此。<br>更多希望完成一个个人知识体系的建设，必要的时候，迁移相关的要点到本博客上以作为分享。</p>
<h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>列举一下目前能想到的大纲，前期先针对这个大纲建立分类（先盖地基）</p>
<ul>
<li>杂项流水<ul>
<li>日记</li>
<li>随记</li>
</ul>
</li>
<li>领域<ul>
<li>工作</li>
<li>专业知识</li>
<li>技能特长</li>
</ul>
</li>
<li>规划<ul>
<li>2023年考试</li>
</ul>
</li>
<li>生活<ul>
<li>日常<ul>
<li>个人物料<ul>
<li>个人电子</li>
<li>娱乐设备</li>
<li>家庭影视</li>
<li>厨房</li>
<li>杂项</li>
</ul>
</li>
<li>生活收支</li>
<li>行车</li>
<li>厨艺</li>
</ul>
</li>
<li>旅行</li>
<li>娱乐<ul>
<li>观影记录</li>
<li>游戏相关</li>
<li>杂志随笔</li>
<li>观剧记录</li>
<li>演出</li>
</ul>
</li>
<li>学习<ul>
<li>读书笔记</li>
</ul>
</li>
</ul>
</li>
<li>成长探索<ul>
<li>音乐<ul>
<li>乐理</li>
<li>吉他</li>
</ul>
</li>
<li>语言<ul>
<li>英语</li>
<li>韩语</li>
<li>日语</li>
</ul>
</li>
<li>摄影<ul>
<li>构图</li>
<li>色彩</li>
</ul>
</li>
<li>影视后期</li>
<li>博物</li>
</ul>
</li>
<li>归档</li>
</ul>
<h2 id="一些操作要点"><a href="#一些操作要点" class="headerlink" title="一些操作要点"></a>一些操作要点</h2><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>Notion</tag>
      </tags>
  </entry>
  <entry>
    <title>java-lang包学习之Class类相关</title>
    <url>/post/5df77236.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java源码系列</category>
      </categories>
      <tags>
        <tag>java.lang</tag>
        <tag>rt.jar</tag>
        <tag>jdk8</tag>
        <tag>Class&lt;T&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title>java-lang包学习</title>
    <url>/post/56093694.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>废话少说，从头学Java之第一篇。<br>按日常使用优先级分级阅读，为了防止篇幅过于太长，其中值得详细探讨的，会单独独立po新文出来。</p>
<span id="more"></span>

<h2 id="lang包基本概览"><a href="#lang包基本概览" class="headerlink" title="lang包基本概览"></a>lang包基本概览</h2><p>doc api中是这样描述的：</p>
<blockquote>
<p>Provides classes that are fundamental to the design of the Java programming language.</p>
</blockquote>
<p>对于Java语言来说，不可或缺的(be fundamental to)，可见这个包是多么的重要！<br>这个包下面有几大块内容：</p>
<ul>
<li>Object类：“万恶之源” </li>
<li>基本类型的包装器</li>
<li>常用数学运算工具类：Math</li>
<li>字符串操作相关类：String等</li>
<li>“系统操作”相关类：ClassLoader等</li>
<li>异常/错误相关定义：Exception、Error等</li>
</ul>
<p>从上面的大概的几块内容来看，确实是日常Java语言中，无处不在的。</p>
<h3 id="lang包下一些类"><a href="#lang包下一些类" class="headerlink" title="lang包下一些类"></a>lang包下一些类</h3><h4 id="接口-Interface-相关"><a href="#接口-Interface-相关" class="headerlink" title="接口(Interface)相关"></a>接口(Interface)相关</h4><h5 id="Appendable"><a href="#Appendable" class="headerlink" title="Appendable"></a>Appendable</h5><p>一个附加字符串定义的接口，提供了三个操作方法，异常抛出的是IOException：<br>这些定义方法中，没有明确任何关于线程安全的定义，需要有各个子类实现类中具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Appendable <span class="title function_">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">Appendable <span class="title function_">append</span><span class="params">(CharSequence csq, <span class="type">int</span> start, <span class="type">int</span> end)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">Appendable <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<h6 id="继承图谱"><a href="#继承图谱" class="headerlink" title="继承图谱"></a>继承图谱</h6><p><img data-src="56093694/hierachy_appendable.jpg" alt="hierachy_appendable"></p>
<h5 id="AutoCloseable"><a href="#AutoCloseable" class="headerlink" title="AutoCloseable"></a>AutoCloseable</h5><p>一个在JDK1.7中引入的特性，从源码文档中可以看出：一个在关闭之前可能持有资源（例如文件或套接字句柄）的对象。 AutoCloseable对象的close() 方法在退出资源规范标头中已为其声明对象的 try-with-resources 块时自动调用。<br>你要实现自动关闭，则需要配合try-with-resources语法定义，才会生效。</p>
<h5 id="CharSequence"><a href="#CharSequence" class="headerlink" title="CharSequence"></a>CharSequence</h5><p>提供了一个可读的char值序列，注意一个点：这个接口没有细化 equals 和 hashCode 方法的一般契约。 因此，比较实现 CharSequence 的两个对象的结果通常是未定义的。 每个对象都可以由不同的类实现，并且不能保证每个类都能够测试其实例与其他类的实例是否相等。 <strong>因此，将任意 CharSequence 实例用作集合中的元素或映射中的键是不合适的。</strong></p>
<p>在JDK1.8中引入了两个stream操作:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> IntStream <span class="title function_">chars</span><span class="params">()</span>; <span class="comment">// zero-extending</span></span><br><span class="line"><span class="keyword">default</span> IntStream <span class="title function_">codePoints</span><span class="params">()</span>; <span class="comment">// Any surrogate pairs encountered</span></span><br></pre></td></tr></table></figure>

<h5 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h5><p>Object.clone时的标记接口：在未实现 Cloneable 接口的实例上调用 Object 的 clone 方法会导致抛出异常 CloneNotSupportedException。</p>
<p>关联子类众多，无处不在。</p>
<h5 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable<T></h5><p>该接口对实现它的每个类的对象进行了总排序。这种排序称为类的自然排序，类的 compareTo 方法称为其自然比较方法。<br>实现此接口的对象列表（和数组）可以由 Collections.sort（和 Arrays.sort）自动排序。实现此接口的对象可以用作排序映射中的键或排序集中的元素，而无需指定比较器。</p>
<h5 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable<T></h5><p>1.5 只提供关于迭代器定义实现。</p>
<h5 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h5><p>1.5 提供的一个字符串读取的read方法的定义，将字符读取到字符缓冲区。其直接实现的子类有两个：</p>
<ul>
<li>抽象类：Reader</li>
<li>抽象类：CharBuffer nio包下的字符缓冲操作类，细节在nio章节详述<br>可以见得，与其子类相关字符操作的，均会涉及该方法重写相关。</li>
</ul>
<h5 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h5><p>1.0 开始，元组级别的接口定义，干嘛的不用多说，接触过java，谁还不知道这个interface呢？<br>在1.8里面，有点点不一样。类上加了一个注解： <code>@FunctionalInterface</code> 该注解在lang的子包: annoation中。<br>主要特性，在doc中也有详细阐述，我们需要知道的是：</p>
<ul>
<li>从定义上，这是一个信息性注解类型(informative annotation type)，就是定义声明了一种在JLS中定义的功能性的接口实现。</li>
<li>从功能上，这种被赋予该注解的功能性的接口，其对应示例可以通过 <strong>lambda 表达式、方法引用或构造函数引用来创建。</strong> 这个特性，在1.8中引入lambda支持之后，日常开发过程中真是无处不再。</li>
<li>元组增强的，我们平时经常能碰到的就Runnable这个被增强过，另一个是在JUC中的Callable接口，还有一个通常跟JWT相关的玩意儿，就不说了；剩下的，跟Core Java相关的，都是围绕1.8引入的lambda, stream息息相关</li>
</ul>
<h5 id="Thread-UncaughtExceptionHandler"><a href="#Thread-UncaughtExceptionHandler" class="headerlink" title="Thread.UncaughtExceptionHandler"></a>Thread.UncaughtExceptionHandler</h5><p>一个线程由于未捕获的异常而突然终止时调用的处理程序接口。<br>这也是一个功能性接口，是Thread内部的一个扩展interface，一般业务侧系统开发，不会直接实现重写这个，除非做底层中间件开发相关的。</p>
<h4 id="类-Class-相关"><a href="#类-Class-相关" class="headerlink" title="类(Class)相关"></a>类(Class)相关</h4><ul>
<li>关于包装器类，需要通用知道的：<ul>
<li>每个包装器（除了Boolean，true,false太特殊，在JVM中有特定表示）都有一个SIZE，用二进制补码的方式表明这个包装器类允许的最大长度(byte)</li>
<li>数值型的包装器，往往都有一个内联的Cache类，用于缓存，在与基本类型转换的时候要注意，<strong>特殊场景的越界可能会发生</strong><h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5>基本类型boolean包装器类，提供了一些与String互转的操作方法。<br>关于转换和逻辑运算的方法，就不过多阐述。<br>源码实现中，有个小点值得提一下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value ? <span class="number">1231</span> : <span class="number">1237</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
Boolean的hashCode返回了是俩数字，而不是其它的。理论，<strong>任意（足够大）的素数即可</strong><br>为啥？这里要涉及到一个知识点，哈希碰撞：<br>细节参阅维基百科的介绍：<a href="https://en.wikipedia.org/wiki/Hash_collision">hash collision</a></li>
</ul>
</li>
</ul>
<h5 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h5><p>基本类型byte包装器类，提两个操作：</p>
<ul>
<li>从String转为byte方法：public static byte parseByte(String s, int radix)</li>
<li>对String进行decode成Byte包装器：public static Byte decode(String nm) throws NumberFormatException<br>这俩操作，都跟Integer包装器类息息相关，底层都调用了Integer包装器类中的相关方法进行运算，这里不过多展开。细节看Integer包装器的介绍。</li>
</ul>
<h5 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h5><p>基本类型char的包装器，大量包含Unicode操作相关，平时直接遇到的场景可能不会很多。<br>值得一提的是，这里面有个of方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> CharacterData <span class="title function_">of</span><span class="params">(<span class="type">int</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;&gt;&gt; <span class="number">8</span> == <span class="number">0</span>) &#123;     <span class="comment">// fast-path</span></span><br><span class="line">            <span class="keyword">return</span> CharacterDataLatin1.instance;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(ch &gt;&gt;&gt; <span class="number">16</span>) &#123;  <span class="comment">//plane 00-16</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> CharacterData00.instance;</span><br><span class="line">            <span class="keyword">case</span>(<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> CharacterData01.instance;</span><br><span class="line">            <span class="keyword">case</span>(<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> CharacterData02.instance;</span><br><span class="line">            <span class="keyword">case</span>(<span class="number">14</span>):</span><br><span class="line">                <span class="keyword">return</span> CharacterData0E.instance;</span><br><span class="line">            <span class="keyword">case</span>(<span class="number">15</span>):   <span class="comment">// Private Use</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">16</span>):   <span class="comment">// Private Use</span></span><br><span class="line">                <span class="keyword">return</span> CharacterDataPrivateUse.instance;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> CharacterDataUndefined.instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>性能可能不是最好的一种快速路由查找的方式，但是却是可能最常用的。 <code>.instance</code> 对实例的处理，私有化默认构造器的方式，都是值得我们平时编写工具类的时候所可以借鉴的。<br>关于Unicode以及对应BMP(Basic Multilingual Plane)参考下面的链接：</p>
<ul>
<li>Unicode: <a href="https://home.unicode.org/">https://home.unicode.org/</a></li>
<li>BMP: <a href="https://en.wikipedia.org/wiki/Plane_(Unicode)">https://en.wikipedia.org/wiki/Plane_(Unicode)</a></li>
</ul>
<h5 id="Class-amp-amp-ClassLoader-amp-amp-ClassValue"><a href="#Class-amp-amp-ClassLoader-amp-amp-ClassValue" class="headerlink" title="Class &amp;&amp; ClassLoader &amp;&amp; ClassValue"></a>Class<T> &amp;&amp; ClassLoader &amp;&amp; ClassValue<T></h5><p>这三个作为一个整体，单独研究研究。<br>细节参考下面的传送门：</p>
<a href="/post/5df77236.html" title="java-lang包学习之Class类相关">java-lang包学习之Class类相关</a>

<h5 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h5><h5 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h5><h5 id="Enum-lt-E-extends-Enum-gt"><a href="#Enum-lt-E-extends-Enum-gt" class="headerlink" title="Enum&lt;E extends Enum&gt;"></a>Enum&lt;E extends Enum<E>&gt;</h5><h5 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h5><h5 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal<T></h5><h5 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h5><h5 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h5><h5 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h5><h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><h5 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h5><h5 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h5><h5 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h5><h5 id="ProcessBuilder-Redirect"><a href="#ProcessBuilder-Redirect" class="headerlink" title="ProcessBuilder.Redirect"></a>ProcessBuilder.Redirect</h5><h5 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h5><h5 id="RuntimePermission"><a href="#RuntimePermission" class="headerlink" title="RuntimePermission"></a>RuntimePermission</h5><h5 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h5><h5 id="Short"><a href="#Short" class="headerlink" title="Short"></a>Short</h5><h5 id="StackTraceElement"><a href="#StackTraceElement" class="headerlink" title="StackTraceElement"></a>StackTraceElement</h5><h5 id="StrictMath"><a href="#StrictMath" class="headerlink" title="StrictMath"></a>StrictMath</h5><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><h5 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h5><h5 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h5><h5 id="System"><a href="#System" class="headerlink" title="System"></a>System</h5><h5 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h5><h5 id="ThreadGroup"><a href="#ThreadGroup" class="headerlink" title="ThreadGroup"></a>ThreadGroup</h5><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal<T></h5><h5 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h5><h5 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h5><h4 id="枚举-Enum-相关"><a href="#枚举-Enum-相关" class="headerlink" title="枚举(Enum)相关"></a>枚举(Enum)相关</h4><h5 id="Character-UnicodeScript"><a href="#Character-UnicodeScript" class="headerlink" title="Character.UnicodeScript"></a>Character.UnicodeScript</h5><h5 id="ProcessBuilder-Redirect-Type"><a href="#ProcessBuilder-Redirect-Type" class="headerlink" title="ProcessBuilder.Redirect.Type"></a>ProcessBuilder.Redirect.Type</h5><h5 id="Thread-State"><a href="#Thread-State" class="headerlink" title="Thread.State"></a>Thread.State</h5><h4 id="异常-Exception-相关"><a href="#异常-Exception-相关" class="headerlink" title="异常(Exception)相关"></a>异常(Exception)相关</h4><h5 id="ArithmeticException"><a href="#ArithmeticException" class="headerlink" title="ArithmeticException"></a>ArithmeticException</h5><h5 id="ArrayIndexOutOfBoundsException"><a href="#ArrayIndexOutOfBoundsException" class="headerlink" title="ArrayIndexOutOfBoundsException"></a>ArrayIndexOutOfBoundsException</h5><h5 id="ArrayStoreException"><a href="#ArrayStoreException" class="headerlink" title="ArrayStoreException"></a>ArrayStoreException</h5><h5 id="ClassCastException"><a href="#ClassCastException" class="headerlink" title="ClassCastException"></a>ClassCastException</h5><h5 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h5><h5 id="CloneNotSupportedException"><a href="#CloneNotSupportedException" class="headerlink" title="CloneNotSupportedException"></a>CloneNotSupportedException</h5><h5 id="EnumConstantNotPresentException"><a href="#EnumConstantNotPresentException" class="headerlink" title="EnumConstantNotPresentException"></a>EnumConstantNotPresentException</h5><h5 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h5><h5 id="IllegalAccessException"><a href="#IllegalAccessException" class="headerlink" title="IllegalAccessException"></a>IllegalAccessException</h5><h5 id="IllegalArgumentException"><a href="#IllegalArgumentException" class="headerlink" title="IllegalArgumentException"></a>IllegalArgumentException</h5><h5 id="IllegalMonitorStateException"><a href="#IllegalMonitorStateException" class="headerlink" title="IllegalMonitorStateException"></a>IllegalMonitorStateException</h5><h5 id="IllegalStateException"><a href="#IllegalStateException" class="headerlink" title="IllegalStateException"></a>IllegalStateException</h5><h5 id="IllegalThreadStateException"><a href="#IllegalThreadStateException" class="headerlink" title="IllegalThreadStateException"></a>IllegalThreadStateException</h5><h5 id="IndexOutOfBoundsException"><a href="#IndexOutOfBoundsException" class="headerlink" title="IndexOutOfBoundsException"></a>IndexOutOfBoundsException</h5><h5 id="InstantiationException"><a href="#InstantiationException" class="headerlink" title="InstantiationException"></a>InstantiationException</h5><h5 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h5><h5 id="NegativeArraySizeException"><a href="#NegativeArraySizeException" class="headerlink" title="NegativeArraySizeException"></a>NegativeArraySizeException</h5><h5 id="NoSuchFieldException"><a href="#NoSuchFieldException" class="headerlink" title="NoSuchFieldException"></a>NoSuchFieldException</h5><h5 id="NoSuchMethodException"><a href="#NoSuchMethodException" class="headerlink" title="NoSuchMethodException"></a>NoSuchMethodException</h5><h5 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h5><h5 id="NumberFormatException"><a href="#NumberFormatException" class="headerlink" title="NumberFormatException"></a>NumberFormatException</h5><h5 id="ReflectiveOperationException"><a href="#ReflectiveOperationException" class="headerlink" title="ReflectiveOperationException"></a>ReflectiveOperationException</h5><h5 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h5><h5 id="SecurityException"><a href="#SecurityException" class="headerlink" title="SecurityException"></a>SecurityException</h5><h5 id="StringIndexOutOfBoundsException"><a href="#StringIndexOutOfBoundsException" class="headerlink" title="StringIndexOutOfBoundsException"></a>StringIndexOutOfBoundsException</h5><h5 id="TypeNotPresentException"><a href="#TypeNotPresentException" class="headerlink" title="TypeNotPresentException"></a>TypeNotPresentException</h5><h5 id="UnsupportedOperationException"><a href="#UnsupportedOperationException" class="headerlink" title="UnsupportedOperationException"></a>UnsupportedOperationException</h5><h4 id="错误-Error-相关"><a href="#错误-Error-相关" class="headerlink" title="错误(Error)相关"></a>错误(Error)相关</h4><h5 id="AbstractMethodError"><a href="#AbstractMethodError" class="headerlink" title="AbstractMethodError"></a>AbstractMethodError</h5><h5 id="AssertionError"><a href="#AssertionError" class="headerlink" title="AssertionError"></a>AssertionError</h5><h5 id="BootstrapMethodError"><a href="#BootstrapMethodError" class="headerlink" title="BootstrapMethodError"></a>BootstrapMethodError</h5><h5 id="ClassCircularityError"><a href="#ClassCircularityError" class="headerlink" title="ClassCircularityError"></a>ClassCircularityError</h5><h5 id="ClassFormatError"><a href="#ClassFormatError" class="headerlink" title="ClassFormatError"></a>ClassFormatError</h5><h5 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h5><h5 id="ExceptionInInitializerError"><a href="#ExceptionInInitializerError" class="headerlink" title="ExceptionInInitializerError"></a>ExceptionInInitializerError</h5><h5 id="IllegalAccessError"><a href="#IllegalAccessError" class="headerlink" title="IllegalAccessError"></a>IllegalAccessError</h5><h5 id="IncompatibleClassChangeError"><a href="#IncompatibleClassChangeError" class="headerlink" title="IncompatibleClassChangeError"></a>IncompatibleClassChangeError</h5><h5 id="InstantiationError"><a href="#InstantiationError" class="headerlink" title="InstantiationError"></a>InstantiationError</h5><h5 id="InternalError"><a href="#InternalError" class="headerlink" title="InternalError"></a>InternalError</h5><h5 id="LinkageError"><a href="#LinkageError" class="headerlink" title="LinkageError"></a>LinkageError</h5><h5 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h5><h5 id="NoSuchFieldError"><a href="#NoSuchFieldError" class="headerlink" title="NoSuchFieldError"></a>NoSuchFieldError</h5><h5 id="NoSuchMethodError"><a href="#NoSuchMethodError" class="headerlink" title="NoSuchMethodError"></a>NoSuchMethodError</h5><h5 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h5><h5 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h5><h5 id="ThreadDeath"><a href="#ThreadDeath" class="headerlink" title="ThreadDeath"></a>ThreadDeath</h5><h5 id="UnknownError"><a href="#UnknownError" class="headerlink" title="UnknownError"></a>UnknownError</h5><h5 id="UnsatisfiedLinkError"><a href="#UnsatisfiedLinkError" class="headerlink" title="UnsatisfiedLinkError"></a>UnsatisfiedLinkError</h5><h5 id="UnsupportedClassVersionError"><a href="#UnsupportedClassVersionError" class="headerlink" title="UnsupportedClassVersionError"></a>UnsupportedClassVersionError</h5><h5 id="VerifyError"><a href="#VerifyError" class="headerlink" title="VerifyError"></a>VerifyError</h5><h5 id="VirtualMachineError"><a href="#VirtualMachineError" class="headerlink" title="VirtualMachineError"></a>VirtualMachineError</h5><h4 id="注解-Annotation-相关"><a href="#注解-Annotation-相关" class="headerlink" title="注解(Annotation)相关"></a>注解(Annotation)相关</h4><h5 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h5><h5 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="FunctionalInterface"></a>FunctionalInterface</h5><h5 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h5><h5 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="SafeVarargs"></a>SafeVarargs</h5><h5 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="SuppressWarnings"></a>SuppressWarnings</h5><h3 id="java-lang-annotation"><a href="#java-lang-annotation" class="headerlink" title="java.lang.annotation"></a>java.lang.annotation</h3><h3 id="java-lang-instrument"><a href="#java-lang-instrument" class="headerlink" title="java.lang.instrument"></a>java.lang.instrument</h3><h3 id="java-lang-invoke"><a href="#java-lang-invoke" class="headerlink" title="java.lang.invoke"></a>java.lang.invoke</h3><h3 id="java-lang-management"><a href="#java-lang-management" class="headerlink" title="java.lang.management"></a>java.lang.management</h3><h3 id="java-lang-ref"><a href="#java-lang-ref" class="headerlink" title="java.lang.ref"></a>java.lang.ref</h3><h3 id="java-lang-reflect"><a href="#java-lang-reflect" class="headerlink" title="java.lang.reflect"></a>java.lang.reflect</h3><h2 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>Java源码系列</category>
      </categories>
      <tags>
        <tag>java.lang</tag>
        <tag>rt.jar</tag>
        <tag>jdk8</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数据迁移</title>
    <url>/post/b0471e7f.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在日常研发工作中，时不时的经常在某些场景需要使用到数据迁移。比如，从产线数据库中，迁移一部分数据到本地、测试环境，进行测试相关。<br>这时候，就遇到点问题，怎么迁移？<br>通常你是没有权限直接接触产生数据库后台的，用工具直接连，你就别想了。完了，我们能接触的就是查询，而查询出来的估计也多半是类Excel表格形式。</p>
<p>将待迁移数据到Excel中之后，接下来问题就来了，怎么将Excel数据导入到目的数据库中呢？</p>
<span id="more"></span>

<h4 id="尝试过的方案"><a href="#尝试过的方案" class="headerlink" title="尝试过的方案"></a>尝试过的方案</h4><ul>
<li>实在没辙：自己写代码，解析Excel，直接通过JPA或者其它的组件进行对数据库操作，生成DML。</li>
<li>Kettle：一款功能比较丰富的，大数据迁移软件</li>
<li>Navicat：一款数据库操作IDE，支持MySQL、Oracle、SQL Server等数据库</li>
<li>DataGrip：intellij出品的一款数据库操作IDE，功能更丰富，支持的数据库更多！</li>
</ul>
<h4 id="额外的故事"><a href="#额外的故事" class="headerlink" title="额外的故事"></a>额外的故事</h4><p>我是在工作中的某一次，需要迁移数十万条产线数据到测试环境，进行测试。</p>
<p>上述方案的前两个首先放弃，Kettle自己其实不不是很熟悉，建立映射的时候，最烦的是，kettle自己生成了数据库的alert语句来匹配导入的列（可能是我不熟悉，可能有方法能解决这个问题）。</p>
<p>完了navicat，导入，excel、csv都可以，正常情况下，如果导入顺利，数十万条，这个还是非常快的。但是，好巧不巧，那次，我重试了n遍，显示导入成功了，但是，目标表中死活就是没有数据。<br>PS：后来才发现，确实，是源文件中的，某时间列，有问题，导入的时候，其实有错误的，只是navicat没有错误提示，直接回滚导入的数据了。。。。</p>
<p>在我快崩溃，准备通过代码的方式来整的时候，我才知道DataGrip这个玩意儿。<br>DataGrip目前使用导入场景来说，最好的一点就是，如果有错误，会提示哪一行，哪一列导入出错了。如果只是时间什么的错误，完全可以就把源数据文件中的这列删掉就是了，再进行导入，这个会快很多。</p>
<p>下面，就分别简单的说说，这俩工具在数据迁移时的使用场景</p>
<h3 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h3><p>操作还是比较简单的，在对应数据库上右键，选择“导入向导”，在剩下步骤选择对应的源文件，完了映射关联表，后续一步一步点下去，最后运行就行了：<br><img data-src="b0471e7f/import_with_navicat.png" alt="navicat导入"></p>
<h3 id="DataGrip"><a href="#DataGrip" class="headerlink" title="DataGrip"></a>DataGrip</h3><p>关于DataGrip的一些介绍，<a href="https://www.jetbrains.com/datagrip/">官网传送门</a></p>
<p>IDEA的手册，写的还是比较详细的，可以参考dg在关于导入的时候的步骤：<a href="https://www.jetbrains.com/help/datagrip/import-file-name-format-dialog.html">https://www.jetbrains.com/help/datagrip/import-file-name-format-dialog.html</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>2021搬家记</title>
    <url>/post/44fb5d01.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>生活，就是理解。生活，就是面对现实微笑，就是越过障碍注视将来。生活，就是自己身上有一架天平，在那上面衡量善与恶。生活，就是有正义感、有真理、有理智，就是始终不渝、诚实不欺、表里如一、心智纯正，并且对权利与义务同等重视。生活，就是知道自己的价值，自己所能做到的与自己所应该做到的。生活，就是理智。——雨果</p>

</blockquote>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>没啥好说的，就是，我又双叒叕要搬家了。<strong>起因就是因为，最近要涨房租</strong><br>与其不如涨价，反正都是涨，我寻思干脆住远一点，直接自己住得了。<br>以前搬家，稍微不那么简单一点，自己会花好长时间去收拾一下。收拾呢，其实也就是找一堆纸箱子，完了去打包收纳而已。<br>在过往的收纳经验来看，最后的结论就是：<strong>大件的我能知道，放到具体哪个里面了。但是，小件，emm，死活最后就铁定不知道在什么地方了。</strong>最真实的可能就是，在日后的生活过程中，扒拉扒拉找些东西的时候，哦？原来我还有这个东西……</p>
<span id="more"></span>
<p>尤其像我，电子产品众多，小东西也是众多，搬过几次家之后，我都不知道我到底还有哪些东西被遗忘进角落了。</p>
<p>综上，这次就来一次大收纳吧。目的就一个：<strong>搬家前后，我知道我有哪些东西，并且快速准确的知道在哪个箱子里面</strong></p>
<h2 id="准备过程"><a href="#准备过程" class="headerlink" title="准备过程"></a>准备过程</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>想法其实很简单，就是日常中，拿超市为例子：超市上的每个上架货品（除了生鲜散称之外）基本都是有一个唯一的条形码，其次货架也有对应的货架编号。今天上了什么货物，要上到哪个架子上。这个是在后台一清二楚的。<br>那么换到我这次搬家场景，我要怎么做呢？</p>
<h3 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h3><p>搬家虽然不是上架售卖物品，但是在这个收纳的过程中，不也就是类似么？收纳的每个纸箱子，就是一个小“货架”，每个待收纳到纸箱子里面的物品，就是对应的一个个“商品”</p>
<h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>在需求设计之前，我需要对这个分类收纳过程中，涉及到的两个关键点分别阐述一下：</p>
<ul>
<li>分类：<ul>
<li>涉及到分类，<strong>第一个就是如何快速识别并记录下物品信息，供后续使用？</strong> 我不可能自己一个个去录入，那是一个非常庞大冗杂的事情。光打标签分类，就是一个非常繁杂的事情。</li>
<li>既然要识别：就会遇到两个场景，一种是确实有现成二维码（如物品外壳上的），还有一大类是零碎的物品怎么办？</li>
<li>有了识别信息之后，如何快速分类呢？</li>
</ul>
</li>
<li>收纳：<ul>
<li>有了分类信息之后了，怎么快速收纳？并且我还要快速准确的知道在哪个箱子里面？</li>
</ul>
</li>
</ul>
<p>其实想的有点繁琐了，其实正常收纳流程是：</p>
<ul>
<li>收纳前：先分类 -&gt; 收集物品信息 -&gt; 分类打码 -&gt; 录系统 -&gt; 收纳</li>
<li>收纳中：关联收纳物与收纳箱之间的关系</li>
<li>收纳后：就是搬家后拿东西了，<strong>反向检索</strong>物品在哪个箱子里。</li>
</ul>
<h3 id="流程初探"><a href="#流程初探" class="headerlink" title="流程初探"></a>流程初探</h3><p>针对上面的思考的若干个点，来一个个解决：</p>
<ul>
<li>快速识别：<ul>
<li>有条形码的：我选择使用 <strong>条码枪</strong> 来快速扫描，来获取条形码信息。你可能会有疑问，为什么要用条码枪？其实用手机，有很多app借助手机摄像头就能扫描，识别率都还不错。那为什么还要用呢？原因就是：<strong>我要做一个整体的收纳系统！</strong>光靠app，但是数据之间怎么实时传递，那还是有点烦人。最后决定，就是一次性投入一点，买个设备吧，日后还能经常用。</li>
<li>没有条形码零碎的：先进行初步的归纳整理，先在后台自行录入物品集合信息，再进行统一的分类并打码（做条形码），这样就能够供快速识别所需。</li>
</ul>
</li>
<li>分类：结合上面快速识别之后，会产生下面几个问题：<ul>
<li>通过条码枪扫描的物品，你拿到的就是一串数字而已，你怎么知道对应的是什么东西？知道了什么东西之后，你又要怎么去分类？<ul>
<li>扫码之前，我是知道是什么东西的，此时我就已经可以分类好了。</li>
<li>光有条码，扫完之后，我要怎么知道是什么东西？这个找到一个现成的免费的，通过条形码去检索物品信息的API接口</li>
</ul>
</li>
<li>没有条码的，这个可以在录入物品集合信息期间，自行分类好，是厨房用品，是小家电，还是衣物、鞋帽什么的。</li>
<li>做收纳箱的分配条码</li>
</ul>
</li>
<li>扫码打包<ul>
<li>遵从扫描单个或多个物品之后，最后扫描分配好的收纳箱子的二维码/条形码，进行封箱登记</li>
</ul>
</li>
<li>后台信息处理<ul>
<li>条码分配：<ul>
<li>收纳箱：前缀统一为BOX，后续分配自增序号，总长度待研究设备之后再定义修改</li>
<li>自定义物品：前缀统一为ITEM，后续分配自增序号</li>
</ul>
</li>
<li>封箱登记流程：<ul>
<li>在扫描常规正常条形码、自定义物品信息后，<del>扫描结果传送至服务器</del> 扫码枪，与pc通信是借助于一个usb收发器来完成的，传输到PC端是向PC输入窗口来实现的。</li>
<li>当扫描到统一前缀BOX的条码时，后台进行封箱登记操作：将前面的所有扫描的物品进行打包，登记当前物品所在的箱子是在当前条码箱子内</li>
</ul>
</li>
<li>统一信息处理后台：这个后台，集中处理所有物品信息，条码信息，封箱信息等后台管理平台。<h2 id="需求设计"><a href="#需求设计" class="headerlink" title="需求设计"></a>需求设计</h2>家庭收纳信息处理后台(TakeInEverything, TIE)<h3 id="技术栈选型"><a href="#技术栈选型" class="headerlink" title="技术栈选型"></a>技术栈选型</h3>一个后台，多种前端。<br>后台核心相关主要：</li>
</ul>
</li>
<li>数据库：MySQL 5.7</li>
<li>SpringBoot</li>
<li>Shrio（统一认证，权限管理等）</li>
<li>Dubbo（接入，供后续可能的服务订阅使用）</li>
<li>Zookeeper</li>
</ul>
<p>web前端：</p>
<ul>
<li>Dubbo</li>
<li>Springboot</li>
</ul>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="一期"><a href="#一期" class="headerlink" title="一期"></a>一期</h3><p>先把核心功能做出来</p>
<h4 id="后台表"><a href="#后台表" class="headerlink" title="后台表"></a>后台表</h4><ul>
<li>分类表(tie_classification)<ul>
<li>id</li>
<li>一级大类(top_sub)</li>
<li>二级小类(second_sub)</li>
<li>添加时间(create_time)</li>
<li>修改时间(update_time)</li>
<li>添加人(add_user)</li>
<li>修改人(update_user)</li>
<li>备注(remark)</li>
</ul>
</li>
<li>物品明细表(tie_item_detail)<ul>
<li>id</li>
<li>物品条码(item_barcode)</li>
<li>物品名称(item_name)</li>
<li>物品品牌(item_brand)</li>
<li>物品供应商(item_supplier)</li>
<li>物品类别(item_class)</li>
<li>添加时间(create_time)</li>
<li>修改时间(update_time)</li>
<li>添加人(add_user)</li>
<li>修改人(update_user)</li>
<li>备注(remark)</li>
</ul>
</li>
<li>收纳明细表(tie_box_detail)<ul>
<li>id</li>
<li>收纳箱条码(box_barcode)</li>
<li>收纳箱名称(box_name)</li>
<li>收纳箱描述(box_description)</li>
<li>收纳箱分类(box_class)</li>
<li>添加时间(create_time)</li>
<li>修改时间(update_time)</li>
<li>添加人(add_user)</li>
<li>修改人(update_user)</li>
<li>备注(remark)</li>
</ul>
</li>
<li>物品收纳表(tie_item_boxing)<ul>
<li>id</li>
<li>物品条码(item_barcode)</li>
<li>收纳箱条码(box_barcode)</li>
<li>收纳时间(take_in_time)</li>
<li>创建时间(create_time)</li>
</ul>
</li>
<li>收纳流水表(tie_takein_log)<ul>
<li>id</li>
<li>条码(barcode)</li>
<li>创建时间(create_time)</li>
</ul>
</li>
<li>用户信息表(tie_user_info)(TODO)<ul>
<li>id</li>
<li>用户名(username)</li>
<li>用户密码(password)</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="收纳流程"><a href="#收纳流程" class="headerlink" title="收纳流程"></a>收纳流程</h4><ol>
<li>分配</li>
<li>采集流程</li>
<li></li>
</ol>
<h2 id="落地"><a href="#落地" class="headerlink" title="落地"></a>落地</h2><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>在思考过程中，也有提到，现在采取扫描枪的方式录入信息，那么怎么快速读取信息？比如，从收纳场景来说，我怎么快速知道，当前收纳箱里面有哪些东西？<br>当前最方便的就是，通过手机来读取，那么读取的可能性就很多了。<br>通过微信小程序？通过独立App？等等</p>
<p>这个就是一个大的联动相关了，这个就需要系统的再想想。</p>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>收纳</tag>
        <tag>搬家</tag>
        <tag>条形码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java性能权威指南</title>
    <url>/post/661f391d.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="笔记实录"><a href="#笔记实录" class="headerlink" title="笔记实录"></a>笔记实录</h1><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1>]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>性能权威指南</tag>
        <tag>O&#39;Reilly</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaNIO探索</title>
    <url>/post/9c2a984.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前言中，引用著名NIO书籍《Java NIO》(Ron Hitchens)中的引言，关于NIO的。原文如下：</p>
<blockquote class="blockquote-center">
<p>Java NIO explores the new I/O capabilities of version 1.4 in detail and shows you how to put these features to work to greatly improve the efficiency of the Java code you write. This compact volume examines the typical challenges that Java programmers face with I/O and shows you how to take advantage of the capabilities of the new I/O features. You’ll learn how to put these tools to work using examples of common, real-world I/O problems and see how the new features have a direct impact on responsiveness, scalability, and reliability.</p>

</blockquote>

<p>最后一句，直接点题：<strong>see how the new features have a direct impact on responsiveness, scalability, and reliability.</strong></p>
<span id="more"></span>

<h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1>]]></content>
      <categories>
        <category>Java源码系列</category>
      </categories>
      <tags>
        <tag>Java NIO</tag>
        <tag>New I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 学习实录</title>
    <url>/post/8a72db17.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Tomcat是一个业界非常优秀的web容器框架，学习里面核心的实现机制，扩展自己的知识面还是很有必要的。每个做Java的，应该没有人没接触过Tomcat。<br>学习Tomcat，有一个核心的命题，看源码。既然要看源码，自然少不了调试，如何调试Tomcat，这里在学习极客时间相关课程中提到过一个方式，可以很好的在IDE中进行调试，那就是通过嵌入式手工创建Tomcat来进行，具体请参考如下链接教程说明以及对应的代码示例：<br><a href="https://devcenter.heroku.com/articles/create-a-java-web-application-using-embedded-tomcat">create-a-java-web-application-using-embedded-tomcat</a><br><a href="https://github.com/heroku/devcenter-embedded-tomcat">github/devcenter-embedded-tomcat</a></p>
<span id="more"></span>

<h1 id="学习实录"><a href="#学习实录" class="headerlink" title="学习实录"></a>学习实录</h1><h2 id="极客时间-深入拆解Tomcat"><a href="#极客时间-深入拆解Tomcat" class="headerlink" title="极客时间-深入拆解Tomcat"></a>极客时间-深入拆解Tomcat</h2><p><strong>注：</strong> 这个课程中使用的是Tomcat 9.x的版本，其它版本的源码可能略有不同<br>整体的架构示意图如下：<br><img data-src="8a72db17/TomcatInfrastructure.jpg" alt="Tomcat整体架构示意图"><br>从图上你可以看到，最顶层是 Server，这里的 Server 指的就是一个 Tomcat 实例。一个 Server 中有一个或者多个 Service，一个 Service 中有多个连接器和一个容器。连接器与容器之间通过标准的 ServletRequest 和 ServletResponse 通信。</p>
<h3 id="连接器（connector）"><a href="#连接器（connector）" class="headerlink" title="连接器（connector）"></a>连接器（connector）</h3><p>EndPoint 负责提供字节流给 Processor，Processor 负责提供 Tomcat Request 对象给 Adapter，Adapter 负责提供 ServletRequest 对象给容器。<br>由于 I/O 模型和应用层协议可以自由组合，比如 NIO + HTTP 或者 NIO2 + AJP。Tomcat 的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫 ProtocolHandler 的接口来封装这两种变化点。<br>整体工作示意图，如下：<br><img data-src="8a72db17/TomcatConnectorAndContainer.jpg" alt="连接器架构示意图"></p>
<h4 id="ProtocolHandler-组件"><a href="#ProtocolHandler-组件" class="headerlink" title="ProtocolHandler 组件"></a>ProtocolHandler 组件</h4><p>连接器用 ProtocolHandler 来处理网络连接和应用层协议，包含了 2 个重要部件：EndPoint 和 Processor</p>
<h5 id="EndPoint"><a href="#EndPoint" class="headerlink" title="EndPoint"></a>EndPoint</h5><p>EndPoint 是通信端点，即通信监听的接口，是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 EndPoint 是用来实现 TCP/IP 协议的。</p>
<h5 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h5><p>如果说 EndPoint 是用来实现 TCP/IP 协议的，那么 Processor 用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象。</p>
<h4 id="Adapter-组件"><a href="#Adapter-组件" class="headerlink" title="Adapter 组件"></a>Adapter 组件</h4><p>ProtocolHandler 接口负责解析请求并生成 Tomcat Request 类。但是这个 Request 对象不是标准的 ServletRequest，也就意味着，<strong>不能用 Tomcat Request 作为参数来调用容器</strong>。Tomcat 设计者的解决方案是引入 CoyoteAdapter，这是适配器模式的经典运用，连接器调用 CoyoteAdapter 的 Sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest，再调用容器的 Service 方法。<br><img data-src="8a72db17/ConnectorInnerDetail.jpg" alt="连接器内部示意图"></p>
<h3 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h3><p>容器的整体架构如下：<br><img data-src="8a72db17/Containerinfrastructure.jpg" alt="Tomcat容器"><br>从图可以明显的看出相对应的层次结构</p>
<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p>Tomcat 设计了 4 种容器，分别是 Engine、Host、Context 和 Wrapper。这 4 种容器不是平行关系，而是父子关系。<br>多层容器设计的考虑：<strong>Tomcat 通过一种分层的架构，使得 Servlet 容器具有很好的灵活性。</strong><br>Context 表示一个 Web 应用程序；Wrapper 表示一个 Servlet，一个 Web 应用程序中可能会有多个 Servlet；Host 代表的是一个虚拟主机，或者说一个站点，可以给 Tomcat 配置多个虚拟主机地址，而一个虚拟主机下可以部署多个 Web 应用程序；Engine 表示引擎，用来管理多个虚拟站点，一个 Service 最多只能有一个 Engine。<br><strong>Tomcat 就是用组合模式</strong>来管理这些容器的。具体实现方法是，所有容器组件都实现了 Container 接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。这里单容器对象指的是最底层的 Wrapper，组合容器对象指的是上面的 Context、Host 或者 Engine。</p>
<h4 id="请求定位-Servlet-的过程"><a href="#请求定位-Servlet-的过程" class="headerlink" title="请求定位 Servlet 的过程"></a>请求定位 Servlet 的过程</h4><p>Tomcat 是用 Mapper 组件来完成确定请求是由哪个 Wrapper 容器里的 Servlet 来处理的<br><strong>工作原理是</strong> ：Mapper 组件里保存了 Web 应用的配置信息，其实就是容器组件与访问路径的映射关系，比如 Host 容器里配置的域名、Context 容器里的 Web 应用路径，以及 Wrapper 容器里 Servlet 映射的路径，你可以想象这些配置信息就是一个 <strong>多层次的 Map</strong>。</p>
<h4 id="工作示例"><a href="#工作示例" class="headerlink" title="工作示例"></a>工作示例</h4><p><strong>注：</strong> 在课程中说到了一个具体的示例，还是说的比较清楚。<br><img data-src="8a72db17/TomcatRequestMappingSample.jpg" alt="Tomcat请求示例一则"><br>假如有用户访问一个 URL，比如图中的<a href="http://user.shopping.com:8080/order/buy%EF%BC%8CTomcat">http://user.shopping.com:8080/order/buy，Tomcat</a> 如何将这个 URL 定位到一个 Servlet 呢？</p>
<ul>
<li>首先，根据协议和端口号选定 Service 和 Engine。</li>
<li>然后，根据域名选定 Host。</li>
<li>之后，根据 URL 路径找到 Context 组件。</li>
<li>最后，根据 URL 路径找到 Wrapper（Servlet）。</li>
</ul>
<p>那么这个调用过程是使用 Pipeline-Valve 管道来实现的。而这个Valve是通过<strong>责任链设计模式</strong>来实现的，Valve就类比于一个Filter中的一环，而Pipeline就是将各个Valve串起来的类。<br>Valve关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Valve <span class="title function_">getNext</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve valve)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pipline关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pipeline</span> <span class="keyword">extends</span> <span class="title class_">Contained</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValve</span><span class="params">(Valve valve)</span>;</span><br><span class="line">  <span class="keyword">public</span> Valve <span class="title function_">getBasic</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasic</span><span class="params">(Valve valve)</span>;</span><br><span class="line">  <span class="keyword">public</span> Valve <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pipeline 中有 addValve 方法。Pipeline 中维护了 Valve 链表，Valve 可以插入到 Pipeline 中，对请求做某些处理。我们还发现 Pipeline 中没有 invoke 方法，因为整个调用链的触发是 Valve 来完成的，Valve 完成自己的处理后，调用 getNext.invoke() 来触发下一个 Valve 调用。<br><strong>注：</strong> 由上面看来就是一种完整的责任链设计模式的实现<br>至此，看清楚了每一个容器都有一个 Pipeline 对象，只要触发这个 Pipeline 的第一个 Valve，这个容器里 Pipeline 中的 Valve 就都会被调用到。<strong>但是，不同容器的 Pipeline 是怎么链式触发的呢，比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline。</strong><br>这是因为 Pipeline 中还有个 <code>getBasic</code> 方法。这个 <code>BasicValve</code> 处于 Valve 链表的末端，它是 Pipeline 中必不可少的一个 Valve，负责调用下层容器的 Pipeline 里的第一个 Valve。如下图所示：<br><img data-src="8a72db17/PipelineVavleWithChainOfResponsibility.jpg" alt="请求Servlet寻址过程中不同容器的Pipeline-Valve调用过程示例"></p>
<p>还有一个问题：<strong>Valve 和 Filter 有什么区别吗？</strong></p>
<ul>
<li>Valve 是 Tomcat 的私有机制，与 Tomcat 的基础架构 /API 是紧耦合的。Servlet API 是公有的标准，所有的 Web 容器包括 Jetty 都支持 Filter 机制。</li>
<li>Valve 工作在 Web 容器级别，拦截所有应用的请求；而 Servlet Filter 工作在应用级别，只能拦截某个 Web 应用的所有请求。如果想做整个 Web 容器的拦截器，必须通过 Valve 来实现。</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img data-src="8a72db17/TomcatModuleDependency.jpg" alt="调用静态流程图"><br>上面这张图描述了组件之间的静态关系，如果想让一个系统能够对外提供服务，我们需要创建、组装并启动这些组件；在服务停止的时候，我们还需要释放资源，销毁这些组件，因此这是一个动态的过程。也就是说，Tomcat 需要动态地管理这些组件的生命周期。<br>我们把不变点抽象出来成为一个接口，这个接口跟生命周期有关，叫作 LifeCycle。LifeCycle 接口里应该定义这么几个方法：init()、start()、stop() 和 destroy()，每个具体的组件去实现这些方法。<br>在父组件的 init() 方法里需要创建子组件并调用子组件的 init() 方法。同样，在父组件的 start() 方法里也需要调用子组件的 start() 方法，因此调用者可以无差别的调用各组件的 init() 方法和 start() 方法，这就是 <strong>组合模式</strong>的使用，并且只要调用最顶层组件，也就是 Server 组件的 init() 和 start() 方法，整个 Tomcat 就被启动起来了。<br>LifeCycle接口定义：<br><img data-src="8a72db17/LifeCycleInterfaceDefinition.jpg" alt="LifeCycle接口定义类图"></p>
<h3 id="LifeCycle-事件"><a href="#LifeCycle-事件" class="headerlink" title="LifeCycle 事件"></a>LifeCycle 事件</h3><p>果将来需要增加新的逻辑，直接修改 start() 方法？这样会违反开闭原则，那如何解决这个问题呢？开闭原则说的是为了扩展系统的功能，你不能直接修改系统中已有的类，但是你可以定义新的类。<br>组件的 init() 和 start() 调用是由它的父组件的状态变化触发的，上层组件的初始化会触发子组件的初始化，上层组件的启动会触发子组件的启动，因此我们把组件的生命周期定义成<strong>一个个状态</strong>，把状态的转变看作是一个事件。而事件是有监听器的，在监听器里可以实现一些逻辑，并且监听器也可以方便的添加和删除，这就是典型的<strong>观察者模式。</strong><br>具体来说就是在 LifeCycle 接口里加入两个方法：添加监听器和删除监听器。除此之外，我们还需要定义一个 Enum 来表示组件有哪些状态，以及处在什么状态会触发什么样的事件。因此 LifeCycle 接口和 LifeCycleState 就定义成了下面这样。<br><img data-src="8a72db17/LifeCycleInterfaceDefinitionWithStateEnumeration.jpg" alt="LifeCycle接口带状态观察模式"></p>
<h3 id="重用性：LifeCycleBase-抽象基类"><a href="#重用性：LifeCycleBase-抽象基类" class="headerlink" title="重用性：LifeCycleBase 抽象基类"></a>重用性：LifeCycleBase 抽象基类</h3><p>回到 LifeCycle 接口，Tomcat 定义一个基类 <code>LifeCycleBase</code> 来实现 LifeCycle 接口，把一些公共的逻辑放到基类中去，比如生命状态的转变与维护、生命事件的触发以及监听器的添加和删除等，而子类就负责实现自己的初始化、启动和停止等方法。为了避免跟基类中的方法同名，我们把具体子类的实现方法改个名字，在后面加上 Internal，叫 initInternal()、startInternal() 等。我们再来看引入了基类 <code>LifeCycleBase</code> 后的类图：<br><img data-src="8a72db17/LifeCycleInterfaceDefinitionWithBaseClass.jpg" alt="LifeCycle接口抽象继承模板设计模式"><br>其中LifeCycleBase 的 init() 方法实现，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">    <span class="comment">//1. 状态检查</span></span><br><span class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">        invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2. 触发 INITIALIZING 事件的监听器</span></span><br><span class="line">        setStateInternal(LifecycleState.INITIALIZING, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 调用具体子类的初始化方法</span></span><br><span class="line">        initInternal();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 触发 INITIALIZED 事件的监听器</span></span><br><span class="line">        setStateInternal(LifecycleState.INITIALIZED, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tomcat启动剖析"><a href="#Tomcat启动剖析" class="headerlink" title="Tomcat启动剖析"></a>Tomcat启动剖析</h3><p>我们可以通过 Tomcat 的 /bin 目录下的脚本 startup.sh 来启动 Tomcat，那你是否知道我们执行了这个脚本后发生了什么呢？来看看下面一张图：<br><img data-src="8a72db17/TomcatStartUpProcedure.jpg" alt="Tomcat启动流程"></p>
<ul>
<li>Tomcat 本质上是一个 Java 程序，因此 startup.sh 脚本会启动一个 JVM 来运行 Tomcat 的启动类 Bootstrap。</li>
<li>Bootstrap 的主要任务是初始化 Tomcat 的类加载器（自己实现的类加载器，在官方发行版的Tomcat/bin目录下），并且创建 Catalina。</li>
<li>Catalina 是一个启动类，它通过解析 server.xml、创建相应的组件，并调用 Server 的 start 方法。</li>
<li>Server 组件的职责就是管理 Service 组件，它会负责调用 Service 的 start 方法。</li>
<li>Service 组件的职责就是管理连接器和顶层容器 Engine，因此它会调用连接器和 Engine 的 start 方法。</li>
</ul>
<h4 id="Catalina"><a href="#Catalina" class="headerlink" title="Catalina"></a>Catalina</h4><p>Catalina 的主要任务就是创建 Server，它不是直接 new 一个 Server 实例就完事了，而是需要解析 server.xml，把在 server.xml 里配置的各种组件一一创建出来，接着调用 Server 组件的 init 方法和 start 方法，这样整个 Tomcat 就启动起来了。作为“管理者”，Catalina 还需要处理各种“异常”情况，比如当我们通过“Ctrl + C”关闭 Tomcat 时，Tomcat 将如何优雅的停止并且清理资源呢？因此 Catalina 在 JVM 中注册一个“关闭钩子”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 如果持有的 Server 实例为空，就解析 server.xml 创建出来</span></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="literal">null</span>) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 如果创建失败，报错退出</span></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">&quot;catalina.noServer&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3. 启动 Server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建并注册关闭钩子</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="literal">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> <span class="title class_">CatalinaShutdownHook</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用 await 方法监听停止请求</span></span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭钩子</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">CatalinaShutdownHook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getServer() != <span class="literal">null</span>) &#123;</span><br><span class="line">                Catalina.<span class="built_in">this</span>.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这段代码中你可以看到，Tomcat 的“关闭钩子”实际上就执行了 Server 的 stop 方法，Server 的 stop 方法会释放和清理所有的资源。</p>
<h4 id="Server-组件"><a href="#Server-组件" class="headerlink" title="Server 组件"></a>Server 组件</h4><p>Server 组件的具体实现类是 StandardServer。Server 继承了 LifeCycleBase，它的生命周期被统一管理，并且它的子组件是 Service，因此它还需要管理 Service 的生命周期，也就是说在启动时调用 Service 组件的启动方法，在停止时调用它们的停止方法。Server 在内部维护了若干 Service 组件，它是以数组来保存的，那 Server 是如何添加一个 Service 到数组中的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    service.setServer(<span class="built_in">this</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">synchronized</span> (servicesLock) &#123;</span><br><span class="line">        <span class="comment">// 创建一个长度 +1 的新数组</span></span><br><span class="line">        Service results[] = <span class="keyword">new</span> <span class="title class_">Service</span>[services.length + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将老的数据复制过去</span></span><br><span class="line">        System.arraycopy(services, <span class="number">0</span>, results, <span class="number">0</span>, services.length);</span><br><span class="line">        results[services.length] = service;</span><br><span class="line">        services = results;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 启动 Service 组件</span></span><br><span class="line">        <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                service.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 触发监听事件</span></span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;service&quot;</span>, <span class="literal">null</span>, service);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 Caralina 的启动方法的最后一行代码就是调用了 Server 的 <code>await</code> 方法。在 await 方法里会创建一个 Socket 监听 8005 端口，并在一个<strong>死循环</strong>里接收 Socket 上的连接请求，如果有新的连接到来就建立连接，然后从 Socket 中读取数据；如果读到的数据是停止命令“SHUTDOWN”，就退出循环，进入 stop 流程。</p>
<h4 id="Service-组件"><a href="#Service-组件" class="headerlink" title="Service 组件"></a>Service 组件</h4><p>Service 组件的具体实现类是 StandardService，核心代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardService</span> <span class="keyword">extends</span> <span class="title class_">LifecycleBase</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Server 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 连接器数组</span></span><br><span class="line">    <span class="keyword">protected</span> Connector connectors[] = <span class="keyword">new</span> <span class="title class_">Connector</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">connectorsLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对应的 Engine 容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Engine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 映射器及其监听器</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Mapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mapper</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">MapperListener</span> <span class="variable">mapperListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperListener</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么还有一个 MapperListener？</strong>这是因为 Tomcat 支持热部署，当 Web 应用的部署发生变化时，Mapper 中的映射信息也要跟着变化，MapperListener 就是一个监听器，它监听容器的变化，并把信息更新到 Mapper 中，这是典型的<strong>观察者模式。</strong><br>作为“管理”角色的组件，最重要的是维护其他组件的生命周期。此外在启动各种组件时，要注意它们的依赖关系，也就是说，要注意启动的顺序。 Service 启动方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//1. 触发启动监听器</span></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//2. 先启动 Engine，Engine 会启动它子容器</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (engine) &#123;</span><br><span class="line">            engine.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 再启动 Mapper 监听器</span></span><br><span class="line">    mapperListener.start();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4. 最后启动连接器，连接器会启动它子组件，比如 Endpoint</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector: connectors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">                connector.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Engine-组件"><a href="#Engine-组件" class="headerlink" title="Engine 组件"></a>Engine 组件</h4><p>Engine 本质是一个容器，因此它继承了 ContainerBase 基类，并且实现了 Engine 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardEngine</span> <span class="keyword">extends</span> <span class="title class_">ContainerBase</span> <span class="keyword">implements</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Engine 的子容器是 Host，所以它持有了一个 Host 容器的数组，这些功能都被抽象到了 ContainerBase 中，ContainerBase 中有这样一个数据结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HashMap&lt;String, Container&gt; children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>ContainerBase 用 HashMap 保存了它的子容器，并且 ContainerBase 还实现了子容器的“增删改查”，甚至连子组件的启动和停止都提供了默认实现，比如 ContainerBase 会用专门的线程池来启动子容器。如下面代码片段所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">   results.add(startStopExecutor.submit(<span class="keyword">new</span> <span class="title class_">StartChild</span>(children[i])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Engine 容器的ValveBase定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StandardEngineValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 拿到请求中的 Host 容器</span></span><br><span class="line">      <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> request.getHost();</span><br><span class="line">      <span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 调用 Host 容器中的 Pipeline 中的第一个 Valve</span></span><br><span class="line">      host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个基础阀实现非常简单，就是把请求转发到 Host 容器。你可能好奇，从代码中可以看到，处理请求的 Host 容器对象是从请求中拿到的，请求对象中怎么会有 Host 容器呢？这是因为请求到达 Engine 容器中之前，Mapper 组件已经对请求进行了路由处理，Mapper 组件通过请求的 URL 定位了相应的容器，并且把容器对象保存到了请求对象中。</p>
<h3 id="NioEndpoint-组件"><a href="#NioEndpoint-组件" class="headerlink" title="NioEndpoint 组件"></a>NioEndpoint 组件</h3><h2 id="Tomcat架构解析-刘光瑞"><a href="#Tomcat架构解析-刘光瑞" class="headerlink" title="Tomcat架构解析-刘光瑞"></a>Tomcat架构解析-刘光瑞</h2><p>这本书基于8.5.x介绍的，里面包含很多高级特性，值得阅读</p>
<h3 id="tomcat介绍"><a href="#tomcat介绍" class="headerlink" title="tomcat介绍"></a>tomcat介绍</h3><p>Tomcat运行目录介绍：<br><img data-src="8a72db17/tomcat_config_path.png" alt="Tomcat目录说明"></p>
<h4 id="8-5之后的一些新特性"><a href="#8-5之后的一些新特性" class="headerlink" title="8.5之后的一些新特性"></a>8.5之后的一些新特性</h4><h3 id="Tomcat-整体架构"><a href="#Tomcat-整体架构" class="headerlink" title="Tomcat 整体架构"></a>Tomcat 整体架构</h3><p><strong>注：</strong> 这个章节介绍了，Tomcat整体的架构设计，分别列出了几个核心组件以及相关核心设计</p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><h4 id="Connector-amp-Container"><a href="#Connector-amp-Container" class="headerlink" title="Connector &amp; Container"></a>Connector &amp; Container</h4><h5 id="Container设计"><a href="#Container设计" class="headerlink" title="Container设计"></a>Container设计</h5><h4 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h4><h4 id="Pipeline-amp-Valve"><a href="#Pipeline-amp-Valve" class="headerlink" title="Pipeline &amp; Valve"></a>Pipeline &amp; Valve</h4><p>在增强组件的灵活性和可扩展方面，<strong>责任链模式</strong> 是一种比较好的选择。在Tomcat中每个Container组件通过执行一个责任链来完成具体的请求处理。<br>Tomcat定义了Pipeline（管道）和Valve（阈）两个接口。<em>前者用于构造责任链，后者代表责任链上的每个处理器。</em></p>
<h4 id="Connector设计"><a href="#Connector设计" class="headerlink" title="Connector设计"></a>Connector设计</h4><h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><h4 id="Bootstrap-amp-Catalina"><a href="#Bootstrap-amp-Catalina" class="headerlink" title="Bootstrap &amp; Catalina"></a>Bootstrap &amp; Catalina</h4><h4 id="Tomcat启动"><a href="#Tomcat启动" class="headerlink" title="Tomcat启动"></a>Tomcat启动</h4><p>Tomcat应用启动该过程非常标准化，统一按照生命周期管理接口Lifecycle的定义进行启动，首先通过调用init方法进行组件的逐级初始化，然后在调用start方法进行启动。<br><img data-src="8a72db17/tomcat_start_sequence.png" alt="应用服务器启动"></p>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发包探究</title>
    <url>/post/9f02a2a0.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="CompleteableFuture"><a href="#CompleteableFuture" class="headerlink" title="CompleteableFuture"></a>CompleteableFuture</h1><h1 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h1><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1>]]></content>
      <categories>
        <category>Java源码系列</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
        <tag>Java8新特性</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Final Cut Pro X 10.1非线性编辑高级教程</title>
    <url>/post/17b99938.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>早些时候买的一本书，一直没怎么看。今天粗略的看了一下，确实要比市面上，在视频网站上看到的教程更为细致，更为精准。<br>在B站上看过一些视频，所谓的教程视频，要么蜻蜓点水，要么就非常过于功利！你看完之后，可能还是一头雾水。<br>这本书不同，主要是通过实战练习的方式，一点一点的来学习。这也是很多做的视频教程中所极度缺失的，点可能介绍到了，但是练习的地方很少，导致你即便跟着上手学，可能最后还是一头雾水。</p>
<h2 id="粗看书本笔录"><a href="#粗看书本笔录" class="headerlink" title="粗看书本笔录"></a>粗看书本笔录</h2><p>这一节中主要罗列出书本中，除去练习之外，重要的知识点，记录下来备查。</p>
<span id="more"></span>

<h3 id="第三章-整理片段"><a href="#第三章-整理片段" class="headerlink" title="第三章-整理片段"></a>第三章-整理片段</h3><p>在这一章中，主要介绍的是告诉你，如何进阶的去整理你的大量的素材。这些在前期新手阶段可能不是重点，但是随着时间的推移，肯定是需要的，不然你的剪辑效率可能会随着时间的推移，直线下降的。这章主要内容就是这些。</p>
<h4 id="关键词使用"><a href="#关键词使用" class="headerlink" title="关键词使用"></a>关键词使用</h4><p>关键词可以使用到片段上，通过关键词可以减少你搜索该片段的时间。选择合适的关键词可以帮助你定位所有与之关联的素材内容。但是，如果一个关键词过于独特，仅仅能翻译出单独某一个素材片段的一点点内容的时候，则不建议通过关键词直接定位，而是通过修改文件名效率反而高一点。例如，包含一架直升机从起飞到降落的全过程，就可以分配以下3个关键词：</p>
<ul>
<li>直升机：应用到整个片段上</li>
<li>起飞：仅仅应用到片段开始的部分中</li>
<li>降落：仅仅应用到片段结束的部分</li>
</ul>
<p><strong>在分配关键词的时候</strong>，不同的关键词所覆盖的片段内容 <strong>也是可以叠加的</strong></p>
<h3 id="第四章-前期剪辑"><a href="#第四章-前期剪辑" class="headerlink" title="第四章-前期剪辑"></a>第四章-前期剪辑</h3><p>B-roll有时候也被称之为 <strong>切出镜头</strong>，它可以帮助你很自然地中断主要故事情节上的画面，隐藏主要故事情节中片段上的跳剪，以及音频的过度。一段不错的B-roll片段中也可以包含高质量的、自然的音频。</p>
<h3 id="剪辑的修改"><a href="#剪辑的修改" class="headerlink" title="剪辑的修改"></a>剪辑的修改</h3><h3 id="精剪"><a href="#精剪" class="headerlink" title="精剪"></a>精剪</h3><h4 id="片段的重新定时"><a href="#片段的重新定时" class="headerlink" title="片段的重新定时"></a>片段的重新定时</h4><ul>
<li>变速效果可以满足一个项目制作过程中多种多样的诉求。</li>
<li>添加变速效果要遵循故事情节的实际要求，否则它会影响观众对故事本身的理解。</li>
</ul>
<h3 id="完成剪辑"><a href="#完成剪辑" class="headerlink" title="完成剪辑"></a>完成剪辑</h3><h2 id="精练习记录"><a href="#精练习记录" class="headerlink" title="精练习记录"></a>精练习记录</h2>]]></content>
      <categories>
        <category>影视后期</category>
      </categories>
      <tags>
        <tag>剪辑工具</tag>
        <tag>视频剪辑</tag>
      </tags>
  </entry>
  <entry>
    <title>美国摄影师用光教程实录</title>
    <url>/post/65136455.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最早看到这本书是从B站的大马猫本老师那边看到的，在先前的某期视频中，推荐的一本书。立马买了这本书的实体书，看了一点点确实不错，能学到不少关于光线的知识。于是乎，随手记录一下，供日后翻阅查看。</p>
<span id="more"></span>

<h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><ul>
<li>用光是摄影的语言</li>
<li>用光的重要原理是能够遇见光线的效果</li>
</ul>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h3 id="第四章-表现物体的表面"><a href="#第四章-表现物体的表面" class="headerlink" title="第四章 表现物体的表面"></a>第四章 表现物体的表面</h3><h4 id="摄影师的处理工作"><a href="#摄影师的处理工作" class="headerlink" title="摄影师的处理工作"></a>摄影师的处理工作</h4><ul>
<li>摄影用光主要对付两种极端情况：高光和阴影。高光和阴影共同表现物体的构成、外形和立体感。</li>
<li>用光的第一步是观察场景中的被摄对象，确定是何种反射造成了被摄物体的特定外形。下一步是确定光源、被摄体和照相机的位置，以便很好地利用某种反射而将其它两种反射的影响造成最低。</li>
</ul>
<h4 id="利用漫反射"><a href="#利用漫反射" class="headerlink" title="利用漫反射"></a>利用漫反射</h4><ul>
<li>漫反射能够使我们了解被摄物体的明暗程度。</li>
<li>漫反射并不能告诉我们更多有关被摄物体<strong>材质</strong>的信息</li>
</ul>
<h4 id="基本规则的奏效与失效"><a href="#基本规则的奏效与失效" class="headerlink" title="基本规则的奏效与失效"></a>基本规则的奏效与失效</h4><ul>
<li>通常灯光放置在与原作成45度角的位置，这是一个通常能奏效的基本规则，但也不能总是奏效。<strong>能够利用的照明角度取决于照相机和被摄物体之间的距离以及所选用的镜头焦距。</strong></li>
</ul>
<h4 id="光源的距离"><a href="#光源的距离" class="headerlink" title="光源的距离"></a>光源的距离</h4><ul>
<li>小角度照明能够避免直接反射，但是如果不谨慎处理，极有可能产生不均匀的照明。入下图所示：<br><img data-src="65136455/IMG_2353.jpeg" alt="不均匀照明的事例"></li>
<li>解决这个问题的唯一方法是尽可能使光源距被摄物体对象远一些。实践中，我们通常无需将光源设置太远便能获得满意的效果</li>
</ul>
<h4 id="克服布光难题"><a href="#克服布光难题" class="headerlink" title="克服布光难题"></a>克服布光难题</h4><p>在光线距离与角度上，可以见的，理想的状态是在一个比较宽敞的工作室中完成，但是实际上可能并非如此：</p>
<ul>
<li>我们看到的原作表面的“炫光”是直接反射和漫反射的混合体</li>
<li>镜头前的偏振镜能够消除偏振反射</li>
<li>对于难以布光的工作环境，其解决方案是将光源靠近相机光轴以取得均匀照明，同时使用偏振镜消除眩光。光源前的偏振滤光片的轴线指向相机，而镜头偏振镜的轴线应与光源偏振片的轴线垂直。<br>注：书中的这个事例，用了两个偏振，一个在镜头前，一个在光源。个人觉得，如果不是那么苛刻，镜头前就够了。<br>书中也有相应较为专业的解释<h5 id="如何使用光源偏振片"><a href="#如何使用光源偏振片" class="headerlink" title="如何使用光源偏振片"></a>如何使用光源偏振片</h5>将光源变成偏振光会带来严重的缺陷，因此无论何时均应尽量避免使用。我们有意识地把难以布光的翻拍问题作为较为少见的案例之一，在这个案例中将光源变成偏振光是唯一可行的办法。</li>
<li>在实践中，由于偏振镜具有较深的中性密度，实际曝光损失可能会达到4-6档</li>
<li>在其它不翻拍的情况下，由于灯光可能会因为透过柔光材料而受到损失，致使问题更加严重。</li>
<li>亮度下降，光圈可能要相应的开得更大，导致无法获得足够的景深；或者曝光时间过长，导致<strong>互易率失效</strong>造成计算困难，并且照相机或被摄物体的抖动越来越难以避免。</li>
</ul>
<h4 id="通过漫反射和阴影表现质感"><a href="#通过漫反射和阴影表现质感" class="headerlink" title="通过漫反射和阴影表现质感"></a>通过漫反射和阴影表现质感</h4><ul>
<li>我们知道光照下的所有物体都会产生漫反射，并且理想的其亮度与照明角度无关。</li>
<li><strong>小型光源</strong>以很低的角度照射被摄物体时能产生反差强烈的高光和阴影，它们对于表现中、低影调被摄体的质感时必不可少的。</li>
<li>侧光能够在纹理颗粒的一侧形成阴影，另一侧产生漫反射高光，我们就是运用这种方式来表现海绵表面的细节。<br>事例：<br><img data-src="65136455/IMG_2354.jpeg" alt="表现质感1"><br><img data-src="65136455/IMG_2355.jpeg" alt="表现质感2"><br><img data-src="65136455/IMG_2356.jpeg" alt="打光示意图"></li>
</ul>
<h4 id="利用直接反射"><a href="#利用直接反射" class="headerlink" title="利用直接反射"></a>利用直接反射</h4><p>在黑色皮面笔记本，利用大而柔和的直接反射，从而表现出皮革的纹理。</p>
<h4 id="表现复杂的表面"><a href="#表现复杂的表面" class="headerlink" title="表现复杂的表面"></a>表现复杂的表面</h4><ul>
<li>复杂表面来描述同时需要漫反射和直接反射才能得到准确的表现的单独表面。直接反射只能够告诉观者木头表面时光滑的，而漫反射则是表现光滑表面下色彩和质感的关键因素。<br>打光示意图：<br><img data-src="65136455/IMG_2357.jpeg" alt="直射反射的打光示意图"></li>
</ul>
]]></content>
      <categories>
        <category>摄影摄像</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>用光</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo学习</title>
    <url>/post/9cb1e15.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="Dubbo核心架构"><a href="#Dubbo核心架构" class="headerlink" title="Dubbo核心架构"></a>Dubbo核心架构</h3><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>RPC</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>一则关于MySQL分区表索引的探索</title>
    <url>/post/c58ba19c.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在工作工程中遇到一个关于MySQL分区表索引的问题</p>
<h2 id="研究过程"><a href="#研究过程" class="headerlink" title="研究过程"></a>研究过程</h2><h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test_a` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `col` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`,`create_time`),</span><br><span class="line">  KEY `index_create_time` (`create_time`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="comment">/*!50500 PARTITION BY RANGE  COLUMNS(create_time)</span></span><br><span class="line"><span class="comment">(PARTITION p1 VALUES LESS THAN (&#x27;20210223&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p2 VALUES LESS THAN (&#x27;20210224&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p3 VALUES LESS THAN (&#x27;20210225&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p4 VALUES LESS THAN (&#x27;20210226&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p5 VALUES LESS THAN (&#x27;20210227&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p6 VALUES LESS THAN (&#x27;20210228&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p7 VALUES LESS THAN (&#x27;20210301&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p8 VALUES LESS THAN (&#x27;20210302&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p9 VALUES LESS THAN (&#x27;20210303&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p10 VALUES LESS THAN (&#x27;20210304&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p11 VALUES LESS THAN (&#x27;20210305&#x27;) ENGINE = InnoDB) */</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test_b` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `col` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`,`create_time`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="comment">/*!50500 PARTITION BY RANGE  COLUMNS(create_time)</span></span><br><span class="line"><span class="comment">(PARTITION p1 VALUES LESS THAN (&#x27;20210223&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p2 VALUES LESS THAN (&#x27;20210224&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p3 VALUES LESS THAN (&#x27;20210225&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p4 VALUES LESS THAN (&#x27;20210226&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p5 VALUES LESS THAN (&#x27;20210227&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p6 VALUES LESS THAN (&#x27;20210228&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p7 VALUES LESS THAN (&#x27;20210301&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p8 VALUES LESS THAN (&#x27;20210302&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p9 VALUES LESS THAN (&#x27;20210303&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p10 VALUES LESS THAN (&#x27;20210304&#x27;) ENGINE = InnoDB,</span></span><br><span class="line"><span class="comment"> PARTITION p11 VALUES LESS THAN (&#x27;20210305&#x27;) ENGINE = InnoDB) */</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
      <categories>
        <category>数据相关</category>
      </categories>
      <tags>
        <tag>MySQL - 关系型数据库 - 索引 - 分区表</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo与TravisCI持续集成</title>
    <url>/post/e62993b1.html</url>
    <content><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>由于TravisCI不论公有开始私有仓库开启收费模式了，故而我选择放弃。<br>本博客相关全部交付<strong>GitHub Actions</strong>自行托管编译了，相关教程请站内搜索GitHub Actions即可</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Hexo个人博客满打满算也算是建站有2~3年了，原先自己的写作的方式是：</p>
<ul>
<li>有多平台协作的软件：例如为知笔记、iOS自带的备忘录、OneNote等等，这些多平台协作的软件，供自己日常写稿子所需。</li>
<li>一个平台编译发布：家中的Windows台式机</li>
<li>整个Hexo工程目录丢在OneDrive中同步</li>
</ul>
<p>这样的模式，存在几个问题：</p>
<ul>
<li>协作协作并不方便，其实根本没有做到随时随地编写发布到博客网站的可能</li>
<li>一个平台编译：多平台编译其实可以，但是存在问题的是，也是之前碰到过的一种情况。<br>我在自己办公windows的备机上也搭建了Hexo环境，也能编译。也登录了同步OneDrive账号，同步了Hexo工程目录。也能编译，也能发布。但是由于某天，不知道什么鬼原因，两台电脑同步出了问题，导致OneDrive自己给所有文件通通重命名了，所有文件名称中加入了计算机名称，这个让我抓狂的。<br>后来就是全部删了，重新hexo init，重新搞了一遍。</li>
<li>跨平台可能未必行：在windows编译的，跑到Mac或者Linux环境下编译，能不能搞定，这个还没试过。不过也能可想而知，会出奇怪的问题。</li>
</ul>
<h3 id="为啥我选择了TravisCI"><a href="#为啥我选择了TravisCI" class="headerlink" title="为啥我选择了TravisCI"></a>为啥我选择了TravisCI</h3><p>也正是因为上述主要的三个问题，导致了，必须得更新同步方式。原先想，自己在家中的服务器上，搭建编译环境，也不是不可以，说白了也就是写一个Shell脚本嘛。不过后来放弃了，<strong>最主要的一个问题是：文章怎么同步？</strong> 我换电脑，写的东西怎么同步到环境里？更别说，如果要用手机呢？<br>后来，在百度和Google找来找去，发现很多提到的一个持续集成的工具TravisCI。<br>在英文版的Hexo官网中，提到了很多现在一键部署的方式，有兴趣可以点击下方传送门：<br><a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>文中并没有提及相关git操作的命令，如果你还不是很熟悉，请请自行查找相关知识</li>
<li>本文是针对已经对hexo使用相对熟悉的哈，如果你还未从未接触过hexo，请先了解一下hexo。</li>
<li><strong>如果未来</strong>你发现按照我的方法集成有问题，不排除可能有语法更新了，组件更新了。如果你有疑问，可以在评论区留言，或者通过Email联系我，我第一时间有空的话，会帮你解答疑问。</li>
</ul>
<h2 id="前置须知"><a href="#前置须知" class="headerlink" title="前置须知"></a>前置须知</h2><h3 id="关于TravisCI"><a href="#关于TravisCI" class="headerlink" title="关于TravisCI"></a>关于TravisCI</h3><p>一句话解释Travis CI干嘛的，说白了就是一个在线编译环境，如果你玩过Jekins，这玩意儿就很好懂了。具体细节，真的建议，看官方文档就好。<br><a href="https://docs.travis-ci.com/">https://docs.travis-ci.com/</a><br>挑一个你了解的开发语言，如Java、Python什么的，去看看示例就好了。<br><img data-src="e62993b1/bg2017121901.png" alt="官网logo"><br>灵性的大胡子，哈哈哈哈</p>
<h3 id="关于我的站点结构"><a href="#关于我的站点结构" class="headerlink" title="关于我的站点结构"></a>关于我的站点结构</h3><ul>
<li>文章托管自然是GitHub，仓库的名字就是：nimbusking.github.io。PS：别折腾自定义的仓库名字了，你要是改了，后面又要折腾不少配置，尤其是绑定了自定义域名的。</li>
<li>绑定了一个自己的主站域名，就是你所见到的。</li>
<li>主站开启了HTTPS，没自己折腾Nginx，于是我交给了<a href="https://www.netlify.com/">Netlify</a>托管，Netlify证书是通过Let’s Encrypt自签的。严格意义上说，现在我的文章都是部署在Netlify的.</li>
<li>域名DNS解析绑到了DNSPOD</li>
<li>无CDN（未来也不会加，理由不解释）</li>
<li>Hexo主题用的是<a href="https://github.com/next-theme/hexo-theme-next">NexT</a>，版本8.2.1，新版本仓库已经迁移了，集成到npm了，而且主要使用了Numjucks<br>以上就是主要的一些情况的补充说明</li>
<li>Hexo版本默认用的是最新的版本（直接由npm安装了）</li>
<li>NodeJS由于沿用自己最初在Windows平台编译的版本，使用的12。</li>
</ul>
<h3 id="关于Hexo与TravisCI集成"><a href="#关于Hexo与TravisCI集成" class="headerlink" title="关于Hexo与TravisCI集成"></a>关于Hexo与TravisCI集成</h3><p>折腾了，差不多1天吧，才搞通了。中间在一个问题上纠结了很久，把遇到的主要情况，先行说明一下。<br>网上百度和Google中搜了很多，很多都试了，都是不行，无法编译通过。主要编译不通过的，放在下文的插曲中有相关说明。后来不经意在，Hexo韩文官网下藏了一篇关于TravisCI集成的文章（很奇怪，为毛英文主站没有？还好Google收录了，让我搜到了）。<br>文章地址：<a href="https://hexo.io/ko/docs/github-pages.html">https://hexo.io/ko/docs/github-pages.html</a><br>怕日后没了，我离线了，在附件小结中可以查看。<br>其实最主要的问题就一个：<strong>让TravisCI拉取的仓库中放哪些文件？</strong>这点很多别人的文章中，并没有明确说明，其中也不乏有误导性的文章，导致我自己也是绕了好大一个弯。<br>这点在官网的文章里，其实有详细说明的：</p>
<div class="note primary"><p>Push the files of your Hexo folder to the repository. The public/ folder is not (and should not be) uploaded by default, make sure the .gitignore file contains public/ line. The folder structure should be roughly similar to this repo, without the .gitmodules file</p>
</div>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>就是</strong>：除了public以及git相关的文件之外，全部push到仓库里。<br>你可以参考我的站点的master文章源文件目录结构：<a href="https://github.com/nimbusking/nimbusking.github.io/tree/master">https://github.com/nimbusking/nimbusking.github.io/tree/master</a></p>
<h4 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h4><p><em>有的文章中提到，只需要传.travis.yml,.config.yml,source，这三个就行了，我真心不知道那些文章中的作者提到的，是怎么hexo generate过的</em><br>我也是在这上面绕了很久，也真的这么做了，结果发现，插件什么都装了，结果到执行hexo generate的时候，死活就会报下面类似的问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Commands:</span><br><span class="line">help Get help on a command.</span><br><span class="line">init Create a new Hexo folder.</span><br><span class="line">version Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">--config Specify config file instead of using _config.yml</span><br><span class="line">--cwd Specify the CWD</span><br><span class="line">--debug Display all verbose messages in the terminal</span><br><span class="line">--draft Display draft posts</span><br><span class="line">--safe Disable all plugins and scripts</span><br><span class="line">--silent Hide output on console</span><br></pre></td></tr></table></figure>

<p>这个类似的提示，hexo没有给出具体的错误，但是结果就是呢，根本就不会生成编译后的public文件夹。后来，我自己在我本地windows上，就copy上面提到的仨文件，一模一样的遇到的提示。至此，说明这个是错误的。</p>
<p>PS：后来，我在_travis.yml，中自己建了一个临时文件夹，完了写shell命令，先hexo init一个临时目录，完了手工copy source目录以及与hexo相关的配置文件。最后，我确实搞定了，可以自动编译通过，但是问题就是，每次都是全新生成的。</p>
<p>插曲就先说到这里，具体正确的步骤，我会在下面那个集成步骤中详细说明。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><p>一个空的名为[username].github.io的仓库，其中username是你自己定义的名字</p>
<ul>
<li>上面这个仓库中，有俩分支：一个默认的master分支，一个gh-pages(你可以起别的名字，但是建议就用这个好了，官网也是这个)。</li>
<li>自定义名称可以，但是一定要记住：<strong>master分支存放博客源文件，gh-pages存放最终hexo generate生成的public文件夹下的内容</strong></li>
<li>你的这个仓库的GitHub Pages指定的分支要选择为：gh-pages，如下图所示：<br><img data-src="e62993b1/AutoCapture_2021-02-22_170448.png" alt="gh-pages"></li>
</ul>
</li>
<li><p>绑定TravisCI在线账号：现在的官网是：<a href="https://travis-ci.com/">https://travis-ci.com/</a></p>
</li>
</ul>
<h2 id="集成步骤"><a href="#集成步骤" class="headerlink" title="集成步骤"></a>集成步骤</h2><p>git clone你的那个空[username].github.io项目到本地的某个目录下</p>
<h3 id="初始化一个空项目"><a href="#初始化一个空项目" class="headerlink" title="初始化一个空项目"></a>初始化一个空项目</h3><p>没啥说的，cd到目录下，hexo init</p>
<h3 id="拷贝源文件"><a href="#拷贝源文件" class="headerlink" title="拷贝源文件"></a>拷贝源文件</h3><p>主要涉及到你之前的hexo工程中的配置文件，像我主要有两个：</p>
<ul>
<li><code>.config.yml</code></li>
<li><code>.config.next.yml</code> (next主题的配置文件)</li>
</ul>
<p>剩下就是你的source目录下所有东西</p>
<h3 id="修改配置文件中的敏感信息"><a href="#修改配置文件中的敏感信息" class="headerlink" title="修改配置文件中的敏感信息"></a>修改配置文件中的敏感信息</h3><p>主要是如果你使用了一些第三方插件，可能会有一些访问的API Token之类的东西，这部分可不能直接上传到github上，否则不久你懂的。<br>将这些敏感信息用一个变量名称代替，这些变量怎么用，后面会提到。比如，我在我的hexo里面使用了algolia搜索，那么在我的_config.yml配置文件中，则改为如下样子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># algolia_applicationID就是一个占位符，其它类似</span></span><br><span class="line"><span class="attr">algolia:</span></span><br><span class="line">  <span class="attr">applicationID:</span> <span class="string">algolia_applicationID</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="string">algolia_apiKey</span></span><br><span class="line">  <span class="attr">indexName:</span> <span class="string">algolia_indexName</span></span><br><span class="line">  <span class="attr">chunkSize:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">title</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">slug</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">path</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">content:strip</span></span><br></pre></td></tr></table></figure>

<h3 id="上传源文件到master分支"><a href="#上传源文件到master分支" class="headerlink" title="上传源文件到master分支"></a>上传源文件到master分支</h3><p>git push就是了，没什么好说的。</p>
<h3 id="生成GitHub-Token"><a href="#生成GitHub-Token" class="headerlink" title="生成GitHub Token"></a>生成GitHub Token</h3><p>这个token是为了在外部授权可以提交代码所用。<br>设置路径，访问你的GitHub主页，路径：Settings(点击你的头像右边的下拉箭头) -&gt; Developer Settings -&gt; Personal access tokens -&gt; Generate New Token，如下图所示：<br><img data-src="e62993b1/AutoCapture_2021-02-22_154729.png" alt="Generate New Token"><br><strong>注意</strong>这个token要及时复制到文本编辑器里面，下次再进来之后，就看不到了。</p>
<h3 id="配置TravisCI账号"><a href="#配置TravisCI账号" class="headerlink" title="配置TravisCI账号"></a>配置TravisCI账号</h3><p>用github授权登录之后，第一次登录travisci官网后，会让你同步仓库。你可能跟我这个不一样，第一次登录会让你去你的github中配置相关的授权信息，照着步骤操作即可。<br><img data-src="e62993b1/AutoCapture_2021-02-22_002857.jpg" alt="同步仓库信息"><br>在搜索框中键入你的仓库名称，随后点击Settings<br><img data-src="e62993b1/AutoCapture_2021-02-22_154127.png" alt="Settings页面"><br>在Settings页面中，只需要注意添加相应的变量即可。如下图所示：<br><img data-src="e62993b1/AutoCapture_2021-02-22_154416.png" alt="Settings页面"><br>我自己在这里添加了7个，其中一个GH_TOKEN就是上面在GitHub通过Generate New Token操作生成的。其余的，一个是GiTalk相关的，一个是algolia相关的。通常，其余配置保证默认即可，如果有特殊配置需求，可以阅读Travis相关的配置说明，如Cron Jobs等。<br>至此，关联上你的GitHub仓库之后，就等于加了一个钩子程序，但是在正式启用前，还缺一个重要的配置文件：<code>.travis.yml</code> ，只有配置了这个文件，才能会被Travis CI识别。</p>
<h3 id="配置-travis-yml文件"><a href="#配置-travis-yml文件" class="headerlink" title="配置.travis.yml文件"></a>配置.travis.yml文件</h3><p>这个步骤是集成TravisCI的核心，注意修改。<br>按照Hexo官网的说明，官网的配置如下：<br>PS：官网默认没有给每项配置作说明，我这里直接在下面配置文件中加上注释了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 脚本运行语言</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="comment"># NodeJS版本</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span> <span class="comment"># use nodejs v10 LTS</span></span><br><span class="line"><span class="comment"># 开启npm缓存</span></span><br><span class="line"><span class="attr">cache:</span> <span class="string">npm</span></span><br><span class="line"><span class="comment"># TravisCI监听的分支为master分支</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># build master branch only</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 这个GH_TOKEN就是在TravisCI后台设置那里添加的变量</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 远程分支</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># 本地目录</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>
<p>自己在配置的时候，发现，就这个完全已经可以成功部署了。<br><strong>注意</strong> 如果你使用的是TraivsCI自身自带的deploy命令，而且你的项目工程中，原先通过“hexo-deployer-git”插件来deploy的，那么你的hexo工程的配置文件：.config.yml中还需修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># 需要将repo给注释了</span></span><br><span class="line">  <span class="comment"># repo: git@github.com:nimbusking/nimbuskblog.git</span></span><br><span class="line">  <span class="comment"># 同时，这里的分支不要选错，hexo generate生成的最终页面，需要deploy到这个分支中</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>

<h3 id="一点不一样的修改"><a href="#一点不一样的修改" class="headerlink" title="一点不一样的修改"></a>一点不一样的修改</h3><p>先贴上我的.travis.yml配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">12</span></span><br><span class="line"><span class="attr">cache:</span> <span class="string">npm</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># build master branch only</span></span><br><span class="line"><span class="comment"># 设置缓存文件</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  <span class="comment"># hexo主题</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-theme-next</span> <span class="string">--save</span></span><br><span class="line">  <span class="comment"># deployer git 插件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line">  <span class="comment"># - npm install hexo-generator-searchdb --save</span></span><br><span class="line">  <span class="comment"># rss订阅插件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-feed</span></span><br><span class="line">  <span class="comment"># 卜算子词数统计</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-wordcount</span> <span class="string">--save</span></span><br><span class="line">  <span class="comment"># 短链</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-abbrlink</span> <span class="string">--save</span></span><br><span class="line">  <span class="comment"># 懒加载</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">lozad</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">uninstall</span> <span class="string">hexo-generator-index</span> <span class="string">--save</span></span><br><span class="line">  <span class="comment"># 置顶插件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-index-pin-top</span> <span class="string">--save</span></span><br><span class="line">  <span class="comment"># algolia搜索</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-algolia</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="comment"># 替换同目录下的_config.yml文件中github_token字符串为travis后台刚才配置的变量，注&gt;意此处sed命令用了双引号。单引号无效！</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/algolia_applicationID/$&#123;ALGOLIA_APPLICATIONID&#125;/g&quot;</span> <span class="string">./_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/algolia_apiKey/$&#123;ALGOLIA_APIKEY&#125;/g&quot;</span> <span class="string">./_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/algolia_indexName/$&#123;ALGOLIA_INDEXNAME&#125;/g&quot;</span> <span class="string">./_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/gitalk_client_id/$&#123;GITALK_CLIENT_ID&#125;/g&quot;</span> <span class="string">./_config.next.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/gitalk_client_secret/$&#123;GITALK_CLIENT_SECRET&#125;/g&quot;</span> <span class="string">./_config.next.yml</span></span><br><span class="line">  <span class="comment"># - pwd</span></span><br><span class="line">  <span class="comment"># clone自定义配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">-b</span> <span class="string">customer_config</span> <span class="string">https://github.com/nimbusking/nimbusking.github.io.git</span> <span class="string">temp</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-f</span> <span class="string">./temp/post-meta.njk</span> <span class="string">./node_modules/hexo-theme-next/layout/_partials/post</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">./temp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">algolia</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>

<p>我这里比官网默认配置多了几个东西：</p>
<ul>
<li>设置了nodejs下的node_modules缓存目录，提高编译速度</li>
<li>通过install前置步骤安装了一些必要的hexo插件</li>
<li>在执行hexo generate命令之前，通过before_script进行了相关必要替换：在这个里面就通过linux sed命令通过取到在travisci后台配置的变量替换到配置文件中。</li>
<li>最后一段git clone，是我自己在配置置顶插件之后，自己有修改相关置顶的样式。为了生效，我需要将next主题中的相关配置给替换成我自己的配置。</li>
<li>在执行了hexo generate之后，我又执行了一下hexo algolia，更新algolia索引</li>
<li>最后就是deploy，$GH_TOKEN就是从TravisCI后台获取的配置的Token值</li>
<li>如果你同样使用了 <strong>netlify托管，别忘了修改其部署的分支（如果通过现在的仓库部署方式的话）为gh-pages</strong></li>
</ul>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><h4 id="遇到Could-not-authorize-build-request错误"><a href="#遇到Could-not-authorize-build-request错误" class="headerlink" title="遇到Could not authorize build request错误"></a>遇到Could not authorize build request错误</h4><p>今天（2021-06-18）发现死活构建不了，在自己mac上push到github上，死活就没看到travis出现自动构建。又尝试手工构建了一下，结果发现怎么都失败了。提示了一个标题中遇到的错误。<br>起初还以为自己配置哪里有问题，到github的授权页面，发现token规则好像更新了，可以更新一下。于是乎又更新了一把，结果发现还是没用。<br>后来百度一下，在官网中找到了：<br>“Could not authorize build request”, usually means that the account’s subscription expired or that it ran out of trial builds.</p>
<p>到你的账户设置下，plan一栏下，看看订阅。<br>如果没有显示，需要你选择的话，那就选择免费的，免费计划，有10000点，个人用户，能构建很久了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，Hexo与TravisCI集成的步骤基本介绍完毕。目前基本完美的解决了编译平台的事情。之后就是，换了一个环境，只需要git clone分支就好了。不过有一个小小的遗憾，因为我用了短链，所以，如果我新建了一个主题文章，那么默认是不会生成短链的，只有在hexo g之后才会生成。所以。。。</p>
<p>至此不过还有个疑问，还没搞定。为什么原来只放那三文件，hexo编译不通过呢？相比现在，上传的源文件中多了如下几个：</p>
<ul>
<li>_config.landscape.yml</li>
<li>package-lock.json</li>
<li>package.json</li>
</ul>
<p>就可以了？我在我的travis.yml脚本中，并没有安装通过npm安装hexo啊，但是照样执行成功了，这是怎么做到的呢？回头可能还得去了解了解NodeJS下底层工作机制了。<br>未完待续。。。</p>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><ul>
<li><a href="e62993b1/hexo_github_pages.7z">Hexo官网中关于TravisCI集成的相关说明</a></li>
</ul>
]]></content>
      <categories>
        <category>站点</category>
      </categories>
      <tags>
        <tag>站点</tag>
        <tag>Hexo</tag>
        <tag>TravisCI</tag>
      </tags>
  </entry>
  <entry>
    <title>电影小评</title>
    <url>/post/7a56ef2a.html</url>
    <content><![CDATA[<h2 id="前篇"><a href="#前篇" class="headerlink" title="前篇"></a>前篇</h2><p>记录日常生活中，观看过的电影，做一些影评或简或杂，留存一点记忆。观看列表，多半都可以在豆瓣中搜到，其中多数不低于7分。</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>影评</tag>
        <tag>电影</tag>
        <tag>豆瓣</tag>
      </tags>
  </entry>
  <entry>
    <title>英语兔学习合集</title>
    <url>/post/d3bb2988.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇用于记录日常学习自B站UP主英语兔专题合集，记录视频中提到的知识点，一方面用于个人学习回顾，另一方面用于学习整理分享。<br>英语兔B站主页：<a href="https://space.bilibili.com/483162496">https://space.bilibili.com/483162496</a><br>文章附录会备注整个学习大纲的xmind导图文件，有需要可以直接下载。<br><strong>声明：本篇仅作为学习笔记分享，请勿挪作它用，如有商业意图，请联系英语兔本人。</strong></p>
<h3 id="摘录原因"><a href="#摘录原因" class="headerlink" title="摘录原因"></a>摘录原因</h3><p>先写一部分原因（第一印象），等完整学习完成之后，再重新回过头来填写这部分内容。</p>
<ul>
<li>发音确实纯正，很到位</li>
<li>演示文稿写的纯粹到位</li>
<li>内容程度：不是在教创新，而是将复杂内容简单化，以一种通俗易懂的方式讲授（暂时无法准确写出具体体会）</li>
</ul>
<h2 id="语法合集"><a href="#语法合集" class="headerlink" title="语法合集"></a>语法合集</h2><p>学习语法的目的：<strong>造句</strong><br><strong>英语语法的核心就是动词！</strong></p>
<span id="more"></span>

<h3 id="基本核心框架"><a href="#基本核心框架" class="headerlink" title="基本核心框架"></a>基本核心框架</h3><h4 id="简单句"><a href="#简单句" class="headerlink" title="简单句"></a>简单句</h4><p>我们将哪些长句子拆分到不能拆分的为止，将这些句子称之为“简单句”。<br>而这些简单句，多数概括为“什么+怎么样”，这俩这构成一个 <strong>句子成分（Parts of Speech）</strong></p>
<h3 id="时态合集"><a href="#时态合集" class="headerlink" title="时态合集"></a>时态合集</h3><p>我们通常所称的英语的时态，实际上准确的说是：动词的时间+动词的状态</p>
<h4 id="动词时间"><a href="#动词时间" class="headerlink" title="动词时间"></a>动词时间</h4><p>四种：过去、现在、将来、过去将来。<br>这里重点解释：过去将来，过去将来跟现在没有必然联系，可能会是下面两种情况：<br><img data-src="d3bb2988/AutoCapture_2021-02-06_221021.jpg" alt="过去将来1"><br><img data-src="d3bb2988/AutoCapture_2021-02-06_221036.jpg" alt="过去将来2"><br><strong>过去将来时间在现实中并不常见，一般只出现在从句中，而像：过去将来完成进行时态，这种纯粹就是因为英语动词有能力构成这种时态，所以也就列举出来。</strong></p>
<h4 id="动词状态"><a href="#动词状态" class="headerlink" title="动词状态"></a>动词状态</h4><ul>
<li><p>进行状态<br>中文举例：这兔子<em>正在吃</em>着胡萝卜。<br>这里的正在吃，就表示兔子这个吃胡萝卜的动作（过程）正在进行中。</p>
</li>
<li><p>完成状态<br>中文举例：这兔子<em>吃掉了</em>胡萝卜<br>这里的吃掉了，表明胡萝卜已经在兔子肚子里，吃完了，饱了。</p>
</li>
</ul>
<p><strong>注意：</strong>完成态的重点在于动作状态完成了，而并没有指出动作具体的发生时间。不管在哪种时间状态里，完成状态并不直接说明动作的具体开始时间。</p>
<ul>
<li>完成进行状态<br>中文举例：这兔子<em>从早上就开始</em>吃胡萝卜，现在<em>还没停</em>呢。<br>言下之意：不但有好多胡萝卜进了兔子肚子里，这还没玩呢，这兔子还有一堆胡萝卜没吃呢。</li>
</ul>
<p><strong>注意：</strong>表示动作的一部分完成了，但是剩下的还在进行中</p>
<ul>
<li>未说明（一般）状态：<br>这种状态比较特殊，可以理解为：没有特别指出的“默认的，简单的，一般的”状态。<br>中文举例：这兔子过去 <em>吃</em>胡萝卜，将来也 <em>吃</em>胡萝卜。<br>这里的 <strong>吃</strong>，过去？将来？过去将来？都不是，其实这个句子中<strong>并没有指出</strong>具体的动作的状态，也就是现阶段经常性发生的动作、物的永久状态，一般现在时</li>
</ul>
<h4 id="时间状态组合"><a href="#时间状态组合" class="headerlink" title="时间状态组合"></a>时间状态组合</h4><p><img data-src="d3bb2988/AutoCapture_2021-02-06_224311.jpg" alt="组合时间轴"></p>
<h5 id="现在时间"><a href="#现在时间" class="headerlink" title="现在时间"></a>现在时间</h5><p>以现在时间为参照点，现在的动作就有四种状态：</p>
<ul>
<li>现在进行中的状态，<strong>现在进行时态</strong>（Present Progressive Tense）</li>
<li>对现在而言的，已经完成了的状态：<strong>现在完成时态</strong>（Present Perfect Tense）</li>
<li>对现在而言，完成了的，但是接下来还会继续的状态：<strong>现在完成进行时态</strong>（Present Perfect Progressive Tense）</li>
<li>对现在而言，没有特别指出的状态：<strong>现在一般时态</strong>（Present Simple Tense）</li>
</ul>
<h5 id="过去时间"><a href="#过去时间" class="headerlink" title="过去时间"></a>过去时间</h5><ul>
<li>过去的，进行中的状态：<strong>过去进行时态</strong>（Past Progressive Tense）,例如：这兔子昨天下午3点那个时候正在吃胡萝卜。</li>
<li>对过去而言，完成了的状态：<strong>过去完成时态</strong>（Past Perfect Tense），例如：这兔子昨天下午3点那个时候已经吃完了胡萝卜。</li>
<li>对过去而言，完成了的，但是接下来还会继续的状态：<strong>过去完成进行时态</strong>（Past Perfect Progressive Tense），例如：这兔子昨天下午3点那个时候已经吃完了一些胡萝卜，还要继续吃（之后还要吃的什么时候，我们不得而知）。</li>
<li>对过去而言，没有特别指出的状态：<strong>过去一般时态</strong>（Past Simple Tense），例如：这兔子过去吃了胡萝卜（只是单纯表示这个动作发生在过去而已）。</li>
</ul>
<h5 id="将来时间"><a href="#将来时间" class="headerlink" title="将来时间"></a>将来时间</h5><ul>
<li>将来的，进行中的状态：<strong>将来进行时态</strong>（Future Progressive Tense）,例如：这兔子明天下午3点那个时候会正在吃胡萝卜。</li>
<li>对将来而言，完成了的状态：<strong>将来完成时态</strong>（Future Perfect Tense），例如：这兔子昨天下午3点那个时候<em>会已经吃完了</em>胡萝卜。（之前什么时候开始吃不知道，也可能现在就已经开始吃了，总之明天3点的时候，肯定吃完了）</li>
<li>对将来而言，完成了的，但是接下来还会继续的状态：<strong>将来完成进行时态</strong>（Future Perfect Progressive Tense），例如：这兔子明天下午3点那个时候已经吃完了一些胡萝卜，还要继续吃（什么时候开始吃，什么时候结束吃，我们都不知道，总之明天下午3点那个时候，已经吃了一段时间了，而且还不停止）。</li>
<li>对将来而言，没有特别指出的状态：<strong>将来一般时态</strong>（Future Simple Tense），例如：这兔子将来吃胡萝卜（只是单纯表示这个动作发生在将来而已）。</li>
</ul>
<h4 id="过去将来"><a href="#过去将来" class="headerlink" title="过去将来"></a>过去将来</h4><p><strong>备注：</strong>确实比较抽象，建议直接看英语兔的梦幻联动解释就好了。<a href="https://www.bilibili.com/video/BV1Sv411y7d8?t=46">https://www.bilibili.com/video/BV1Sv411y7d8?t=46</a> 11分钟开始</p>
<ul>
<li>过去将来进行时态：（Past Future Progressive Tense）</li>
<li>过去将来完成时态：（Past Future Perfect Tense）</li>
<li>过去将来完成进行时态：（Past Future Perfect Progressive Tense）</li>
<li>过去将来一般时态：（Past Future Simple Tense）</li>
</ul>
<p>总结起来，如果将这16中形态放在一条时间线上，应该就是这样子：<br><img data-src="d3bb2988/AutoCapture_2021-02-06_231020.jpg" alt="16种时态时间轴"></p>
<h4 id="时态最容易犯错点"><a href="#时态最容易犯错点" class="headerlink" title="时态最容易犯错点"></a>时态最容易犯错点</h4><p>导致我们经常犯错，英语兔总结主要下面四点：<br><strong>备注：</strong>个人感觉总结的非常到位，正是我苦恼了十几年的玩意儿。</p>
<ul>
<li>时<strong>和</strong>态未分清：你必须要了解，时间和状态是怎么组合的，而不是一味地揉在一起。</li>
<li>动词变位（Verb Conjugation）现象：指的就是单词的拼写往往会改变，在中文中表示动作的时间和状态，比如：吃-&gt;吃<strong>了</strong>，你只需要加上描述时间的字眼就行了，本身不需要对动作本身作任何变动。在英语中则不同，表示不同的时态，不但往往要加上表示时间的信息，还往往会对动词的本身的拼写作出改动。</li>
<li>助动词（Auxiliary Verbs）：往往需要借助另外的动词来表述含义，往往也会包含着动词变位现象。</li>
<li>其它语法概念混合：例如结合情态动词、单纯的加情态、情态的基础上否定时间、情态的基础上改为被动，等等这些语法现象。</li>
</ul>
<h4 id="一般现在时态"><a href="#一般现在时态" class="headerlink" title="一般现在时态"></a>一般现在时态</h4><p><strong>语法构成：</strong> +动词原形，+动词原形+s（第三人称单数）<br>正如一般现在时的特性所述，这个过程往往并不是表示当前正在进行中的状态。更多的是：</p>
<ul>
<li>表达事实，<br>例如：<ul>
<li>I eat carrots. 我吃胡萝卜：我是吃胡萝卜这种食物的。（这是个事实陈述）</li>
<li>The rabbit eats carrots. 兔子吃胡萝卜：兔子是吃胡萝卜的动物。（也是事实陈述）</li>
</ul>
</li>
<li>表达习惯/重复的动作<br>例如：<ul>
<li>I play basketball. 我打篮球.（我有这个习惯）</li>
</ul>
</li>
<li>表示预计发生的事情</li>
</ul>
<h4 id="现在进行时态"><a href="#现在进行时态" class="headerlink" title="现在进行时态"></a>现在进行时态</h4><p><strong>语法构成：</strong> 助动词be的变位 + 动词的现在分词<br>be动词，这里有两个身份：</p>
<ul>
<li>（连）系动词：I am a smart rabbit. -&gt; I = a smart rabbit.</li>
<li>助动词，构成时态</li>
</ul>
<p>现在分词：通常就是在结尾加ing</p>
<h4 id="现在完成时态"><a href="#现在完成时态" class="headerlink" title="现在完成时态"></a>现在完成时态</h4><p><strong>语法构成：</strong> 助动词hava的变为 + 动词的过去分词<br>have这里有两个身份：</p>
<ul>
<li>实义动词：</li>
<li>助动词，构成时态</li>
</ul>
<p>过去分词：通常在结尾加ed，但是有些动词是“不规则变化”，如：eat -&gt; eaten</p>
<h4 id="现在完成进行时态"><a href="#现在完成进行时态" class="headerlink" title="现在完成进行时态"></a>现在完成进行时态</h4><p><strong>语法构成</strong>： have的变为 + been + 动词的现在分词。看起来就是现在进行时与现在完成时的组合。</p>
<h4 id="一般过去时态"><a href="#一般过去时态" class="headerlink" title="一般过去时态"></a>一般过去时态</h4><p><strong>语法构成：</strong> +动词的过去式。<br>通常：过去式，在动词结尾+ed。注意不要和动词的过去式和过去分词混淆。 </p>
<h4 id="过去进行时态"><a href="#过去进行时态" class="headerlink" title="过去进行时态"></a>过去进行时态</h4><p>强调过去某个时间段，强调某个动作是进行过程中的。<br><strong>语法构成：</strong> 助动词be的变位（考虑时间的变位，通常就是be动词的过去式） + 动词的现在分词</p>
<h5 id="辨析：现在完成时态-VS-一般过去时态-VS-过去进行时态"><a href="#辨析：现在完成时态-VS-一般过去时态-VS-过去进行时态" class="headerlink" title="辨析：现在完成时态 VS. 一般过去时态 VS. 过去进行时态"></a>辨析：现在完成时态 VS. 一般过去时态 VS. 过去进行时态</h5><p>现在完成时态：描述已经完成的动作（肯定是过去时间里完成的），后面两个过去时态，都是描述过去的动作。那么这三者有什么区别？<br>现在完成时态：通常表述过去发生的动作，而一般过去时态，通常表述过去发生的动作的结果。一个强调动作，一个强调结果。<br>例如：I have gone to Shanghai. / I went to Shanghai. 前者强调去上海这个动作，言下之意，你现在找不到我。而后者强调结果，我去过上海，言下之意，我回来了。</p>
<p>一般过去时态：通常表述过去一个动作做了没了，而过去进行时态表示：某个动作在过去某个时间是正在进行过程中的。一个点，一个时间段。</p>
<h4 id="过去完成时态"><a href="#过去完成时态" class="headerlink" title="过去完成时态"></a>过去完成时态</h4><p><strong>语法构成：</strong> 助动词have的变位（have的过去式） + 动词的过去分词<br>在现在完成时态的基础上，将have改为had过去式。<br>过去完成时代：在过去的一个时间点（可能确定，也可能不确定）的基础上，还在之前发生的一个动作，持续一段时间，对过去那个确定/不确定的一个时间点造成的影响。<br>例如：He tried to find me yesterday afternoon, but I had already gone to Shanghai.</p>
<h4 id="过去完成进行时态"><a href="#过去完成进行时态" class="headerlink" title="过去完成进行时态"></a>过去完成进行时态</h4><p>跟现在完成进行时态概念类似，只是将时间节点挪到过去。强调过去已经进行了一个动作，还要在过去某个时间点之后，还要继续进行。</p>
<p>借助于助动词will/shall等来表达动词将来</p>
<h4 id="英语“表达”将来时态"><a href="#英语“表达”将来时态" class="headerlink" title="英语“表达”将来时态"></a>英语“表达”将来时态</h4><ul>
<li>一般现在时态可以表达将来的动作，如: The bus leaves at 8PM.</li>
<li>助动词be的变位 + going + to + 动词原形，如： I am going to eat a carrot。</li>
<li>亦可是：上句中的going也可以省略，变为助动词be的变位 + to + 动词原形，如：You are to eat a carrot.</li>
<li>又或者也可以用介词about取代going，即：+ about + to + 动词原形，如：I am about to eat a carrot.</li>
</ul>
<h4 id="一般将来时态"><a href="#一般将来时态" class="headerlink" title="一般将来时态"></a>一般将来时态</h4><p><strong>语法构成：</strong> will + 动词原形，描述的跟一般过去时间描述的刚好相反，表述将来某个时间点发生的动作（说话者十分肯定会发生的事情）。<br><strong>注意</strong>，如果不太确定，就不能用一般将来时态，此时就需要借助动词的“语气”来表述。</p>
<h4 id="将来进行时态"><a href="#将来进行时态" class="headerlink" title="将来进行时态"></a>将来进行时态</h4><p><strong>语法构成：</strong> will + be + 动词的现在分词<br>在将来某个时间，表述某个动作正在进行过程中。一般将来时态相当于一张（你想象）的照片，将来进行时态相当于一段（你想象）的视频。</p>
<h4 id="将来完成时态"><a href="#将来完成时态" class="headerlink" title="将来完成时态"></a>将来完成时态</h4><p><strong>语法构成</strong> will + have + 动词的过去分词<br>将来那一点A的过去B（B和现在的前后不能确定），对将来那一点A的影响。</p>
<h4 id="将来完成进行时态"><a href="#将来完成进行时态" class="headerlink" title="将来完成进行时态"></a>将来完成进行时态</h4><p>就是跟现在完成进行时态变为：will + have + been + 动词的现在分词。<br>对将来某个时间点已经完成的一个动作，还要继续持续进行着。</p>
<h4 id="过去将来时态"><a href="#过去将来时态" class="headerlink" title="过去将来时态"></a>过去将来时态</h4><p>这里如果以现在的时间点作为参照，讨论过去将来，又是过去又是将来，会很矛盾。这里过去将来，是以过去某个时间点作为参考。<br><strong>语法构成：</strong> would + 动词原形</p>
<h4 id="时态总结"><a href="#时态总结" class="headerlink" title="时态总结"></a>时态总结</h4><p>常用时态并不多<br><img data-src="d3bb2988/AutoCapture_2021-02-14_221142.jpg" alt="英语中常用时态"></p>
<h3 id="动词语气"><a href="#动词语气" class="headerlink" title="动词语气"></a>动词语气</h3><p>最主要三种语气：</p>
<ul>
<li>陈述语气</li>
<li>祈使语气</li>
<li>虚拟语气<br>其它例如：</li>
<li>疑问语气</li>
<li>条件语气</li>
<li>感叹语气</li>
</ul>
<h4 id="陈述语气-Indicative-Mood"><a href="#陈述语气-Indicative-Mood" class="headerlink" title="陈述语气(Indicative Mood)"></a>陈述语气(Indicative Mood)</h4><p>描述现实</p>
<h4 id="祈使语气-Imperative-Mood"><a href="#祈使语气-Imperative-Mood" class="headerlink" title="祈使语气(Imperative Mood)"></a>祈使语气(Imperative Mood)</h4><p>命令/请求。<br>通常：</p>
<ol>
<li>用第二人称（“你”）用一般现在时态代替。 <del>You</del> eat the carrot! -&gt; Eat the carrot!</li>
<li>去掉“你”，保证动词原形。</li>
</ol>
<h4 id="虚拟语气"><a href="#虚拟语气" class="headerlink" title="虚拟语气"></a>虚拟语气</h4><p>之所以难是因为，中文中其实有同样意思的表达，但是在英文中，多了一个动词变位现象。英语在“描述动作/事件”这一方面的思维习惯：如果是描述你脑中的想象，尤其是和事实相反的，或者说“主观的意愿”，就要使用虚拟语气。如果是描述现实，或者直接请求/命令的，就使用祈使、陈述语气。</p>
<h5 id="对“不可能”的假设"><a href="#对“不可能”的假设" class="headerlink" title="对“不可能”的假设"></a>对“不可能”的假设</h5><p><strong>第一种用法：</strong> 和现在事实相反。<br>例如：If I saw the rabbit now, I would bite him.<br>条件句：过去式<br>主句：would + 动词原形</p>
<p><strong>第二种用法：</strong> 和将来事实相反（可能性很小）<br>表面未来发生的可能发生的可能性较小<br>例如：If I <em>should see</em> the rabbit tomorrow, I <em>would</em> bite him.<br>条件句：should + 动词原形<br>主句：would + 动词原形</p>
<p><strong>第三种用法：</strong> 和过去事实相反，动词过去式改成过去完成形态。<br>例如：If I <em>had seen</em> the rabbit a few days ago, I <em>would have bitten</em> him.<br>条件句：had + 动词过去分词<br>主句：would have + 动词过去分词</p>
<h5 id="表达愿望、请求、建议、命令等"><a href="#表达愿望、请求、建议、命令等" class="headerlink" title="表达愿望、请求、建议、命令等"></a>表达愿望、请求、建议、命令等</h5><p>希望某个动作/事件发生，想象的，例如：<br>对现在的愿望：wish + 动词过去式，例如： I wish that I <em>were</em> a rabbit.<br>对过去的愿望：wish + had/would have + 动词过去分词，例如：I wish (that) I <em>had eaten</em> the carrot.<br>对将来的愿望：wish + should/count/might/would + 动词原形，例如：I wish (that) I <em>could eat</em> the carrot.</p>
<p>除wish之外，还有其它一些词，例如：</p>
<ul>
<li>would rather</li>
<li>demand</li>
<li>suggest</li>
<li>insist</li>
<li>order<br>上述几个词之后，均是  <strong>should +动词原形</strong></li>
</ul>
<h3 id="英语从句"><a href="#英语从句" class="headerlink" title="英语从句"></a>英语从句</h3><h4 id="概括性总结"><a href="#概括性总结" class="headerlink" title="概括性总结"></a>概括性总结</h4><ol>
<li>英语从句的原理<br>在英语中，一个句子A可以成为一个整句的某种句子成分，可以理解为，A成了整句其余部分B的附属，服“从”B，同时也不能独立成句，而B，也就成了A的“主”人。</li>
<li>英语从句的分类<br>按句子成分/句型分类：</li>
</ol>
<ul>
<li>主语 + 动词</li>
<li>主语 + 动词 + 宾语</li>
<li>主语 + 动词 + 间接宾语 + 直接宾语</li>
<li>主语 + 动词 + 宾语 + （宾语）补语</li>
<li>主语 + 动词 + （主语）补语（表语）</li>
<li>定语、状语、同位语</li>
</ul>
<p>按照词类：动词、名词、代词、冠词、形容词、数词、副词、介词、叹词、连词</p>
<ul>
<li>名词性从句：<ul>
<li>主语从句</li>
<li>宾语从句</li>
<li>表语从句</li>
<li>宾语补语从句（出现的比较少）</li>
<li>同位语从句</li>
</ul>
</li>
<li>定语从句（大形容词，形容词从句/关系【词】从句）</li>
<li>状语从句（大副词，副词性从句/副词从句）<ul>
<li>时间状语从句：带有时间副词特性的</li>
<li>地点状语从句：带有地点副词特性的</li>
<li>条件、原因、方式、比较。。。状语从句</li>
</ul>
</li>
</ul>
<h4 id="形容词从句"><a href="#形容词从句" class="headerlink" title="形容词从句"></a>形容词从句</h4><p>这是英语中最多、最杂、也是最难的一类从句。这类从句对某个人或者事物进行描述，具有形容词的性质，因此称之为形容词从句。同时在句子中也充当定语成分，所以有时候也通常称之为“定语从句”</p>
<h5 id="形容词从句的思维方式"><a href="#形容词从句的思维方式" class="headerlink" title="形容词从句的思维方式"></a>形容词从句的思维方式</h5><p><strong>备注</strong> 这里英语兔先从中英文语法习惯分析开始，先从中文开始分析完了再引入英文，这点确实新颖，也容易理解。<br>中文构成定语非常简单：一个形容词/句子 + 的 + 名词就搞定了，例如：</p>
<ul>
<li><em>好吃</em> <strong>的</strong> 胡萝卜</li>
<li><em>我买来</em> <strong>的</strong> 胡萝卜</li>
<li><em>我昨天再菜市场向刚从地里回来的乌龟哪儿买来</em> <strong>的</strong> 胡萝卜</li>
</ul>
<p>英语则不一样了，例如一根我买来的胡萝卜，则要翻译成：<br>a <em>carrot</em> <strong>that</strong> I bought<br>这种方式可以理解为：在被修饰的词（carrot)之后，添加另一个和它有关系的词，然后再将这个新词放到另一个句子中进行补充说明/逻辑阐述。而这里的新词就是：<strong>关系词</strong>，被修饰的词就是：<strong>先行词</strong>，这里的另一个句子就是：<strong>定语从句/形容词从句/关系从句</strong><br>说白了，中英文两种差异是：中文句子的定语都是“前置”的，英文中多数都是后置的。</p>
<h5 id="形容词从句的构成"><a href="#形容词从句的构成" class="headerlink" title="形容词从句的构成"></a>形容词从句的构成</h5><p>关系代词引导的形容词从句。</p>
<h6 id="that-vs-which"><a href="#that-vs-which" class="headerlink" title="that vs. which"></a>that vs. which</h6><p>如果先行词是唯一的：that<br>相反如果先行词是多选一的：which<br>总结就是，用which可以换为that，但是指明了唯一属性的，那就只能用that</p>
<p>关系副词引导的形容词从句，例如：</p>
<ul>
<li>This was the <em>place</em> <strong>where = at which</strong> the rabbit ate the carrot.</li>
<li>This is the <em>reason</em> <strong>why = for which</strong> the rabbit ate the carrot.</li>
<li>That was the <em>day</em> <strong>when = on which</strong> the rabbit ate the carrot for the first time.<br>关系副词 = 介词 + which<h5 id="形容词从句的限定性和非限定性"><a href="#形容词从句的限定性和非限定性" class="headerlink" title="形容词从句的限定性和非限定性"></a>形容词从句的限定性和非限定性</h5>例如：</li>
<li>I have a head which is round.(好几个头，其中一个是圆的)</li>
<li>I have a head, which is round.（就一个，那个是圆的）<br>因此正因为非限定性形容词从句的这种“非限定”接着补充的特性，所以往往来作为句子的插入语。<br>The biggest carrot, <del>which the rabbit ate</del>, was on the table.<br>上句中的非限定性从句可以完全去掉，不影响句意。但是却不能这么说：<br><del>The biggest carrot which the rabbite ate was on the table.</del><br>另外，比较特殊的是，非限定性定语从句不一定补充某个先行词，而是可以指代整句话，比如：</li>
</ul>
<p><em>The rabbit ate the carrot</em>, which was not surprising.</p>
<h4 id="名词从句"><a href="#名词从句" class="headerlink" title="名词从句"></a>名词从句</h4><p>包括如下：</p>
<ul>
<li>主语从句</li>
<li>并于从句</li>
<li>表语从句</li>
<li>同位语从句</li>
<li>宾语补语从句</li>
</ul>
<h2 id="音标合集"><a href="#音标合集" class="headerlink" title="音标合集"></a>音标合集</h2><h2 id="英语语音技巧"><a href="#英语语音技巧" class="headerlink" title="英语语音技巧"></a>英语语音技巧</h2><p>==========</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="d3bb2988/%E8%AF%AD%E6%B3%95%E5%90%88%E9%9B%86.xmind">语法合集</a></p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>每日英语听写(Daily English Dictation)</title>
    <url>/post/bac59465.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本篇所有涉及英文听力文稿均来自B站UP主：Coach-Shane专题视频<br><a href="https://www.bilibili.com/video/BV1U7411a7xG?p=1">https://www.bilibili.com/video/BV1U7411a7xG?p=1</a><br>所有文稿，经视频学习后，手工摘录备注于此，便于自己复习同时方便他人查阅。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Dictation-1"><a href="#Dictation-1" class="headerlink" title="Dictation 1"></a>Dictation 1</h3><h4 id="正文-1"><a href="#正文-1" class="headerlink" title="正文"></a>正文</h4><p>Mother Teresa, who received a Nobel Peace Prize for her work <u>on behalf of</u> the poor, dies in Calcutta, India – she was 87 years old.</p>
<h3 id="Dictation-2"><a href="#Dictation-2" class="headerlink" title="Dictation 2"></a>Dictation 2</h3><span id="more"></span>]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>听写</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝光原盘电影重置教程</title>
    <url>/post/fcecb73d.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近几天升级置换了自己的群辉NAS硬盘，也藉由此开始混起了PT。<br>2020年在硬件上升级最大的就是：置换了4K显示器（也是我换的最满意的一个硬设之一），其实早就该这么搞了。</p>
<span id="more"></span>
<p>以前也喜欢看超清的电影，记得大学那会儿，第一次下的最大的蓝光电影是一个科幻片：《创战纪》。到现在我还记得，小笔记本连续开机几天几夜终于下完了那一部70-80GB的电影，好在当时笔记本还行，也居然看完了。<br>时至今日，搞定了4K显示，存储也上去了，可以去PT捞一波蓝光片源了。大多数蓝光片源来说，要么第三方个人DIY已经制作过，比如集成了不错的中文字幕，修正了冗余的音轨啊什么的。<br>但是在我收藏的列表里面，找来找去，发现我一个很喜欢的电视剧《我的大叔》，主演李知恩(IU)，还没看过这部片子的小伙伴，可以去<a href="https://movie.douban.com/subject/27602137/">豆瓣</a>看看，评分9.4<br><img data-src="fcecb73d/AutoCapture_2021-01-20_205038.jpg" alt="豆瓣评分"><br>韩文又不怎么懂的我，根本没法看，也因此才诞生了这篇教程文章。<br>对没错！<br>我要亲手给这个蓝光片源集成中文字幕。废话先不多说，贴张剧图<br><img data-src="fcecb73d/MY_MISTER_01_20210120_204700.383.jpg" alt="我的大叔剧照"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2021年2月17日备注：<br>起初打算通过寻找相应方式直接提取已有汉化硬字幕的剧，找来找去都是围绕着一个古老的工具esrXP作为起始的。研究过一段时间之后，发现在现有的windows10上操作极其复杂。而且还充满很多不确定因素，更可怕的是，这才是第一步提取。。。想来想去，果断放弃这种通过直接提取视频文字的方式。<br>于是换了一种思路：本质还是提取字幕，不可能手打。提取的方式从原先的直接提取视频转为提取图片。进而就演变成如下流程：<br>视频-&gt;截帧成为图片-&gt;OCR提取图片文字-&gt;形成初略时间轴-&gt;精校对-&gt;重压原蓝光视频文件</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="片源"><a href="#片源" class="headerlink" title="片源"></a>片源</h3><p>正常的BD片源即可，ISO文件可以用虚拟光驱加载，但是切记不要直接修改，先备份一下！万一搞的不好，弄毁了，那就哭瞎了，可能又得重新下了。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>BDFix<br>easyavs2bdnxml</p>
<h2 id="制作案例1"><a href="#制作案例1" class="headerlink" title="制作案例1"></a>制作案例1</h2><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>蓝光原盘</tag>
        <tag>BlueRay</tag>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Nexus私服搭建</title>
    <url>/post/f3b827b0.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本篇搭建设计到的相关资源如下：</p>
<ul>
<li>操作系统：CentOS 7.9</li>
<li>JDK: 1.8.0_211</li>
<li>Nexus私服版本：nexus-3.29.2-02</li>
</ul>
<h3 id="Nexus介绍"><a href="#Nexus介绍" class="headerlink" title="Nexus介绍"></a>Nexus介绍</h3><p>Nexus 是Maven仓库管理器，如果我们使用Maven，我们可以从Maven中央仓库下载所需要的构件（artifact），但这通常没有公司这么干，一般都是在本地架设一个Maven仓库服务器，在代理远程仓库的同时维护本地仓库，以节省带宽和时间，Nexus就可以满足这样的需要。此外，它还提供了强大的仓库管理功能，构件搜索功能，它基于REST，友好的UI是一个extjs的REST客户端，它占用较少的内存，基于简单文件系统而非数据库。这些优点使其日趋成为最流行的Maven仓库管理器。<br>Nexus不是Maven的核心概念，它仅仅是一种衍生出来的特殊的Maven仓库。对于Maven来说，仓库只有两种：本地仓库和远程仓库。</p>
<h3 id="Nexus私服特点"><a href="#Nexus私服特点" class="headerlink" title="Nexus私服特点"></a>Nexus私服特点</h3><p>搭建私服后：本地仓库没有，再去私服下载，私服没有，再去中央仓库下载</p>
<ul>
<li>减少网络带宽流量</li>
<li>加速Maven构建</li>
<li>部署第三方构件</li>
<li>提高稳定性、增强控制</li>
<li>降低中央仓库的负载</li>
</ul>
<span id="more"></span>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@microservice ~]# mkdir /usr/local/nexus</span><br><span class="line">[root@microservice ~]# tar zxf nexus-3.29.2-02-unix.tar.gz -C /usr/local/nexus/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动nexus必须使用nexus用户，不可以使用权限过高的用户，比如root，否则会启动失败</span></span><br><span class="line">[root@microservice ~]# useradd nexus</span><br><span class="line">[root@microservice ~]# chown -R nexus:nexus /usr/local/nexus/</span><br><span class="line">[root@microservice ~]# ls /usr/local/nexus/</span><br><span class="line">nexus-3.29.2-02     # 这是应用目录</span><br><span class="line">sonatype-work         # 这是工作目录，存放镜像仓库</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行内存和工作目录nexus-3.29.2-02/bin/nexus.vmoptions （修改对应字段即可）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行监听地址和端口nexus-3.29.2-02/etc/nexus-default.properties</span></span><br><span class="line">[root@microservice ~]# ln -s /usr/local/nexus/nexus-3.29.2-02/bin/nexus /usr/local/bin/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建命令软连接</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至nexus用户，并启动nexus服务，如果使用root用户，会因为权限过高而启动失败</span></span><br><span class="line">[root@microservice ~]# su nexus</span><br><span class="line">[nexus@microservice nexus]$ nexus start </span><br><span class="line">Starting nexus</span><br><span class="line">[nexus@microservice ~]# netstat -anput | grep 8081</span><br><span class="line">tcp        0      0 0.0.0.0:8081            0.0.0.0:*               LISTEN      4687/java </span><br></pre></td></tr></table></figure>

<p>启动nexus之后，在浏览器访问<a href="http://ip:8081端口，ip就是你服务器的ip，访问之后，单击页面右上角的Sign">http://ip:8081端口，ip就是你服务器的ip，访问之后，单击页面右上角的Sign</a> in<br>初次登录会提示一个获取admin用户的默认密码路径，如下图所示：<br><img data-src="f3b827b0/03c5869d4ef5c4b3ee329ea106999903.png" alt="admin初始密码"></p>
<p>按指定的路径，cat即可，获取到初始化admin用户密码之后就可以登录了，登录后会提示重置admin用户密码。<br>在Configure Anonymous Access时，按需选择，如果允许匿名访问私服，则可以允许，反之选择disable。</p>
<h3 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h3><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><h3 id="设置自动启动"><a href="#设置自动启动" class="headerlink" title="设置自动启动"></a>设置自动启动</h3><p>通过systemctl来进行管理，在/etc/systemd/system目录下见一个名为<em>nexus.service</em>的文件，文件内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Nexus Repository Manager</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nexus运行的用户和组</span></span><br><span class="line">User=nexus</span><br><span class="line">Group=nexus</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行环境，nexus运行的依赖项，JAVA_HOME的运行环境</span></span><br><span class="line">Environment=INSTALL4J_JAVA_HOME=/etc/java/jdk1.8.0_211</span><br><span class="line">ExecStart=/usr/local/bin/nexus start</span><br><span class="line">ExecStop=/usr/local/bin/nexus stop </span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>设置服务自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 加载新的unit配置文件</span></span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置允许服务自启动</span></span></span><br><span class="line">sudo systemctl enable nexus.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 服务启动</span></span></span><br><span class="line">sudo systemctl start nexus.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 服务停止</span></span></span><br><span class="line">sudo systemctl stop nexus.service</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 服务启动状态</span></span></span><br><span class="line">sudo systemctl status nexus.service</span><br></pre></td></tr></table></figure>

<p><strong>如果在start过程中遇到问题，systemctl status nexus.service命令查看运行结果，如果还是有问题，通过journalctl -xe查看</strong></p>
<h3 id="设置代理仓库"><a href="#设置代理仓库" class="headerlink" title="设置代理仓库"></a>设置代理仓库</h3><p>阿里云仓库的URL：<a href="https://maven.aliyun.com/nexus/content/groups/public/">https://maven.aliyun.com/nexus/content/groups/public/</a></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="file-descriptor警告"><a href="#file-descriptor警告" class="headerlink" title="file descriptor警告"></a>file descriptor警告</h3><p>具体体现在/support/status状态页面的File Descriptors项目可能会显示 <em>Recommended file descriptor limit is 65536 but count is 4096.</em> 警告。<br>根据提示其实也能猜的出来，就是建议当前运行的私服建议文件句柄到65536。<br>这里在官网有具体的解释：<a href="https://help.sonatype.com/repomanager3/installation/system-requirements#SystemRequirements-AdequateFileHandleLimits">https://help.sonatype.com/repomanager3/installation/system-requirements#SystemRequirements-AdequateFileHandleLimits</a><br>解决办法就是为当前nexus私服运行的用户，如：nexus，指定文件句柄：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用root权限在/etc/security/limits.conf文件末尾添加：</span></span><br><span class="line">nexus - nofile 65536</span><br></pre></td></tr></table></figure>

<p>修改之后，重新进入运行用户，如：nexus，并重启nexus私服</p>
<h3 id="项目中配置好私服访问地址后报未授权错误（Not-authorized）"><a href="#项目中配置好私服访问地址后报未授权错误（Not-authorized）" class="headerlink" title="项目中配置好私服访问地址后报未授权错误（Not authorized）"></a>项目中配置好私服访问地址后报未授权错误（Not authorized）</h3><p>具体报错如下：<br>Could not transfer artifact org.apache.curator:curator-recipes:pom:2.11.0 from/to nexus<br>(<a href="http://192.168.198.128:8081/repository/maven-public/">http://192.168.198.128:8081/repository/maven-public/</a>): Not authorized</p>
<p>这个原因是因为，在你本地maven配置文件（setting.xml）中mirrors标签只配置了私服的镜像，而在servers标签中配置对应的用户名和密码，要么找不到，要么没有配置<br>检查如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus private<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.198.128:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案：检查你的配置，是否有确实两个配置中的一个或者是否两个配置中的id是否一致。如果没有配置则配置一下，如果不匹配，则将俩id改成一致</strong><br>本质就是，通过mirror中的id去寻找server中相同id的用户名和密码，完了去访问私服。<br>如果配错或者漏配了，自然当前配置的mirror找不到用户名和密码，自然不能访问。（前提默认你私服的配置不允许匿名访问仓库）</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://blog.51cto.com/14227204/2492248">部署maven及Nexus私服</a></li>
<li><a href="https://www.jianshu.com/p/88fbca59b963">Maven私服Nexus安装与使用</a></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Nexus私服</tag>
        <tag>CentOS 7</tag>
      </tags>
  </entry>
  <entry>
    <title>影视后期相关之拍摄</title>
    <url>/post/bbf06dfa.html</url>
    <content><![CDATA[<h2 id="调色相关"><a href="#调色相关" class="headerlink" title="调色相关"></a>调色相关</h2><p>注：调色场景并不是绝对一定，掌握住要点，针对不同照片的具体展现形式，不同的调整才是关键所在。</p>
<h3 id="青橙色调"><a href="#青橙色调" class="headerlink" title="青橙色调"></a>青橙色调</h3><ul>
<li>适合场景：<ul>
<li>白天和夜景的大部分场景</li>
<li>画面中具备天空、大海等青蓝色元素，和肤色，灯光等橙色元素即可</li>
</ul>
</li>
<li>一种调整细节思路<ul>
<li>HSL界面（主要关注色相饱和度）：<ul>
<li>红色和黄色色相往橙色偏</li>
<li>橙色色相（稍微）偏一点红色，饱和度提升。有人的话，橙色调整需要额外注意，因为橙色会改人物的肤色。</li>
<li>（如果有）树叶草坪等元素：色相往黄色偏，饱和度降低。</li>
<li>青色和蓝色：色相往 <strong>中间偏</strong> ，饱和度酌情提升</li>
</ul>
</li>
<li>校准页面（Camera RAW 和 Lightroom修改）<ul>
<li>红颜色右移，红颜色饱和度左移</li>
<li>蓝颜色左移，蓝颜色饱和度右移</li>
</ul>
</li>
</ul>
</li>
<li>二种调整细节思路</li>
</ul>
<span id="more"></span>

<h3 id="黑金"><a href="#黑金" class="headerlink" title="黑金"></a>黑金</h3><h3 id="分离色调"><a href="#分离色调" class="headerlink" title="分离色调"></a>分离色调</h3><h4 id="概要工作原理"><a href="#概要工作原理" class="headerlink" title="概要工作原理"></a>概要工作原理</h4><p>分离色调中的高光和阴影将分别影响照片中的高光和阴影区域中的各自颜色补充。<br>注：分离其实就是对照片中高反差的部分进行补偿修正，形成色调差，加强照片的对比。</p>
<h4 id="实践要点"><a href="#实践要点" class="headerlink" title="实践要点"></a>实践要点</h4><p>当照片中阴影面积较多，可以适当通过分离色调中，对阴影部分加一点绿色，来提升照片的亲和度。<br>电影感的色调中，比如原片中包含充足的光线时：可以在高光部分添加一点绿色，让原本的日光的冷色弱化一些。阴影中可以添加暖色调，让画面柔和一点。<br>来自B站：摄影师EDI（ <a href="https://www.bilibili.com/video/BV1Yv411i721">https://www.bilibili.com/video/BV1Yv411i721</a> ）的调色分享：<br><img data-src="bbf06dfa/AutoCapture_2020-11-08_193408.jpg" alt="调色前"><br><img data-src="bbf06dfa/AutoCapture_2020-11-08_193451.jpg" alt="调色后"></p>
<h2 id="构图相关"><a href="#构图相关" class="headerlink" title="构图相关"></a>构图相关</h2><h3 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h3><p>此部分记录于B站UP主(macro啊)，视频链接：<a href="https://www.bilibili.com/video/BV1y4411g72J">https://www.bilibili.com/video/BV1y4411g72J</a></p>
<h4 id="黄金分割（0-618）"><a href="#黄金分割（0-618）" class="headerlink" title="黄金分割（0.618）"></a>黄金分割（0.618）</h4><p>主体左右/上下分布在画面的0.618分割线上</p>
<h4 id="九宫格构图"><a href="#九宫格构图" class="headerlink" title="九宫格构图"></a>九宫格构图</h4><p>横竖共四根分割线将图像分为9块。相交的4个点称之为视觉重点。将图片中呈现的重点元素分布在这4个点周围</p>
<h4 id="“画面做减法”"><a href="#“画面做减法”" class="headerlink" title="“画面做减法”"></a>“画面做减法”</h4><p>概括为“少即是多”，有突出主体的情况下，尽可能精简<br><img data-src="bbf06dfa/AutoCapture_2020-11-07_205058.jpg" alt="示例1"></p>
<h4 id="主体优先"><a href="#主体优先" class="headerlink" title="主体优先"></a>主体优先</h4><p>关键在于是否将主体的展示元素放在视觉的关键点上。<br><img data-src="bbf06dfa/AutoCapture_2020-11-07_205412.jpg" alt="示例2"><br><img data-src="bbf06dfa/AutoCapture_2020-11-07_205450.jpg" alt="示例3"></p>
<h4 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h4><h4 id="中心构图"><a href="#中心构图" class="headerlink" title="中心构图"></a>中心构图</h4><p>拍摄主体放在画面元素的中间点</p>
]]></content>
      <categories>
        <category>影视后期</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>后期调色</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机（第三版）</title>
    <url>/post/d7ba81a7.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>JVM作为Java底层的核心，一直以来是我的短板，其底层等相关不甚了解。借此机会，通过这种方式学习，记录，分析&amp;分享。<br>书中涉及代码调试案例，收录在<a href="https://github.com/nimbusking/learningjvm">learningjvm</a>项目中，各看官有需要可以自行查阅。</p>
<h1 id="书籍实录"><a href="#书籍实录" class="headerlink" title="书籍实录"></a>书籍实录</h1><h2 id="第一章：走进JAVA"><a href="#第一章：走进JAVA" class="headerlink" title="第一章：走进JAVA"></a>第一章：走进JAVA</h2><h3 id="Java发展史"><a href="#Java发展史" class="headerlink" title="Java发展史"></a>Java发展史</h3><p>宏观上了解Java整个发展体系：</p>
<ul>
<li>1995年5月23日，Oak语言改名为Java，并且在SunWorld大会上正式发布Java1.0版本，并且提出“Write Once, Run Anyware”的口号。</li>
<li>1996年1月23日，JDK1.0发布，代表技术包括：Java虚拟机、Applet、AWT等。<span id="more"></span></li>
<li>1997年2月19日，Sun公司发布JDK1.1，技术代表有：JAR文件格式、JDBC、JavaBeans、RMI等。语法特性有一定增强：如内部类（Inner Class）和反射（Reflaction）</li>
<li>1998年12月4日，JDK1.2发布（工程代号：Playground），Sun拆分Java技术体系为三个方向：分片是面向桌面应用开发的J2SE、面向企业开发的J2EE、面向手机等移动终端开发的J2ME。技术代表如：EJB、Java Plug-in、Java IDL、Swing等，并且在这个版本中Java虚拟机第一次内置了JIT（Just In Time）及时编译器。</li>
<li>2000年5月8日，JDK1.3发布（工程代号：Kestrel【美洲红隼】），代表技术：Java类库，使用CORBAIIOP来实现RMI的通信协议。</li>
<li>2002年2月13日，JDK1.4发布（工程代号：Merlin【灰背隼】）技术特性例如：正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器等等。</li>
<li>2004年9月30日，JDK5发布（工程代号：Tiger【老虎】）语法特性加强：自动装箱、泛型、动态注解、枚举、可变长参数、循环遍历（foreach循环）等等。虚拟机上，改进了Java内存模型（Java Memory Model，JMM）、提供了java.util.concurrent并发包等。</li>
<li>2006年12月11日，JDK6发布（工程代号：Mustang【野马】）改进的包括：提供初步的动态语言支持（通过内置的Mozilla JavaScript Rhino引擎实现）、提供编译期注解处理器和微型HTTP服务器API，等等。Java虚拟机内部做了大量改进，包括锁与同步、垃圾收集、类加载等方面。</li>
<li>2011年7月28日，JDK7正式版发布（工程代号Dopphin【海豚】）改进的包括：提供新的G1收集器、加强对非Java语言的调用支持、可并行的类加载架构等。</li>
<li>2014年3月18日，JDK8发布，主要功能特性包括：<ul>
<li>JEP 126: 对Lambda表达式的支持，这让Java语言拥有了流畅的函数式表达能力</li>
<li>JEP 104: 内置Nashorn JavaScript引擎的支持</li>
<li>JEP 150: 新的时间、日期API</li>
<li>JEP 122: 彻底移除HotSpot的永久代</li>
<li>…..</li>
</ul>
</li>
<li>2017年9月21日，JDK9艰难面世：Jigsaw模块化功能、增强若干工具（JS Shell、JLink、JHSDB等），整顿了HotSpot各个模块各自为战的日志系统，支持HTTP2客户端API等91个JEP</li>
<li>2018年3月20日，JDK10发布：主要目标，内部重构：统一源仓库、统一垃圾收集器接口、统一即时编译器接口（JVMCI在JDK9已经有了，这里引入新的Graal即时编译器）</li>
<li>2018年9月25日，JDK11发布：包含17个JEP，其中有ZGC这样的革命性垃圾收集器出现，也有把JDK10中的类型推断加入Lambda语法这种可见性的改善</li>
<li>2019年3月20日，JDK12发布：包含9个JEP：Switch表达式、Java微测试套件（JMH）等新功能，最引人注目的特性无疑是加入了由ReaHat</li>
<li>领导开发的Shenadnoah垃圾收集器。</li>
</ul>
<h3 id="Java虚拟机家族"><a href="#Java虚拟机家族" class="headerlink" title="Java虚拟机家族"></a>Java虚拟机家族</h3><ul>
<li>虚拟机始祖：Sun Classiz/Exact VM</li>
<li>武林盟主：HotSpot VM<br>  HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知及时编译器以方法为单位进行编译。</li>
<li>小家碧玉：Mobile/Embedded VM</li>
<li>天下第二：BEA JRockit/IBM J9 VM</li>
<li>软硬合璧：BEA Liquid VM/Azul VM<br>  Azul VM实例都可以管理至少数十个CPU和数百GB的内存的硬件资源，并提供巨大内存范围内停顿时间可控的垃圾收集器（即业内赫赫有名的PGC和C4收集器）<br>  Zing虚拟机是一个从HotSpot某个旧版代码分支基础上独立出来重新开发的高性能Java虚拟机。要求低延迟、快速预热等场景中，Zing VM都要比HotSpot表现的更好。Zing的PGC、C4收集器可以轻易支持TB级别的Java堆内存，而且保证暂停时间仍然可以维持在不超过10毫秒的范围内，HotSpot要等到JDK11和JDK12的ZGC及Shenandoah收集器才达到了相同的目标，而且目前的效果仍然远不如C4。</li>
<li>挑战者：Apache Harmony/Google Android Dalvik VM</li>
<li>没有成功，但并非失败：Microsoft JVM及其它</li>
</ul>
<h2 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着需积极进程的启动而一直存在，有些区域则是以来用户线程的启用和结束而建立和销毁。分为：方法区（Method Area），虚拟机栈（VM Stack），本地方法栈（Native Method Stack），堆（Heap），程序计数器（Program Counter Register）</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>线程私有，生命周期与线程相同。<br>虚拟机栈描述的是Java <strong>方法执行</strong>的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等等。<br>每一个方法调用直至执行完毕的过程，就对应着一个栈帧在虚拟机占中从入栈到出站的过程。</p>
<p>“栈”通常就是指这里讲的虚拟机栈，或者更多情况下只是指虚拟机栈中的局部变量表部分。</p>
<p><strong>局部变量表</strong>存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。<br>这些数据类型在局部变量表中的存储空间以 <strong>局部变量槽（slot）</strong>来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。</p>
<p>在《Java虚拟机规范》中，对栈区域规定了两类异常情况：</p>
<ul>
<li>如果线程请求的栈深度大雨虚拟机所允许的深度，将抛出 <strong>StackOverflowError</strong>异常</li>
<li>如果Java虚拟机栈容量可以动态扩展（注：HotSpot虚拟机是不可以动态扩展的，只要线程申请成功了就不会有OOM，但是如果申请时就失败，仍然会出现OOM异常），当栈扩展时无法申请到足够的内存会抛出 <strong>OutOfMemoryError</strong>异常。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>Native Method Stack与虚拟机栈类似，一个是位虚拟机执行Java方法（字节码）服务；一个是为虚拟机用到的本地（native）方法服务。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，Java世界里“几乎”所有对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的内存区域。从回收内存角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”，“老年代”，“永久代”，“Eden空间”，“From Survivor空间”，“To Survivor空间”等名词。</p>
<p>无论从什么角度，无论如何划分，都不会改变Java堆中存储内容堆共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的 <strong>只是为了更好地回收内存，或者更快地分配内存</strong>。</p>
<p>Java堆即可以被实现成固定大小，也可以是扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。<br><strong>如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常</strong></p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的 <strong>类型信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、即时编译器编译后的代码缓存数据等。<br>方法区与“永久代”本来是两个概念，<strong>仅仅因为</strong>当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用“永久代”实现方法区而已，这样使得HotSpot的垃圾收集器能像管理Java堆一样管理这部分内存，省区专门为方法区编写内存管理代码的工作。</p>
<ul>
<li>JDK6时HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划里</li>
<li>JDK7时，已经把原本放在永久代的字符串常量池、静态变量移出</li>
<li>JDK8时，完全放弃永久代概念，该用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK7中剩余的主要是类型信息，全部移动到元空间中。</li>
</ul>
<p><strong>如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常</strong></p>
<h4 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h4><p>Runtime Constant Pool是方法区的一部分。Class文件中除了有<strong>类的版本</strong>、<strong>字段</strong>、<strong>方法</strong>、<strong>接口</strong>等描述信息外，还有一项信息是<strong>常量池表</strong>。主要用于：<strong>存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</p>
<p>Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用的较多的是String类的 **intern()**方法。</p>
<p><strong>当常量池无法再申请到内存时会抛出OutOfMemoryError（本来就是方法区一部分，自然收到方法区内存限制）</strong></p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>Direct Memory并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机》中定义的内存区域。<strong>这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现</strong></p>
<h5 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h5><p>在JDK1.4中新加入了NIO（New Input/Output）类。引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，<strong>它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据</strong>。</p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>本机直接内存分配不受到Java堆大小限制，但是，既然时内存，肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制。<br><strong>一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息</strong>，但是会常常忽略直接内存，使得各个内存区域总和大于物理内存限制，<strong>从而导致动态扩展时出现OutOfMemoryError异常</strong></p>
<h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3><p>注：书中探讨的是常用的HotSpot虚拟机的Java堆中的 <strong>对象分配、布局和访问的全过程</strong>。</p>
<h4 id="对象的创建（过程）"><a href="#对象的创建（过程）" class="headerlink" title="对象的创建（过程）"></a>对象的创建（过程）</h4><ul>
<li>检查过程<br>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到另一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否加载、解析和初始化过。如果没有，那么必须先执行相应的<strong>类加载过程</strong>。</li>
<li>分配过程<br>类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成之后便可完全确定，对象分配空间的任务实际上便等同于吧一块确定大小的内存块从Java堆中划分出来。<br>当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是<strong>指针碰撞</strong>，既简单又高效。而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的<strong>空闲列表</strong>来分配内存。</li>
</ul>
<p><strong>分配过程中的操作原子性</strong><br>    - 采用CAS配上失败重试的机制<br>    - 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，成为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。<strong>虚拟机是否需要使用TLAB，可以通过-XX：+/-UseTLAB参数来设定</strong></p>
<ul>
<li>初始化过程<br>内存分配完成之hi，虚拟机必须将分配到内存空间（但不包括对象头）都初始化成零值。<ul>
<li>对象设置<br>  对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</li>
<li>构造函数初始化<br>  new指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化。</li>
</ul>
</li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</strong>。</p>
<h5 id="对象头信息"><a href="#对象头信息" class="headerlink" title="对象头信息"></a>对象头信息</h5><ul>
<li>一类：用于存储对象自身运行时数据，如：哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li>
<li>另一类：类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象时哪个类型的实例。</li>
</ul>
<h5 id="实例数据信息"><a href="#实例数据信息" class="headerlink" title="实例数据信息"></a>实例数据信息</h5><p>程序代码中定义的各种类型字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。<em>这部分的存储顺序会收到虚拟机分配策略参数（-XX:FieldsAllocationStyle参数）和字段在Java源码中的定义顺序的影响</em></p>
<h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><p>不是必然存在，也没有特别的含义，仅仅起着占位符的作用。任何对象大小都必须是8字节的整数倍。如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>Java程序会通过栈上的reference数据来操作对上的具体对象，但由于reference类型在《Java虚拟机规范》里面只规定了 <strong>它是一个指向对象的引用</strong>，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置。主流的访问方式有：<strong>句柄</strong> 和 <strong>直接指针</strong>。</p>
<ul>
<li>句柄访问：Java堆中可能会划分出一块内存来作为 <em>句柄池</em>，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息</li>
<li>直接指针访问：reference中存储的直接就是对象的地址</li>
</ul>
<p><img data-src="d7ba81a7/memory_hander_detect.png" alt="通过句柄访问内存"><br><img data-src="d7ba81a7/direct_memory_detect.png" alt="通过直接指针访问内存"></p>
<h4 id="实战：OutOfMemoryError异常"><a href="#实战：OutOfMemoryError异常" class="headerlink" title="实战：OutOfMemoryError异常"></a>实战：OutOfMemoryError异常</h4><p><strong>注：</strong> 书中介绍了很多实战经验，这里仅记录一些经验相关事项，具体实例代码参考书中详细说明<br>本节实战的主要目的有两个：</p>
<ul>
<li>通过代码验证《Java虚拟机规范》中描述的各个运行时区域存储的内容</li>
<li>遇到实际的内存溢出异常时，能够根据异常的提示信息迅速得知时哪个区域的内存溢出，知道怎样的代码可能会导致这些区域内存溢出，以及出现这些异常后该如何处理。</li>
</ul>
<h5 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h5><p><strong>根本原因：</strong> Java堆用于存储对象实例，只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。<br><strong>常规处理方法：</strong></p>
<ul>
<li>先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转存储快照进行分析，首先确认内存中导致的OOM的对象是否时必要的，也就是到底时出现了 <strong>内存泄露（Memory Leak）</strong> 还是 <strong>内存溢出（Memory Overflow）</strong></li>
<li>如果是内存泄漏，可以通过工具查看泄漏对象到GC Roots的引用链，<em>找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收</em>，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确的定位到这些对象的创建位置，进而找出产生内存泄漏的代码的具体位置。</li>
<li>如果不是内存泄漏，就是对象必须要存活的话，就要分析Java虚拟机堆参数（-Xmx与-Xms）设置，与机器内存相比，是否还是有上调的空间。<em>再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等等，尽量减少程序运行期间的内存消耗。</em></li>
</ul>
<h5 id="虚拟机和本地方法栈溢出"><a href="#虚拟机和本地方法栈溢出" class="headerlink" title="虚拟机和本地方法栈溢出"></a>虚拟机和本地方法栈溢出</h5><p>《Java虚拟机规范》中描述了两种情况:</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常</li>
<li>如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常<br>通常默认参数，对于正常的调用（包括不能做尾递归优化的递归调用），默认深度（1000~2000）完全够用。如果建立过多线程导致的内存溢出，在不能减少线程数量或者更换64位虚拟机的情况下，<strong>就只能通过减少最大堆和减少栈容量</strong> 来换取更多的线程</li>
</ul>
<h5 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h5><p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，要达成的条件比较苛刻。<br>在JDK8以后，永久代便完全退出了历史舞台，元空间作为其替代者登场，HotSpot提供了一些参数作为原空间的防御措施，主要包括：</p>
<ul>
<li>-XX: MaxMetaspaceSize: 设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小</li>
<li>-XX: MetaspaceSize：指定元空间初始空间大小，以字节为单位，达到该值就会触发垃圾收集器进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过XX: MaxMetaspaceSize（如果设置了的话）情况下，适当提高该值</li>
<li>-XX: MinMetaspaceFreeRatio：作用是在垃圾收集器之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有 <code>-XX: MinMetaspaceFreeRatio</code> 控制最大的元空间剩余容量的百分比。</li>
</ul>
<h5 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h5><p><strong>注：</strong> 至少本人目前从来没有直接接触到在Java程序层面涉及到的直接内存分配的场景，所以这节不作记录。</p>
<h2 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2><h3 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死"></a>对象已死</h3><h4 id="关于引用计数算法"><a href="#关于引用计数算法" class="headerlink" title="关于引用计数算法"></a>关于引用计数算法</h4><p>可以通过一个循环引用的Java程序实例就可以从侧面判定出，Java虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>当前主流的商用程序语言的内存管理子系统，都是通过 <strong>可达性分析(Reachability Analysis)</strong> 算法来判定对象是否存活的。<br><strong>基本思想：</strong> 通过一系列称为“GC Roots”的根对象作为起始点集，从这些点开始，根据引用向下搜索，搜索过程所走的路径称之为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者说（图论）从GC Roots到这个对象不可达时，则证明此对象时不可能再引用的。</p>
<p>Java技术体系中，可固定作为GC Roots对象包括以下几种类型：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量。</li>
<li>在方法区中 <strong>类静态属性</strong> 引用的对象，譬如Java类的引用类型静态变量</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p>除了这些固定GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其它对象“临时性”地加入，共同构成完整的GC Roots集合。譬如后文将会提到的 <strong>分代收集</strong> 和 <strong>局部回收（Partial GC）</strong></p>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为 <strong>强引用（Strongly Re-ference）</strong>、<strong>软引用（Soft Reference）</strong>、<strong>弱引用（Weak Reference）</strong>、和 <strong>虚引用（Phantom Reference）</strong> 这4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li>
<li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 <strong>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</strong> 在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
<h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>要真正宣告一个对象死亡，至少要经历两次标记的过程：</p>
<ul>
<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那他将会被第一次标记</li>
<li>随后进行一次筛选，筛选的条件是次对象是是否必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</li>
</ul>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集器。<br>方法区的垃圾收集主要回收两个部分： <strong>废弃的常量和不再使用的类型</strong></p>
<ul>
<li>回收废弃常量与回收Java堆中的对象非常相似，如果没有任何字符串对象引用常量池中的常量，且虚拟机中也没有其它地方引用这个字面量。如果此时发生内存回收，而且垃圾收集器判定必要的话，则这个常量会被回收。</li>
<li>判定一个类型是否属于“不再被使用的类”的条件就比较苛刻，需要同时满足下面三个条件：<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的</li>
<li>该类对应的java.lang.Class对象没有被任何地方引用，无法再任何地方通过反射访问该类。</li>
</ul>
</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>两个分代假说：</p>
<ul>
<li>弱分代假说（Weak Generational Hypothesis ）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（String Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。<br>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象一句其年龄（年龄即对象熬过垃圾收集的过程的次数）分配到不同的区域之中存储。<br>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了 <strong>“Minor GC”“Major GC”“Full GC”</strong> 这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了 <strong>“标记-复制算法”“标记-清除算法”“标记-整理算法”</strong> 等针对性的垃圾收集算法。</li>
</ul>
<p>通常意义下，直接可以按照不同内存区域中的对象，直接回收，但是往往存在一个明显的困难： <strong>对象不是孤立的，对象之间会存在跨代引用</strong>，为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p>
<ul>
<li>跨代引用假说（Intergenrational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>
</ul>
<p>统一定义：</p>
<ul>
<li>部分收集（Partial GC）：指 <strong>目标不是完整收集整个Java堆的垃圾收集</strong>，其中又分为<ul>
<li>新生代收集（Minor GC/Young GC）：<strong>指目标只是新生代的垃圾收集。</strong></li>
<li>老年代收集（Major GC/Old GC）：<strong>指目标只是老年代的垃圾收集。</strong> 目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：指目标是 <strong>收集整个新生代以及部分老年代的垃圾收集</strong>。目前只有G1收集器会有这种行为</li>
</ul>
</li>
<li>整堆收集（Full GC）：<strong>收集整个Java堆和方法区的垃圾收集</strong></li>
</ul>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>算法分为 <strong>“标记”和“清除”</strong> 两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。<br>该算法主要的两个问题：</p>
<ul>
<li>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须 <em>进行大量标记和清除的动作</em>，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li>
<li>第二个是 <strong>内存空间的碎片化问题</strong>，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>“半区复制”（Semispace Copying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<h5 id="该算法改进-Appel式回收"><a href="#该算法改进-Appel式回收" class="headerlink" title="该算法改进-Appel式回收"></a>该算法改进-Appel式回收</h5><p>称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。<br>Appel式回收的具体做法是：<strong>把新生代分为一块较大的Eden空间和两块较小的Survivor空间</strong>，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。</p>
<p><strong>特例：</strong> Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，<strong>当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</strong></p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，<strong>而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</strong>，“标记-整理”算法的示意图如图所示：<br><img data-src="d7ba81a7/mark_compact_demostration.png" alt="“标记-整理”算法示意图"></p>
<h3 id="HotSpot的算法细节实现"><a href="#HotSpot的算法细节实现" class="headerlink" title="HotSpot的算法细节实现"></a>HotSpot的算法细节实现</h3><p><strong>注：</strong> 这一节非常琐碎，对算法实现细节做了很多阐述，核心就是怎么高效的收集？与之带来的问题基本上是一环套一环的，可以暂时先了解，如遇到特定场景、特定问题之后，再回过头来啃一啃这里面的实现。暂时，也就记录一些名词，不去理解具体的实现细节。</p>
<h4 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h4><p>迄今为止，所有收集器在根节点枚举这一步骤时都是必须 <strong>暂停用户线程</strong> 的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。具体在HotSpot中的做法是：<br>使用一组称为 <strong>OopMap的数据结构</strong> 来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（见第11章）过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</p>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>前面提到的OopMap存在一个问题： <em>可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</em></p>
<p>实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，<strong>这些位置被称为安全点（Safepoint）。</strong><br>安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，<strong>“长时间执行”的最明显特征</strong> 就是 <strong>指令序列的复用</strong>，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>
<p>对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：<strong>抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</strong></p>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行”的时候呢？<br>所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候 <em>线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</em> 对于这种情况，就必须引入 <strong>安全区域（Safe Region）</strong> 来解决。</p>
<p><strong>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</strong></p>
<h4 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h4><h5 id="诞生的背景"><a href="#诞生的背景" class="headerlink" title="诞生的背景"></a>诞生的背景</h5><p>垃圾收集器在<strong>新生代</strong>中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。</p>
<p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。</p>
<h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？<br>我们引入<strong>三色标记（Tri-color M arking）</strong>作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li><strong>白色：</strong> 表示对象<strong>尚未</strong>被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li><strong>黑色：</strong> 表示对象<strong>已经</strong>被垃圾收集器访问过，且这个对象的<strong>所有引用</strong>都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li><strong>灰色：</strong> 表示对象已经被垃圾收集器访问过，但这个对象上<strong>至少存在一个引用</strong>还没有被扫描过。</li>
</ul>
<h3 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h3><p>说明：使用“经典”二字是为了与几款目前仍处于实验状态，但执行效果上有革命性改进的高性能低延迟收集器区分开来，这些经典的收集器尽管已经算不上是最先进的技术，但它们曾在实践中千锤百炼，足够成熟，基本上可认为是现在到未来两、三年内，能够在商用生产环境上放心使用的全部垃圾收集器了。<br><img data-src="d7ba81a7/hotspot_gc.png" alt="HotSpot虚拟机的垃圾收集器"></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。<br><img data-src="d7ba81a7/Serial_SerialOld.png" alt="Serial/Serial Old收集器运行示意图"><br><strong>Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择</strong></p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了<strong>同时使用多条线程进行垃圾收集</strong>之外，其余的行为包括Serial收集器完全一致。<br><img data-src="d7ba81a7/ParNew_SerialOld.png" alt="ParNew/Serial Old收集器运行示意图"><br>不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：<em>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</em><br>可以理解为：ParNew合并入CMS，成为它专门处理新生代的组成部分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。</p>
<p>ParNew收集器是激活CMS后（使用-XX：+UseConcMarkSweepGC选项）的默认新生代收集器，也可以使用-XX：+/-UseParNewGC选项来强制指定或者禁用它。</p>
<h5 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h5><ul>
<li><strong>并行（Parallel）：</strong> 并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。</li>
<li><strong>并发（Concurrent）：</strong> 并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求</li>
</ul>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是<strong>基于标记-复制算法实现</strong>的收集器，也是能够并行收集的多线程收集器</p>
<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，<em>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间</em>，而Parallel Scavenge收集器的目标则是<strong>达到一个可控制的吞吐量（Throughput）</strong>。所谓<strong>吞吐量</strong>就是<em>处理器用于运行用户代码的时间与处理器总消耗时间的比值</em></p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。<br><img data-src="d7ba81a7/SerialOld.png" alt="Serial Old收集器运行示意图"></p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。<br>由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分利用服务器多处理器的并行处理能力，<em>在老年代内存空间很大而且硬件规格比较高级的运行环境中</em>，<strong>这种组合的总吞吐量甚至不一定比ParNew加CMS的组合来得优秀。</strong><br><img data-src="d7ba81a7/ParallelOld.png" alt="ParallelOld收集器运行示意图"></p>
<p>**在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。<br>**</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。基于标记-清除算法实现。<br>基本分为四个步骤：</p>
<ul>
<li>1）初始标记（CMS initial mark）<strong>（Stop The World）</strong>：初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快；</li>
<li>2）并发标记（CMS concurrent mark）：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li>
<li>3）重新标记（CMS remark）<strong>（Stop The World）</strong>：而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（详见3.4.6节中关于增量更新的讲解），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>4）并发清除（CMS concurrent sweep）：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。<br><img data-src="d7ba81a7/Concurrent_Mark_Sweep.png" alt="Concurrent Mark Sweep收集器运行示意图"></li>
</ul>
<p>CMS至少有以下三个明显的缺点：</p>
<ul>
<li>CMS收集器对处理器资源非常敏感</li>
<li>由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。</li>
<li>CMS是一款基于“标记-清除”算法实现的收集器，就可能想到这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。可以适当调高参数**-XX：CMSInitiatingOccupancyFraction<strong>的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。<br>CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认是开启的，此参数从</strong>JDK 9开始废弃**），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction（此参数从JDK 9开始废弃），这个参数的作用是要求CM S收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。</li>
</ul>
<h4 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h4><p>面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>
<p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为<strong>多个大小相等的独立区域（Region）</strong>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p>
<p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1M B～32M B，且应为2的N次幂。</p>
<p>G1收集器之所以能建立可预测的停顿时间模型：是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>
<h4 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h4><p>衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”。</p>
<h5 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h5><h5 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h5><p>ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>
<h3 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h3><h4 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h4><p>从JDK 10开始，为了隔离垃圾收集器与Java虚拟机解释、编译、监控等子系统的关系，RedHat提出了垃圾收集器的统一接口，即JEP 304提案，Epsilon是这个接口的有效性验证和参考实现，同时也用于需要剥离垃圾收集器影响的性能测试和压力测试。</p>
<p><strong>背景：</strong><br>传统Java有着内存占用较大，在容器中启动时间长，即时编译需要缓慢优化等特点，这对大型应用来说并不是什么太大的问题，但对短时间、小规模的服务形式就有诸多不适。为了应对新的技术潮流，最近几个版本的JDK逐渐加入了提前编译、面向应用的类数据共享等支持。Epsilon也是有着类似的目标，如果读者的应用只要<strong>运行数分钟甚至数秒</strong>，只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。</p>
<h4 id="收集器的权衡"><a href="#收集器的权衡" class="headerlink" title="收集器的权衡"></a>收集器的权衡</h4><p>我们应该如何选择一款适合自己应用的收集器呢？这个问题的答案主要受以下三个因素影响：</p>
<ul>
<li>应用程序的主要关注点是什么？<ul>
<li>如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那吞吐量就是主要关注点；</li>
<li> 如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；</li>
<li> 而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。</li>
</ul>
</li>
<li>运行应用的基础设施如何？譬如硬件规格，要涉及的系统架构是x86-32/64、SPARC还是ARM /Aarch64；处理器的数量多少，分配内存的大小；选择的操作系统是Linux、Solaris还是Windows等。</li>
<li>使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？</li>
</ul>
<h4 id="虚拟机及垃圾收集器日志"><a href="#虚拟机及垃圾收集器日志" class="headerlink" title="虚拟机及垃圾收集器日志"></a>虚拟机及垃圾收集器日志</h4><p><strong>阅读分析虚拟机和垃圾收集器的日志是处理Java虚拟机内存问题必备的基础技能</strong>，垃圾收集器日志是一系列人为设定的规则，多少有点随开发者编码时的心情而定，没有任何的“业界标准”可言，换句话说，每个收集器的日志格式都可能不一样。</p>
<p>在JDK 9以前，HotSpot并没有提供统一的日志处理框架，虚拟机各个功能模块的日志开关分布在不同的参数上，<strong>日志级别、循环日志大小、输出格式、重定向等</strong> 设置在不同功能上都要单独解决。</p>
<p>直到JDK 9，这种混乱不堪的局面才终于消失，HotSpot所有功能的日志都收归到了“-Xlog”参数上</p>
<p>几个例子：</p>
<ul>
<li>查看GC基本信息，在JDK 9之前使用-XX：+PrintGC，JDK 9后使用-Xlog：gc</li>
<li>查看GC详细信息，在JDK 9之前使用-XX：+PrintGCDetails，在JDK 9之后使用-X-log：gc*</li>
<li>查看GC前后的堆、方法区可用容量变化，在JDK 9之前使用-XX：+PrintHeapAtGC，JDK 9之后使用-Xlog：gc+heap=debug</li>
<li>查看GC过程中用户线程并发时间以及停顿的时间，在JDK 9之前使用-XX：+Print-GCApplicationConcurrentTime以及-XX：+PrintGCApplicationStoppedTime，JDK 9之后使用-Xlog：safepoint：</li>
<li>查看收集器Ergonomics机制（自动设置堆空间各分代区域大小、收集目标等内容，从Parallel收集器开始支持）自动调节的相关信息。在JDK 9之前使用-XX：+PrintAdaptive-SizePolicy，JDK 9之后使用-Xlog：gc+ergo*=trace</li>
<li>查看熬过收集后剩余对象的年龄分布信息，在JDK 9前使用-XX：+PrintTenuring-Distribution，JDK 9之后使用-Xlog：gc+age=trace</li>
</ul>
<h4 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h4><p><img data-src="d7ba81a7/gc_params1.png" alt="垃圾收集相关的常用参数1"><br><img data-src="d7ba81a7/gc_params2.png" alt="垃圾收集相关的常用参数2"></p>
<h3 id="实战：内存分配与回收策略"><a href="#实战：内存分配与回收策略" class="headerlink" title="实战：内存分配与回收策略"></a>实战：内存分配与回收策略</h3><p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：<strong>自动给对象分配内存以及自动回收分配给对象的内存</strong>。</p>
<h4 id="对象优先分配再Eden内存"><a href="#对象优先分配再Eden内存" class="headerlink" title="对象优先分配再Eden内存"></a>对象优先分配再Eden内存</h4><p><strong>大多数情况下，对象再新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</strong>。<br>HotSpot虚拟机提供了 <code>-XX: +PrintGCDetails</code> 这个收集器参数日志，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候出书当前的内存各个区域分配的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">// 出现一次Minor GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>HotSpot虚拟机提供了 <code>-XX:PretenureSizeThreshold</code> 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区以及两个Survivor区之间来回复制，产生大量的内存复制操作。<br><strong>注意</strong><br>-XX：PretenureSizeThreshold参数只对Serial和ParNew两款新生代收集器有效，HotSpot的其他新生代收集器，如Parallel Scavenge并不支持这个参数。如果必须使用此参数进行调优，可考虑ParNew加CMS的收集器组合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">* -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPretenureSizeThreshold</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">byte</span>[] allocation;</span><br><span class="line">allocation = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老年代中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>HotSpot虚拟机中多数收集器都采用了<strong>分代收集来管理堆内存</strong>，那内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。<br>为做到这点，虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器</strong>，存储在对象头中（详见第2章）。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>-XX：MaxTenuringThreshold</code> 设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:Survivor-</span></span><br><span class="line"><span class="comment">Ratio=8 -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">* -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTenuringThreshold</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>]; <span class="comment">// 什么时候进入老年代决定于XX:MaxTenuringThreshold设置</span></span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="literal">null</span>;</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好地适应不同程序的内存状况，HotSpot虚拟机<strong>并不是永远</strong>要求对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">-XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment">* -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTenuringThreshold2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>]; <span class="comment">// allocation1+allocation2大于survivo空间一半</span></span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="literal">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间<strong>是否大于</strong>新生代所有对象总空间，</p>
<ul>
<li>如果这个条件成立，那这一次Minor GC可以确保是安全的。</li>
<li>如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；<ul>
<li>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，</li>
<li>如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；</li>
<li>如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。</li>
</ul>
</li>
</ul>
<p><strong>注：</strong> 说白了，就是在MinorGC前，需要判定老年代要不要腾出空间来存储Survivor中的内存对象，如果老年代自己都不够，那就来一次Full GC腾出空间来与Survivor空间置换之后，再进行MinorGC。</p>
<h2 id="第四章-虚拟机性能监控、故障处理工具"><a href="#第四章-虚拟机性能监控、故障处理工具" class="headerlink" title="第四章 虚拟机性能监控、故障处理工具"></a>第四章 虚拟机性能监控、故障处理工具</h2><p><strong>给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。</strong><br>这里说的数据包括但不限于异常堆栈、虚拟机运行日志、垃圾收集器日志、线程快照（threaddump/javacore文件）、堆转储快照（heapdump/hprof文件）等。</p>
<h3 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h3><ul>
<li>商业授权工具：主要是JMC（Java M ission Control）及它要使用到的JFR（Java Flight Recorder），JMC这个原本来自于JRockit的运维监控套件从JDK 7 Update 40开始就被集成到OracleJDK中，JDK 11之前都无须独立下载，但是在商业环境中使用它则是要付费的。</li>
<li>正式支持工具：这一类工具属于被长期支持的工具，不同平台、不同版本的JDK之间，这类工具可能会略有差异，但是不会出现某一个工具突然消失的情况。</li>
<li>实验性工具：这一类工具在它们的使用说明中被声明为“没有技术支持，并且是实验性质的”（Unsupported and Experimental）产品，日后可能会转正，也可能会在某个JDK版本中无声无息地消失。但事实上它们通常都非常稳定而且功能强大，也能在处理应用程序性能问题、定位故障时发挥很大的作用。</li>
</ul>
<h4 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps: 虚拟机进程状况工具"></a>jps: 虚拟机进程状况工具</h4><p>除了名字像UNIX的ps命令之外，它的功能也和ps命令类似：可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual M achine Identifier）。</p>
<p><strong>作用：</strong> 如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就必须依赖jps命令显示主类的功能才能区分了。<br><img data-src="d7ba81a7/jps_params.png" alt="jps工具主要选项"></p>
<h4 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h4><p>jstat（JVM Statistics M onitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的<strong>类加载、内存、垃圾收集、即时编译等运行时数据</strong>，在没有GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。</p>
<p><img data-src="d7ba81a7/jstat_params.png" alt="jstat工具主要选项"></p>
<h4 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h4><p>jinfo（Configuration Info for Java）的作用是实时查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了。</p>
<h4 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h4><p>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。如果不使用jmap命令，要想获取Java堆转储快照也还有一些比较“暴力”的手段：譬如在第2章中用过的-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件，又或者在Linux系统下通过<strong>Kill -3</strong>命令发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转储快照。</p>
<p><img data-src="d7ba81a7/jmap_params.png" alt="jmap工具主要选项"></p>
<h4 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h4><p>JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。<em>不过实事求是地说，在实际工作中，除非手上真的没有别的工具可用，否则多数人是不会直接使用jhat命令来分析堆转储快照文件的。</em></p>
<h4 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h4><p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。</p>
<p><img data-src="d7ba81a7/jstack_params.png" alt="jstack工具主要选项"></p>
<h3 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h3><p>注：本小结介绍了几种集中可视化分析内存的方案，各有特色，值得仔细研究，这是理论与实践相结合的最佳实践。</p>
<h4 id="JHSDB：基于服务代理的调试工具"><a href="#JHSDB：基于服务代理的调试工具" class="headerlink" title="JHSDB：基于服务代理的调试工具"></a>JHSDB：基于服务代理的调试工具</h4><p>JDK中提供了JCMD和JHSDB两个集成式的多功能工具箱，它们不仅整合了前面介绍的所有基础工具所能提供的专项功能，而且由于有着“后发优势”，能够做的往往比之前的老工具们更好、更强大。</p>
<p><strong>注：</strong> 本小节实践我实在jdk9.0.4版本下完成的，尝试在jdk8下实验，确实如作者所述在sa-jdi.jar包中存在HSDB工具类，但是尝试直接运行了，但是出现了找不到windbg.dll动态链接库的错误。因此，直接更换为jdk9运行。<strong>故而以下文字记录，基于本书介绍的同时，涉及测试的结果，均是个人实验记录所得，可能跟原书中表现有些许差异。</strong></p>
<p><strong>介绍</strong><br>JHSDB是一款基于服务性代理（Serviceability Agent，SA）实现的进程外调试工具。<br>服务性代理是HotSpot虚拟机中一组用于映射Java虚拟机运行信息的、主要基于Java语言（含少量JNI代码）实现的API集合。服务性代理以HotSpot内部的数据结构为参照物进行设计，把这些C++的数据抽象出Java模型对象，相当于HotSpot的C++代码的一个镜像。通过服务性代理的API，可以在一个独立的Java虚拟机的进程里分析其他HotSpot虚拟机的内部数据，或者从HotSpot虚拟机进程内存中dump出来的转储快照里还原出它的运行状态细节。</p>
<p>测试代码(跟原书中略有差别，主要体现在变量命名的差异)，这片代码主要用于调试，三个对象分布在内存哪里？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JHSDBTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">        <span class="type">ObjectHolder</span> <span class="variable">instanceObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ObjectHolder</span> <span class="variable">localObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>); <span class="comment">// 调试运行的时候，在这里设置一个断点，用于通过jps获取jvm进程id</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JHSDBTest</span>.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>答案：</strong> 根据前面的理论学习，不难分析出：<strong>staticObj随着Test的类型信息存放在方法区，instanceObj随着Test的对象实例存放在Java堆，localObject则是存放在foo()方法栈帧的局部变量表中。</strong><br>但是实际是这样的吗？<br>由于JHSDB本身对压缩指针的支持存在很多缺陷，建议用64位系统的读者在实验时禁用压缩指针，另外为了后续操作时可以加快在内存中搜索对象的速度，也建议读者限制一下Java堆的大小。本例中，作者建议采用的运行参数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmx10m -XX:+UseSerialGC -XX:-UseCompressedOops</span><br></pre></td></tr></table></figure>

<p>程序执行后，通过jps查到测试程序进程ID，从下面片段中得知，15986就是我们测试程序所要的进程id</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">kemi</span>&gt;<span class="title">jps</span> -<span class="title">l</span></span></span><br><span class="line"><span class="function">15252 <span class="title">org.jetbrains.idea.maven.server.RemoteMavenServer36</span></span></span><br><span class="line"><span class="function">15444</span></span><br><span class="line"><span class="function">13868 <span class="title">jdk.jcmd</span>/<span class="title">sun.tools.jps.Jps</span></span></span><br><span class="line"><span class="function">16172 <span class="title">D</span>:\<span class="title">Program</span></span></span><br><span class="line"><span class="function">3628 <span class="title">org.jetbrains.jps.cmdline.Launcher</span></span></span><br><span class="line"><span class="function">8588 <span class="title">cc.nimbusk.jhsdb.JHSDBTest</span></span></span><br></pre></td></tr></table></figure>

<p>紧接着，通过jhsdb命令，来运行可视化界面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jhsdb hsdb --pid <span class="number">8588</span></span><br></pre></td></tr></table></figure>

<p>运行之后，界面如下图所示<br><img data-src="d7ba81a7/hsdb_running_window.png" alt="JHSDB的界面"><br>从运行效果来看其实生成的就是一个Swing的小程序，这点我们从jdk8的sa-jdi.jar包中的目录结构也能看出来<br><img data-src="d7ba81a7/sa-jdi_jar_infrastructure.png" alt="sa-jdi.jar包目录结构"></p>
<p>点击菜单：<strong>Tools-&gt;Heap Parameters</strong>，就可以看到堆内存分配布局，由于作者的运行参数中 <strong>指定了使用的是Serial收集器</strong>，图中我们看到了典型的Serial的分代内存布局，Heap Parameters窗口中清楚列出了新生代的Eden、S1、S2和老年代的容量（单位为字节）以及它们的虚拟内存地址起止范围。<br><img data-src="d7ba81a7/jhsdb_heap_parameters.png" alt="Serial收集器的堆布局"><br>实际如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap Parameters:</span><br><span class="line">Gen 0:   eden [0x0000026f4d200000,0x0000026f4d2d57c8,0x0000026f4d4b0000) space capacity = 2818048, 31.029989553052324 used</span><br><span class="line">  from [0x0000026f4d500000,0x0000026f4d550000,0x0000026f4d550000) space capacity = 327680, 100.0 used</span><br><span class="line">  to   [0x0000026f4d4b0000,0x0000026f4d4b0000,0x0000026f4d500000) space capacity = 327680, 0.0 usedInvocations: 1</span><br><span class="line"></span><br><span class="line">Gen 1:   old  [0x0000026f4d550000,0x0000026f4d670de0,0x0000026f4dc00000) space capacity = 7012352, 16.873083382009344 usedInvocations: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>其中：<strong>0x0000026f4d200000</strong> 就是起始虚拟内存地址（eden新生代起始），<strong>0x0000026f4d500000</strong> 就是结束虚拟地址（To Survivor结束）</p>
<p>再通过菜单Windows-&gt;Console窗口，打开命令行，使用scanoops命令在Java堆的新生代（从Eden起始地址到To Survivor结束地址）范围内查找ObjectHolder的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scanoops <span class="number">0x0000026f4d200000</span> <span class="number">0x0000026f4d500000</span> cc.nimbusk.jhsdb.JHSDBTest$ObjectHolder</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hsdb&gt; scanoops <span class="number">0x0000026f4d200000</span> <span class="number">0x0000026f4d500000</span> cc.nimbusk.jhsdb.JHSDBTest$ObjectHolder</span><br><span class="line">No such type.</span><br><span class="line">hsdb&gt; scanoops <span class="number">0x0000026f4d200000</span> <span class="number">0x0000026f4d500000</span> cc.nimbusk.jhsdb.JHSDBTest$ObjectHolder</span><br><span class="line"><span class="number">0x0000026f4d2cb4b0</span> cc/nimbusk/jhsdb/JHSDBTest$ObjectHolder</span><br><span class="line"><span class="number">0x0000026f4d2cb4d8</span> cc/nimbusk/jhsdb/JHSDBTest$ObjectHolder</span><br><span class="line"><span class="number">0x0000026f4d2cb4e8</span> cc/nimbusk/jhsdb/JHSDBTest$ObjectHolder</span><br><span class="line">Error: sun.jvm.hotspot.debugger.DebuggerException: Windbg Error: ReadVirtual failed!</span><br><span class="line">hsdb&gt; </span><br></pre></td></tr></table></figure>

<p><strong>注：</strong> 这里跟书中作者有点区别，原书作者实例中，通过jps运行之后，得到的进程ID是没有包路径的，但是我自己实验的时候，发现是有的。这个在后面的scanoops命令使用的时候有用。如果不带包路径的话，在内存中是找不到的，会提示你 <strong>No such type</strong></p>
<p>我们从结果分析一下，确实在内存中找到三个ObjectHolder对象，我们再看看第一行地址分布：<br>这三个对象的地址前缀都是：<strong>0x0000026f4d2</strong>，而我们通过前面的Heap Parameters拿到所有分代内存分布发现，只有Eden区域地址（eden [0x0000026f4d200000,0x0000026f4d2d57c8,0x0000026f4d4b0000)），<strong>这也就顺带验证了：一般情况下新对象在Eden中创建的分配规则</strong>。</p>
<p>再使用：<strong>Tools-&gt;Inspector</strong> 功能确认一下这三个地址中存放的对象：<br><img data-src="d7ba81a7/jhsdb_tools_inspector.png" alt="Insepector实例数据"></p>
<p>Inspector为我们展示了对象头和指向对象元数据的指针，里面包括了 <strong>Java类型的名字、继承关系、实现接口关系，字段信息、方法信息、运行时常量池的指针、内嵌的虚方法表（vtable）以及接口方法表（itable）等。</strong> 由于我们的确没有在ObjectHolder上定义过任何字段，所以图中并没有看到任何实例字段数据，读者在做实验时不妨定义一些不同数据类型的字段，观察它们在HotSpot虚拟机里面是如何存储的。</p>
<p><strong>注：</strong> 实际上，目前在实验的时候，发现点不开_metadata._klass: InstanceKlass for cc/nimbusk/jhsdb/JHSDBTest$ObjectHolder，看不到里面具体的内容，后台报了一个数组越界的错误。尝试将JHSDBTest类包路径去除，重新运行发现又报了一个空指针错误。。。嗯，看来这个swing问题不少，暂时没去研究了</p>
<p>接下来要根据堆中对象实例地址找出引用它们的指针，原本JHSDB的Tools菜单中有ComputeReverse Ptrs来完成这个功能，但是Swing本身可能会报空指针异常，这里直接通过命令来实现，revptrs命令后跟上第一个对象的地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里内存地址跟前文中看到的不一样，是因为，中途切换环境，我重新运行了。实际实验的时候，同样的方法，按照实际分配的地址即可。这里不再赘述</span></span><br><span class="line">revptrs <span class="number">0x00000119d44ca868</span></span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hsdb&gt; revptrs <span class="number">0x00000119d44ca868</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">Oop <span class="keyword">for</span> java/lang/Class @ <span class="number">0x00000119d44c9488</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在通过Inspector查找这个地址：0x00000119d44c9488，得到如下图所示：<br><img data-src="d7ba81a7/jhsdb_class_object.png" alt="方法区实例内存地址"><br>果然找到了一个引用该对象的地方，是在一个 <code>java.lang.Class</code> 的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个 <code>java.lang.Class</code> 类型的对象实例，里面有一个名为 <strong>staticObj</strong> 的实例字段。（在JDK 7以前，即还没有开始“去永久代”行动时，这些静态变量是存放在永久代上的，JDK 7起把静态变量、字符常量这些从永久代移除出去。）</p>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。<strong>JDK 7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点。</strong></p>
<p>接着查找第二个对象实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hsdb&gt; revptrs <span class="number">0x00000119d44ca890</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">Oop <span class="keyword">for</span> JHSDBTest$Test @ <span class="number">0x00000119d44ca878</span></span><br></pre></td></tr></table></figure>

<p>这次找到一个类型为JHSDBTest$Test的对象实例，在Inspector中该对象实例显示如图所示：<br><img data-src="d7ba81a7/jhsdb_instance_object.png" alt="方法区实例内存地址"><br>这个结果完全符合我们的预期，第二个ObjectHolder的指针是在Java堆中JHSDBTest$Test对象的instanceObj字段上。</p>
<p>我们查找第三个对象的时候，发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hsdb&gt; revptrs <span class="number">0x00000119d44ca8a0</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">hsdb&gt; </span><br></pre></td></tr></table></figure>

<p><strong>看来revptrs命令并不支持查找栈上的指针引用，不过没有关系，得益于我们测试代码足够简洁，人工也可以来完成这件事情。</strong> 在Java Thread窗口选中main线程后点击Stack Memory按钮查看该线程的栈内存，如图下图所示：<br><img data-src="d7ba81a7/jhsdb_statck_memory.png" alt="stack memory按钮"><br>打开栈内存之后：<br><img data-src="d7ba81a7/jhsdb_statck_memory_view.png" alt="main线程的栈内存"></p>
<p>观察一个唯一的栈上的分配的内存，如下图所示：<br><img data-src="d7ba81a7/jhsdb_statck_memory_collection.png" alt="栈内存上的分配情况"><br>这个线程只有两个方法栈帧，尽管没有查找功能，<strong>但通过肉眼观察在地址0x0000000cb5aff570上的值正好就是0x00000119d44ca8a0</strong>，而且JHSDB在旁边已经自动生成注释，说明这里确实是引用了一个来自新生代的JHSDBTest$ObjectHolder对象。<br>至此，本次实验中三个对象均已找到，并成功追溯到引用它们的地方，也就实践验证了开篇中提出的这些对象的引用是存储在什么地方的问题。</p>
<p>JHSDB提供了非常强大且灵活的命令和功能，本节的例子只是其中一个很小的应用，读者在实际开发、学习时，可以用它来调试虚拟机进程或者dump出来的内存转储快照，以积累更多的实际经验。<br>关于其它的相关描述，查看fx大神的描述<a href="https://www.iteye.com/blog/rednaxelafx-1847971">rednaxelafx</a></p>
<h4 id="JConsole-Java监视与管理控制台"><a href="#JConsole-Java监视与管理控制台" class="headerlink" title="JConsole:Java监视与管理控制台"></a>JConsole:Java监视与管理控制台</h4><p>JConsole（Java Monitoring and Management Console）是一款基于JMX（Java Manage-mentExtensions）的可视化监视、管理工具。它的主要功能是通过JMX的MBean（Managed Bean）对系统进行信息收集和参数动态调整。<br>JMX是一种开放性的技术，不仅可以用在虚拟机本身的管理上，还可以运行于虚拟机之上的软件中，典型的如中间件大多也基于JMX来实现管理与监控。虚拟机对JMX MBean的访问也是完全开放的，可以使用代码调用API、支持JMX协议的管理控制台，或者其他符合JMX规范的软件进行访问。</p>
<h5 id="启动JConsole"><a href="#启动JConsole" class="headerlink" title="启动JConsole"></a>启动JConsole</h5><p><img data-src="d7ba81a7/jconsole_login.jpg" alt="JConsole连接页面"><br>通过JDK/bin目录下的jconsole.exe启动JConsole后，会自动搜索出本机运行的所有虚拟机进程，而不需要用户自己使用jps来查询，如图4-10所示。双击选择其中一个进程便可进入主界面开始监控。JMX支持跨服务器的管理，也可以使用下面的“远程进程”功能来连接远程服务器，对远程虚拟机进行监控。如下图所示：<br><img data-src="d7ba81a7/jconsole_main_page.jpg" alt="JConsole主界面"></p>
<h5 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h5><p>“内存”页签的作用相当于可视化的jstat命令，用于监视被收集器管理的虚拟机内存（被收集器直接管理的Java堆和被间接管理的方法区）的变化趋势。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存占位符对象，一个OOMObject大约占64KB&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 这段代码的作用是以64KB/50ms的速度向Java堆中填充数据，一共填充1000次，使用JConsole的“内存”页签进行监视，观察曲线和柱状指示图的变化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -Xms100m -Xmx100m -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nimbus.k 2021-08-03 22:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMObjectTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] placeholder = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fillHeap</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="comment">// 稍作延时，令监视曲线的变化更加明显</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        fillHeap(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解读：</strong><br>程序运行后，在“内存”页签中可以看到内存池Eden区的运行趋势呈现折线状，如图4-12所示。监视范围扩大至整个堆后，会发现曲线是一直平滑向上增长的。从柱状图可以看到，在1000次循环执行结束，运行了System.gc()后，虽然整个新生代Eden和Survivor区都基本被清空了，但是代表老年代的柱状图仍然保持峰值状态，说明被填充进堆中的数据在System.gc()方法执行之后仍然存活。</p>
<p>这里作者给我们提出了两个问题：</p>
<ul>
<li>虚拟机启动参数只限制了Java堆为100M B，但没有明确使用-Xmn参数指定新生代大小，读者能否从监控图中估算出新生代的容量？</li>
<li>为何执行了System.gc()之后，图4-12中代表老年代的柱状图仍然显示峰值状态，代码需要如何调整才能让System.gc()回收掉填充到堆中的对象？</li>
</ul>
<p><img data-src="d7ba81a7/jconsole_memory_monitoring.jpg" alt="Eden区内存变化状况"></p>
<p>问题1答案：图4-12显示Eden空间为27328KB，因为没有设置-XX：SurvivorRadio参数，所以Eden与Survivor空间比例的默认值为8∶1，因此整个新生代空间大约为27328KB×125%=34160KB。<br>问题2答案：执行System.gc()之后，空间未能回收是因为List<OOMObject>list对象仍然存活，fillHeap()方法仍然没有退出，因此list对象在System.gc()执行时仍然处于作用域之内 <strong>(准确地说，只有虚拟机使用解释器执行的时候，“在作用域之内”才能保证它不会被回收，因为这里的回收还涉及局部变量表变量槽的复用、即时编译器介入时机等问题，具体读者可参考第8章)</strong> 。如果把System.gc()移动到fillHeap()方法外调用就可以回收掉全部内存。</p>
<p><strong>注：</strong> 问题一答案容易理解，实际就是这么分配的，如果想要验证可以通过调整SurvivorRadio参数来调整；问题2，我们来通过稍微修改一下上述OOMObjectTest代码片段，来看看是不是如作者所说：<br>代码片段如下，只将main方法中相关代码做了调整，其余不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">200</span>;) &#123;</span><br><span class="line">            fillHeap(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 每被50整除时，再手工触发一次GC</span></span><br><span class="line">                System.gc();</span><br><span class="line">            &#125;</span><br><span class="line">            i = i + <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时运行监控结过，如下图所示：<br><img data-src="d7ba81a7/jconsole_memory_monitoring2.jpg" alt="Eden区内存完全回收场景"><br>从图中可以看出，确实完全回收了（留有少部分，毕竟还有其它区域代码的实例需要占用空间）</p>
<h5 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h5><p>如果说JConsole的“内存”页签相当于可视化的jstat命令的话，那“线程”页签的功能就相当于可视化的jstack命令了，遇到线程停顿的时候可以使用这个页签的功能进行分析。前面讲解jstack命令时提到 <strong>线程长时间停顿的主要原因有等待外部资源（数据库连接、网络资源、设备资源等）、死循环、锁等待等。</strong></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程死循环演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nimbus.k 2021-08-03 22:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMonitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程死循环演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createBusyThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">// 第41行</span></span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;testBusyThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程锁等待演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createLockThread</span><span class="params">(<span class="keyword">final</span> Object lock)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;testLockThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        br.readLine();</span><br><span class="line">        createBusyThread();</span><br><span class="line">        br.readLine();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        createLockThread(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行后，首先在“线程”页签中选择main线程，如图4-13所示。堆栈追踪显示BufferedReader的readBytes()方法正在等待System.in的键盘输入，这时候线程为Runnable状态，Runnable状态的线程仍会被分配运行时间，但readBytes()方法检查到流没有更新就会立刻归还执行令牌给操作系统，这种等待只消耗很小的处理器资源。<br><img data-src="d7ba81a7/jconsole_thread_main.jpg" alt="main线程"><br>接着监控testBusyThread线程，又如下图所示。testBusyThread线程一直在执行空循环，从堆栈追踪中看到一直在MonitoringTest.java代码的41行停留，41行的代码为while(true)。这时候线程为Runnable状态，而且没有归还线程执行令牌的动作，所以会在空循环耗尽操作系统分配给它的执行时间，直到线程切换为止，这种等待会消耗大量的处理器资源。<br><img data-src="d7ba81a7/jconsole_thread_testBusyThread.jpg" alt="testBusyThread线程"><br>testLockThread线程在等待lock对象的notify()或notifyAll()方法的出现，<strong>线程这时候处于WAITING状态，在重新唤醒前不会被分配执行时间。</strong> 如下图所示：<br><img data-src="d7ba81a7/jconsole_memory_testLockThread.jpg" alt="testLockThread线程"><br>testLockThread线程正处于正常的活锁等待中，只要lock对象的notify()或notifyAll()方法被调用，这个线程便能激活继续执行</p>
<h6 id="死锁代码样例"><a href="#死锁代码样例" class="headerlink" title="死锁代码样例"></a>死锁代码样例</h6><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一则死锁代码样例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nimbus.k 2021-08-03 23:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程死锁等待演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynAddRunalbe</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SynAddRunalbe</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.valueOf(a)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Integer.valueOf(b)) &#123;</span><br><span class="line">                    System.out.println(a + b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SynAddRunalbe</span>(<span class="number">1</span>, <span class="number">2</span>)).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SynAddRunalbe</span>(<span class="number">2</span>, <span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码释意</strong><br>这段代码开了200个线程去分别计算1+2以及2+1的值，理论上for循环都是可省略的，两个线程也可能会导致死锁，不过那样概率太小，需要尝试运行很多次才能看到死锁的效果。如果运气不是特别差的话，上面带for循环的版本最多运行两三次就会遇到线程死锁，程序无法结束。<br><strong>根本原因</strong><br>造成死锁的根本原<br>因是Integer.valueOf()方法出于减少对象创建次数和节省内存的考虑，会对数值为-128～127之间的Integer对象进行缓存（这是《Java虚拟机规范》中明确要求缓存的默认值，实际值可以调整，具体取决于java.lang.Integer.Integer-Cache.high参数的设置。），如果valueOf()方法传入的参数在这个范围之内，就直接返回缓存中的对象。也就是说代码中尽管调用了200次Integer.valueOf()方法，但一共只返回了两个不同的Integer对象。<em>假如某个线程的两个synchronized块之间发生了一次线程切换，那就会出现线程A在等待被线程B持有的Integer.valueOf(1)，线程B又在等待被线程A持有的Integer.valueOf(2)，结果大家都跑不下去的情况。</em></p>
<p><img data-src="d7ba81a7/jconsole_deadlock.jpg" alt="testLockThread线程"><br><strong>很清晰地显示，线程Thread-3在等待一个被线程Thread-4持有的Integer对象，而点击线程Thread-4则显示它也在等待一个被线程Thread-3持有的Integer对象，这样两个线程就互相卡住，除非牺牲其中一个，否则死锁无法释放。</strong></p>
<h4 id="VisualVM：多合-故障处理工具"><a href="#VisualVM：多合-故障处理工具" class="headerlink" title="VisualVM：多合-故障处理工具"></a>VisualVM：多合-故障处理工具</h4><p>VisualVM（All-in-One Java Troubleshooting Tool）是功能最强大的运行监视和故障处理程序之一，曾经在很长一段时间内是Oracle官方主力发展的虚拟机故障处理工具。Oracle曾在VisualVM的软件说明中写上了“All-in-One”的字样，预示着它除了 <strong>常规的运行监视、故障处理外，还将提供其他方面的能力，譬如性能分析（Profiling）。</strong><br>相比其它收费第三方工具，VisualVM还有一个很大的优点：<strong>不需要被监视的程序基于特殊Agent去运行，因此它的通用性很强，对应用程序实际性能的影响也较小，使得它可以直接应用在生产环境中。</strong></p>
<h5 id="VisualVM兼容范围与插件安装"><a href="#VisualVM兼容范围与插件安装" class="headerlink" title="VisualVM兼容范围与插件安装"></a>VisualVM兼容范围与插件安装</h5><p>VisualVM基于NetBeans平台开发工具，所以一开始它就具备了通过插件扩展功能的能力，有了插件扩展支持，VisualVM可以做到：</p>
<ul>
<li>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</li>
<li>监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息（jstat、jstack）。</li>
<li>dump以及分析堆转储快照（jmap、jhat）。</li>
<li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li>
<li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。</li>
<li>其他插件带来的无限可能性。</li>
</ul>
<p><strong>用笔者的话来说</strong><br>首次启动VisualVM后，读者先不必着急找应用程序进行监测，初始状态下的VisualVM并没有加载任何插件，虽然基本的监视、线程面板的功能主程序都以默认插件的形式提供，但是如果不在VisualVM上装任何扩展插件，就相当于放弃它最精华的功能，和没有安装任何应用软件的操作系统差不多。</p>
<p>独立安装的插件存储在VisualVM的根目录，譬如JDK 9之前自带的VisulalVM，插件安装后是放在JDK_HOME/lib/visualvm中的。<br>JDK 9之后VisulalVM形成了一个独立项目：<a href="https://visualvm.github.io/?Java_VisualVM">VisualVM主页</a></p>
<p>插件安装非特殊场景，无需手动安装，在有网络连接的环境下，点击“工具-&gt;插件菜单”，在页签的“可用插件”及“已安装”中列举了当前版本VisualVM可以使用的全部插件，选中插件后在右边窗口会显示这个插件的基本信息，如开发者、版本、功能描述等。<br><img data-src="d7ba81a7/visualvm_plugins_main_page.jpg" alt="testLockThread线程"></p>
<h5 id="生成、浏览堆转储快照"><a href="#生成、浏览堆转储快照" class="headerlink" title="生成、浏览堆转储快照"></a>生成、浏览堆转储快照</h5><p>在VisualVM中生成堆转储快照文件有两种方式，可以执行下列任一操作：</p>
<ul>
<li>在“应用程序”窗口中右键单击应用程序节点，然后选择“堆Dump”。</li>
<li>在“应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在“监视”标签中单击“堆Dump”。</li>
</ul>
<p>生成堆转储快照文件之后，应用程序页签会在该堆的应用程序下增加一个以[heap-dump]开头的子节点，并且在主页签中打开该转储快照，如图4-20所示。如果需要把堆转储快照保存或发送出去，就应在heapdump节点上右键选择“另存为”菜单，否则当VisualVM关闭时，生成的堆转储快照文件会被当作临时文件自动清理掉。要打开一个由已经存在的堆转储快照文件，通过文件菜单中的“装入”功能，选择硬盘上的文件即可。<br><img data-src="d7ba81a7/visualvm_heapdump.jpg" alt="浏览dump文件"></p>
<p>堆页签中的“摘要”面板可以看到应用程序dump时的运行时参数、System.getPro-perties()的内容、线程堆栈等信息；“类”面板则是以类为统计口径统计类的实例数量、容量信息；“实例”面板不能直接使用，因为VisualVM在此时还无法确定用户想查看哪个类的实例，所以需要通过“类”面板进入，在“类”中选择一个需要查看的类，然后双击即可在“实例”里面看到此类的其中500个实例的具体属性信息；“OQL控制台”面板则是运行OQL查询语句的，同jhat中介绍的OQL功能一样。如果读者想要了解具体OQL的语法和使用方法，可参见本书附录D的内容。</p>
<h4 id="Java-Mission-Control：可持续在线的监控工具"><a href="#Java-Mission-Control：可持续在线的监控工具" class="headerlink" title="Java Mission Control：可持续在线的监控工具"></a>Java Mission Control：可持续在线的监控工具</h4><p>Oracle Java SE Advanced &amp; Suite与普通Oracle Java SE在功能上的主要差别是前者包含了一系列的监控、管理工具，譬如用于企业JRE定制管理的AMC（Java Advanced M anagement Console）控制台、JUT（Java Usage Tracker）跟踪系统，用于持续收集数据的JFR（Java Flight Recorder）飞行记录仪和用于监控Java虚拟机的JMC（Java M ission Control）。<br>这些功能全部都是需要商业授权才能在生产环境中使用，但根据Oracle Binary Code协议，在个人开发环境中，允许免费使用JMC和JFR，本节笔者将简要介绍它们的原理和使用。</p>
<p>JFR是一套内建在HotSpot虚拟机里面的监控和基于事件的信息搜集框架，与其他的监控工具（如JProfiling）相比，Oracle特别强调它“可持续在线”（Always-On）的特性。 <strong>JFR在生产环境中对吞吐量的影响一般不会高于1%（甚至号称是Zero Performance Overhead）</strong>，而且JFR监控过程的开始、停止都是完全可动态的，即不需要重启应用。JFR的监控对应用也是完全透明的，即不需要对应用程序的源码做任何修改，或者基于特定的代理来运行。</p>
<h3 id="HotSpot虚拟机插件及工具"><a href="#HotSpot虚拟机插件及工具" class="headerlink" title="HotSpot虚拟机插件及工具"></a>HotSpot虚拟机插件及工具</h3><p>开发团队曾经编写（或者收集）过不少虚拟机的插件和辅助工具，它们存放在HotSpot源码hotspot/src/share/tools目录下，包括（含曾经有过但新版本中已被移除的）：</p>
<ul>
<li>Ideal Graph Visualizer：用于可视化展示C2即时编译器是如何将字节码转化为理想图，然后转化为机器码的。</li>
<li>Client Compiler Visualizer：用于查看C1即时编译器生成高级中间表示（HIR），转换成低级中间表示（LIR）和做物理寄存器分配的过程。</li>
<li>MakeDeps：帮助处理HotSpot的编译依赖的工具。</li>
<li>Project Creator：帮忙生成Visual Studio的.project文件的工具。</li>
<li>LogCompilation：将-XX：+LogCompilation输出的日志整理成更容易阅读的格式的工具。</li>
<li>HSDIS：即时编译器的反汇编插件。</li>
</ul>
<h4 id="HSDIS：JIT生成代码反汇编"><a href="#HSDIS：JIT生成代码反汇编" class="headerlink" title="HSDIS：JIT生成代码反汇编"></a>HSDIS：JIT生成代码反汇编</h4><p>《Java虚拟机规范》中的规定逐渐成为Java虚拟机实现的“概念模型”，即实现只保证与规范描述等效，而不一定是按照规范描述去执行。由于这个原因，我们在讨论程序的执行语义问题（虚拟机做了什么）时，在字节码层面上分析完全可行，<strong>但讨论程序的执行行为问题（虚拟机是怎样做的、性能如何）时，在字节码层面上分析就没有什么意义了，必须通过其他途径解决。</strong></p>
<p>HSDIS是一个被官方推荐的HotSpot虚拟机即时编译代码的反汇编插件，它包含在HotSpot虚拟机的源码当中，在OpenJDK的网站<a href="https://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/tip/src/share/tools/hsdis/">3</a>也可以找到单独的源码下载，但并没有提供编译后的程序。</p>
<p>HSDIS插件的作用是让HotSpot的-XX：+PrintAssembly指令调用它来把即时编译器动态生成的本地代码还原为汇编代码输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。读者可以根据自己的操作系统和处理器型号，<strong>从网上直接搜索、下载编译好的插件，直接放到JDK_HOME/jre/bin/server目录（JDK 9以下）或JDK_HOME/lib/amd64/server（JDK 9或以上）中即可使用。</strong><br><strong>注：</strong> 这里我自己编译了一个64位windows的<img data-src="d7ba81a7/hsdis-amd64.dll" alt="hsdis-amd64.dll">，运行jdk版本是：1.8.211</p>
<p>如果读者使用的是SlowDebug或者FastDebug版的HotSpot，那可以直接通过-XX：+PrintAssembly指令使用的插件；如果读者使用的是Product版的HotSpot，则还要额外加入一个-XX：+UnlockDiagnosticVMOptions参数才可以工作。<br>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.nimbusk.learningjvm.hsdis;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO</span></span><br><span class="line"><span class="comment"> * 虚拟机参数：-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp -XX:CompileCommand=dontinline,*Bar.sum -XX:CompileCommand=compileonly,*Bar.sum</span></span><br><span class="line"><span class="comment"> * 命令行：java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp -XX:CompileCommand=dontinline,*Bar.sum -XX:CompileCommand=compileonly,*Bar.sum cc.nimbusk.learningjvm.hsdis.Bar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nimbus.k 2021-08-07 11:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Bar</span>().sum(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解读参数：</strong><br>其中，参数-Xcomp是让虚拟机以编译模式执行代码，这样不需要执行足够次数来预热就能触发即时编译。两个-XX：CompileCommand的意思是让编译器不要内联sum()并且只编译sum()，-XX：+PrintAssembly就是输出反汇编内容。</p>
<p><strong>作者运行结果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Disassembling <span class="keyword">for</span> mach=<span class="string">&#x27;i386&#x27;</span>]</span><br><span class="line">[Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line"># &#123;method&#125; <span class="string">&#x27;sum&#x27;</span> <span class="string">&#x27;(I)I&#x27;</span> in <span class="string">&#x27;test/Bar&#x27;</span></span><br><span class="line"># <span class="built_in">this</span>: ecx = <span class="string">&#x27;test/Bar&#x27;</span></span><br><span class="line"># parm0: edx = <span class="type">int</span></span><br><span class="line"># [sp+<span class="number">0x20</span>] (sp of caller)</span><br><span class="line">……</span><br><span class="line"><span class="number">0x01cac407</span>: cmp <span class="number">0x4</span>(%ecx),%eax</span><br><span class="line"><span class="number">0x01cac40a</span>: jne <span class="number">0x01c6b050</span> ; &#123;runtime_call&#125;</span><br><span class="line">[Verified Entry Point]</span><br><span class="line"><span class="number">0x01cac410</span>: mov %eax,-<span class="number">0x8000</span>(%esp)</span><br><span class="line"><span class="number">0x01cac417</span>: push %ebp</span><br><span class="line"><span class="number">0x01cac418</span>: sub $<span class="number">0x18</span>,%esp ; *aload_0</span><br><span class="line">; - test.Bar::sum@<span class="number">0</span> (line <span class="number">8</span>)</span><br><span class="line">;; block B0 [<span class="number">0</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">0x01cac41b</span>: mov <span class="number">0x8</span>(%ecx),%eax ; *getfield a</span><br><span class="line">; - test.Bar::sum@<span class="number">1</span> (line <span class="number">8</span>)</span><br><span class="line"><span class="number">0x01cac41e</span>: mov $<span class="number">0x3d2fad8</span>,%esi ; &#123;oop(a</span><br><span class="line"><span class="string">&#x27;java/lang/Class&#x27;</span> = <span class="string">&#x27;test/Bar&#x27;</span>)&#125;</span><br><span class="line"><span class="number">0x01cac423</span>: mov <span class="number">0x68</span>(%esi),%esi ; *getstatic b</span><br><span class="line">; - test.Bar::sum@<span class="number">4</span> (line <span class="number">8</span>)</span><br><span class="line"><span class="number">0x01cac426</span>: add %esi,%eax</span><br><span class="line"><span class="number">0x01cac428</span>: add %edx,%eax</span><br><span class="line"><span class="number">0x01cac42a</span>: add $<span class="number">0x18</span>,%esp</span><br><span class="line"><span class="number">0x01cac42d</span>: pop %ebp</span><br><span class="line"><span class="number">0x01cac42e</span>: test %eax,<span class="number">0x2b0100</span> ; &#123;poll_return&#125;</span><br><span class="line"><span class="number">0x01cac434</span>: ret</span><br></pre></td></tr></table></figure>

<p><strong>笔者运行结果：</strong><br>看了一下，我是在64位环境下编译的，还是跟作者书中32位的有差距的，但是整体没什么问题。比如一个最明显的： <code>ret</code> 跟 <code>retq</code> ，为了更好的比较，我这里就都贴出来，但是后文中的分析还是摘录作者文章中分析示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompilerOracle: dontinline *Bar.sum</span><br><span class="line">CompilerOracle: compileonly *Bar.sum</span><br><span class="line">Loaded disassembler from G:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_211</span>\jre\bin\server\hsdis-amd64.dll</span><br><span class="line">Decoding compiled method <span class="number">0x0000000002dcca50</span>:</span><br><span class="line">Code:</span><br><span class="line">[Disassembling <span class="keyword">for</span> mach=<span class="string">&#x27;i386:x86-64&#x27;</span>]</span><br><span class="line">[Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line">  # &#123;method&#125; &#123;<span class="number">0x0000000025a92ab0</span>&#125; <span class="string">&#x27;sum&#x27;</span> <span class="string">&#x27;(I)I&#x27;</span> in <span class="string">&#x27;cc/nimbusk/learningjvm/hsdis/Bar&#x27;</span></span><br><span class="line">  # <span class="built_in">this</span>:     rdx:rdx   = <span class="string">&#x27;cc/nimbusk/learningjvm/hsdis/Bar&#x27;</span></span><br><span class="line">  # parm0:    r8        = <span class="type">int</span></span><br><span class="line">  #           [sp+<span class="number">0x40</span>]  (sp of caller)</span><br><span class="line">  <span class="number">0x0000000002dccba0</span>: mov    <span class="number">0x8</span>(%rdx),%r10d</span><br><span class="line">  <span class="number">0x0000000002dccba4</span>: shl    $<span class="number">0x3</span>,%r10</span><br><span class="line">  <span class="number">0x0000000002dccba8</span>: cmp    %rax,%r10</span><br><span class="line">  <span class="number">0x0000000002dccbab</span>: jne    <span class="number">0x0000000002b65f60</span>  ;   &#123;runtime_call&#125;</span><br><span class="line">  <span class="number">0x0000000002dccbb1</span>: data16 data16 nopw <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line">  <span class="number">0x0000000002dccbbc</span>: data16 data16 xchg %ax,%ax</span><br><span class="line">[Verified Entry Point]</span><br><span class="line">  <span class="number">0x0000000002dccbc0</span>: mov    %eax,-<span class="number">0x6000</span>(%rsp)</span><br><span class="line">  <span class="number">0x0000000002dccbc7</span>: push   %rbp</span><br><span class="line">  <span class="number">0x0000000002dccbc8</span>: sub    $<span class="number">0x30</span>,%rsp</span><br><span class="line">  <span class="number">0x0000000002dccbcc</span>: movabs $<span class="number">0x25a92d70</span>,%rax   ;   &#123;metadata(method data <span class="keyword">for</span> &#123;method&#125; &#123;<span class="number">0x0000000025a92ab0</span>&#125; <span class="string">&#x27;sum&#x27;</span> <span class="string">&#x27;(I)I&#x27;</span> in <span class="string">&#x27;cc/nimbusk/learningjvm/hsdis/Bar&#x27;</span>)&#125;</span><br><span class="line">  <span class="number">0x0000000002dccbd6</span>: mov    <span class="number">0xdc</span>(%rax),%esi</span><br><span class="line">  <span class="number">0x0000000002dccbdc</span>: add    $<span class="number">0x8</span>,%esi</span><br><span class="line">  <span class="number">0x0000000002dccbdf</span>: mov    %esi,<span class="number">0xdc</span>(%rax)</span><br><span class="line">  <span class="number">0x0000000002dccbe5</span>: movabs $<span class="number">0x25a92aa8</span>,%rax   ;   &#123;metadata(&#123;method&#125; &#123;<span class="number">0x0000000025a92ab0</span>&#125; <span class="string">&#x27;sum&#x27;</span> <span class="string">&#x27;(I)I&#x27;</span> in <span class="string">&#x27;cc/nimbusk/learningjvm/hsdis/Bar&#x27;</span>)&#125;</span><br><span class="line">  <span class="number">0x0000000002dccbef</span>: and    $<span class="number">0x0</span>,%esi</span><br><span class="line">  <span class="number">0x0000000002dccbf2</span>: cmp    $<span class="number">0x0</span>,%esi</span><br><span class="line">  <span class="number">0x0000000002dccbf5</span>: je     <span class="number">0x0000000002dccc1c</span>  ;*aload_0</span><br><span class="line">                                                ; - cc.nimbusk.learningjvm.hsdis.Bar::sum@<span class="number">0</span> (line <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">0x0000000002dccbfb</span>: mov    <span class="number">0xc</span>(%rdx),%eax     ;*getfield a</span><br><span class="line">                                                ; - cc.nimbusk.learningjvm.hsdis.Bar::sum@<span class="number">1</span> (line <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">0x0000000002dccbfe</span>: movabs $<span class="number">0x715d56770</span>,%rsi  ;   &#123;oop(a <span class="string">&#x27;java/lang/Class&#x27;</span> = <span class="string">&#x27;cc/nimbusk/learningjvm/hsdis/Bar&#x27;</span>)&#125;</span><br><span class="line">  <span class="number">0x0000000002dccc08</span>: mov    <span class="number">0x68</span>(%rsi),%esi    ;*getstatic b</span><br><span class="line">                                                ; - cc.nimbusk.learningjvm.hsdis.Bar::sum@<span class="number">4</span> (line <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">  <span class="number">0x0000000002dccc0b</span>: add    %esi,%eax</span><br><span class="line">  <span class="number">0x0000000002dccc0d</span>: add    %r8d,%eax</span><br><span class="line">  <span class="number">0x0000000002dccc10</span>: add    $<span class="number">0x30</span>,%rsp</span><br><span class="line">  <span class="number">0x0000000002dccc14</span>: pop    %rbp</span><br><span class="line">  <span class="number">0x0000000002dccc15</span>: test   %eax,-<span class="number">0xaacb1b</span>(%rip)        # <span class="number">0x0000000002320100</span></span><br><span class="line">                                                ;   &#123;poll_return&#125;</span><br><span class="line">  <span class="number">0x0000000002dccc1b</span>: retq  </span><br></pre></td></tr></table></figure>
<p><strong>书中作者解读</strong><br>虽然是汇编，但代码并不多，我们一句一句来阅读：</p>
<ul>
<li>mov%eax，-0x8000(%esp)：检查栈溢。</li>
<li>push%ebp：保存上一栈帧基址。</li>
<li>sub$0x18，%esp：给新帧分配空间。</li>
<li>mov 0x8(%ecx)，%eax：取实例变量a，这里0x8(%ecx)就是ecx+0x8的意思，前面代码片段“[Constants]”中提示了“this：ecx=’test/Bar’”，即ecx寄存器中放的就是this对象的地址。偏移0x8是越过this对象的对象头，之后就是实例变量a的内存位置。这次是访问Java堆中的数据。</li>
<li>mov$0x3d2fad8，%esi：取test.Bar在方法区的指针。</li>
<li>mov 0x68(%esi)，%esi：取类变量b，这次是访问方法区中的数据。</li>
<li>add%esi，%eax、add%edx，%eax：做2次加法，求a+b+c的值，前面的代码把a放在eax中，把b放在esi中，而c在[Constants]中提示了，“parm0：edx=int”，说明c在edx中。</li>
<li>add$0x18，%esp：撤销栈帧。</li>
<li>pop%ebp：恢复上一栈帧。</li>
<li>test%eax，0x2b0100：轮询方法返回处的SafePoint。</li>
<li>ret：方法返回。</li>
</ul>
<p><strong>笔者64位运行环境下结果比较</strong><br>目前笔者能力有限，汇编的知识早已还给老师了。主要从[Verified Entry Point]下面看起，跟32位环境，以及作者并没有介绍示例代码运行的JDK环境，至少能看出来，在1.8下，hotspot运行在分配内存的时候，还是要多做了一些事情的。</p>
<p><a href="https://github.com/AdoptOpenJDK/jitwatch">JITWatch</a>是HSDIS经常搭配使用的可视化的编译日志分析工具，为便于在JITWatch中读取，读<br>者可使用以下参数把日志输出到logfile文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+TraceClassLoading</span><br><span class="line">-XX:+LogCompilation</span><br><span class="line">-XX:LogFile=/tmp/logfile.log</span><br><span class="line">-XX:+PrintAssembly</span><br><span class="line">-XX:+TraceClassLoading</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong> GitHub页面上有对应的release包使用，直接访问下载即可。重新修改参数之后，运行一下得到运行结果的log，这里贴一下我运行的<br><img data-src="d7ba81a7/logfile.log" alt="logfile.log"><br>运行界面如下图所示（由于作者没有继续深入，暂时这块笔者暂定，后续有机会再补充详细设定）：<br><img data-src="d7ba81a7/JITWatch_window.jpg" alt="JITWatch运行界面"></p>
<h5 id="JITWatch详细使用"><a href="#JITWatch详细使用" class="headerlink" title="JITWatch详细使用"></a>JITWatch详细使用</h5><h2 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h2><p><strong>注：</strong> 作者在书中是这么说的：<strong>在前面3章笔者系统性地介绍了处理Java虚拟机内存问题的知识与工具，在处理应用中的实际问题时，除了知识与工具外，经验同样是一个很重要的因素。</strong>，对于笔者个人来说又何尝不是如此呢？本章都是作者经验之笔，所以我在摘录的时候，多数直接从文章中拎出来了。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>本章内容将着重考虑如何在应用部署层面去解决问题，有不少案例中的问题的确可以在设计和开发阶段就先行避免，但这并不是本书要讨论的话题。也有一些问题可以直接通过升级硬件或者使用最新JDK版本里的新技术去解决，但我们同时也会探讨如何在不改变已有软硬件版本和规格的前提下，调整部署和配置策略去解决或者缓解问题。</p>
<h4 id="大内存硬件上的程序部署策略"><a href="#大内存硬件上的程序部署策略" class="headerlink" title="大内存硬件上的程序部署策略"></a>大内存硬件上的程序部署策略</h4><p>每一款Java虚拟机中的每一款垃圾收集器都有自己的应用目标与最适合的应用场景，如果在特定场景中选择了不恰当的配置和部署方式，自然会事倍功半。目前单 <strong>体应用在较大内存</strong>的硬件上主要的部署方式有两种：</p>
<ul>
<li>通过一个单独的Java虚拟机实例来管理大量的Java堆内存。</li>
<li>同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源。</li>
</ul>
<p>此案例中的管理员采用了第一种部署方式。对于用户交互性强、对停顿时间敏感、内存又较大的系统，并不是一定要使用Shenandoah、ZGC这些明确以控制延迟为目标的垃圾收集器才能解决问题（当然不可否认，如果情况允许的话，这是最值得考虑的方案），使用Parallel Scavenge/Old收集器，并且给Java虚拟机分配较大的堆内存也是有很多运行得很成功的案例的，<strong>但前提是必须把应用的Full GC频率控制得足够低</strong>，至少要低到不会在用户使用过程中发生，譬如十几个小时乃至一整天都不出现一次Full GC，这样 <em>可以通过在深夜执行定时任务的方式触发Full GC甚至是自动重启应用服务器来保持内存可用空间在一个稳定的水平。</em><br><strong>控制Full GC频率的关键是老年代的相对稳定</strong>，这主要取决于应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。<br>在许多网站和B/S形式的应用里，多数对象的生存周期都应该是请求级或者页面级的，会话级和全局级的长生命对象相对较少。只要代码写得合理，实现在超大堆中正常使用没有Full GC应当并不困难，这样的话，使用超大堆内存时，应用响应速度才可能会有所保证。除此之外，如果读者计划使用单个Java虚拟机实例来管理大内存，还需要考虑下面可能面临的问题：</p>
<ul>
<li>回收大块堆内存而导致的长时间停顿，自从G1收集器的出现，增量回收得到比较好的应用，这个问题有所缓解，但要到ZGC和Shenandoah收集器成熟之后才得到相对彻底地解决。</li>
<li>大内存必须有64位Java虚拟机的支持，但由于压缩指针、处理器缓存行容量（Cache Line）等因素，<strong>64位虚拟机的性能测试结果普遍略低于相同版本的32位虚拟机。</strong></li>
<li>必须保证应用程序足够稳定，因为这种大型单体应用要是发生了堆内存溢出，几乎无法产生堆转储快照（要产生十几GB乃至更大的快照文件），哪怕成功 <strong>生成了快照也难以进行分析</strong>；如果确实出了问题要进行诊断，可能就必须应用JMC这种能够在生产环境中进行的运维工具。</li>
<li>相同的程序在64位虚拟机中消耗的内存一般比32位虚拟机要大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的，<strong>可以开启（默认即开启）压缩指针功能来缓解。</strong></li>
</ul>
<p>考虑到我们在一台物理机器上建立逻辑集群的目的仅仅是尽可能利用硬件资源，并不是要按职责、按领域做应用拆分，也不需要考虑状态保留、热转移之类的高可用性需求，不需要保证每个虚拟机进程有绝对准确的均衡负载，因此使用无Session复制的亲合式集群是一个相当合适的选择。仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（譬如根据Session ID分配）将一个固定的用户请求永远分配到一个固定的集群节点进行处理即可，这样程序开发阶段就几乎不必为集群环境做任何特别的考虑。<br>当然，第二种部署方案也不是没有缺点的，如果读者计划使用逻辑集群的方式来部署程序，可能会遇到下面这些问题：</p>
<ul>
<li>节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），<em>很容易导致I/O异常。</em></li>
<li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点的连接池已经满了，而另外一些节点仍有较多空余。尽管可以使用<em>集中式的JNDI</em>来解决，但这个方案有一定复杂性并且可能带来额外的性能代价。</li>
<li>如果使用32位Java虚拟机作为集群节点的话，各个节点仍然不可避免地受到<em>32位的内存限制</em>，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆最多一般只能开到1.5GB。在某些Linux或UNIX系统（如Solaris）中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB（2的32次幂）内存的限制。</li>
<li>大量使用本地缓存（如大量使用HashMap作为K/V缓存）的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把<em>本地缓存改为集中式缓存。</em></li>
</ul>
<p>介绍完这两种部署方式，重新回到这个案例之中：</p>
<ul>
<li>最后的部署方案并没有选择升级JDK版本，而是调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），占用了10GB内存</li>
<li>另外建立一个Apache服务作为前端均衡代理作为访问门户。</li>
<li>考虑到用户对响应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问，处理器资源敏感度较低，因此改为CMS收集器进行垃圾回收。<br>部署方式调整后，服务再没有出现长时间停顿，速度比起硬件升级前有较大提升。</li>
</ul>
<h4 id="集群间同步导致的内存溢出"><a href="#集群间同步导致的内存溢出" class="headerlink" title="集群间同步导致的内存溢出"></a>集群间同步导致的内存溢出</h4><h5 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h5><p>一个基于B/S的MIS系统，硬件为两台双路处理器、8GB内存的HP小型机，应用中间件是WebLogic9.2，每台机器启动了3个WebLogic实例，构成一个6个节点的亲合式集群。由于是亲合式集群，节点之间没有进行Session同步，但是有一些需求要实现部分数据在各个节点间共享。最开始这些数据是存放在数据库中的，但由于读写频繁、竞争很激烈，性能影响较大，后面使用JBossCache构建了一个全局缓存。全局缓存启用后，服务正常使用了一段较长的时间。但在最近不定期出现多次的内存溢出问题。</p>
<h5 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h5><p>管理员发回了堆转储快照，发现里面存在着大量的org.jgroups.protocols.pbcast.NAKACK对象。JBossCache是基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现收发数据包的各种所需特性自由组合，数据包接收和发送时要经过每层协议栈的up()和down()方法，其中的NAKACK栈用于保障各个包的有效顺序以及重发。</p>
<p>由于信息有传输失败需要重发的可能性，在确认所有注册在GMS（Group M embership Service）的节点都收到正确的信息前，发送的信息必须在内存中保留。而此MIS的服务端中有一个负责安全校验的全局过滤器，每当接收到请求时，均会更新一次最后操作时间，并且将这个时间同步到所有的节点中去，使得一个用户在一段时间内不能在多台机器上重复登录。在服务使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间网络交互非常频繁。<strong>当网络情况不能满足传输要求时，重发数据在内存中不断堆积，很快就产生了内存溢出。</strong></p>
<h4 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h4><h5 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h5><p>这是一个学校的小型项目：基于B/S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据，系统使用了逆向AJAX技术（也称为Comet或者Server Side Push），选用CometD 1.1.1作为服务端推送框架，服务器是Jetty 7.1.4，硬件为一台很普通PC机，Core i5 CPU，4GB内存，运行32位Windows操作系统。</p>
<h5 id="发现过程"><a href="#发现过程" class="headerlink" title="发现过程"></a>发现过程</h5><p>测试期间发现服务端不定时抛出内存溢出异常，服务不一定每次都出现异常，但假如正式考试时崩溃一次，那估计整场电子考试都会乱套。网站管理员尝试过把堆内存调到最大，32位系统最多到1.6GB基本无法再加大了，而且开大了基本没效果，抛出内存溢出异常好像还更加频繁。加入-XX：+HeapDumpOnOutOfMemoryError参数，居然也没有任何反应，抛出内存溢出异常时什么文件都没有产生。无奈之下只好挂着jstat紧盯屏幕，发现垃圾收集并不频繁，Eden区、Survivor区、老年代以及方法区的内存全部都很稳定，压力并不大，但就是照样不停抛出内存溢出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[org.eclipse.jetty.util.log] handle failed java.lang.OutOfMemoryError: <span class="literal">null</span></span><br><span class="line">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">99</span>)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">288</span>)</span><br><span class="line">at org.eclipse.jetty.io.nio.DirectNIOBuffer.&lt;init&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h5 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h5><p>在此应用中导致溢出的关键是垃圾收集进行时，虚拟机虽然会对直接内存进行回收，但是直接内存却不能像新生代、老年代那样，发现空间不足了就主动通知收集器进行垃圾回收，它只能等待老年代满后Full GC出现后，“顺便”帮它清理掉内存的废弃对象。否则就不得不一直等到抛出内存溢出异常时，先捕获到异常，再在Catch块里面通过System.gc()命令来触发垃圾收集。但如果Java虚拟机再打开了-XX：+DisableExplicitGC开关，禁止了人工触发垃圾收集的话，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。而本案例中使用的CometD 1.1.1框架，正好有大量的NIO操作需要使用到直接内存。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>从实践经验的角度出发，在处理小内存或者32位的应用问题时，<strong>除了Java堆和方法区之外，我们注意到下面这些区域还会占用较多的内存，这里所有的内存总和受到操作系统进程最大内存的限制：</strong></p>
<ul>
<li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（如果线程请求的栈深度大于虚拟机所允许的深度）或者OutOfMemoryError（如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存）。</li>
<li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，可能会抛出IOException：Too many open files异常。</li>
<li>JNI代码：如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中，而是占用Java虚拟机的本地方法栈和本地内存的。</li>
<li>虚拟机和垃圾收集器：虚拟机、垃圾收集器的工作也是要消耗一定数量的内存的。</li>
</ul>
<h4 id="外部命令导致系统缓慢"><a href="#外部命令导致系统缓慢" class="headerlink" title="外部命令导致系统缓慢"></a>外部命令导致系统缓慢</h4><p>在Java虚拟机中，用户编写的Java代码通常最多只会创建新的线程，不应当有进程的产生，这又是个相当不正常的现象。<br>通过联系该系统的开发人员，最终找到了答案：<strong>每个用户请求的处理都需要执行一个外部Shell脚本来获得系统的一些信息。</strong><br>执行这个Shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的。这种调用方式可以达到执行Shell脚本的目的，但是它在Java虚拟机中是非常消耗资源的操作，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。Java虚拟机执行这个命令的过程是首先复制一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。<strong>如果频繁执行这个操作，系统的消耗必然会很大，而且不仅是处理器消耗，内存负担也很重。</strong></p>
<h4 id="服务器虚拟机进程崩溃"><a href="#服务器虚拟机进程崩溃" class="headerlink" title="服务器虚拟机进程崩溃"></a>服务器虚拟机进程崩溃</h4><h5 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h5><p>一个基于B/S的MIS系统，硬件为两台双路处理器、8GB内存的HP系统，服务器是WebLogic9.2（与第二个案例中那套是同一个系统）。正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个hs_err_pid###.log文件后，虚拟机进程就消失了，两台物理机器里的每个节点都出现过进程崩溃的现象。从系统日志中注意到，每个节点的虚拟机进程在崩溃之前，都发生过大量相同的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.net.SocketException: Connection reset</span><br><span class="line">at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">168</span>)</span><br><span class="line">at java.io.BufferedInputStream.fill(BufferedInputStream.java:<span class="number">218</span>)</span><br><span class="line">at java.io.BufferedInputStream.read(BufferedInputStream.java:<span class="number">235</span>)</span><br><span class="line">at org.apache.axis.transport.http.HTTPSender.readHeadersFromSocket(HTTPSender.java:<span class="number">583</span>)</span><br><span class="line">at org.apache.axis.transport.http.HTTPSender.invoke(HTTPSender.java:<span class="number">143</span>)</span><br><span class="line">... <span class="number">99</span> more</span><br></pre></td></tr></table></figure>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>这是一个远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的待办事项变化时，要通过Web服务通知OA门户系统，把待办事项的变化同步到OA门户之中。通过SoapUI测试了一下同步待办事项的几个Web服务，发现调用后竟然需要长达3分钟才能返回，并且返回结果都是超时导致的连接中断。<br>由于MIS系统的用户多，待办事项变化很快，为了不被OA系统速度拖累，使用了异步的方式调用Web服务，<strong>但由于两边服务速度的完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃。</strong></p>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>通知OA门户方修复无法使用的集成接口，并将<strong>异步调用改为生产者/消费者模式的消息队列</strong>实现后，系统恢复正常。</p>
<h4 id="不恰当数据结构导致内存占用过大"><a href="#不恰当数据结构导致内存占用过大" class="headerlink" title="不恰当数据结构导致内存占用过大"></a>不恰当数据结构导致内存占用过大</h4><h2 id="第6章-类文件结构"><a href="#第6章-类文件结构" class="headerlink" title="第6章 类文件结构"></a>第6章 类文件结构</h2><p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>“无符号数”和“表”。</strong></p>
<ul>
<li><strong>无符号数</strong>属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li><strong>表</strong>是由多个无符号数或者其他表作为数据项构成的<em>复合数据类型</em>，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由表6-1所示的数据项按严格顺序排列构成。<br><img data-src="d7ba81a7/class_file_infrastracture.jpg" alt="Class文件格式"><br>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。</li>
</ul>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。。Class文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE。<br>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。<br>一则测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.clazz;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>书中作者都是用JDK1.6编译运行的，后文贴图等相关，均会是我通过JDK1.9编译运行<br><img data-src="d7ba81a7/data_interpretor_major_version.jpg" alt="Java Class文件结构-主版本号"><br>如书中所述：开头4个字节的十六进制表示是0xCAFEBABE，代表次版本号的第5个和第6个字节值为0x0000，而主版本号的值为0x0035，也即是十进制的53，也就是支持JDK1.9版本<br>关于次版本号：而到了JDK 12时期，由于JDK提供的功能集已经非常庞大，有一些复杂的新特性需要以“公测”的形式放出，所以设计者重新启用了副版本号，将它用于标识“技术预览版”功能特性的支持。如果Class文件中使用了该版本JDK尚未列入正式特性清单中的预览功能，则必须把次版本号标识为65535，以便Java虚拟机在加载类文件时能够区分出来。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，<em>它是Class文件结构中与其他项目关联最多的数据</em>，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。<br>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不同，这个容量计数是从1而不是0开始的。如下图所示：<br><img data-src="d7ba81a7/data_interpretor_constant_poll_count.jpg" alt="常量池计数"><br><strong>注</strong> 常量池容量（偏移地址：0x00000008）为十六进制数0x0013，即十进制的19，这就代表常量池中有18项常量。（这个跟作者的1.6编译的，不一样，书中标注的有21项，整整少了3项）。<br><strong>之所以常量池从1开始计数：</strong> 设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始。<br>常量池中主要存放两大类常量：<strong>字面量（Literal）和符号引用（Symbolic References）。</strong>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而 <em>符号引用则属于编译原理方面</em> 的概念，主要包括下面几类常量：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）<br>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接（具体见第7章）。也就是说，<strong>在Class文件中不会保存各个方法、字段最终在内存中的布局信息</strong>，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。<br>常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量[1]，为了支持Java模块化系统（Jigsaw），又加入了CONSTANT_M odule_info和CONSTANT_Package_info两个常量，所以截至JDK13，常量表中分别有17种不同类型的常量。<br><img data-src="d7ba81a7/data_interpretor_constant_poll_tags.jpg" alt="常量池的项目类型"></li>
</ul>
<p><em>之所以说常量池是最烦琐的数据，是因为这17种常量类型各自有着完全独立的数据结构，两两之间并没有什么共性和联系，因此只能逐项进行讲解。</em><br><strong>注：</strong>笔者也会根据The Java Virtual Machine Specification Java SE 9 Edition版本中的相关章节描述进行补充说明，由于实际在win10系统下编译跟书本中描述出入有点大，后续关于具体细致内容，主要以书本介绍为主。具体自行编译结果，后续等章节末尾，会单独开小节去研究。<br><img data-src="d7ba81a7/constant_pool_structure.jpg" alt="常量池结构"><br>第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，查表的标志列可知这个常量属于 <strong>CONSTANT_Class_info</strong>类型，此类型的常量代表一个类或者接口的符号引用。CONSTANT_Class_info的结构比较简单：<br><img data-src="d7ba81a7/CONSTANT_Class_info.jpg" alt="CONSTANT_Class_info型常量的结构"><br>书中示例用javap分析Class文件字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt;javap -verbose TestClass</span><br><span class="line">Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class org.fenixsoft.clazz.TestClass extends java.lang.Object</span><br><span class="line">SourceFile: &quot;TestClass.java&quot;</span><br><span class="line">minor version: 0</span><br><span class="line">major version: 50</span><br><span class="line">Constant pool:</span><br><span class="line">const #1 = class #2; // org/fenixsoft/clazz/TestClass</span><br><span class="line">const #2 = Asciz org/fenixsoft/clazz/TestClass;</span><br><span class="line">const #3 = class #4; // java/lang/Object</span><br><span class="line">const #4 = Asciz java/lang/Object;</span><br><span class="line">const #5 = Asciz m;</span><br><span class="line">const #6 = Asciz I;</span><br><span class="line">const #7 = Asciz &lt;init&gt;;</span><br><span class="line">const #8 = Asciz ()V;</span><br><span class="line">const #9 = Asciz Code;</span><br><span class="line">const #10 = Method #3.#11; // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">const #11 = NameAndType #7:#8;// &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">const #12 = Asciz LineNumberTable;</span><br><span class="line">const #13 = Asciz LocalVariableTable;</span><br><span class="line">const #14 = Asciz this;</span><br><span class="line">const #15 = Asciz Lorg/fenixsoft/clazz/TestClass;;</span><br><span class="line">const #16 = Asciz inc;</span><br><span class="line">const #17 = Asciz ()I;</span><br><span class="line">const #18 = Field #1.#19; // org/fenixsoft/clazz/TestClass.m:I</span><br><span class="line">const #19 = NameAndType #5:#6; // m:I</span><br><span class="line">const #20 = Asciz SourceFile;</span><br><span class="line">const #21 = Asciz TestClass.java;</span><br></pre></td></tr></table></figure>

<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。如下图所示：<br><img data-src="d7ba81a7/access_flag.jpg" alt="访问标志"><br><strong>分析过程：</strong>access_flags中一共有16个标志位可以使用，当前只定义了其中9个，没有使用到的标志位要求一律为零。以代码清单6-1中的代码为例，TestClass是一个普通Java类，不是接口、枚举、注解或者模块，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_M ODULE这七个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。从图6-5中看到，access_flags标志（偏移地址：0x000000EF）的确为0x0021。</p>
<h4 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h4><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。读者可以回忆一下在Java语言中描述一个字段可以包含哪些信息。字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。</p>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项</p>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。</p>
<h3 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h3><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构（这两种架构的执行过程、区别和影响将在第8章中探讨），<strong>所以大多数指令都不包含操作数，只有一个操作码</strong>，指令参数都存放在操作数栈中。<br>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。<strong>因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。</strong></p>
<h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之间来回传输，这类指令包括：</p>
<ul>
<li>将一个局部变量加载到操作栈： <code>iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、dload_&lt;n&gt;、aload、aload_&lt;n&gt;</code></li>
<li>将一个数值从操作数栈存储到局部变量表： <code>istore、istore_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt;</code></li>
<li>将一个常量加载到操作数栈： <code>bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</code></li>
<li>扩充局部变量表的访问索引的指令：wide</li>
</ul>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如 <code>iload_&lt;n&gt;</code> ），这些指令助记符实际上代表了一组指令（例如 <code>iload_&lt;n&gt;</code>，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。</p>
<h4 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h4><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上运算指令可以分为两种：<em>对整型数据进行运算的指令与对浮点型数据进行运算的指令。</em><br>无论是哪种算术指令，均是使用Java虚拟机的算术类型来进行计算的，换句话说是不存在直接支持byte、short、char和boolean类型的算术指令，对于上述几种数据的运算，应使用操作int类型的指令代替。所有的算术指令包括：</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imul、lmul、fmul、dmul</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem</li>
<li>取反指令：ineg、lneg、fneg、dneg</li>
<li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
<li>局部变量自增指令：iinc</li>
<li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li>
</ul>
<p>数据运算可能会导致溢出，《Java虚拟机规范》中并没有明确定义过整型数据溢出具体会得到什么计算结果，仅规定了在处理整型数据时，<strong>只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）</strong>中当 <strong>出现除数为零</strong>时会导致虚拟机抛出ArithmeticException异常，其余任何整型数运算场景都不应该抛出运行时异常。</p>
<h4 id="类型转化指令"><a href="#类型转化指令" class="headerlink" title="类型转化指令"></a>类型转化指令</h4><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作。<br>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversion，即小范围类型向大范围类型的安全转换）：</p>
<ul>
<li>int类型到long、float或者double类型</li>
<li>long类型到float、double类型</li>
<li>float类型到double类型<br>与之相对的，处理窄化类型转换（Narrowing Numeric Conversion）时，<em>就必须显式地使用转换指令来完成</em>，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。<strong>窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</strong></li>
</ul>
<h4 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h4><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在下一章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：<br>-创建类实例的指令：new<br>-创建数组的指令：newarray、anewarray、multianewarray<br>-访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic<br>-把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload<br>-将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore<br>-取数组长度的指令：arraylength<br>-检查类实例类型的指令：instanceof、checkcast</p>
<h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4><p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li>
<li>将栈最顶端的两个数值互换：swap</li>
</ul>
<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令包括：</p>
<ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</li>
<li>复合条件分支：tableswitch、lookupswitch</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret<br>由于各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便、完善就显得尤为重要，而Java虚拟机提供的int类型的条件分支指令是最为丰富、强大的。</li>
</ul>
<h4 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h4><p>方法调用（分派、执行过程）将在第8章具体讲解，这里仅列举以下五条指令用于方法调用：</p>
<ul>
<li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li>
<li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li>
<li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li>
<li>invokestatic指令：用于调用类静态方法（static方法）。</li>
<li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><p>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。</p>
<h4 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h4><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用 <strong>管程（Monitor，更常见的是直接将它称为“锁”）</strong>来实现的。<br><strong>注：</strong>关于管程的概念，想要具体了解的，需要通过查阅操作系统原理相关的书籍介绍，例如：《Operating Systems: Internals and Design Principles.》（操作系统：精髓与设计原理），第七版中，第5章，5.4节中关于管程的介绍。<br>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。<br>当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，<em>如果设置了</em>，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。<br>同步代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onlyMe</span><span class="params">(Foo f)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(f) &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释后的字节码序列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method void onlyMe(Foo)</span><br><span class="line">0 aload_1 // 将对象f入栈</span><br><span class="line">1 dup 　　 // 复制栈顶元素（即f的引用）</span><br><span class="line">2 astore_2 // 将栈顶元素存储到局部变量表变量槽 2中</span><br><span class="line">3 monitorenter // 以栈定元素（即f）作为锁，开始同步</span><br><span class="line">4 aload_0 // 将局部变量槽 0（即this指针）的元素入栈</span><br><span class="line">5 invokevirtual #5 // 调用doSomething()方法</span><br><span class="line">8 aload_2 // 将局部变量Slow 2的元素（即f）入栈</span><br><span class="line">9 monitorexit // 退出同步</span><br><span class="line">10 goto 18 // 方法正常结束，跳转到18返回</span><br><span class="line">13 astore_3 // 从这步开始是异常路径，见下面异常表的Taget 13</span><br><span class="line">14 aload_2 // 将局部变量Slow 2的元素（即f）入栈</span><br><span class="line">15 monitorexit // 退出同步</span><br><span class="line">16 aload_3 // 将局部变量Slow 3的元素（即异常对象）入栈</span><br><span class="line">17 athrow // 把异常对象重新抛出给onlyMe()方法的调用者</span><br><span class="line">18 return // 方法正常返回</span><br><span class="line">Exception table:</span><br><span class="line">FromTo Target Type</span><br><span class="line">4 10 13 any</span><br><span class="line">13 16 13 any</span><br></pre></td></tr></table></figure>

<h3 id="公有设计，私有实现"><a href="#公有设计，私有实现" class="headerlink" title="公有设计，私有实现"></a>公有设计，私有实现</h3><p>《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。<br>虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么，虚拟机实现的方式主要有以下两种：</p>
<ul>
<li>将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集；</li>
<li>将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即即时编译器代码生成技术）。</li>
</ul>
<h2 id="第7章-虚拟机类加载机制"><a href="#第7章-虚拟机类加载机制" class="headerlink" title="第7章 虚拟机类加载机制"></a>第7章 虚拟机类加载机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作 <strong>虚拟机的类加载机制。</strong></p>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。<br><img data-src="d7ba81a7/class_lifecycle.jpg" alt="类的生命周期"><br>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而 <strong>解析阶段则不一定</strong>：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）<br>类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并<em>没有进行强制约束</em>，这点可以交给虚拟机的具体实现来自由把握。但是对于<em>初始化阶段</em>，《Java虚拟机规范》则是<strong>严格</strong>规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ul>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.M ethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ul>
<p>对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个<strong>非常强烈的限定语——“有且只有”</strong>，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p>
<h4 id="被动引用例子1"><a href="#被动引用例子1" class="headerlink" title="被动引用例子1"></a>被动引用例子1</h4><p>一则代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nimbus.k 2021-08-16 17:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;subClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoInitialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</strong></p>
<h4 id="被动引用例子2"><a href="#被动引用例子2" class="headerlink" title="被动引用例子2"></a>被动引用例子2</h4><p>代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示二：</span></span><br><span class="line"><span class="comment">* 通过数组定义来引用类，不会触发此类的初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后发现没有输出“SuperClass init！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，<strong>创建动作由字节码指令newarray触发</strong>。</p>
<h4 id="被动引用例子3"><a href="#被动引用例子3" class="headerlink" title="被动引用例子3"></a>被动引用例子3</h4><p>代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示三：</span></span><br><span class="line"><span class="comment">* 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的</span></span><br><span class="line"><span class="comment">类的初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HELLOWORLD</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行之后，也没有输出“ConstClass init！”，这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD，但其实在<strong>编译阶段通过常量传播优化，已经将此常量的值“helloworld”直接存储在NotInitialization类的常量池中</strong>，以后NotInitialization对常量ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class文件后就已不存在任何联系了。<br><strong>注：</strong>关于这个示例，我们可以通过两个途径来作证：第一：前文提到的开启JVM的+TraceClassLoading参数可以看的加载过程。第二：我们通过反编译工具看一下，常量持有的情况<br><img data-src="d7ba81a7/decompile_java_const_pool_transfering.jpg" alt="被动引用3反编译"></p>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>加载、验证、准备、解析和初始化这五个阶段所执行的具体动作。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：<br>1）通过一个类的全限定名来获取定义此类的二进制字节流。<br>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。<br>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式 <em>（重写一个类加载器的findClass()或loadClass()方法）</em>，实现根据自己的想法来赋予应用程序获取运行代码的动态性。<br>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。<br>验证阶段是非常重要的，这个阶段是否严谨，<em>直接决定了Java虚拟机是否能承受恶意代码的攻击</em>，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。<br>从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
<li>……</li>
</ul>
<h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li>
<li>……</li>
</ul>
<h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的 <em>方法体（Class文件中的Code属性）进行校验分析</em>，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
<li>……</li>
</ul>
<p><strong>注：</strong> 这里书中引出了一个经典的离散数学中的问题：“停机问题”(Hlating Problem)，即：即不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。在我们讨论字节码校验的上下文语境里，通俗一点的解释是通过程序去校验程序逻辑是无法做到绝对准确的，不可能用程序来准确判定一段程序是否存在Bug。具体的可以参考维基百科中的相关介绍：<a href="https://en.wikipedia.org/wiki/Halting_problem">Halting_problem</a>，更多的细节过于复杂，只需了解，<em>JDK6之后，Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行</em>。</p>
<h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，<br>关于准备阶段，还有两个容易产生混淆的概念书中有着重强调，首先是这时候进行内存分配的仅包括类变量，而 <em>不包括实例变量</em>，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次是这里所说的 <em>初始值“通常情况”下是数据类型的零值</em>，假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那变量value在准备阶段过后的初始值为0而不是123，因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把 <strong>value赋值为123的动作要到类的初始化阶段才会被执行</strong>。<br><img data-src="d7ba81a7/primitive_types_default_value.jpg" alt="基本数据类型的零值"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。<em>直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</em></p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。一段示例，演示intanceof在不同类加载器下运算结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.nimbusk.learningjvm.classloading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器与instanceof关键字演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nimbus.k 2021-08-18 20:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">myLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myLoader.loadClass(<span class="string">&quot;cc.nimbusk.learningjvm.classloading.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> cc.nimbusk.learningjvm.classloading.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cc</span>.nimbusk.learningjvm.classloading.ClassLoaderTest</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>返回了false。这是因为Java虚拟机中同时存在了两个ClassLoaderTest类，一个是由虚拟机的应用程序类加载器所加载的，另外一个是由我们自定义的类加载器加载的，虽然它们都来自同一个Class文件，但在Java虚拟机中仍然是两个互相独立的类，做对象所属类型检查时的结果自然为false。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。<br>自JDK 1.2以来，Java一直保持着 <strong>三层类加载器、双亲委派的类加载架构</strong></p>
<h5 id="启动类加载器（Bootstrap-Class-Loader）"><a href="#启动类加载器（Bootstrap-Class-Loader）" class="headerlink" title="启动类加载器（Bootstrap Class Loader）"></a>启动类加载器（Bootstrap Class Loader）</h5><p>启动类加载器（Bootstrap Class Loader）：前面已经介绍过，这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）<strong>类库加载到虚拟机的内存中</strong>。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可，下面代码展示的就是<code>java.lang.ClassLoader.getClassLoader()</code>方法的代码片段，其中的注释和代码实现都明确地说明了以null值来代表引导类加载器的约定规则。</p>
<h5 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h5><p>这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</p>
<h5 id="应用程序类加载器（Application-Class-Loader）"><a href="#应用程序类加载器（Application-Class-Loader）" class="headerlink" title="应用程序类加载器（Application Class Loader）"></a>应用程序类加载器（Application Class Loader）</h5><p>这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystem-ClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p><strong>类加载器的“双亲委派模型（Parents DelegationModel）”</strong>。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载<br>器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。<br>双亲委派模型对于保证Java程序的稳定运作极为重要，但它的实现却异常简单，用以实现双亲委派的代码只有短短十余行，全部集中在<code>java.lang.ClassLoader的loadClass()</code>方法之中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">                <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在父类加载器无法加载时</span></span><br><span class="line">                <span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h5><p><strong>注：</strong> 书中列举了几个不是严格按照双亲委派模型来进行的场景，比如早期的JNDI服务需要借助于<code>java.lang.Thread类的setContext-ClassLoader()方法</code>进行设置。以及为了解决这个问题，<em>在JDK6之后提供的 <code>java.util.ServiceLoader</code> 类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</em></p>
<h4 id="Java模块化系统"><a href="#Java模块化系统" class="headerlink" title="Java模块化系统"></a>Java模块化系统</h4><p>在JDK 9中引入的Java模块化系统（Java Platform Module System，JPMS）是对Java技术的一次重要升级，为了能够实现模块化的关键目标——<em>可配置的封装隔离机制</em>，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容：</p>
<ul>
<li>依赖其他模块的列表。</li>
<li>导出的包列表，即其他模块可以使用的列表。</li>
<li>开放的包列表，即其他模块可反射访问模块的列表。</li>
<li>使用的服务列表。</li>
<li>提供服务的实现列表。</li>
</ul>
<h5 id="模块的兼容性"><a href="#模块的兼容性" class="headerlink" title="模块的兼容性"></a>模块的兼容性</h5><p>为了使可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK 9提出了与“类路径”（ClassPath）相对应的“模块路径”（ModulePath）的概念。</p>
<h2 id="第8章-虚拟机字节码执行引擎"><a href="#第8章-虚拟机字节码执行引擎" class="headerlink" title="第8章 虚拟机字节码执行引擎"></a>第8章 虚拟机字节码执行引擎</h2><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual MachineStack）的栈元素。<br>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。<br>对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame），与这个栈帧所关联的方法被称为“当前方法”（Current Method）。<br><img data-src="d7ba81a7/stack_frame_model.jpg" alt="栈帧概念结构"></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>[1] 关于JLS()与JVMS(Java Virtual Machine Specification)发行版本地址：<a href="https://docs.oracle.com/javase/specs/">https://docs.oracle.com/javase/specs/</a></p>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>周志明</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间-深入拆解Java虚拟机</title>
    <url>/post/52d27346.html</url>
    <content><![CDATA[<h1 id="课程实录"><a href="#课程实录" class="headerlink" title="课程实录"></a>课程实录</h1><h2 id="01-Java代码是怎么运行的？"><a href="#01-Java代码是怎么运行的？" class="headerlink" title="(01)Java代码是怎么运行的？"></a>(01)Java代码是怎么运行的？</h2><ul>
<li>从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。<br>Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。</li>
<li>在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。</li>
<li>当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。<br>在 HotSpot 里面，上述翻译过程有两种形式：</li>
<li>第一种是解释执行，即逐条将字节码翻译成机器码并执行；</li>
<li>第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。<br>!(HotSpot字节码解释执行与即时编译)[52d27346/AutoCapture_2020-07-12_195739.jpg]<br>两者之间，<em>前者的优势在于无需等待编译</em>，而<em>后者的优势在于实际运行速度更快</em>。HotSpot默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。</li>
</ul>
<h3 id="Java虚拟机的运行效率"><a href="#Java虚拟机的运行效率" class="headerlink" title="Java虚拟机的运行效率"></a>Java虚拟机的运行效率</h3><p>HotSpot 采用了多种技术来提升启动性能以及峰值性能，刚刚提到的即时编译便是其中最重要的技术之一。即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。<br>对于占据大部分的 <strong>不常用的代码</strong>，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。<br><strong>注：</strong>综合编译，以优化达到理想的运行性能</p>
<p>为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2 和 Graal。Graal 是 Java 10 正式引入的实验性即时编译器。</p>
<ul>
<li>C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。</li>
<li>C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。<br>从 Java 7 开始，HotSpot 默认采用分层编译的方式：<em>热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。</em></li>
</ul>
<h2 id="03-Java虚拟机是如何加载Java类"><a href="#03-Java虚拟机是如何加载Java类" class="headerlink" title="(03)Java虚拟机是如何加载Java类"></a>(03)Java虚拟机是如何加载Java类</h2><h2 id="10-Java对象的内存布局"><a href="#10-Java对象的内存布局" class="headerlink" title="(10)Java对象的内存布局"></a>(10)Java对象的内存布局</h2><h2 id="11-amp-12-垃圾回收"><a href="#11-amp-12-垃圾回收" class="headerlink" title="(11&amp;12)垃圾回收"></a>(11&amp;12)垃圾回收</h2><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><h1 id="额外实践"><a href="#额外实践" class="headerlink" title="额外实践"></a>额外实践</h1>]]></content>
      <categories>
        <category>极客时间</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间-ElasticSearch</title>
    <url>/post/70b658a.html</url>
    <content><![CDATA[<h2 id="课程实录"><a href="#课程实录" class="headerlink" title="课程实录"></a>课程实录</h2><h3 id="08-Logstash安装与导入数据"><a href="#08-Logstash安装与导入数据" class="headerlink" title="(08)Logstash安装与导入数据"></a>(08)Logstash安装与导入数据</h3><p><a href="70b658a/movies.csv">Movies示例数据集</a><br>ES Mapping：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT movies</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number_of_shards&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;excludes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;_id&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>logstash.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; &quot;/Users/yiruan/dev/elk7/logstash-7.0.1/bin/movies.csv&quot;</span><br><span class="line">    start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    sincedb_path =&gt; &quot;/dev/null&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  csv &#123;</span><br><span class="line">    separator =&gt; &quot;,&quot;</span><br><span class="line">    columns =&gt; [&quot;id&quot;,&quot;content&quot;,&quot;genre&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    split =&gt; &#123; &quot;genre&quot; =&gt; &quot;|&quot; &#125;</span><br><span class="line">    remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line"></span><br><span class="line">    split =&gt; [&quot;content&quot;, &quot;(&quot;]</span><br><span class="line">    add_field =&gt; &#123; &quot;title&quot; =&gt; &quot;%&#123;[content][0]&#125;&quot;&#125;</span><br><span class="line">    add_field =&gt; &#123; &quot;year&quot; =&gt; &quot;%&#123;[content][1]&#125;&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate &#123;</span><br><span class="line">    convert =&gt; &#123;</span><br><span class="line">      &quot;year&quot; =&gt; &quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    strip =&gt; [&quot;title&quot;]</span><br><span class="line">    remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;,&quot;content&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">   elasticsearch &#123;</span><br><span class="line">     hosts =&gt; &quot;http://localhost:9200&quot;</span><br><span class="line">     index =&gt; &quot;movies&quot;</span><br><span class="line">     document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="09-基本概念：索引、文档和REST-API"><a href="#09-基本概念：索引、文档和REST-API" class="headerlink" title="(09)基本概念：索引、文档和REST API"></a>(09)基本概念：索引、文档和REST API</h3><h4 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档(Document)"></a>文档(Document)</h4><ul>
<li>Elasticsearch是面向文档的，文档是所有可搜索数据的最小单位<ul>
<li>日志文件中的日志项</li>
<li>一本电影的具体信息 / 一张唱片的详细信息</li>
<li>MP3播放器里的一首歌 / 一篇PDF文档中的具体内容</li>
</ul>
</li>
<li>文档会被序列化成JSON格式，保存在Elasticserach中<ul>
<li>JSON对象由字段组成</li>
<li>每个字段都有对应的字段类型（字符串、数值、布尔、日期、二进制、范围类型）</li>
</ul>
</li>
<li>每个文档都有一个Unique ID<ul>
<li>你可以自己指定ID</li>
<li>或者通过Elasticsearch自动生成</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h5 id="JSON文档"><a href="#JSON文档" class="headerlink" title="JSON文档"></a>JSON文档</h5><ul>
<li>一篇文章包含了一系列的字段，类似数据库表中的一条记录。</li>
<li>JSON文档，格式灵活，不需要预先定义格式<ul>
<li>字段的类型可以指定或者通过Elasticsearch自动推算</li>
<li>支持数组/支持嵌套<br><img data-src="70b658a/AutoCapture_2020-07-11_093758.jpg" alt="CSV流文件处理后示例"></li>
</ul>
</li>
</ul>
<p><strong>注：</strong>在课程中，通过一个CSV源文件，再经过logstash处理后输出到ES中到文档存储格式</p>
<h5 id="文档的元数据"><a href="#文档的元数据" class="headerlink" title="文档的元数据"></a>文档的元数据</h5><p>一篇文档示例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_index&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;movies&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">14.69302</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;year&quot;</span> <span class="punctuation">:</span> <span class="number">1995</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;@version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;genre&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;Adventure&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Animations&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Children&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Comedy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Fantasy&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Toy Story&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>元数据用于标注文档的相关信息</p>
<ul>
<li>_index - 文档所属的索引名</li>
<li>_type - 文档所属的类型名</li>
<li>_id - 文档唯一id</li>
<li>_source - 文档的原始JSON数据</li>
<li>_all - 整合所有自断内容到该字段，从7.0开始已被废除</li>
<li>_version - 文档到版本信息：大并发读写的时候，会很有用</li>
<li>_score - 相关性打分</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>Index - 所以是文档的容器，是一类文档的结合</p>
<ul>
<li>Index体现了逻辑的概念：每个索引都有自己的Mapping定义，用于定义包含的文档的字段名和字段类型。</li>
<li>Shard体现了物理空间的概念：索引中的数据分散在Shard分片上</li>
</ul>
<p>索引中可以设置Mapping与Settings</p>
<ul>
<li>Mapping定义文档字段的类型</li>
<li>Setting定义不同到数据分布：要用多少分片，数据最后是怎么分布到</li>
</ul>
<p>例如，上面那个电影信息的文档的索引结构就可以是如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;movies&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;settings&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;creation_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1552737458543&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;number_of_shards&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;number_of_replicas&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Qnd7lMrnQPGdaeJ9oR0tfQ&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;created&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6060299&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;provided_name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;movies&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="索引的不同语意"><a href="#索引的不同语意" class="headerlink" title="索引的不同语意"></a>索引的不同语意</h5><ul>
<li>名词：一个Elasticsearch集群中，可以创建很多个不同的索引</li>
<li>动词：保存一个文档到Elasticsearch的过程也叫索引（indexing）<ul>
<li>ES中，创建一个倒排索引到过程</li>
</ul>
</li>
<li>通用型的名词：一个B树索引，一个倒排索引</li>
</ul>
<h5 id="Type字段"><a href="#Type字段" class="headerlink" title="Type字段"></a>Type字段</h5><p>在7.0之前，一个Index可以设置多个Types<br>从6.0开始，Type已经被废弃。<br>从7.0开始，一个索引<strong>只能创建一个</strong> type - “_doc”</p>
<h4 id="与关系型数据库抽象类比"><a href="#与关系型数据库抽象类比" class="headerlink" title="与关系型数据库抽象类比"></a>与关系型数据库抽象类比</h4><p>整体上类比的可能不是那么恰当</p>
<ul>
<li>关系型数据库中表的概念 -&gt; ES中的索引</li>
<li>关系型数据库中每一条记录 -&gt; ES中的文档</li>
<li>关系型数据库中的每个字段 -&gt; ES文档中的一个字段</li>
</ul>
<h4 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h4><p>方便各种语言整合调用，只需要直接通过调用REST API即可<br>查看每个索引占用的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_cat/indices?v&amp;h=i,tm&amp;s=tm:desc</span><br></pre></td></tr></table></figure>

<h3 id="10-基本概念：节点、集群、分片及副本"><a href="#10-基本概念：节点、集群、分片及副本" class="headerlink" title="(10)基本概念：节点、集群、分片及副本"></a>(10)基本概念：节点、集群、分片及副本</h3><h4 id="分布式系统的可用性与扩展性"><a href="#分布式系统的可用性与扩展性" class="headerlink" title="分布式系统的可用性与扩展性"></a>分布式系统的可用性与扩展性</h4><ul>
<li>高可用性<ul>
<li>服务可用性 - 允许有节点停止服务</li>
<li>数据可用性 - 部分节点丢失，不会丢失数据</li>
</ul>
</li>
<li>可扩展性<ul>
<li>请求量提升 / 数据的不断增长（将数据分布到所有节点上）</li>
</ul>
</li>
</ul>
<h4 id="分布式特性"><a href="#分布式特性" class="headerlink" title="分布式特性"></a>分布式特性</h4><ul>
<li>Elasticsearch的分布式架构的好处<ul>
<li>存储水平扩容</li>
<li>提供系统的可用性，部分节点停止服务，整个集群的服务不受影响</li>
</ul>
</li>
<li>Elasticsearch的分布式架构<ul>
<li>不同的集群可以通过不同的名字来区分，默认名字：“elasticsearch”</li>
<li>通过配置文件修改，或者在命令行中直接指定：-E cluster.name=geektime进行设定</li>
<li>一个集群可以有一个或者多个节点</li>
</ul>
</li>
</ul>
<h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><ul>
<li>一个节点就是一个Elasticsearch的实例<ul>
<li>本质上就是一个JAVA进程</li>
<li>一台机器可以运行多个ES进程，但是生产环境一般建议一台机器上只运行一个</li>
</ul>
</li>
<li>每一个节点都有名字，通过配置文件配置或者启动的时候指定：-E node.name=node1</li>
<li>每个节点在启动之后会分配一个UID，保存在data目录下</li>
</ul>
<h5 id="Master-eligible-nodes-与-Master-Node"><a href="#Master-eligible-nodes-与-Master-Node" class="headerlink" title="Master-eligible nodes 与 Master Node"></a>Master-eligible nodes 与 Master Node</h5><ul>
<li>每个节点启动后，默认就是一个Master-eligible节点<ul>
<li>可以设置node.master: false禁止</li>
</ul>
</li>
<li>Master-eligible节点可以参加选主流程成为最后的Master节点</li>
<li>当第一个节点启动的时候，它会将自己选举成Master节点</li>
<li>每个节点上都保存了集群的状态，只有Master节点才能修改集群的状态信息<ul>
<li>集群状态（Cluster State），维护了一个集群中，必要的信息<ul>
<li>所有的节点信息</li>
<li>所有的索引和其相关的Mapping与Setting信息</li>
<li>分片路由信息</li>
</ul>
</li>
<li>任意节点都能修改信息会导致数据的不一致性</li>
</ul>
</li>
</ul>
<h5 id="Data-Node-与-Coordinating-Node"><a href="#Data-Node-与-Coordinating-Node" class="headerlink" title="Data Node 与 Coordinating Node"></a>Data Node 与 Coordinating Node</h5><ul>
<li>Data Node<ul>
<li>可以保存数据的节点，叫做Data Node。负责保存分片数据。在数据扩展上起到了至关重要的作用，例如在集群上无法存数据到时候，可以增加数据节点来解决这一问题。</li>
</ul>
</li>
<li>Coordinating Node<ul>
<li>负责接受Client的请求，将请求分发到合适到节点，最终把结果汇集到一起</li>
<li>每个节点默认都起到了Coordinating Node到职责</li>
</ul>
</li>
</ul>
<h5 id="其它类型的节点"><a href="#其它类型的节点" class="headerlink" title="其它类型的节点"></a>其它类型的节点</h5><ul>
<li>Hot &amp; Warm Node<ul>
<li>不同硬件配置的Data Node，用来实现Hot &amp; Warm架构，降低集群部署的成本</li>
</ul>
</li>
<li>Machine Learning Node<ul>
<li>负责跑机器学习的Job，比如用来做异常检测</li>
</ul>
</li>
<li>Tribe Node<ul>
<li>（5.3开始使用Cross Cluster Search）Tribe Node连接到不同到ES集群，并且支持将这些集群当成一个单独的集群处理。</li>
</ul>
</li>
</ul>
<h4 id="分片（Primary-Shard-amp-Replica-Shard）"><a href="#分片（Primary-Shard-amp-Replica-Shard）" class="headerlink" title="分片（Primary Shard &amp; Replica Shard）"></a>分片（Primary Shard &amp; Replica Shard）</h4><ul>
<li>主分片，用于解决数据水平扩展的问题。通过主分片，可以将数据分布到集群内的所有节点之上<ul>
<li>一个分片是一个运行的Lucene实例</li>
<li>主分片数在索引创建时指定，后续不允许修改，除非Reindex</li>
</ul>
</li>
<li>副本，用于解决数据高可用的问题，分片是主分片的拷贝<ul>
<li>副本分片数，可以动态调整</li>
<li>增加副本数，还可以在一定程度上提高服务的可用性（读取到吞吐）<br><img data-src="70b658a/AutoCapture_2020-07-11_103828.jpg" alt="分片示例"></li>
</ul>
</li>
</ul>
<h5 id="分片的设定"><a href="#分片的设定" class="headerlink" title="分片的设定"></a>分片的设定</h5><p>对于生产环境中的分片设定，需要提前做好容量规划，</p>
<ul>
<li>如果分片数量设置过小<ul>
<li>导致后续无法增加节点实现的水平扩展</li>
<li>单个分片的数据量太大，导致数据重新分配耗时</li>
</ul>
</li>
<li>分片数设置过大，7.0开始，默认主分片设置成1，解决了over-sharding的问题<ul>
<li>影响搜索结果的相关性打分，影响统计结果的准确性</li>
<li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能</li>
</ul>
</li>
</ul>
<h4 id="文档的CRUD"><a href="#文档的CRUD" class="headerlink" title="文档的CRUD"></a>文档的CRUD</h4><p><strong>注：</strong>注意Index与Update之间的区别</p>
<ul>
<li>Type名，约定都用_doc</li>
<li>Create - 如果ID已经存在，会失败</li>
<li>Index - 如果ID不存在，创建新的文档。否则，先删除现有的文档，再创建新的文档，版本会增加</li>
<li>Update - 文档必须已经存在，更新只会对相应字段做增量修改<br><img data-src="70b658a/AutoCapture_2020-07-11_110449.jpg" alt="CRUD示例"></li>
</ul>
<h5 id="BULK-API"><a href="#BULK-API" class="headerlink" title="BULK API"></a>BULK API</h5><ul>
<li>支持在一次API调用中，对不同的索引进行操作</li>
<li>支持四种类型操作：CRUD</li>
<li>可以在URI中指定Index，也可以在请求的Payload中进行</li>
<li>操作中单条操作失败，并不会影响其他操作</li>
<li>返回结果包含了每一条操作执行的结果</li>
</ul>
<h5 id="批量读取mget与批量查询msearch"><a href="#批量读取mget与批量查询msearch" class="headerlink" title="批量读取mget与批量查询msearch"></a>批量读取mget与批量查询msearch</h5><p>批量读取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    &quot;docs&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;test&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;1&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_index&quot; : &quot;test&quot;,</span><br><span class="line">            &quot;_id&quot; : &quot;2&quot;</span><br><span class="line">            &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST kibana_sample_data_ecommerce/_msearch</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&quot;query&quot; : &#123;&quot;match_all&quot; : &#123;&#125;&#125;, &quot;size&quot; : 1&#125;</span><br><span class="line">&#123;&quot;index&quot; : &quot;kibana_sample_data_flights&quot;&#125;</span><br><span class="line">&#123;&quot;query&quot; : &#123;&quot;match_all&quot; : &#123;&#125;&#125;, &quot;size&quot; : 2&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-倒排索引介绍"><a href="#12-倒排索引介绍" class="headerlink" title="(12)倒排索引介绍"></a>(12)倒排索引介绍</h3><p>在搜索引擎中，正排索引是一个文档ID到文档内容到关联，而倒排索引恰恰相反，就是一个单词到文档ID关联的关系。例如：<br><img data-src="70b658a/AutoCapture_2020-07-11_113536.jpg" alt="倒排索引与正排索引对比"></p>
<h4 id="倒排索引的核心组成"><a href="#倒排索引的核心组成" class="headerlink" title="倒排索引的核心组成"></a>倒排索引的核心组成</h4><p>倒排索引通常包含两个部分：</p>
<ul>
<li>单词词典（Term Dictionary），记录所有文档的单词，记录单词到倒排列表的关联关系<ul>
<li>单词词典一般比较大，可以通过B+树或者哈希链算法实现，以满足高性能的插入与查询</li>
</ul>
</li>
<li>倒排列表（Posting List），记录了单词对应的文档结构，由倒排索引项组成<ul>
<li>倒排索引项（Posting）<ul>
<li>文档ID</li>
<li>词频TF - 该单词在文档中出现的次数，用于相关性评分</li>
<li>位置（Position） - 单词在文档中分词的位置，用于语句搜索（phrase query）</li>
<li>偏移（Offset） - 记录单词的开始和结束位置，实现高亮显示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在ES中的倒排索引：<br>JSON文档中的每个字段，都有自己的倒排索引，可以指定对某些字段不做索引：</p>
<ul>
<li>优点：节省存储空间</li>
<li>缺点：字段无法被搜索</li>
</ul>
<h3 id="13-通过Analyzer进行分词"><a href="#13-通过Analyzer进行分词" class="headerlink" title="(13)通过Analyzer进行分词"></a>(13)通过Analyzer进行分词</h3><h4 id="Analysis-与-Analyzer"><a href="#Analysis-与-Analyzer" class="headerlink" title="Analysis 与 Analyzer"></a>Analysis 与 Analyzer</h4><ul>
<li>Analysis - 文本分析是把全文本转化一系列单词（term / token）的过程，也叫分词</li>
<li>Analysis是通过Analyzer（分词器）来实现的<ul>
<li>可以通过ES内置的分词器，或者按需定制化分词器</li>
</ul>
</li>
<li>除了在数据写入时转换词条，匹配Query语句时候也需要使用相同的分词器对查询语句进行分析</li>
</ul>
<h5 id="Analyzer的组成"><a href="#Analyzer的组成" class="headerlink" title="Analyzer的组成"></a>Analyzer的组成</h5><p>分词器是专门处理分词的组件，Analyzer由三部分组成</p>
<ul>
<li>Character Filters（针对原始文本处理，例如去除html标签）</li>
<li>Tokenizer（按照规则切分单词）</li>
<li>Token Filter（将切分的单词进行加工，小写，删除Stopwords，增加同义词）<br>处理流程示例如下图所示：<br><img data-src="70b658a/AutoCapture_2020-07-11_115912.jpg" alt="分词处理流程示例"></li>
</ul>
<h3 id="14-Search-API概览"><a href="#14-Search-API概览" class="headerlink" title="(14)Search API概览"></a>(14)Search API概览</h3><p>指定查询的索引<br><img data-src="70b658a/AutoCapture_2020-07-11_133509.jpg" alt="指定查询的索引"><br>查询响应：</p>
<ul>
<li>took 花费的时间</li>
<li>total 符合条件的总文档数</li>
<li>hits 结果集，默认前10个文档<ul>
<li>_index: 索引名</li>
<li>_id: 文档的ID</li>
<li>_score: 相关度评分</li>
<li>_source: 文档原始信息</li>
</ul>
</li>
</ul>
<h4 id="搜索的相关性Relevance"><a href="#搜索的相关性Relevance" class="headerlink" title="搜索的相关性Relevance"></a>搜索的相关性Relevance</h4><ul>
<li>搜索是用户和搜索引擎的对话</li>
<li>用户关心的是搜索结果的相关性<ul>
<li>是否可以找到相关的内容</li>
<li>有多少不相关的内容被返回了</li>
<li>文档的打分是否合理</li>
<li>结合业务需求，平衡结果排名</li>
</ul>
</li>
</ul>
<h4 id="衡量相关性"><a href="#衡量相关性" class="headerlink" title="衡量相关性"></a>衡量相关性</h4><p>Information Retrieval</p>
<ul>
<li>Precision(查准率) - 尽可能返回较少的无关文档</li>
<li>Recall(查全率) - 尽量返回较多的相关文档</li>
<li>Ranking - 是否能够按照相关度进行排序</li>
</ul>
<h3 id="15-URI-Search详解"><a href="#15-URI-Search详解" class="headerlink" title="(15)URI Search详解"></a>(15)URI Search详解</h3><p>顾名思义，通过URI query实现搜索，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /movies/_search?q=2012&amp;df=title&amp;sort=year:desc&amp;from=0&amp;size=10&amp;timeout=1s</span><br><span class="line">&#123;</span><br><span class="line">    &quot;profile&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述命令中：</p>
<ul>
<li>q指定查询语句，使用Query String Syntax</li>
<li>df默认字段，不指定时，会对所有字段进行查询</li>
<li>Sort排序 / from和size用于分页</li>
<li>Profile可以查看查询是如何被执行的</li>
</ul>
<h4 id="Query-String-Syntax"><a href="#Query-String-Syntax" class="headerlink" title="Query String Syntax"></a>Query String Syntax</h4><ul>
<li>指定字段 v.s 泛查询<ul>
<li>q = title:2012 / q=2012</li>
</ul>
</li>
<li>Term v.s Phrase<ul>
<li>Beautiful Mind 等效于 Beautiful OR Mind</li>
<li>“Beautiful Mind”，等效于Beautiful AND Mind。 Phrase查询，还要求前后顺序保持一致。</li>
</ul>
</li>
<li>分组与引号<ul>
<li>Term Query: title:(Beautiful AND Mind)</li>
<li>Phrase Query: title=”Beautiful Mind”</li>
</ul>
</li>
<li>布尔操作<ul>
<li>AND | OR | NOT 或者 &amp;&amp; | || | !<ul>
<li>所有布尔操作符必须大写</li>
<li>例如：title:(matrix NOT reloaded)</li>
</ul>
</li>
</ul>
</li>
<li>分组<ul>
<li><ul>
<li>表示 must</li>
</ul>
</li>
<li><ul>
<li>表示 must not</li>
</ul>
</li>
<li>title:(+matrix -reloaded)</li>
</ul>
</li>
<li>范围查询<ul>
<li>区间表示:[] 闭区间, {}开区间<ul>
<li>year:{2019 TO 2018}</li>
<li>year:[* TO 2018]</li>
</ul>
</li>
</ul>
</li>
<li>算数符号<ul>
<li>year:&gt;2010</li>
<li>year:(&gt;2010 &amp;&amp; &lt;= 2018)</li>
<li>year:(+&gt;2010 +&lt;=2018)</li>
</ul>
</li>
<li>通配符查询（通配符查询效率低，占用内存大，不建议使用。特别放在最前面）<ul>
<li>？表示1个字符，*代表0或者多个字符<ul>
<li>title:mi?d</li>
<li>title:be*</li>
</ul>
</li>
</ul>
</li>
<li>正则表达式<ul>
<li>title:[bt]oy</li>
</ul>
</li>
<li>模糊匹配与近似查询<ul>
<li>title:befutifl~1</li>
<li>title:”Loard Rings”<del>2 // 近似匹配，如果不加</del>2则是需要强匹配的Phrase Query </li>
</ul>
</li>
</ul>
<p>查询示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// TermQuery示例</span><br><span class="line">GET /movies/_search?q=title:(Beautiful AND Mind)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bool查询示例</span><br><span class="line">GET /movies/_search?q=title:(Beautiful NOT Mind)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /movies/_search?q=title:(Beautiful %2BMind)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /movies/_search?q=title:be*</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /movies/_search?q=title:&quot;lord rings&quot;~2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-Request-Body-与-Query-DSL简介"><a href="#16-Request-Body-与-Query-DSL简介" class="headerlink" title="(16)Request Body 与 Query DSL简介"></a>(16)Request Body 与 Query DSL简介</h3><p>总体上，建议使用Request Body查询</p>
<ul>
<li>将查询语句通过HTTP Request Body发送给ES</li>
<li>Query DSL<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /movies,404_idx/_search?ignore_unavailable=true</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="脚本字段"><a href="#脚本字段" class="headerlink" title="脚本字段"></a>脚本字段</h4><p>在Request Body中使用painless字段，组合查询出新的字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET kibana_sample_data_ecommerce/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script_fields&quot;: &#123;</span><br><span class="line">    &quot;new_field&quot;: &#123;</span><br><span class="line">      &quot;script&quot;: &#123;</span><br><span class="line">        &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">        &quot;source&quot;: &quot;doc[&#x27;order_date&#x27;].value+&#x27;_hello&#x27;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot; : 10,</span><br><span class="line">  &quot;size&quot;: 5,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-Query-String-与-Simple-Query-String查询"><a href="#17-Query-String-与-Simple-Query-String查询" class="headerlink" title="(17)Query String 与 Simple Query String查询"></a>(17)Query String 与 Simple Query String查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PUT /users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;Ruan Yiming&quot;,</span><br><span class="line">  &quot;about&quot;:&quot;java, golang, node, swift, elasticsearch&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /users/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;Li Yiming&quot;,</span><br><span class="line">  &quot;about&quot;:&quot;Hadoop&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;default_field&quot;: &quot;name&quot;,</span><br><span class="line">      &quot;query&quot;: &quot;Ruan AND Yiming&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;fields&quot;:[&quot;name&quot;,&quot;about&quot;],</span><br><span class="line">      &quot;query&quot;: &quot;(Ruan AND Yiming) OR (Java AND Elasticsearch)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Simple Query 默认的operator是 Or</span><br><span class="line">POST users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;simple_query_string&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;Ruan AND Yiming&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;name&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;simple_query_string&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;Ruan Yiming&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;name&quot;],</span><br><span class="line">      &quot;default_operator&quot;: &quot;AND&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /movies/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;profile&quot;: true,</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;query_string&quot;:&#123;</span><br><span class="line">            &quot;default_field&quot;: &quot;title&quot;,</span><br><span class="line">            &quot;query&quot;: &quot;Beafiful AND Mind&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多fields</span><br><span class="line">GET /movies/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;profile&quot;: true,</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;query_string&quot;:&#123;</span><br><span class="line">            &quot;fields&quot;:[</span><br><span class="line">                &quot;title&quot;,</span><br><span class="line">                &quot;year&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;query&quot;: &quot;2012&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /movies/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;profile&quot;:true,</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;simple_query_string&quot;:&#123;</span><br><span class="line">            &quot;query&quot;:&quot;Beautiful +mind&quot;,</span><br><span class="line">            &quot;fields&quot;:[&quot;title&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="18-Dynamic-Mapping和常见字段类型"><a href="#18-Dynamic-Mapping和常见字段类型" class="headerlink" title="(18)Dynamic Mapping和常见字段类型"></a>(18)Dynamic Mapping和常见字段类型</h3><ul>
<li>Mapping类似数据库中的schema定义，作用如下：<ul>
<li>定义索引中的字段名称</li>
<li>定义字段的数据类型，例如字符串，数字，布尔等等</li>
<li>字段，倒排索引的相关配置（Analyzed or Not Analyzed, Analyzer）</li>
</ul>
</li>
<li>Mapping会把JSON稳定映射成为Lucene所需要的扁平格式</li>
<li>一个Mapping属于一个索引的Type<ul>
<li><p>每个文档都属于一个Type</p>
</li>
<li><p>一个Type有一个Mapping定义</p>
</li>
<li><p>7.0开始，不需要在Mapping定义中指定type信息</p>
<h4 id="字段的数据类型"><a href="#字段的数据类型" class="headerlink" title="字段的数据类型"></a>字段的数据类型</h4></li>
</ul>
</li>
<li>简单类型<ul>
<li>Text / Keyword</li>
<li>Date</li>
<li>Integer / Floating</li>
<li>Boolean</li>
<li>IPv4 &amp; IPv6</li>
</ul>
</li>
<li>复杂类型 - 对象和嵌套对象<ul>
<li>对象类型 / 嵌套类型</li>
</ul>
</li>
<li>特殊类型 <ul>
<li>geo_point &amp; geo_shape / percolator</li>
</ul>
</li>
</ul>
<h4 id="什么是Dynamic-Mapping"><a href="#什么是Dynamic-Mapping" class="headerlink" title="什么是Dynamic Mapping"></a>什么是Dynamic Mapping</h4><ul>
<li>在写入文档的时候，如果索引不存在，会自动创建索引</li>
<li>Dynamic Mapping的机制，使得我们无需手动定义Mapping。ES会自动根据稳定信息，推算出字段的类型</li>
<li>但是有时候会推算的不对，例如地理位置信息</li>
<li>当类型如果设置不对时，会导致一些功能无法正常运行，例如Range查询</li>
</ul>
<h5 id="类型的自动识别"><a href="#类型的自动识别" class="headerlink" title="类型的自动识别"></a>类型的自动识别</h5><p><img data-src="70b658a/AutoCapture_2020-07-11_173010.jpg" alt="ES动态Mapping中类型自动匹配关系"></p>
<h5 id="能否改mapping的字段类型"><a href="#能否改mapping的字段类型" class="headerlink" title="能否改mapping的字段类型"></a>能否改mapping的字段类型</h5><p>分两种情况：</p>
<ul>
<li>新增字段：<ul>
<li>Dynamic设置为true时，一旦有新增字段的文档写入，mapping也同时被更新</li>
<li>Dynamic设置为false时，mapping不会被更新，心中字段的数据无法被搜索</li>
<li>Dynamic</li>
</ul>
</li>
<li>如果希望改变字段类型，必须ReindexAPI，重建索引<br>因为：</li>
<li>如果修改了字段的数据类型，会导致已被索引的属性无法被搜索</li>
<li>但是如果是新增的字段，就不会有这样的影响</li>
</ul>
<h5 id="自定义Mapping的一些建议"><a href="#自定义Mapping的一些建议" class="headerlink" title="自定义Mapping的一些建议"></a>自定义Mapping的一些建议</h5><ul>
<li>可以参考API手册，纯手写</li>
<li>为了减少输入工作量，减少出错的概率，可以依照以下步骤<ul>
<li>创建一个临时的index，写入一些样本数据</li>
<li>通过访问Mapping API获得该临时文件的动态Mapping定义</li>
<li>修改后用，使用新的配置来创建索引</li>
<li>删除临时索引</li>
</ul>
</li>
</ul>
<h5 id="index优化建议"><a href="#index优化建议" class="headerlink" title="index优化建议"></a>index优化建议</h5><ul>
<li>四种不同级别的Index Options配置，可以控制倒排索引记录的内容<ul>
<li>docs - 记录doc id</li>
<li>freqs - 记录doc id和term frequencies</li>
<li>positions - 记录doc id / term frequencies / term position</li>
<li>offsets - 记录doc id / term frequencies / term position / character offects</li>
</ul>
</li>
<li>Text类型默认记录positions，其它默认为docs</li>
<li>记录内容越多，占用存储空间越大</li>
<li>null_value的属性使用：如果需要搜索，但是可能没有有效值，可以设置该属性为null以实现对null值的索引</li>
</ul>
<h3 id="20-多字段类型"><a href="#20-多字段类型" class="headerlink" title="(20)多字段类型"></a>(20)多字段类型</h3><p>多字段特性，举例：</p>
<ul>
<li>厂商的名字实现精确匹配<ul>
<li>增加一个keyword字段</li>
</ul>
</li>
<li>使用不同的analyzer<ul>
<li>不同语言</li>
<li>pinyin字段的搜索</li>
<li>还支持为搜索和索引指定不同的analyzer<br>例如：<br><img data-src="70b658a/AutoCapture_2020-07-11_213211.jpg" alt="多字段Mapping示例"></li>
</ul>
</li>
</ul>
<h4 id="精确值-Exact-Values-与-全文本-Full-text"><a href="#精确值-Exact-Values-与-全文本-Full-text" class="headerlink" title="精确值(Exact Values) 与 全文本(Full text)"></a>精确值(Exact Values) 与 全文本(Full text)</h4><p>精确值：包括数字、日期、具体一个字符串（例如“Apple Store”）<br>    + ES中的keyword<br>    + 与全文本中最大的区别就是：精确值不需要被做分词的处理<br>全文本：非结构化的文本数据<br>    + ES中的text</p>
<h4 id="自定义分词"><a href="#自定义分词" class="headerlink" title="自定义分词"></a>自定义分词</h4><p>当自带的分词器无法满足时，可以自定义分词器，通过组合不同的组件来实现：</p>
<ul>
<li>Character Filters</li>
<li>Tokenizer</li>
<li>Token Filter<h5 id="Character-Filters"><a href="#Character-Filters" class="headerlink" title="Character Filters"></a>Character Filters</h5>在Tokenizer处理之前对文本进行特殊的处理，例如增加删除及替换字符。可以配置多个Character Filters。最终会影响Tokenizer的position和offset信息。<br>一些自带的Character Filters</li>
<li>HTML strip - 去除HTML标签，例如在网络爬虫数据之后，就可以把一些不必要的标签给过滤了</li>
<li>Mapping - 字符串替换</li>
<li>Pattern replace - 正则匹配替换<h5 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h5>将原始的文本按照一定的规则，切为分词（term or token）<br>ES内置的Tokenizers：</li>
<li>whitespace：空白符</li>
<li>standard：</li>
<li>uax_url_email</li>
<li>pattern：正则</li>
<li>keyword：不做任何处理，直接把输入的字符串当做一个keyword输出</li>
<li>path hierarchy<br>也可以用Java插件开发，实现自己的Tokenizer<h5 id="Token-Filter"><a href="#Token-Filter" class="headerlink" title="Token Filter"></a>Token Filter</h5>将Tokenizer输出的单词（term），进行增加、修改、删除<br>自带的Token Filters：</li>
<li>Lowercase</li>
<li>stop：过滤停用词</li>
<li>synonym（添加近义词）<h5 id="设置一个Custom-Analyzer"><a href="#设置一个Custom-Analyzer" class="headerlink" title="设置一个Custom Analyzer"></a>设置一个Custom Analyzer</h5>例如：<br><img data-src="70b658a/AutoCapture_2020-07-11_215242.jpg" alt="自定义分词器实现"></li>
</ul>
<h4 id="课程示例"><a href="#课程示例" class="headerlink" title="课程示例"></a>课程示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 过滤html标签</span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;:&quot;keyword&quot;,</span><br><span class="line">  &quot;char_filter&quot;:[&quot;html_strip&quot;],</span><br><span class="line">  &quot;text&quot;: &quot;&lt;b&gt;hello world&lt;/b&gt;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 利用char_filter替换符号</span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;char_filter&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot; : &quot;mapping&quot;,</span><br><span class="line">        &quot;mappings&quot; : [ &quot;- =&gt; _&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &quot;text&quot;: &quot;123-456, I-test! test-990 650-555-1234&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 利用char filter替换表情符号</span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;char_filter&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot; : &quot;mapping&quot;,</span><br><span class="line">        &quot;mappings&quot; : [ &quot;:) =&gt; happy&quot;, &quot;:( =&gt; sad&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;text&quot;: [&quot;I am felling :)&quot;, &quot;Feeling :( today&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过自定义正则表达式实现替换</span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;char_filter&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot; : &quot;pattern_replace&quot;,</span><br><span class="line">        &quot;pattern&quot; : &quot;http://(.*)&quot;,</span><br><span class="line">        &quot;replacement&quot; : &quot;$1&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;text&quot; : &quot;http://www.elastic.co&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 利用tokenizer切分，切分后按照一级级目录切分后的结果</span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;:&quot;path_hierarchy&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;/user/ymruan/a/b/c/d/e&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// whitespace and stop</span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;filter&quot;: [&quot;stop&quot;,&quot;snowball&quot;],</span><br><span class="line">  &quot;text&quot;: [&quot;The gilrs in China are playing this game!&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//remove 加入lowercase后，The被当成 stopword删除</span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokenizer&quot;: &quot;whitespace&quot;,</span><br><span class="line">  &quot;filter&quot;: [&quot;lowercase&quot;,&quot;stop&quot;,&quot;snowball&quot;],</span><br><span class="line">  &quot;text&quot;: [&quot;The gilrs in China are playing this game!&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义分词索引示例"><a href="#自定义分词索引示例" class="headerlink" title="自定义分词索引示例"></a>自定义分词索引示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 自定义分词器索引</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;analyzer&quot;: &#123;</span><br><span class="line">        &quot;my_custom_analyzer&quot; : &#123;</span><br><span class="line">          &quot;type&quot;: &quot;custom&quot;,</span><br><span class="line">          &quot;char_filter&quot;: [</span><br><span class="line">            &quot;emoticons&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;tokenizer&quot;: &quot;punctuation&quot;,</span><br><span class="line">          &quot;filter&quot;: [</span><br><span class="line">            &quot;lowercase&quot;,</span><br><span class="line">            &quot;english_stop&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;tokenizer&quot;: &#123;</span><br><span class="line">        &quot;punctuation&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;pattern&quot;,</span><br><span class="line">          &quot;pattern&quot;: &quot;[ .,!? ]&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;char_filter&quot;: &#123;</span><br><span class="line">        &quot;emoticons&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;mapping&quot;,</span><br><span class="line">          &quot;mappings&quot;: [</span><br><span class="line">            &quot;:) =&gt; _happy_&quot;,</span><br><span class="line">            &quot;:( =&gt; _sad_&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;english_stop&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;stop&quot;,</span><br><span class="line">          &quot;stopwords&quot;: &quot;_english_&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;my_custom_analyzer&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;I&#x27;m a :) person, and you?&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;i&#x27;m&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;_happy_&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 6,</span><br><span class="line">      &quot;end_offset&quot; : 8,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;person&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 9,</span><br><span class="line">      &quot;end_offset&quot; : 15,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;you&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 21,</span><br><span class="line">      &quot;end_offset&quot; : 24,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 5</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-Index-Template和Dynamic-Template"><a href="#21-Index-Template和Dynamic-Template" class="headerlink" title="(21)Index Template和Dynamic Template"></a>(21)Index Template和Dynamic Template</h3><h4 id="什么是Index-Template"><a href="#什么是Index-Template" class="headerlink" title="什么是Index Template"></a>什么是Index Template</h4><p>Index Templates：帮助按照一定的模板自动设定Mappings和Settings，并按照一定的规则，自动匹配到新创建的索引之上。</p>
<ul>
<li>模板仅在一个索引被新创建时，才会产生作用。修改模板不会影响已创建的索引</li>
<li>可以设定多个索引模板，这些设置会被“merge”在一起</li>
<li>可以指定“order”的数值，控制“merging”的过程<br>两个自动创建的示例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT _template/template_default</span><br><span class="line">&#123;</span><br><span class="line">  &quot;index_patterns&quot;: [&quot;*&quot;],</span><br><span class="line">  &quot;order&quot; : 0,</span><br><span class="line">  &quot;version&quot;: 1,</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot;: 1,</span><br><span class="line">    &quot;number_of_replicas&quot;:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT /_template/template_test</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index_patterns&quot; : [&quot;test*&quot;],</span><br><span class="line">    &quot;order&quot; : 1,</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">        &quot;number_of_shards&quot;: 1,</span><br><span class="line">        &quot;number_of_replicas&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">        &quot;date_detection&quot;: false,</span><br><span class="line">        &quot;numeric_detection&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Index-Template的工作方式"><a href="#Index-Template的工作方式" class="headerlink" title="Index Template的工作方式"></a>Index Template的工作方式</h4>当一个索引被新创建时</li>
<li>应用ES默认的settings和mappings</li>
<li>应用order数值低的Index Template中的设定</li>
<li>应用order高的Index Template中的设定，之前的设定会被覆盖</li>
<li>应用创建索引时，用户指定的Settings和Mappings，并覆盖之前模板中的设定</li>
</ul>
<h4 id="什么是Dynamic-Template"><a href="#什么是Dynamic-Template" class="headerlink" title="什么是Dynamic Template"></a>什么是Dynamic Template</h4><p>根据ES识别的数据类型，结合字段名称，来动态设定字段类型，例如：</p>
<ul>
<li>所有的字符串类型都设定成keyword，或者关闭keyword字段</li>
<li>is开头的字段都设置成boolean</li>
<li>long开头的都设置成long类型</li>
</ul>
<h5 id="课程代码示例"><a href="#课程代码示例" class="headerlink" title="课程代码示例"></a>课程代码示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Dynaminc Mapping 根据类型和字段名</span><br><span class="line">DELETE my_index</span><br><span class="line"></span><br><span class="line">PUT my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;:&quot;Ruan&quot;,</span><br><span class="line">  &quot;isVIP&quot;:&quot;true&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_mapping</span><br><span class="line">DELETE my_index</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic_templates&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">        &quot;strings_as_boolean&quot;: &#123;</span><br><span class="line">          &quot;match_mapping_type&quot;:   &quot;string&quot;,</span><br><span class="line">          &quot;match&quot;:&quot;is*&quot;,</span><br><span class="line">          &quot;mapping&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;strings_as_keywords&quot;: &#123;</span><br><span class="line">          &quot;match_mapping_type&quot;:   &quot;string&quot;,</span><br><span class="line">          &quot;mapping&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE my_index</span><br><span class="line"># 结合路径</span><br><span class="line">## Dynamic Template是定义在某个索引的Mapping中的</span><br><span class="line">## Tempalte有一个名称</span><br><span class="line">## 匹配规则是一个数组</span><br><span class="line">## 为匹配到的字段设置Mapping</span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic_templates&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;full_name&quot;: &#123;</span><br><span class="line">          &quot;path_match&quot;:   &quot;name.*&quot;,</span><br><span class="line">          &quot;path_unmatch&quot;: &quot;*.middle&quot;,</span><br><span class="line">          &quot;mapping&quot;: &#123;</span><br><span class="line">            &quot;type&quot;:       &quot;text&quot;,</span><br><span class="line">            &quot;copy_to&quot;:    &quot;full_name&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h4><ul>
<li>Index Templates <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/indices-templates.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/indices-templates.html</a></li>
<li>Dynamic Template <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/dynamic-mapping.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.1/dynamic-mapping.html</a></li>
</ul>
<h3 id="22-ES聚合分析简介"><a href="#22-ES聚合分析简介" class="headerlink" title="(22)ES聚合分析简介"></a>(22)ES聚合分析简介</h3><h4 id="什么是聚合-Aggregation"><a href="#什么是聚合-Aggregation" class="headerlink" title="什么是聚合(Aggregation)"></a>什么是聚合(Aggregation)</h4><ul>
<li>ES除搜索以外，提供的针对ES数据进行统计分析的功能<ul>
<li>实时性高</li>
<li>Hadoop有时候统计数据可能需要一天的时间(T+1)</li>
</ul>
</li>
<li>通过聚合，我们会得到一个数据的概览，是分析和总结全套的数据，而不是寻找单个稳定<ul>
<li>比如：沙尖咀和香港岛的客房数量</li>
<li>不同的价格区间，可预订的经济型酒店和五星级酒店的数量</li>
</ul>
</li>
<li>高性能，只需要一条语句，就可以从ES中得到分析结果<ul>
<li>无需再客户端自己实现分析的逻辑<h4 id="聚合的分类"><a href="#聚合的分类" class="headerlink" title="聚合的分类"></a>聚合的分类</h4></li>
</ul>
</li>
<li>Bucket Aggregation - 一些列满足特定条件的文档的集合，即数据桶</li>
<li>Metric Aggregation - 一些数学运算，可以对文档字段进行统计分析</li>
<li>Pipeline Aggregation - 对其他的聚合结果进行二次聚合</li>
<li>Matrix Aggregation - 支持对多个字段的操作并提供一个结果矩阵<h4 id="Bucket-amp-Metric"><a href="#Bucket-amp-Metric" class="headerlink" title="Bucket &amp; Metric"></a>Bucket &amp; Metric</h4>Metric类比于SQL中的一系列统计方法<br>Bucket类比于SQL中的一系列的Group<br>Bucket示意图：<br><img data-src="70b658a/AutoCapture_2020-07-11_232645.jpg" alt="Bucket示意图"><br>Metric：</li>
<li>Metric会基于数据集计算结果，除了支持在字段上进行计算，同样也支持在脚本（painless script）产生的结果之上进行计算</li>
<li>大多数Metric是数学计算，仅输出一个值<ul>
<li>min / max / sum / avg / cardinality</li>
</ul>
</li>
<li>部分metric支持输出多个数值<ul>
<li>stats / percentiles / percentile_ranks<h5 id="一个Bucket的例子"><a href="#一个Bucket的例子" class="headerlink" title="一个Bucket的例子"></a>一个Bucket的例子</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看航班目的地的统计信息</span><br><span class="line">GET kibana_sample_data_flights/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;flight_dest&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;DestCountry&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输出结果</span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 31,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : &#123;</span><br><span class="line">      &quot;value&quot; : 10000,</span><br><span class="line">      &quot;relation&quot; : &quot;gte&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_score&quot; : null,</span><br><span class="line">    &quot;hits&quot; : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;flight_dest&quot; : &#123;</span><br><span class="line">      &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">      &quot;sum_other_doc_count&quot; : 3187,</span><br><span class="line">      &quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;IT&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 2371</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;US&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 1987</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;CN&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 1096</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;CA&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 944</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;JP&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 774</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;RU&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 739</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;CH&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 691</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;GB&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 449</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;AU&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 416</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;PL&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 405</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="一个Metrics示例"><a href="#一个Metrics示例" class="headerlink" title="一个Metrics示例"></a>一个Metrics示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看航班目的地的统计信息，增加平均，最高最低价格</span><br><span class="line">GET kibana_sample_data_flights/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot;: 0,</span><br><span class="line">    &quot;aggs&quot;:&#123;</span><br><span class="line">        &quot;flight_dest&quot;:&#123;</span><br><span class="line">            &quot;terms&quot;:&#123;</span><br><span class="line">                &quot;field&quot;:&quot;DestCountry&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot;:&#123;</span><br><span class="line">                &quot;avg_price&quot;:&#123;</span><br><span class="line">                    &quot;avg&quot;:&#123;</span><br><span class="line">                        &quot;field&quot;:&quot;AvgTicketPrice&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;max_price&quot;:&#123;</span><br><span class="line">                    &quot;max&quot;:&#123;</span><br><span class="line">                        &quot;field&quot;:&quot;AvgTicketPrice&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;min_price&quot;:&#123;</span><br><span class="line">                    &quot;min&quot;:&#123;</span><br><span class="line">                        &quot;field&quot;:&quot;AvgTicketPrice&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 43,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : &#123;</span><br><span class="line">      &quot;value&quot; : 10000,</span><br><span class="line">      &quot;relation&quot; : &quot;gte&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_score&quot; : null,</span><br><span class="line">    &quot;hits&quot; : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;flight_dest&quot; : &#123;</span><br><span class="line">      &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">      &quot;sum_other_doc_count&quot; : 3187,</span><br><span class="line">      &quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;IT&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 2371,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1195.3363037109375</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 100.57646942138672</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 586.9627099618385</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;US&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 1987,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1199.72900390625</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 100.14596557617188</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 595.7743908825026</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;CN&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 1096,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1198.4901123046875</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 102.90382385253906</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 640.7101617033464</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;CA&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 944,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1198.8525390625</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 100.5572509765625</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 648.7471090413757</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;JP&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 774,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1199.4913330078125</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 103.97209930419922</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 650.9203447346847</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;RU&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 739,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1196.7423095703125</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 101.0040054321289</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 662.9949632162009</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;CH&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 691,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1196.496826171875</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 101.3473129272461</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 575.1067587028537</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;GB&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 449,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1197.78564453125</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 111.34574890136719</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 650.5326856005696</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;AU&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 416,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1197.6326904296875</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 102.2943115234375</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 669.5588319668403</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;PL&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 405,</span><br><span class="line">          &quot;max_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 1185.43701171875</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;min_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 104.28328704833984</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;avg_price&quot; : &#123;</span><br><span class="line">            &quot;value&quot; : 662.4497233072917</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-基于词项-Term-和基于全文的搜索"><a href="#24-基于词项-Term-和基于全文的搜索" class="headerlink" title="(24)基于词项(Term)和基于全文的搜索"></a>(24)基于词项(Term)和基于全文的搜索</h3><h4 id="基于Term的查询"><a href="#基于Term的查询" class="headerlink" title="基于Term的查询"></a>基于Term的查询</h4><ul>
<li>Term的重要性<ul>
<li><strong>Term是表达语义的最小单位。</strong>搜索和利用统计语言模型进行自然语言处理都需要处理Term。</li>
</ul>
</li>
<li>特点<ul>
<li>Term Level Query:<ul>
<li>Term Query</li>
<li>Range Query</li>
<li>Exists Query</li>
<li>Prefix Query</li>
<li>Wildcard Query</li>
</ul>
</li>
<li>在ES中，Term查询，对输入 <strong>不做分词</strong> 会将输入作为一个整体，在倒排索引中查找准确的词项，并且使用相关度算分公式为每个包含该词项的文档进行 <strong>相关度算分</strong><ul>
<li>所以，在Term查询中，如果需要精确匹配，在Mapping的设置中，可以将这个字段设置成keyword字段，查询的时候指定keyword就可以精确匹配</li>
</ul>
</li>
<li>可以通过Constant Score将查询 <strong>转换成一个Filtering，避免算法，并利用缓存，提高性能</strong></li>
</ul>
</li>
</ul>
<h5 id="Term查询示例"><a href="#Term查询示例" class="headerlink" title="Term查询示例"></a>Term查询示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE products</span><br><span class="line">PUT products</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST /products/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot;,&quot;desc&quot;:&quot;iPhone&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;productID&quot; : &quot;KDKE-B-9947-#kL5&quot;,&quot;desc&quot;:&quot;iPad&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 3 &#125;&#125;</span><br><span class="line">&#123; &quot;productID&quot; : &quot;JODL-X-1937-#pV7&quot;,&quot;desc&quot;:&quot;MBP&quot; &#125;</span><br><span class="line"></span><br><span class="line">GET /products</span><br><span class="line"></span><br><span class="line">POST /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;desc&quot;: &#123;</span><br><span class="line">        # 这里搜索iPhone并不会得到结果，因为term查询默认不会对输入进行分词处理，也就是这里搜索的desc内容是iPhone</span><br><span class="line">        # 但是ES在做数据索引的时候，默认会对text类型的数据进行分词处理，所以实际应该是iphone</span><br><span class="line">        //&quot;value&quot;: &quot;iPhone&quot;</span><br><span class="line">        &quot;value&quot;:&quot;iphone&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;productID&quot;: &#123;</span><br><span class="line">        # 这里搜索是匹配不到的，因为同样会被做分词处理</span><br><span class="line">        &quot;value&quot;: &quot;XHDK-A-1293-#fJ3&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 可以通过_analyze分析，看一下默认标准分词处理</span><br><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;text&quot;: [&quot;XHDK-A-1293-#fJ3&quot;]</span><br><span class="line">&#125;</span><br><span class="line"># 输出结果，可以看出默认标准分词之后，所有的字母都变成了小写同时，符号-都没有了</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;xhdk&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 4,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;a&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 5,</span><br><span class="line">      &quot;end_offset&quot; : 6,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;1293&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 7,</span><br><span class="line">      &quot;end_offset&quot; : 11,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;NUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;fj3&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 13,</span><br><span class="line">      &quot;end_offset&quot; : 16,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 针对keyword查询则能严格查询到指定的结果值</span><br><span class="line">POST /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  //&quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;productID.keyword&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;XHDK-A-1293-#fJ3&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复合查询-Constant-Score-转为Filter"><a href="#复合查询-Constant-Score-转为Filter" class="headerlink" title="复合查询 - Constant Score 转为Filter"></a>复合查询 - Constant Score 转为Filter</h4><ul>
<li>将Query转成Filter，忽略TF-IDF计算，避免相关性算分的开销</li>
<li>Filter可以有效利用缓存<br>例如上述示例中：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line">POST /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;productID.keyword&quot;: &quot;XHDK-A-1293-#fJ3&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="基于全文的查询"><a href="#基于全文的查询" class="headerlink" title="基于全文的查询"></a>基于全文的查询</h4><ul>
<li>基于全文本查找<ul>
<li>Match Query</li>
<li>Match Phrase Query</li>
<li>Query String Query</li>
</ul>
</li>
<li>特点<ul>
<li>索引和搜索时都会进行分词，查询字符串先传递到一个合适的分词器，然后生成一个供查询的词项列表</li>
<li>查询的时候，<strong>先对输入的查询进行分词</strong>，然后每个词项逐个进行底层查询，最终将结果进行合并。并为每个文档生成一个算分。例如：查“Matrix reloaded”，实际会查到包括Matrix或者reload的所有结果<br>拆解步骤例如：<br><img data-src="70b658a/AutoCapture_2020-07-12_105807.jpg" alt="Match Query分步骤拆解示例"></li>
</ul>
</li>
</ul>
<h3 id="25-结构化搜索"><a href="#25-结构化搜索" class="headerlink" title="(25)结构化搜索"></a>(25)结构化搜索</h3><h4 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h4><ul>
<li>结构化搜索（Structured search）是指对结构化数据的搜索<ul>
<li>日期、布尔类型和数字都是结构化的</li>
</ul>
</li>
<li>文本也可以是结构化的<ul>
<li>如彩色笔可以有离散的颜色集合：红（read）、绿（green）、蓝（blue）</li>
<li>一个博客可能被标记了标签，例如，分布式（distributed）和搜索（search）</li>
<li>电商网站上的商品都有UPCs（通用产品码）或者其它的唯一标识，它们都需要遵从严格规定的、结构化的格式。</li>
</ul>
</li>
</ul>
<h4 id="ES中的结构化搜索"><a href="#ES中的结构化搜索" class="headerlink" title="ES中的结构化搜索"></a>ES中的结构化搜索</h4><ul>
<li>布尔、时间，日期和数字这类结构化数据：有精确的格式，我们可以对这些格式进行逻辑操作。包括比较数字或时间的范围，或判定两个值的大小。</li>
<li>结构化的文本可以做精确匹配或者部分匹配<ul>
<li>Term查询 | Prefix前缀查询</li>
</ul>
</li>
<li>结构化结果只有“是”或“否”两个值<ul>
<li><strong>根据场景需要，可以决定结构化搜索是否需要打分（constant score）</strong></li>
</ul>
</li>
</ul>
<h4 id="课程代码示例-1"><a href="#课程代码示例-1" class="headerlink" title="课程代码示例"></a>课程代码示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#结构化搜索，精确匹配</span><br><span class="line">DELETE products</span><br><span class="line">POST /products/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 10,&quot;avaliable&quot;:true,&quot;date&quot;:&quot;2018-01-01&quot;, &quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 20,&quot;avaliable&quot;:true,&quot;date&quot;:&quot;2019-01-01&quot;, &quot;productID&quot; : &quot;KDKE-B-9947-#kL5&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 3 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30,&quot;avaliable&quot;:true, &quot;productID&quot; : &quot;JODL-X-1937-#pV7&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 4 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30,&quot;avaliable&quot;:false, &quot;productID&quot; : &quot;QQPX-R-3956-#aD8&quot; &#125;</span><br><span class="line"></span><br><span class="line">GET products/_mapping</span><br><span class="line"># 输出结果</span><br><span class="line">&#123;</span><br><span class="line">  &quot;products&quot; : &#123;</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">      &quot;properties&quot; : &#123;</span><br><span class="line">        &quot;avaliable&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;boolean&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;date&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;date&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;price&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;long&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;productID&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;text&quot;,</span><br><span class="line">          &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;keyword&quot; : &#123;</span><br><span class="line">              &quot;type&quot; : &quot;keyword&quot;,</span><br><span class="line">              &quot;ignore_above&quot; : 256</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#对布尔值 match 查询，有算分</span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;avaliable&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#对布尔值，通过constant score 转成 filtering，没有算分</span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;avaliable&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#数字类型 Term</span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#数字类型 terms</span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;terms&quot;: &#123;</span><br><span class="line">          &quot;price&quot;: [</span><br><span class="line">            &quot;20&quot;,</span><br><span class="line">            &quot;30&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#数字 Range 查询</span><br><span class="line">GET products/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;constant_score&quot; : &#123;</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;range&quot; : &#123;</span><br><span class="line">                    &quot;price&quot; : &#123;</span><br><span class="line">                        &quot;gte&quot; : 20,</span><br><span class="line">                        &quot;lte&quot;  : 30</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日期 range</span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;constant_score&quot; : &#123;</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;range&quot; : &#123;</span><br><span class="line">                    &quot;date&quot; : &#123;</span><br><span class="line">                      &quot;gte&quot; : &quot;now-1y&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#exists查询</span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;exists&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;date&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#处理多值字段</span><br><span class="line">POST /movies/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot; : &quot;Father of the Bridge Part II&quot;,&quot;year&quot;:1995, &quot;genre&quot;:&quot;Comedy&quot;&#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot; : &quot;Dave&quot;,&quot;year&quot;:1993,&quot;genre&quot;:[&quot;Comedy&quot;,&quot;Romance&quot;] &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#多值字段查询，term查询是包含，而不是等于。</span><br><span class="line">## 要想通过这种方式，精确匹配查询，解决办法是：</span><br><span class="line">## 增加一个genre_count字段进行计数，再组合bool query的方式组合查询</span><br><span class="line">POST movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;genre.keyword&quot;: &quot;Comedy&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#字符类型 terms</span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;terms&quot;: &#123;</span><br><span class="line">          &quot;productID.keyword&quot;: [</span><br><span class="line">            &quot;QQPX-R-3956-#aD8&quot;,</span><br><span class="line">            &quot;JODL-X-1937-#pV7&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;date&quot;: &quot;2019-01-01&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;date&quot;: &quot;2019-01-01&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;productID.keyword&quot;: &quot;XHDK-A-1293-#fJ3&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;productID.keyword&quot;: &quot;XHDK-A-1293-#fJ3&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#对布尔数值</span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;avaliable&quot;: &quot;false&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;avaliable&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;false&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;20&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class="line">  &quot;explain&quot;: true,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &quot;20&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must_not&quot;: &#123;</span><br><span class="line">            &quot;exists&quot;: &#123;</span><br><span class="line">              &quot;field&quot;: &quot;date&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26-搜索相关性算法"><a href="#26-搜索相关性算法" class="headerlink" title="(26)搜索相关性算法"></a>(26)搜索相关性算法</h3><h4 id="相关性和相关性算分"><a href="#相关性和相关性算分" class="headerlink" title="相关性和相关性算分"></a>相关性和相关性算分</h4><p>相关性-Relevance</p>
<ul>
<li>搜索的相关性算分，描述了一个文档和查询语句匹配的程度。ES会对每个匹配查询条件的结果进行算分（_score）</li>
<li>打分的本质是排序，需要把符合用户需求的稳定排在前面。ES5之前，默认的相关性算法采用TF-IDF，现在采用BM25<h4 id="词频TF"><a href="#词频TF" class="headerlink" title="词频TF"></a>词频TF</h4></li>
<li>Term Frequency: 检索词在一篇文档中出现的频率<ul>
<li>检索词出现的次数除以文档的总字数</li>
</ul>
</li>
<li>度量一条查询和结果文档相关性的简单方法：简单将搜索中每一个词的TF进行相加<ul>
<li>例如：TF(区块链) + TF(的) + TF(应用)</li>
</ul>
</li>
<li>Stop Word<ul>
<li>“的”在文档中出现了很多次，但是对贡献相关度几乎没有作用，不应该考虑这些词的TF</li>
</ul>
</li>
</ul>
<h4 id="逆文档频率IDF"><a href="#逆文档频率IDF" class="headerlink" title="逆文档频率IDF"></a>逆文档频率IDF</h4><ul>
<li>DF：检索词在所有文档中出现的频率，例如：<ul>
<li>“区块链”在相对比较少的文档中出现</li>
<li>“应用”在相对比较多的文档中出现</li>
<li>“Stop word”在大量的文档中出现</li>
</ul>
</li>
<li>Inverse Document Frequency: 简单说 = log(全部文档数 / 检索词出现过的文档总数)</li>
<li>TF-IDF <strong>本质上就是讲TF求和变成了加权求和</strong>，例如：<ul>
<li>TF(区块链) * IDF(区块链) + TF() * IDF(的) + TF(应用) * IDF(应用)<br><img data-src="70b658a/AutoCapture_2020-07-12_123744.jpg" alt="TF-IDF假设运算结果表">  </li>
</ul>
</li>
</ul>
<h4 id="TF-IDF的概念"><a href="#TF-IDF的概念" class="headerlink" title="TF-IDF的概念"></a>TF-IDF的概念</h4><ul>
<li>TF-IDF被公认为是信息检索领域最重要的发明</li>
<li>除了在信息检索，在文献分类和其他相关领域有着非常广泛的应用</li>
<li>IDF的概念，最早是剑桥大学“斯巴克·琼斯”提出<ul>
<li>1972年，“关键词特殊性的统计解释和它在文献检索中的应用”</li>
<li>但是没有从理论上解释IDF应该是用log(全部文档数 / 检索词出现过的文档总数)，而不是其它函数。也没有做进一步的研究</li>
</ul>
</li>
<li>1970，1980年代萨尔顿和罗宾逊，进行了进一步的证明和研究，并用了香农的信息论做了证明</li>
<li>现代搜索引擎，对TF-IDF进行了大量细微的优化</li>
</ul>
<p>在Lucene中的TF-IDF评分公式：<br><img data-src="70b658a/AutoCapture_2020-07-12_125601.jpg" alt="Lucene中的TF-IDF评分公式"><br>boosting-权重提升因子</p>
<h4 id="BM25"><a href="#BM25" class="headerlink" title="BM25"></a>BM25</h4><ul>
<li>从ES5开始，默认算法改为BM25</li>
<li>和经典的TF-IDF相比，当TF无限增加时，BM25算分会趋于一个数值<br><img data-src="70b658a/AutoCapture_2020-07-12_125752.jpg" alt="BM25-Classic TF算分曲线">  </li>
</ul>
<p>定制Similarity<br><img data-src="70b658a/AutoCapture_2020-07-12_130022.jpg" alt="定制Similarity"> </p>
<p>可以在查询中打开explain开关，开关注算分步骤</p>
<h5 id="Boosting-Relevance"><a href="#Boosting-Relevance" class="headerlink" title="Boosting Relevance"></a>Boosting Relevance</h5><ul>
<li>Boosting是控制相关度的一种手段<ul>
<li>索引，字段或查询子条件</li>
</ul>
</li>
<li>参数boost的含义<ul>
<li>当boost &gt; 1时，打分的相关度相对性提升</li>
<li>当0 &lt; boost &lt; 1时，打分的权重相对性降低</li>
<li>当boost &lt; 0时，贡献负分</li>
</ul>
</li>
</ul>
<h4 id="相关阅读-1"><a href="#相关阅读-1" class="headerlink" title="相关阅读"></a>相关阅读</h4><ul>
<li><a href="https://en.wikipedia.org/wiki/Okapi_BM25">Wikipedia-BM25算法</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">Wikipedia-经典TF-IDF算法</a></li>
</ul>
<h3 id="27-Query-amp-Filtering与多字符串多字段查询"><a href="#27-Query-amp-Filtering与多字符串多字段查询" class="headerlink" title="(27)Query &amp; Filtering与多字符串多字段查询"></a>(27)Query &amp; Filtering与多字符串多字段查询</h3><h4 id="Query-Context-amp-Filter-Context"><a href="#Query-Context-amp-Filter-Context" class="headerlink" title="Query Context &amp; Filter Context"></a>Query Context &amp; Filter Context</h4><ul>
<li>高级搜索的功能：支持多项文本输入，针对多个字段进行搜索</li>
<li>搜索引擎一般也提供基于时间，价格等条件的过滤</li>
<li>在ElasticSearch中，有Query和Filter两种不同的Context<ul>
<li>Query Context: 相关性算分</li>
<li>Filter Context: 不需要算法（Yes or No），可以利用Cache，获得更好的性能<h4 id="条件组合示例"><a href="#条件组合示例" class="headerlink" title="条件组合示例"></a>条件组合示例</h4></li>
</ul>
</li>
<li>假设要搜索一本电影，包含了以下条件：<ul>
<li>评论中包含了Guitar，用户打分高于3分，同时上映日期要在1993与2000年之间</li>
</ul>
</li>
<li>这个搜索其实包含了3段逻辑，针对不同的字段：<ul>
<li>评论字段中要包含Guitar/用户评分大于3/上映日期需要在给定的范围</li>
</ul>
</li>
<li>同时包含这三个逻辑，并且有比较好的性能？<ul>
<li>复合查询：bool Query<h4 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h4></li>
</ul>
</li>
<li>一个bool查询，是一个或者多个查询子句的组合<ul>
<li>总共包括4种子句。其中2种会影响算分，2种不影响算分</li>
</ul>
</li>
<li>相关性并不只是全文本检索的专利。也适用于 yes | no的子句，匹配的子句越多，相关性评分越高。如果多条查询子句被合并为一条复合查询语句，比如bool查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。<table>
<thead>
<tr>
<th align="center">搜索关键词</th>
<th align="center">功能释义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">must</td>
<td align="center">必须匹配。贡献算分</td>
</tr>
<tr>
<td align="center">should</td>
<td align="center">选择性匹配。贡献算分</td>
</tr>
<tr>
<td align="center">must_not</td>
<td align="center">Filter Context查询子句，必须不能匹配</td>
</tr>
<tr>
<td align="center">filter</td>
<td align="center">Filter Context必须匹配，但是不贡献算分</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="bool查询示例"><a href="#bool查询示例" class="headerlink" title="bool查询示例"></a>bool查询示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot; : &#123;</span><br><span class="line">      &quot;must&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123; &quot;price&quot; : &quot;30&quot; &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot; : &#123; &quot;avaliable&quot; : &quot;true&quot; &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;must_not&quot; : &#123;</span><br><span class="line">        &quot;range&quot; : &#123;</span><br><span class="line">          &quot;price&quot; : &#123; &quot;lte&quot; : 10 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;should&quot; : [</span><br><span class="line">        &#123; &quot;term&quot; : &#123; &quot;productID.keyword&quot; : &quot;JODL-X-1937-#pV7&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;term&quot; : &#123; &quot;productID.keyword&quot; : &quot;XHDK-A-1293-#fJ3&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;minimum_should_match&quot; :1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#改变数据模型，增加字段。解决数组包含而不是精确匹配的问题</span><br><span class="line">POST /newmovies/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot; : &quot;Father of the Bridge Part II&quot;,&quot;year&quot;:1995, &quot;genre&quot;:&quot;Comedy&quot;,&quot;genre_count&quot;:1 &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot; : &quot;Dave&quot;,&quot;year&quot;:1993,&quot;genre&quot;:[&quot;Comedy&quot;,&quot;Romance&quot;],&quot;genre_count&quot;:2 &#125;</span><br><span class="line"></span><br><span class="line">#must，有算分</span><br><span class="line">POST /newmovies/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;&quot;term&quot;: &#123;&quot;genre.keyword&quot;: &#123;&quot;value&quot;: &quot;Comedy&quot;&#125;&#125;&#125;,</span><br><span class="line">        &#123;&quot;term&quot;: &#123;&quot;genre_count&quot;: &#123;&quot;value&quot;: 1&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="相关度算分影响"><a href="#相关度算分影响" class="headerlink" title="相关度算分影响"></a>相关度算分影响</h5><p>查询语句的结构，会对相关度算分产生影响<br><img data-src="70b658a/AutoCapture_2020-07-26_090151.jpg" alt="相关度算分产生影响示例"></p>
<ul>
<li>同一层级下的竞争字段，具有相同的权重</li>
<li>通过嵌套bool查询，可以改变对算分的影响</li>
</ul>
<h4 id="控制算分字段boosting"><a href="#控制算分字段boosting" class="headerlink" title="控制算分字段boosting"></a>控制算分字段boosting</h4><ul>
<li>Boosting是控制相关度的一种手段<ul>
<li>索引、字段或者查询子条件</li>
</ul>
</li>
<li>参数Boosting的含义<ul>
<li>当boost &gt; 1时，打分的相关度相对性提升</li>
<li>当0 &lt; boost &lt; 1时，打分的权重相对性降低</li>
<li>当0 &lt; boost时，贡献负分</li>
</ul>
</li>
</ul>
<h5 id="boosting示例"><a href="#boosting示例" class="headerlink" title="boosting示例"></a>boosting示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE blogs</span><br><span class="line">POST /blogs/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;Apple iPad&quot;, &quot;content&quot;:&quot;Apple iPad,Apple iPad&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;Apple iPad,Apple iPad&quot;, &quot;content&quot;:&quot;Apple iPad&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;&quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;apple,ipad&quot;,</span><br><span class="line">            &quot;boost&quot;: 1.1</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;&quot;match&quot;: &#123;</span><br><span class="line">          &quot;content&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;apple,ipad&quot;,</span><br><span class="line">            &quot;boost&quot;:</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">DELETE news</span><br><span class="line">POST /news/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;content&quot;:&quot;Apple Mac&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;content&quot;:&quot;Apple iPad&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 3 &#125;&#125;</span><br><span class="line">&#123; &quot;content&quot;:&quot;Apple employee like Apple Pie and Apple Juice&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST news/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123;</span><br><span class="line">        &quot;match&quot;:&#123;&quot;content&quot;:&quot;apple&quot;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST news/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123;</span><br><span class="line">        &quot;match&quot;:&#123;&quot;content&quot;:&quot;apple&quot;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;must_not&quot;: &#123;</span><br><span class="line">        &quot;match&quot;:&#123;&quot;content&quot;:&quot;pie&quot;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 搜索相关度降低算分</span><br><span class="line">POST news/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;boosting&quot;: &#123;</span><br><span class="line">      &quot;positive&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;content&quot;: &quot;apple&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;negative&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;content&quot;: &quot;pie&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;negative_boost&quot;: 0.5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="28-单字符串多字段查询Disjunction-Max-Query"><a href="#28-单字符串多字段查询Disjunction-Max-Query" class="headerlink" title="(28)单字符串多字段查询Disjunction Max Query"></a>(28)单字符串多字段查询Disjunction Max Query</h3><h4 id="查询示例"><a href="#查询示例" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT /blogs/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;: &quot;Quick brown rabbits&quot;,</span><br><span class="line">    &quot;body&quot;:  &quot;Brown rabbits are commonly seen.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /blogs/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;: &quot;Keeping pets healthy&quot;,</span><br><span class="line">    &quot;body&quot;:  &quot;My quick brown fox eats rabbits on a regular basis.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;should&quot;: [</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Brown fox&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Brown fox&quot; &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设需要查询下面一个场景：</p>
<ul>
<li>博客标题<ul>
<li>文档1中出现“Brown”</li>
</ul>
</li>
<li>博客内容<ul>
<li>文档1中出现了“Brown”</li>
<li>“Brown fox”在文档2中全部出现，并且保持和查询一致的顺序（目测相关性最高）<h5 id="算分过程解析"><a href="#算分过程解析" class="headerlink" title="算分过程解析"></a>算分过程解析</h5></li>
</ul>
</li>
<li>查询should语句中的两个查询<ul>
<li>文档2虽然包含，但是title不包含</li>
</ul>
</li>
<li>加和两个查询的评分</li>
<li>乘以匹配语句的总数</li>
<li>除以所有语句的总数</li>
</ul>
<h4 id="Disjunction-Max-Query查询"><a href="#Disjunction-Max-Query查询" class="headerlink" title="Disjunction Max Query查询"></a>Disjunction Max Query查询</h4><ul>
<li>上面例子中，title和body相互竞争<ul>
<li>不应该将分数简单叠加，而是应该找到 <strong>单个最佳匹配</strong>的字段的评分</li>
</ul>
</li>
<li>Disjunction Max Query<ul>
<li><strong>将任何与任一查询匹配的文档作为结果返回</strong>。采用字段上最匹配的评分最终评分返回</li>
</ul>
</li>
</ul>
<h5 id="查询示例-1"><a href="#查询示例-1" class="headerlink" title="查询示例"></a>查询示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;dis_max&quot;: &#123;</span><br><span class="line">            &quot;queries&quot;: [</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Quick pets&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Quick pets&quot; &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;dis_max&quot;: &#123;</span><br><span class="line">            &quot;queries&quot;: [</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Quick pets&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Quick pets&quot; &#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            # 类似于一个boosting过程</span><br><span class="line">            &quot;tie_breaker&quot;: 0.2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Tie-Breaker参数调整"><a href="#Tie-Breaker参数调整" class="headerlink" title="Tie Breaker参数调整"></a>Tie Breaker参数调整</h5><ul>
<li>获得最佳匹配语句的评分</li>
<li>将其它匹配语句的评分与tie_breaker相乘</li>
<li>将以上评分求和并规范化 </li>
</ul>
<h3 id="29-单字符串多字段查询Multi-Match"><a href="#29-单字符串多字段查询Multi-Match" class="headerlink" title="(29)单字符串多字段查询Multi Match"></a>(29)单字符串多字段查询Multi Match</h3><h4 id="三种场景"><a href="#三种场景" class="headerlink" title="三种场景"></a>三种场景</h4><ul>
<li>最佳字段（Best Fields）<ul>
<li>当字段之间相互竞争，又相互关联。例如title和body这样的字段。评分来自最匹配字段</li>
</ul>
</li>
<li>多数字段（Most Fields）<ul>
<li>处理英文内容时：一种常见的手段是，在主字段（English Analyzer），抽取词干，加入同义词，以匹配更多的文档。相同的文本，加入字段（Standard Analyzer），以提供更加精准的匹配。其他字段作为匹配文档提高相关度的信号。匹配字段越多则越好。</li>
</ul>
</li>
<li>混合字段（Cross Fields）<ul>
<li>对于某些实体，例如人名，地址，图书信息。需要在多个字段中确定信息，单个字段只能作为整体的一部分。希望在任何这些列出的字段找到尽可能多的词。</li>
</ul>
</li>
</ul>
<h4 id="Multi-Match-Query"><a href="#Multi-Match-Query" class="headerlink" title="Multi Match Query"></a>Multi Match Query</h4><p>示例查询样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;best_fields&quot;,</span><br><span class="line">      &quot;query&quot;: &quot;Quick pets&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;title&quot;,&quot;body&quot;],</span><br><span class="line">      &quot;tie_breaker&quot;: 0.2,</span><br><span class="line">      &quot;minimum_should_match&quot;: &quot;20%&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST books/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">        &quot;query&quot;:  &quot;Quick brown fox&quot;,</span><br><span class="line">        &quot;fields&quot;: &quot;*_title&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST books/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">        &quot;query&quot;:  &quot;Quick brown fox&quot;,</span><br><span class="line">        &quot;fields&quot;: [ &quot;*_title&quot;, &quot;chapter_title^2&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">########## </span><br><span class="line">PUT /titles</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;english&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST titles/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;My dog barks&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;I see a lot of barking dogs on the road &quot; &#125;</span><br><span class="line"></span><br><span class="line">### 这个查询结果，id=1的查询算分要高于id=2的</span><br><span class="line">### 因为采用了english分词器，默认会把输入的barking dogs，解析为bark dog。</span><br><span class="line">### 这样一来，两片文档命中的term都相同的情况下，由于第一篇文档更短，所以算分较高</span><br><span class="line">GET titles/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;barking dogs&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#### 上述问题，通过增加fileds中指定新的标准分词器，提示查询精确度</span><br><span class="line">DELETE /titles</span><br><span class="line">PUT /titles</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;english&quot;,</span><br><span class="line">        &quot;fields&quot;: &#123;&quot;std&quot;: &#123;&quot;type&quot;: &quot;text&quot;,&quot;analyzer&quot;: &quot;standard&quot;&#125;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST titles/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;My dog barks&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;I see a lot of barking dogs on the road &quot; &#125;</span><br><span class="line"></span><br><span class="line">GET /titles/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot;: &#123;</span><br><span class="line">        &quot;multi_match&quot;: &#123;</span><br><span class="line">            &quot;query&quot;:  &quot;barking dogs&quot;,</span><br><span class="line">            &quot;type&quot;:   &quot;most_fields&quot;,</span><br><span class="line">            &quot;fields&quot;: [ &quot;title&quot;, &quot;title.std&quot; ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Best Fields 是默认类型，可以不用指定</li>
<li>Minimum should match 等参数可以传递生成的Query中</li>
</ul>
<h4 id="跨字段搜索"><a href="#跨字段搜索" class="headerlink" title="跨字段搜索"></a>跨字段搜索</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT address/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;street&quot; : &quot;5 Poland Street&quot;,</span><br><span class="line">  &quot;city&quot; : &quot;London&quot;,</span><br><span class="line">  &quot;country&quot; : &quot;United Kingdom&quot;,</span><br><span class="line">  &quot;postcode&quot; : &quot;W1V 3DG&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 搜索不到指定结果</span><br><span class="line">POST address/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;Poland Street W1V&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;most_fields&quot;,</span><br><span class="line">      &quot;operator&quot;: &quot;and&quot;, </span><br><span class="line">      &quot;fields&quot;: [&quot;street&quot;, &quot;city&quot;, &quot;country&quot;, &quot;postcode&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">## </span><br><span class="line">POST address/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;Poland Street W1V&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;cross_fields&quot;,</span><br><span class="line">      &quot;operator&quot;: &quot;and&quot;, </span><br><span class="line">      &quot;fields&quot;: [&quot;street&quot;, &quot;city&quot;, &quot;country&quot;, &quot;postcode&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>支持使用Operator</li>
<li>与copy_to相比，其中一个优势就是它可以在搜索时为单个字段提升权重。</li>
</ul>
<h3 id="30-多语言及中文分词与检索"><a href="#30-多语言及中文分词与检索" class="headerlink" title="(30)多语言及中文分词与检索"></a>(30)多语言及中文分词与检索</h3><h4 id="自然语言与查询Recall"><a href="#自然语言与查询Recall" class="headerlink" title="自然语言与查询Recall"></a>自然语言与查询Recall</h4><ul>
<li>当处理人类自然语言时，有些情况，尽管搜索和原文不完全匹配，但是希望搜到一些内容<ul>
<li>例如：Quick brown fox 和 Fast brown fox / Jumping fox 和 Jumped foxes</li>
</ul>
</li>
<li>一些可以采取的优化措施：<ul>
<li>归一化词元：清除变音符号，如rôle的时候也会匹配role</li>
<li>抽取词根：清除单复数和时态的差异</li>
<li>包含同义词</li>
<li>拼写错误：拼写错误，或者同音异形词</li>
</ul>
</li>
</ul>
<h4 id="混合多语言挑战"><a href="#混合多语言挑战" class="headerlink" title="混合多语言挑战"></a>混合多语言挑战</h4><ul>
<li>一些具体的多语言场景<ul>
<li>不同的索引使用不同的语言 / 同一个索引中，不同的字段使用不同的语言 / 一个文档的一个字段内混合不同的语言</li>
</ul>
</li>
<li>混合语言存在的一些挑战<ul>
<li>词干提取：以色列文档，可能包含了希伯来语，阿拉伯语，俄语和英语</li>
<li>不正确的文档频率 - 英文为主的文章中，德文算分高（稀有）</li>
<li>需要判断用户搜索时使用的语言，语言识别（Compact Language Detector）<ul>
<li>例如：根据语言，查询不同的索引</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="分词挑战"><a href="#分词挑战" class="headerlink" title="分词挑战"></a>分词挑战</h4><ul>
<li>英文分词：You’re分成一个还是多个？</li>
<li>中文分词：<ul>
<li>分词标准：哈工大标准中，姓和名分开。HanLP是在一起的。具体情况需指定不同的标准</li>
<li>歧义（组合型歧义，交集型歧义，真歧义）<ul>
<li>中华人民共和国/美国会通过对台售武法案/上海仁和服装厂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="52-Ingest-Pipeline-amp-Painless-Script"><a href="#52-Ingest-Pipeline-amp-Painless-Script" class="headerlink" title="(52)Ingest Pipeline &amp; Painless Script"></a>(52)Ingest Pipeline &amp; Painless Script</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>当遇到一个输入文档中，某个输入字段不是正常的字符串，而是一个带有逗号的数组，此时需要对对应字段处理并进行Aggregation操作。<br>例如下面的：tags</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT tech_blogs/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;: &quot;Introducing big data......&quot;,</span><br><span class="line">    &quot;tags&quot;: &quot;hadoop,elasticsearch,spark&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;You know, for big data&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Ingest-Node"><a href="#Ingest-Node" class="headerlink" title="Ingest Node"></a>Ingest Node</h4><p>ElasticSearch 5.0之后，引入的一种新的节点类型。默认配置下，每个节点都是Ingest Node<br>特点：</p>
<ul>
<li>具有预处理数据的能力，可以拦截Index或Bulk API的请求</li>
<li>对数据进行转换，并重新返回给Index或Bulk API</li>
<li>无需Logstash，就可以进行数据预处理，例如：<ul>
<li>为某个字段设置默认值；重命名某个字段的字段名；对字段值进行Split操作</li>
<li>支持设置Painless脚本，对数据进行更加复杂的加工<h5 id="Pipeline-amp-Processor"><a href="#Pipeline-amp-Processor" class="headerlink" title="Pipeline &amp; Processor"></a>Pipeline &amp; Processor</h5>注：类似于Java WEB中的Filter概念<br>Pipeline管道会对通过的数据（文档），按照顺序进行加工。<br>Processor: ElasticSearch对一些加工的行为进行了抽象的包装<br>ElasticSearch有很多内置的Processors，<strong>也可以通过自定义编写插件的方式</strong>，来实现自己的Processor<br><img data-src="70b658a/AutoCapture_2020-06-20_174345.jpg" alt="Pipeline处理"></li>
</ul>
</li>
</ul>
<h5 id="Ingest-Node-v-s-Logstash"><a href="#Ingest-Node-v-s-Logstash" class="headerlink" title="Ingest Node v.s Logstash"></a>Ingest Node v.s Logstash</h5><p><img data-src="70b658a/AutoCapture_2020-06-20_175410.jpg" alt="Ingest Node v.s Logstash"></p>
<h4 id="Painless简介"><a href="#Painless简介" class="headerlink" title="Painless简介"></a>Painless简介</h4><ul>
<li>自ElasticSearch 5.X后引入，专门为ElasticSearch设计，扩展了Java的语法</li>
<li>6.0 开始，ES只支持Painless。Groovy，JavaScript和Python都不再支持</li>
<li>Painless支持所有Java的数据类型及Java API子集</li>
<li>Painless Script具备以下特性：<ul>
<li><p>高性能 &amp; 安全</p>
</li>
<li><p>支持显示类型或者动态定义类型</p>
<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5></li>
</ul>
</li>
<li>可以对文档字段进行加工处理：<ul>
<li>更新或删除字段，处理数据聚合操作</li>
<li>Script Field: 对返回的字段提前进行计算</li>
<li>Function Score: 对文档的算分进行处理</li>
</ul>
</li>
<li>可以在Ingest Pipeline中执行搅拌</li>
<li>在Reindex API，Update By Query时，对数据进行处理</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT tech_blogs/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Introducing big data......&quot;,</span><br><span class="line">  &quot;tags&quot;: &quot;hadoop,elasticsearch,spark&quot;,</span><br><span class="line">  &quot;content&quot;: &quot;You know, for big data&quot;,</span><br><span class="line">  &quot;views&quot;: 0</span><br><span class="line">&#125;</span><br><span class="line">## 通过Painless Script来动态更新上述文档中的views数值</span><br><span class="line">POST tech_blogs/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.views += params.new_views&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;new_views&quot;: 100</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST tech_blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 保存脚本在Cluster State中</span><br><span class="line">POST _scripts/sample_update_views</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.views += params.new_views&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST tech_blogs/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;sample_update_views&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;new_views&quot;: 1000</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST tech_blogs/_search</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：此种编译脚本编译开销还是比较大的<br><img data-src="70b658a/AutoCapture_2020-06-20_181355.jpg" alt="脚本编译开销"></p>
<h3 id="53-数据建模实例与最佳实践"><a href="#53-数据建模实例与最佳实践" class="headerlink" title="(53)数据建模实例与最佳实践"></a>(53)数据建模实例与最佳实践</h3><h4 id="什么是数据建模？"><a href="#什么是数据建模？" class="headerlink" title="什么是数据建模？"></a>什么是数据建模？</h4><p>数据建模（Data modeling），是创建数据模型的过程</p>
<ul>
<li><strong>数据模型</strong>是对真实世界进行抽象描述的一种工具和方法，实现对显示世界的映射<ul>
<li>博客、作者、用户评论</li>
</ul>
</li>
<li>三个过程：概念模型 =&gt; 逻辑模型 =&gt; <strong>数据模型（第三范式）</strong><ul>
<li>数据模型：结合具体的数据库，在满足业务读写性能等需求的前提下，确定最终的定义</li>
</ul>
</li>
</ul>
<h4 id="数据建模过程"><a href="#数据建模过程" class="headerlink" title="数据建模过程"></a>数据建模过程</h4><p>数据建模过程：功能需求 + 性能需求</p>
<ul>
<li>逻辑模型<ul>
<li>实体属性</li>
<li>实体之间的关系</li>
<li>搜索相关的配置</li>
</ul>
</li>
<li>物理模型<ul>
<li>索引模板<ul>
<li>分片的数量</li>
</ul>
</li>
<li>索引的Mapping<ul>
<li>字段配置：字段是否需要被搜索、字段是否需要被聚合</li>
<li>关系处理</li>
</ul>
</li>
</ul>
</li>
<li>数据需求<ul>
<li>索引与分配</li>
<li>文档</li>
<li>字段</li>
</ul>
</li>
</ul>
<h4 id="建模步骤"><a href="#建模步骤" class="headerlink" title="建模步骤"></a>建模步骤</h4><p>确定字段类型 =&gt; 字段是否要搜索及分词 =&gt; 字段是否需要聚合及排序 =&gt; 字段是否需要额外的存储</p>
<h5 id="字段类型：Text-v-s-Keyword"><a href="#字段类型：Text-v-s-Keyword" class="headerlink" title="字段类型：Text v.s Keyword"></a>字段类型：Text v.s Keyword</h5><ul>
<li>Text<ul>
<li>用于全文本字段，文本会被Analyzer分词</li>
<li><strong>默认不支持聚合分析</strong>及排序。需要设置fielddata为true</li>
</ul>
</li>
<li>Keyword<ul>
<li>用于id，枚举及不需要分词的文本。例如：电话号码，email地址，手机号码，邮政编码，性别等</li>
<li>适用于Filter（精确匹配），Sorting和Aggregations</li>
</ul>
</li>
<li>设置多字段类型<ul>
<li>默认会为文本类型设置成为text，并且设置一个keyword的子字段</li>
<li>在处理人类语言时，通过增加“英文”，“拼音”和“标准”分词器，提高搜索结构</li>
</ul>
</li>
</ul>
<h5 id="字段类型：结构化数据"><a href="#字段类型：结构化数据" class="headerlink" title="字段类型：结构化数据"></a>字段类型：结构化数据</h5><ul>
<li>数值类型<ul>
<li>尽量选择贴近的类型。例如可以用byte，就不要用long</li>
</ul>
</li>
<li>枚举类型<ul>
<li>设置为keyword。即便是数字，也应该设置成keyword，获取更好的性能</li>
</ul>
</li>
<li>其它<ul>
<li>日期、布尔、地理信息等</li>
</ul>
</li>
</ul>
<h5 id="搜索角度"><a href="#搜索角度" class="headerlink" title="搜索角度"></a>搜索角度</h5><ul>
<li>如果不需要检索，排序和聚合分析<ul>
<li>Enable设置成false</li>
</ul>
</li>
<li>如果不需要检索<ul>
<li>Index设置成false</li>
</ul>
</li>
<li>对需要检索的字段，可以通过如下配置，设定存储粒度<ul>
<li>Index options / Norms: 不需要归一化数据时，可以关闭</li>
</ul>
</li>
</ul>
<h5 id="聚合及排序角度"><a href="#聚合及排序角度" class="headerlink" title="聚合及排序角度"></a>聚合及排序角度</h5><ul>
<li>如果不需要检索，排序和聚合分析<ul>
<li>Enable设置成false</li>
</ul>
</li>
<li>如果不需要排序或者聚合分析功能<ul>
<li>Doc_values / fielddata 设置成false</li>
</ul>
</li>
<li>更新频繁，聚合查询频繁的keyword类型的字段<ul>
<li>推荐奖eager_global_ordinals设置成true。（利用缓存特性，提供Terms &amp; Aggregations的性能）</li>
</ul>
</li>
</ul>
<h5 id="额外存储角度"><a href="#额外存储角度" class="headerlink" title="额外存储角度"></a>额外存储角度</h5><ul>
<li>是否需要专门存储当前字段数据<ul>
<li>Store设置成true，可以存储该字段的原始内容</li>
<li>一般结合_source的enabled为false适合使用</li>
</ul>
</li>
<li>Disable _source 后 : 节约磁盘；适用于指标型数据<ul>
<li>所以通常：一般建议先考虑增加压缩比</li>
<li>因为：无法看到 _source字段，无法做Reindex，无法做Update</li>
</ul>
</li>
</ul>
<h4 id="一个数据建模的案例"><a href="#一个数据建模的案例" class="headerlink" title="一个数据建模的案例"></a>一个数据建模的案例</h4><p><img data-src="70b658a/AutoCapture_2020-06-29_222348.jpg" alt="一个图书索引信息"><br>解释备注：</p>
<ul>
<li>这是一个图书信息，包含：书名、简介、作者、发行日期、图书封面</li>
<li>默认Mapping的时候，会把“图书封面”设置成一个text类型，还加了一个子的字段keyword。</li>
</ul>
<p>优化：<br><img data-src="70b658a/AutoCapture_2020-06-29_222750.jpg" alt="一个图书索引信息"><br>解释备注：</p>
<ul>
<li>“图书封面”一般不会去检索</li>
</ul>
<h5 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h5><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2>]]></content>
      <categories>
        <category>极客时间</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Sony α7III Mk拍摄设置技巧</title>
    <url>/post/5a5ddfe.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本篇文章整理Sony 7M3K在摄影摄像中的一些拍摄设置技巧。多数技巧都来源B站或油管等UP主推荐，不排除后期个人设置心得。</p>
<h2 id="配置整理"><a href="#配置整理" class="headerlink" title="配置整理"></a>配置整理</h2><h3 id="B站洪峰设置教程"><a href="#B站洪峰设置教程" class="headerlink" title="B站洪峰设置教程"></a>B站洪峰设置教程</h3><p>源视频链接：<a href="https://www.bilibili.com/video/BV1R4411A7p4">https://www.bilibili.com/video/BV1R4411A7p4</a><br>该期视频中主要提到了HLG3、SLOG3、Cine4这三种模式拍摄设置技巧。其中：<br>Cine4 - 一般用在白天阴天模式下拍摄<br>HLG3 &amp; SLOG3 - 主要用在明暗反差比较大，宽容度要去比较高的情况下使用。<br>其中SLOG3模式，拍摄人物时用的较多，这种视频样式较灰，后期调色较容易；HLG3主要用在白天，明暗度对比比较大场景。</p>
<h4 id="Cine4图片配置设置"><a href="#Cine4图片配置设置" class="headerlink" title="Cine4图片配置设置"></a>Cine4图片配置设置</h4><p>黑色等级 = +2<br>伽马 = Cine4<br>黑伽马 = (范围 = 宽， 等级 = +4)<br>膝点 = (模式 = 手动， 手动设置 = [Point = 80%, Slope = +2])<br>色彩模式 = Pro<br>饱和度 = -5<br>色相 = 0<br>色彩深度 = (R = +3, G = +1, B = -1, C = -4, M = -4, Y = +3)<br>细节 = -6</p>
<h4 id="SLOG3图片配置设置"><a href="#SLOG3图片配置设置" class="headerlink" title="SLOG3图片配置设置"></a>SLOG3图片配置设置</h4><p>原生PP8</p>
<h4 id="HLG3预设"><a href="#HLG3预设" class="headerlink" title="HLG3预设"></a>HLG3预设</h4><p>PP10 - HLG3<br>黑色等级 = +5<br>伽马 = HLG3<br>黑伽马 = (范围 = 宽， 等级 = +4)<br>膝点 = (模式 = 手动， 手动设置 = [Point = 90%])<br>色彩模式 = BT. 2020<br>饱和度 = 0<br>色相 = +3<br>色彩深度 = (R = +1, G = +2, B = -2, C = 0, M = +2, Y = +2)<br>细节 = -6</p>
<h4 id="三种模式曝光设置"><a href="#三种模式曝光设置" class="headerlink" title="三种模式曝光设置"></a>三种模式曝光设置</h4><p>Cine4无需过度曝光，正常曝光即可。<br>SLOG3一定要过度曝光设置<br>HLG3拍摄，正常曝光，无需过度曝光设置</p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2>]]></content>
      <categories>
        <category>摄影摄像</category>
      </categories>
      <tags>
        <tag>Sony 7M3K</tag>
        <tag>HLG3</tag>
        <tag>SLOG3</tag>
        <tag>Cine4</tag>
      </tags>
  </entry>
  <entry>
    <title>【阅读】魔鬼经济学</title>
    <url>/post/739028af.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>魔鬼经济学-揭示隐藏在表象之下的真实世界<br>FREAKONOMICS-A Rogue Economist Explorers the Hidden Side of Everything</p>
<h2 id="书籍摘录"><a href="#书籍摘录" class="headerlink" title="书籍摘录"></a>书籍摘录</h2><h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2>]]></content>
      <categories>
        <category>经济</category>
      </categories>
      <tags>
        <tag>魔鬼经济学</tag>
        <tag>史蒂夫·列维特</tag>
        <tag>史蒂夫·都伯纳</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间-数据结构与算法-实战篇</title>
    <url>/post/faed3d05.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇作为前篇<a href="https://nimbusk.cc/post/6fac06a2">极客时间-数据结构与算法</a>的实战与分析，在本文中，主要会针对课程中提到的所有数据结构与算法相关的理论实现、经典工业级应用源码剖析等等</p>
<h2 id="实战实录"><a href="#实战实录" class="headerlink" title="实战实录"></a>实战实录</h2>]]></content>
      <categories>
        <category>极客时间</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间-数据结构与算法</title>
    <url>/post/6fac06a2.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要记录王争老师在极客时间算法课程中主要提到的核心要点。</p>
<h2 id="课程纪实"><a href="#课程纪实" class="headerlink" title="课程纪实"></a>课程纪实</h2><h3 id="复杂度分析方法"><a href="#复杂度分析方法" class="headerlink" title="复杂度分析方法"></a>复杂度分析方法</h3><p>用课程中提到的一句话：复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p>
<h4 id="如何分析与统计算法的执行效率和资源消耗"><a href="#如何分析与统计算法的执行效率和资源消耗" class="headerlink" title="如何分析与统计算法的执行效率和资源消耗"></a>如何分析与统计算法的执行效率和资源消耗</h4><h5 id="为什么需要复杂度分析？"><a href="#为什么需要复杂度分析？" class="headerlink" title="为什么需要复杂度分析？"></a>为什么需要复杂度分析？</h5><ul>
<li>测试结果非常依赖测试环境：不同的硬件环境，测试的结果自然不同</li>
<li>测试结果受数据规模的影响很大</li>
</ul>
<p>因此需要一种不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。</p>
<span id="more"></span>

<h5 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h5><p>公式可以表示为：<br><img data-src="6fac06a2/1.png" alt="表达公式"><br>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度(asymptotic time complexity)，简称时间复杂度。</p>
<h6 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h6><ul>
<li><p>只关注循环执行次数最多的一段代码<br>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了<br><img data-src="6fac06a2/2.png" alt="示例代码"></p>
</li>
<li><p>加法法则:总复杂度等于量级最大的那段代码的复杂度<br>总的时间复杂度就等于量级最大的那段代码的时间复杂度</p>
</li>
<li><p>乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积<br>落实到具体的代码上,我们可以把乘法法则看成是嵌套循环</p>
</li>
</ul>
<h6 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h6><p>常见的复杂度量级图解:<br><img data-src="6fac06a2/3.png" alt="复杂度量级"></p>
<ul>
<li>多项式量级<ul>
<li>O(1)</li>
<li>O(logn)、O(nlogn)</li>
<li>O(m+n)、O(m*n)</li>
</ul>
</li>
<li>非多项式量级</li>
</ul>
<p>几种时间复杂度增长关系<br><img data-src="6fac06a2/4.png" alt="复杂度增长关系"></p>
<h5 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h5><p>时间复杂度的全称是渐进时间复杂度,表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度(asymptotic space complexity)，表示算法的存储空间与数据规模之间的增长关系。</p>
<h4 id="浅析最好、最坏、平均、均摊时间复杂度"><a href="#浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="浅析最好、最坏、平均、均摊时间复杂度"></a>浅析最好、最坏、平均、均摊时间复杂度</h4><h5 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h5><p>最好情况时间复杂度就是：在 <strong>最理想</strong> 的情况下，执行这段代码的时间复杂度</p>
<h5 id="最快情况"><a href="#最快情况" class="headerlink" title="最快情况"></a>最快情况</h5><p>最坏情况时间复杂度就是：在 <strong>最糟糕</strong> 的情况下，执行这段代码的时间复杂度</p>
<h5 id="平均情况"><a href="#平均情况" class="headerlink" title="平均情况"></a>平均情况</h5><p>这是一个简单的概率论中的知识<br><img data-src="6fac06a2/5.png" alt="平均时间复杂度分析"></p>
<h5 id="均摊时间"><a href="#均摊时间" class="headerlink" title="均摊时间"></a>均摊时间</h5><h3 id="常见几种基本数据结构"><a href="#常见几种基本数据结构" class="headerlink" title="常见几种基本数据结构"></a>常见几种基本数据结构</h3><p>数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。<br>如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>解释：数组(Array)是一种线性表数据结构。它用一组连续的内存空间,来存储一组具有相同类型的数据。</p>
<h5 id="线性表-Linear-List"><a href="#线性表-Linear-List" class="headerlink" title="线性表(Linear List)"></a>线性表(Linear List)</h5><p><img data-src="6fac06a2/6.png" alt="线性表逻辑结构"></p>
<h5 id="非线性表"><a href="#非线性表" class="headerlink" title="非线性表"></a>非线性表</h5><p>之所以叫非线性,是因为,在非线性表中,数据之间并不是简单的前后关系。<br>连续的内存空间和相同类型的数据<br><img data-src="6fac06a2/7.png" alt="非线性表逻辑结构"></p>
<p><strong>常常会问数组和链表的区别</strong><br>“链表适合插入、删除,时间复杂度 O(1);数组适合查找,查找时间复杂度为O(1)”。<br><em>正确的表述应该是</em>,数组支持随机访问,根据下标随机访问的时间复杂度为 O(1)。</p>
<h5 id="数组特点"><a href="#数组特点" class="headerlink" title="数组特点"></a>数组特点</h5><p>低效的“插入”和“删除”</p>
<h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><p>如果在数组的末尾插入元素,那就不需要移动数据了,这时的时间复杂度为 O(1)。但如果在数组的开头插入元素,那所有的数据都需要依次往后移动一位,所以最坏时间复杂度是O(n)。 因为我们在每个位置插入元素的概率是一样的,所以平均情况时间复杂度为 (1+2+ …n)/n=O(n)。</p>
<h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><p>如果删除数组末尾的数据,则最好情况时间复杂度为 O(1);如果删除开头的数据,则最坏情况时间复杂度为 O(n);平均情况时间复杂度也为 O(n)。</p>
<h5 id="几点经验"><a href="#几点经验" class="headerlink" title="几点经验"></a>几点经验</h5><ul>
<li>ava ArrayList 无法存储基本类型,比如 int、long,需要封装为 Integer、Long 类,而Autoboxing、Unboxing 则有一定的性能消耗,所以如果特别关注性能,或者希望使用基本类型,就可以选用数组。</li>
<li>如果数据大小事先已知,并且对数据的操作非常简单,用不到 ArrayList 提供的大部分方法,也可以直接使用数组。</li>
<li>还有一个是我个人的喜好,当要表示多维数组时,用数组往往会更加直观。比如Object[][] array;而用容器的话则需要这样定义:ArrayList<ArrayList> array。</li>
</ul>
<h5 id="开篇答疑"><a href="#开篇答疑" class="headerlink" title="开篇答疑"></a>开篇答疑</h5><p>为什么大多数编程语言中,数组要从 0 开始编号,而不是从1 开始呢?<br>正常的寻址公式这样的：<br><img data-src="6fac06a2/8.png" alt="正常的数组寻址公式"><br>如果数组从1开始计数，那么寻址公式就是下面这样的<br><img data-src="6fac06a2/9.png" alt="数组起始为1的时候寻址公式"><br>此时很明显，计算机计算的步骤要比从0开始多计算，因而需要消耗更多的计算资源</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>先进先出策略 FIFO(First In,First Out)、最少使用策略 LFU(Least Frequently Used)、最近最少使用策略 LRU(Least Recently Used)。<br>数组需要一块连续的内存空间，而链表恰恰相反</p>
<h5 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h5><p>单链表、双向链表和循环链表</p>
<h6 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h6><p><img data-src="6fac06a2/10.png" alt="单链表模拟结构"><br>注意：第一个结点叫作头结点、最后一个结点叫作尾结点。</p>
<h6 id="循环链表和双向链表"><a href="#循环链表和双向链表" class="headerlink" title="循环链表和双向链表"></a>循环链表和双向链表</h6><p>单链表的尾结点指针指向空地址,表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点<br><img data-src="6fac06a2/11.png" alt="循环链表模拟结构"></p>
<p>双向链表,顾名思义,它支持两个方向,每个结点不止有一个后继指针 next 指向后面的结点,还有一个前驱指针 prev 指向前面的结点。<br><img data-src="6fac06a2/12.png" alt="双向链表模拟结构"><br>根据要查找的值与 p 的大小关系,决定是往前还是往后查找,所以平均只需要查找一半的数据。</p>
<p>双向循环链表<br><img data-src="6fac06a2/13.png" alt="双向循环链表模拟结构"></p>
<h5 id="用空间换时间"><a href="#用空间换时间" class="headerlink" title="用空间换时间"></a>用空间换时间</h5><p>当内存空间充足的时候,如果我们更加追求代码的执行速度,我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构<br>如果内存比较紧缺,比如代码跑在手机或者单片机上,这个时候,就要反过来用时间换空间的设计思路。<br><img data-src="6fac06a2/14.png" alt="数组与链表操作时间复杂度"></p>
<h5 id="开篇答疑（一）"><a href="#开篇答疑（一）" class="headerlink" title="开篇答疑（一）"></a>开篇答疑（一）</h5><p>如何基于链表实现 LRU 缓存淘汰算法?</p>
<ul>
<li><ol>
<li>如果此数据之前已经被缓存在链表中了,我们遍历得到这个数据对应的结点,并将其从原来的位置删除,然后再插入到链表的头部。</li>
</ol>
</li>
<li><ol start="2">
<li>如果此数据没有在缓存链表中,又可以分为两种情况</li>
</ol>
<ul>
<li>如果此时缓存未满,则将此结点直接插入到链表的头部;</li>
<li>如果此时缓存已满,则链表尾结点删除,将新的数据结点插入链表的头部。<br>当然也可以用数组来完成这个判断过程</li>
</ul>
</li>
</ul>
<h5 id="如何轻松写出正确的链表代码？"><a href="#如何轻松写出正确的链表代码？" class="headerlink" title="如何轻松写出正确的链表代码？"></a>如何轻松写出正确的链表代码？</h5><h6 id="技巧一-理解指针或引用的含义"><a href="#技巧一-理解指针或引用的含义" class="headerlink" title="技巧一:理解指针或引用的含义"></a>技巧一:理解指针或引用的含义</h6><p>没啥好说的，如果是通过C/C++来实现，需要注意</p>
<h6 id="技巧二-警惕指针丢失和内存泄漏"><a href="#技巧二-警惕指针丢失和内存泄漏" class="headerlink" title="技巧二:警惕指针丢失和内存泄漏"></a>技巧二:警惕指针丢失和内存泄漏</h6><p>一个典型错误示例：<br><img data-src="6fac06a2/15.png" alt="错误的插入节点步骤"><br>正确的示例片段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = x; <span class="comment">// 将p的next指针指向x结点</span></span><br><span class="line">x-&gt;next = p-&gt;next; <span class="comment">// 将x的结点的next指针指向b结点</span></span><br></pre></td></tr></table></figure>
<p>删除链表结点时,也一定要记得手动释放内存空间</p>
<h6 id="技巧三-利用哨兵简化实现难度"><a href="#技巧三-利用哨兵简化实现难度" class="headerlink" title="技巧三:利用哨兵简化实现难度"></a>技巧三:利用哨兵简化实现难度</h6><p>在任何时候,不管链表是不是空,head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反,没有哨兵结点的链表就叫作不带头链表。<br><img data-src="6fac06a2/16.png" alt="带头链表模拟结构"><br>这种利用哨兵简化编程难度的技巧,在很多代码实现中都有用到,比如<strong>插入排序、归并排序、动态规划</strong>等</p>
<h6 id="技巧四-重点留意边界条件处理"><a href="#技巧四-重点留意边界条件处理" class="headerlink" title="技巧四:重点留意边界条件处理"></a>技巧四:重点留意边界条件处理</h6><ul>
<li>如果链表为空时,代码是否能正常工作?</li>
<li>如果链表只包含一个结点时,代码是否能正常工作?</li>
<li>如果链表只包含两个结点时,代码是否能正常工作?</li>
<li>代码逻辑在处理头结点和尾结点的时候,是否能正常工作?</li>
</ul>
<h6 id="技巧五-举例画图-辅助思考"><a href="#技巧五-举例画图-辅助思考" class="headerlink" title="技巧五:举例画图,辅助思考"></a>技巧五:举例画图,辅助思考</h6><p><img data-src="6fac06a2/17.png" alt="画图思考示例"></p>
<h6 id="技巧六-多写多练-没有捷径"><a href="#技巧六-多写多练-没有捷径" class="headerlink" title="技巧六:多写多练,没有捷径"></a>技巧六:多写多练,没有捷径</h6><p>几个核心要点：</p>
<ul>
<li>单链表反转</li>
<li>链表中环的检测</li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第n个节点</li>
<li>求链表的中间节点</li>
</ul>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种“操作受限”的线性表,只允许在一端插入和删除数据<br>当某个数据集合只涉及在一端插入和删除数据,并且满足后进先出、先进后出的特性,我们就应该首选“栈”这种数据结构。</p>
<h5 id="如何实现一个栈？"><a href="#如何实现一个栈？" class="headerlink" title="如何实现一个栈？"></a>如何实现一个栈？</h5><h6 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h6><p>用数组实现的栈,我们叫作顺序栈，支持动态扩容的顺序栈<br>来看下面的思考：<br><img data-src="6fac06a2/18.png" alt="一些假设和定义"><br><img data-src="6fac06a2/19.png" alt="入栈的时间复杂度"></p>
<h6 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h6><p>顾名思义，用链表来实现的</p>
<h5 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h5><p>操作系统给每个线程分配了一块独立的内存空间,这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数,就会将临时变量作为一个栈帧入栈,当被调用函数执行完成,返回之后,将这个函数对应的栈帧出栈。</p>
<h5 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h5><h5 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h5><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="如何理解“队列”"><a href="#如何理解“队列”" class="headerlink" title="如何理解“队列”?"></a>如何理解“队列”?</h5><p>入队 enqueue(),放一个数据到队列尾部;出队 dequeue(),从队列头部取一个元素。<br><img data-src="6fac06a2/20.png" alt="入栈的时间复杂度"></p>
<h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><h5 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h5><h6 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h6><p>阻塞队列其实就是在队列基础上增加了阻塞操作<br>在队列为空的时候,从队头取数据会被阻塞。因为此时还没有数据可取,直到队列中有了数据才能返回;如果队列已经满了,那么插入数据的操作就会被阻塞,直到队列中有空闲位置后再插入数据,然后再返回。<br><img data-src="6fac06a2/21.png" alt="阻塞队列模拟结构"></p>
<h6 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h6><p>最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁,但是锁粒度大并发度会比较低,同一时刻仅允许一个存或者取操作。实际上,基于数组的循环队列,利用 CAS 原子操作,可以实现非常高效的并发队列</p>
<h5 id="开篇答疑-1"><a href="#开篇答疑-1" class="headerlink" title="开篇答疑"></a>开篇答疑</h5><p><em>线程池没有空闲线程时,新的任务请求线程资源时,线程池该如何处理?各种处理策略又是如何实现的呢?</em></p>
<ul>
<li>是非阻塞的处理方式,直接拒绝任务请求;</li>
<li>阻塞的处理方式,将请求排队,等到有空闲线程时,取出排队的请求继续处理</li>
<li>基于链表<br>基于链表的实现方式,可以实现一个支持无限排队的无界队列(unbounded queue),但是可能会导致过多的请求排队等待,请求处理的响应时间过长。所以,针对响应时间比较敏感的系统,基于链表实现的无限排队的线程池是不合适的。</li>
<li>基于数组<br>而基于数组实现的有界队列(bounded queue),队列的大小有限,所以线程池中排队的请求超过队列大小时,接下来的请求就会被拒绝,这种方式对响应时间敏感的系统来说,就相对更加合理。不过,设置一个合理的队列大小,也是非常有讲究的。队列太大导致等待的请求太多,队列太小会导致无法充分利用系统资源、发挥最大性能。</li>
</ul>
<h3 id="基础排序"><a href="#基础排序" class="headerlink" title="基础排序"></a>基础排序</h3><p>各基础排序时间复杂度比较<br><img data-src="6fac06a2/22.png" alt="基础排序时间复杂度比较"></p>
<h4 id="如何分析一个“排序算法”"><a href="#如何分析一个“排序算法”" class="headerlink" title="如何分析一个“排序算法”?"></a>如何分析一个“排序算法”?</h4><h5 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h5><ul>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外,你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</li>
<li>为什么要区分这三种时间复杂度呢?第一,有些排序算法会区分,为了好对比,所以我们最好都做一下区分。第二,对于要排序的数据,有的接近有序,有的完全无序。有序度不同的数据,对于排序的执行时间肯定是有影响的,我们要知道排序算法在不同数据下的性能表现。</li>
</ul>
<h5 id="时间复杂度的系数、常数-、低阶"><a href="#时间复杂度的系数、常数-、低阶" class="headerlink" title="时间复杂度的系数、常数 、低阶"></a>时间复杂度的系数、常数 、低阶</h5><p>对同一阶时间复杂度的排序算法性能对比的时候, 我们就要把系数、常数、低阶也考虑进来。</p>
<h5 id="比较次数和交换-或移动-次数"><a href="#比较次数和交换-或移动-次数" class="headerlink" title="比较次数和交换(或移动)次数"></a>比较次数和交换(或移动)次数</h5><p>基于比较的排序算法的执行过程,会涉及两种操作,一种是元素比较大小,另一种是元素交换或移动。所以,如果我们在分析排序算法的执行效率的时候,应该把比较次数和交换(或移动)次数也考虑进去。</p>
<h5 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h5><p>算法的内存消耗可以通过空间复杂度来衡量,排序算法也不例外。不过,针对排序算法的空间复杂度,我们还引入了一个新的概念,原地排序(Sorted in place)。<br>原地排序算法,就是特指空间复杂度是 O(1) 的排序算法。我们今天讲的三种排序算法,都是原地排序算法。</p>
<h5 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h5><p>稳定性。这个概念是说,如果待排序的序列中存在值相等的元素,经过排序之后,相等元素之间原有的先后顺序不变。<br>稳定排序算法可以保持金额相同的两个对象,在排序之后的前后顺序不变<br><img data-src="6fac06a2/23.png" alt="基础排序时间复杂度比较"></p>
<h4 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h4><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较,看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置,重复 n 次,就完成了 n 个数据的排序工作。<br><img data-src="6fac06a2/24.png" alt="冒泡排序示例步骤拆解"></p>
<h5 id="几点关于冒泡排序的思考"><a href="#几点关于冒泡排序的思考" class="headerlink" title="几点关于冒泡排序的思考"></a>几点关于冒泡排序的思考</h5><ul>
<li>冒泡排序是原地排序算法吗?<br>冒泡的过程只涉及相邻数据的交换操作,只需要常量级的临时空间,所以它的空间复杂度为O(1),是一个原地排序算法。</li>
<li>冒泡排序是稳定的排序算法吗?<br>在冒泡排序中,只有交换才可以改变两个元素的前后顺序。<br>保证冒泡排序算法的稳定性,当有相邻的两个元素大小相等的时候,我们不做交换,相同大小的数据在排序前后不会改变顺序,所以冒泡排序是稳定的排序算法。</li>
<li>冒泡排序的时间复杂度是多少?<br>最好情况时间复杂度是 O(n)<br>最坏情况时间复杂度为 O(n)。<br>用概率论方法定量分析平均时间复杂度,涉及的数学推理和计算就会很复杂。<br>一种思路,通过<strong>“有序度”和“逆序度”</strong>这两个概念来进行分析。<h6 id="有关有序度与无序度的讨论"><a href="#有关有序度与无序度的讨论" class="headerlink" title="有关有序度与无序度的讨论"></a>有关有序度与无序度的讨论</h6>有序度是数组中具有有序关系的元素对的个数<br>例如：<br><img data-src="6fac06a2/25.png" alt="数组的有序度"><br>对于一个倒序排列的数组,比如 6,5,4,3,2,1,有序度是 0;对于一个完全有序的数组,比如 1,2,3,4,5,6,有序度就是n*(n-1)/2,也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。</li>
</ul>
<p><strong>一个公式:逆序度 = 满有序度 - 有序度。</strong></p>
<p>拿前面举的那个冒泡排序的例子：<br><img data-src="6fac06a2/26.png" alt="一则冒泡排序示例分析"><br>逆序度,也就是n*(n-1)/2–初始有序度。此例中就是 15–3=12,要进行 12 次交换操作。<br>对于包含 n 个数据的数组进行冒泡排序,平均交换次数是多少呢?最坏情况下,初始状态的有序度是 0,所以要进行 n*(n-1)/2 次交换。最好情况下,初始状态的有序度是 n*(n- 1)/2,就不需要进行交换。我们可以取个中间值 n*(n-1)/4,来表示初始有序度既不是很高也不是很低的平均情况。<br>平均情况下,需要 n*(n-1)/4 次交换操作,比较操作肯定要比交换操作多,而复杂度的上限是 O(n ),所以平均情况下的时间复杂度就是 O(n )。</p>
<h4 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h4><p>一个有序的数组,我们往里面添加一个新的数据后,如何继续保持数据有序呢?<br><img data-src="6fac06a2/27.png" alt="保持有序的插入排序示例"></p>
<h5 id="步骤拆解"><a href="#步骤拆解" class="headerlink" title="步骤拆解"></a>步骤拆解</h5><p>我们将数组中的数据分为两个区间,已排序区间和未排序区间。<br>初始已排序区间只有一个元素,就是数组的第一个元素。<br>插入算法的核心思想是取未排序区间中的元素,在已排序区间中找到合适的插入位置将其插入,并保证已排序区间数据一直有序。重复这个过程, 直到未排序区间中元素为空,算法结束。<br><img data-src="6fac06a2/28.png" alt="插入排序分步骤拆解"></p>
<h5 id="几点思考"><a href="#几点思考" class="headerlink" title="几点思考"></a>几点思考</h5><ul>
<li>插入排序是原地排序算法吗?<br>实现过程可以很明显地看出,插入排序算法的运行并不需要额外的存储空间,所以空间复杂度是 O(1),也就是说,这是一个原地排序算法。</li>
<li>插入排序是稳定的排序算法吗?<br>保持原有的前后顺序不变,所以插入排序是稳定的排序算法</li>
<li>插入排序的时间复杂度是多少?<br>每次插入都相当于在数组的第一个位置插入新的数据,所以需要移动大量的数据,所以最坏情况时间复杂度为 O(n )</li>
</ul>
<h4 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h4><p>也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素,将其放到已排序区间的末尾。<br><img data-src="6fac06a2/29.png" alt="选择排序原理示意图"><br>选择排序空间复杂度为 O(1),是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n )<br><strong>选择排序是一种不稳定的排序算法。</strong></p>
<h5 id="开篇答疑-2"><a href="#开篇答疑-2" class="headerlink" title="开篇答疑"></a>开篇答疑</h5><p>冒泡排序和插入排序的时间复杂度都是O(n ),都是原地排序算法,为什么插入排序要比冒泡排序更受欢迎呢?</p>
<ul>
<li>冒泡排序不管怎么优化,元素交换的次数是一个固定值,是原始数据的逆序度。</li>
<li>插入排序是同样的,不管怎么优化,元素移动的次数也等于原始数据的逆序度。</li>
<li>冒泡排序的数据交换要比插入排序的数据移动要复杂,冒泡排序需要 3 个赋值操作,而插入排序只需要 1 个。</li>
<li><strong>插入排序的优化感兴趣,可以自行学习一下希尔排序</strong></li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>对于小规模数据的排序,用起来非常高效。但是在大规模数据排序的时候,这个时间复杂度还是稍微有点高,所以我们更倾向于用下一节要讲的时间复杂度为 O(nlogn) 的排序算法。</p>
<h4 id="如何用快排思想在O-n-内查找第K大元素？"><a href="#如何用快排思想在O-n-内查找第K大元素？" class="headerlink" title="如何用快排思想在O(n)内查找第K大元素？"></a>如何用快排思想在O(n)内查找第K大元素？</h4><p>两种时间复杂度为 O(nlogn) 的排序算法,归并排序和快速排序。这两种排序算法适合大规模的数据排序<br>我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot,对数组 A[0…n-1] 原地分区,这样数组就分成了三部分,A[0…p-1]、A[p]、A[p+1…n-1]。<br>如果 p+1=K,那 A[p] 就是要求解的元素;如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间,我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理,如果K &lt; p+1,那我们就在 A[0…p-1] 区间查找。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>核心思想还是蛮简单的。如果要排序一个数组,我们先把数组从中间分成前后两部分,然后对前后两部分分别排序,再将排好序的两部分合并在一起,这样整个数组就都有序了。<br><img data-src="6fac06a2/30.png" alt="归并排序分解图"><br>分治是一种解决问题的处理思想,递归是一种编程技巧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法, A 是数组，n 表示数组大小</span></span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">merge_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line"><span class="comment">// 递归终止条件</span></span><br><span class="line"><span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line"><span class="comment">// 取 p 到 r 之间的中间位置 q</span></span><br><span class="line">q = (p+r) / <span class="number">2</span></span><br><span class="line"><span class="comment">// 分治递归</span></span><br><span class="line">merge_sort_c(A, p, q)</span><br><span class="line">merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line"><span class="comment">// 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span></span><br><span class="line">merge(A[p...r], A[p...q], A[q+<span class="number">1.</span>..r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="归并排序的性能分析"><a href="#归并排序的性能分析" class="headerlink" title="归并排序的性能分析"></a>归并排序的性能分析</h5><ul>
<li>归并排序是稳定的排序算法吗?<br>归并排序稳不稳定关键要看merge() 函数,也就是两个有序子数组合并成一个有序数组的那部分代码</li>
<li>归并排序的时间复杂度是多少?<br>不仅递归求解的问题可以写成递推公式,递归代码的时间复杂度也可以写成递推公式。<br>如果我们定义求解问题 a 的时间是 T(a)，求解问题 b、c 的时间分别是 T(b) 和 T( c)，那我<br>们就可以得到这样的递推关系式：<br>T(a) = T(b) + T(c) + K<br>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</li>
<li>第三,归并排序的空间复杂度是多少?<br>归并排序的时间复杂度任何情况下都是 O(nlogn)<br>有一个致命的“弱点”,<strong>那就是归并排序不是原地排序算法。</strong></li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>如果要排序数组中下标从 p 到 r 之间的一组数据,我们选择 p 到 r 之间的任意一个数据作为 pivot(分区点)。<br>我们遍历 p 到 r 之间的数据,将小于 pivot 的放到左边,将大于 pivot 的放到右边,将pivot 放到中间。经过这一步骤之后,数组 p 到 r 之间的数据就被分成了三个部分,前面 p 到 q-1 之间都是小于 pivot 的,中间是 pivot,后面的 q+1 到 r 之间是大于 pivot 的。<br><img data-src="6fac06a2/31.png" alt="快速排序分区示意图"></p>
<p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。<br>递推公式：<br>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)<br>终止条件：<br>p &gt;= r<br>用代码表示就如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序，A 是数组，n 表示数组的大小</span></span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">quick_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序递归函数，p,r 为下标</span></span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line"><span class="keyword">if</span> p &gt;= r then <span class="type">return</span></span><br><span class="line"><span class="variable">q</span> <span class="operator">=</span> partition(A, p, r) <span class="comment">// 获取分区点</span></span><br><span class="line">quick_sort_c(A, p, q-<span class="number">1</span>)</span><br><span class="line">quick_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速排序之原地分区函数"><a href="#快速排序之原地分区函数" class="headerlink" title="快速排序之原地分区函数"></a>快速排序之原地分区函数</h5><p>伪代码如下：<br><img data-src="6fac06a2/32.png" alt="快速排序原地分区函数伪代码示例"></p>
<p><img data-src="6fac06a2/33.png" alt="原地分区后的快速排序步骤拆解示例"><br>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法</p>
<h5 id="快排与归并的不同"><a href="#快排与归并的不同" class="headerlink" title="快排与归并的不同"></a>快排与归并的不同</h5><p>快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？<br><img data-src="6fac06a2/34.png" alt="图解快排与归并的不同"><br>可以发现，归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
<h3 id="线性排序"><a href="#线性排序" class="headerlink" title="线性排序"></a>线性排序</h3><p>三种时间复杂度是O(n)的排序算法:桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的,所以我们把这类排序算法叫作线性排序( Linear sort</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p><img data-src="6fac06a2/35.png" alt="桶排序示例"><br>桶排序看起来很优秀,那它是不是可以替代我们之前讲的排序算法呢?<br>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中,数据量比较大,内存有限,无法将数据全部加載到内存中。<br>例如：<br>比如说我们有10GB的订单数据,我们希望按订单金额(假设金额都是正整数)进行排序,但是我们的内存有限,只有几百MB,没办法一次性把106B的数据都加载到内存中。这个时候该怎么办呢?<br>先扫描一遍文件,看订单金额所处的数据范围。假设经过扫描之后我们得到,订单金额最小是1元最大是10万元。我们将所有订单根据金额划分到100个桶里,第一个桶我们存储金额在1元到1000元之内的订单,第二桶存储金额在1001元到2000元之内的订单,以此类推。每一个桶对应一个文件,并且按照金额范围的大小顺序编号命名(00,01,0299)<br>如果订单金额在1到10万之间均匀分布,那订单会被均匀划分到100个文件中,每个小文件中存储大约100MB的订单数据,我们就可以将这100个小文件依次放到内存中,用快排来排序<br><strong>但是</strong>订单按照金额在1元到10万元之间并不一定是均匀分布的:<br><em>如何借助桶排序的处理思想来解决这个问题。</em><br>可以先扫描一遍文件,看订单金额所处的数据范国。假设经过扫描之后我们得到; 最小是1元,最大是10万元。我们将所有订单根据金额划分到100个桶里,第门存储金额在1元到1000元之内的订单,第二桶存储金额在1001元到2000元单,以此类推。每一个桶对应一个文件,并且按照金额范围的大小顺序编号命名01,02.99)。<br>针对这些划分之后还是比较大的文件,我们可以继续划分,比如,订单金额在1元到1000 元之间的比较多,我们就将这个区间继续划分为10个小区间,1元到100元,101元到200元,201元到300元.901元到1000元。如果划分之后,101元到200元之间的订单还是太多,无法一次性读入内存,那就继续再划分,直到所有的文件都能读入内存为止</p>
<h4 id="计数排序-Counting-sort"><a href="#计数排序-Counting-sort" class="headerlink" title="计数排序( Counting sort)"></a>计数排序( Counting sort)</h4><p>计数排序其实是桶排序的一种特殊情况<br>举例：考生的满分是900分,最小是0分,这个数据的范围很小,所以我们可以分成901个桶对应分数从0分到900分。根据考生的成绩,我们将这50万考生划分到这901个桶里。</p>
<h5 id="深入理解计数含义"><a href="#深入理解计数含义" class="headerlink" title="深入理解计数含义"></a>深入理解计数含义</h5><p>计数排序的算法思想就是这么简单,跟桶排序非常类似,只是桶的大小粒度不一样。不过, 为什么这个排序算法叫“计数”排序呢?“计数”的含义来自哪里呢?<br>【举例】假设只有8个考生,分数在0到5分之间。这8 个考生的成绩我们放在一个数组A[8]中,它们分別是:2,5,3,0,2,3,0,3。<br>考生的成绩从0到5分,我们使用大小为6的数组C[6]表示桶,其中下标对应分数。如下图所示：<br><img data-src="6fac06a2/36.png" alt="考生成绩划分后的计数数组"><br>从上图中可以看出：<br><img data-src="6fac06a2/37.png" alt="思考"><br><img data-src="6fac06a2/38.png" alt="成绩3的划分场景"></p>
<h5 id="关键问题：如何计算位置？"><a href="#关键问题：如何计算位置？" class="headerlink" title="关键问题：如何计算位置？"></a>关键问题：如何计算位置？</h5><p>如何快速计算出,每个分数的考生在有序数组中对应的存储位置呢?<br>我们对C[6]数组顺序求和,C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数k的考生个数，如下图所示：<br><img data-src="6fac06a2/39.png" alt="顺序求和之后的数组"><br>我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3] 要减 1，变成 6。<br>以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。<br><img data-src="6fac06a2/40.png" alt="拆解计算步骤"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 查找数组中数据的范围</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">max = a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组 c，下标大小 [0,max]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">c[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算每个元素的个数，放入 c 中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">c[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次累加</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 临时数组 r，存储排序之后的结果</span></span><br><span class="line"><span class="type">int</span>[] r = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c[a[i]]-<span class="number">1</span>;</span><br><span class="line">r[index] = a[i];</span><br><span class="line">c[a[i]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将结果拷贝给 a 数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">a[i] = r[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是 [-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。</p>
<h4 id="基数排序-Radix-sort"><a href="#基数排序-Radix-sort" class="headerlink" title="基数排序( Radix sort)"></a>基数排序( Radix sort)</h4><p>假设我们有10万个手机号码,希望将这10万个手机号码从小到大排序,你有什么比较快速的排序方法呢?<br><img data-src="6fac06a2/41.png" alt="图解计数排序过程"><br>这里按照每位来排序的排序算法要是稳定的,否则这个实现思路就是不正确的。因为如如果是非稳定排序算法,那最后一次排序只会考虑最高位的大小顺序,完全不管其他位的大小关系,那么低位的排序就完全没有意义了。<br><strong>有时候要排序的数据并不都是等长的</strong><br>实际上,我们可以把所有的单词补齐到相同长度,位数不够的可以在后面补“0”,因为根据ASCI值,所有字母都大于“0”,所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了</p>
<p>基数排序对要排序的数据是有要求的,需要可以分割出独立的“位”来比较,而且位之间有递进的关系,如果a数据的高位比b数据大,那剩下的低位就不用比较了。除此之外,每一位的数据范围不能太大,要可以用线性排序算法来排序,否则,基数排序的时间复杂度就无法做到O(n)了。</p>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>如何实现一个通用的、高性能的排序函数？<br><img data-src="6fac06a2/42.png" alt="各排序函数时间复杂度一览"><br>为了兼顾任意规模数据的排序, 一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。<br>快速排序在最坏情况下的时间复杂度是 O(n ),如何来解决这个“复杂度恶化”的问题呢?</p>
<h4 id="如何优化快速排序"><a href="#如何优化快速排序" class="headerlink" title="如何优化快速排序?"></a>如何优化快速排序?</h4><p>每次分区点都选择最后一个数据,那快速排序算法就会变得非常糟糕,时间复杂度就会退化为 O(n )。实际上,这种 O(n ) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理。<br>最理想的分区点是:被分区点分开的两个分区中,数据的数量差不多。</p>
<ul>
<li>三数取中法<br>我们从区间的首、尾、中间,分别取出一个数,然后对比大小,取这 3 个数的中间值作为分区点。</li>
<li>随机法<br>随机法就是每次从要排序的区间中,随机选择一个元素作为分区点。</li>
</ul>
<p><strong>递归要警惕堆栈溢出。为了避免快速排序里,递归过深而堆栈过小,导致堆栈溢出,我们有两种解决办法:第一种是限制递归深度。一旦递归过深,超过了我们事先设定的阈值,就停止递归。第二种是通过在堆上模拟实现一个函数调用栈,手动模拟递归压栈、出栈的过程,这样就没有了系统栈大小的限制。</strong></p>
<h4 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h4><p>Glibc 中的 qsort() 函数举例</p>
<ul>
<li>qsort() 会优先使用归并排序来排序输入数据</li>
<li>要排序的数据量比较大的时候,qsort() 会改为用快速排序算法来排序。</li>
<li>提到的递归太深会导致堆栈溢出的问题,qsort() 是通过自己实现一个堆上的栈,手动模拟递归来解决的</li>
<li>用到了插入排序。在快速排序的过程中,当要排序的区间中,元素的个数小于等于 4 时,qsort() 就退化为插入排序,不再继续用递归来做快速排序,</li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>实战总结篇，限于本文篇幅可能会过长，该部分参见个人另一篇博客中的具体实战讨论细节<br>传送门：<a href="https://nimbusk.cc/post/faed3d05">极客时间-数据结构与算法-实战篇</a></p>
]]></content>
      <categories>
        <category>极客时间</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>rss订阅测试</title>
    <url>/post/34b1852f.html</url>
    <content><![CDATA[<h3 id="订阅测试"><a href="#订阅测试" class="headerlink" title="订阅测试"></a>订阅测试</h3>]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【半佛】如何躲避投资理财骗局</title>
    <url>/post/d27ded01.html</url>
    <content><![CDATA[<h2 id="原视频地址"><a href="#原视频地址" class="headerlink" title="原视频地址"></a>原视频地址</h2><p><a href="https://www.bilibili.com/video/BV13g4y1676D">https://www.bilibili.com/video/BV13g4y1676D</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在本期核心内容中，半佛老师不是在说如何理财，而是告诫我们合理理财，更好的控制个人的现金流，不要盲目的追求高收益。尤其倾家荡产的去投资，最后可能就是得不偿失！搞的真的就是倾家荡产了。</p>
<h2 id="内容知识点"><a href="#内容知识点" class="headerlink" title="内容知识点"></a>内容知识点</h2><p>“很多话你听着觉得可能是废话，很多整理被传多了都会让人失去敬畏之心”<br>防坑的重点，永远是事前而不是事后</p>
<span id="more"></span>
<h3 id="投资理财的元规则"><a href="#投资理财的元规则" class="headerlink" title="投资理财的元规则"></a>投资理财的元规则</h3><p><strong>用自己用不到的钱来投资</strong><br>这条规则是投资理财行为的底线。通俗的说，不要把过日子的钱都拿来投资。具体来说就是：即便投资过后都亏了，但是不会对你的实际生活产生实质的影响。即：<strong>一笔资金存在明确的指向性用途，则该笔资金不能拿来做投资</strong><br>当风险和收益不对等情况下，一但出现风险，你是没有办法承担这个风险带来的损失的。</p>
<h3 id="投资理财核心三原则"><a href="#投资理财核心三原则" class="headerlink" title="投资理财核心三原则"></a>投资理财核心三原则</h3><p><strong>安全性、流动性、盈利性</strong></p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>安全第一！盈利是最不重要的。<br>结合上一小节投资理财的元规则和本节提到的安全性，则构成了<strong>投资理财最可靠的风险兜底策略</strong>。</p>
<h5 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h5><p>币圈包括各类衍生的区块链投资产品，不建议普通人碰。原因：资金安全得不到任何保障。为什么这么说？</p>
<ul>
<li>你的真金白银换成了别人个人或者<em>非主权国家</em>发行的虚拟货币</li>
<li>整个交易过程都是匿名的<h5 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h5>做投资项目，把钱打到对方的个人账户！<h4 id="流动性"><a href="#流动性" class="headerlink" title="流动性"></a>流动性</h4>流动性指资产变现的能力，例如房产，房产变现能力很差，不能快速变现！<br>注意<strong>投资的可变现能力</strong>，动不动就锁定好几年的产品，要慎重考虑！</li>
</ul>
<p><strong>现金流才是企业的生命，而盈利往往只是脂肪，个人也是如此</strong><br>个人为什么这么说？</p>
<ul>
<li>一来房子不能快速变现，抗风险极差</li>
<li>二来还要还房贷，每个月还在吞噬现金流（严格可以说是负债的）</li>
</ul>
<h4 id="盈利性"><a href="#盈利性" class="headerlink" title="盈利性"></a>盈利性</h4><p>只要资金安全、资金灵活，资金流不会断，赚多赚少不会影响大局。<br>为什么很明显的骗局还能骗到很多人？<br>就是这些人<em>只看到了盈利性</em>，而忘记了安全性和流动性</p>
<h3 id="投资要风险分担"><a href="#投资要风险分担" class="headerlink" title="投资要风险分担"></a>投资要风险分担</h3><p>这个过程不要纠结于单一目标，通俗地说：不要把鸡蛋放到同一个笼子里，容易鸡飞蛋打。<br>把资金分散到不同的<strong>投资标的</strong>是控制风险的有效手段，但问题是：<strong>很多人对风险分散的认知有问题！</strong><br>把不同的资金分散投资到不同的P2P产品，这个不是风险分散！</p>
<h3 id="不要投资自己不懂的产品"><a href="#不要投资自己不懂的产品" class="headerlink" title="不要投资自己不懂的产品"></a>不要投资自己不懂的产品</h3><p>通常投资前的蜜罐关键词：</p>
<ul>
<li>实力雄厚</li>
<li>有人担保</li>
<li>收益率高</li>
<li>高新技术</li>
<li>未来大趋势</li>
</ul>
<p>技术细节呢？<br>概括的说：如果你不知道自己投的东西是什么，是什么原理，反过来当出现风险的时候，你都不知道怎么出现风险的。你怎么保障你的资金安全？<br>什么叫懂了：</p>
<ul>
<li>明确知道产品是怎么运作的</li>
<li>知道是怎么赚钱的</li>
<li>知道是怎么赔钱的<br>完了自己判断这个投资是划算还是不划算</li>
</ul>
<h4 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h4><p>原油宝，问题是有几个人知道：</p>
<ul>
<li>原油期货的交易机制和价格变动</li>
<li>平仓线和保证金机制</li>
</ul>
<h4 id="案例4"><a href="#案例4" class="headerlink" title="案例4"></a>案例4</h4><p>你都没明白区块链和虚拟货币的技术原理，当这类产品“炸了”，你都不知道怎么“炸的”。</p>
<h3 id="投资≠杠杆"><a href="#投资≠杠杆" class="headerlink" title="投资≠杠杆"></a>投资≠杠杆</h3><p>投资就投资，不要加杠杆投资。例如：把信用卡透支出来的钱拿来炒股，搞期货玩大杠杆保证金（抵押车、房）。<br>通俗的说：一分钱非要办十分的事<br>杠杆的同时，虽然可以收到高额的回报，但是同时你也要承担高风险。例如：投资1万元，10倍杠杆，你就能获得10W元，但是与此同时，你只能承担过去十分之一的风险，稍有不慎就是<strong>爆仓</strong>；不配资能够承受100%的价格波动，配资10倍，10%的波动就会玩完，100倍的配资，1%的价格波动就会玩完。</p>
<p><strong>幸存者偏差</strong>：每一个成功的案例之后，都有千千万万个失败的案例。</p>
<h3 id="高回报率不可信"><a href="#高回报率不可信" class="headerlink" title="高回报率不可信"></a>高回报率不可信</h3><p>风险跟收益从来都是对等的。<br>有一部分人内心存在这样一个观点：我知道这个东西是高风险的，但是只要自己跑得快，就能及时脱手。这还是投资游戏么？</p>
<h3 id="不要轻易学专业人士的操作"><a href="#不要轻易学专业人士的操作" class="headerlink" title="不要轻易学专业人士的操作"></a>不要轻易学专业人士的操作</h3><p>专业人士跟普通人的资本、心态、知识储备、操作技术、对损失的态度各有不同。所以不要一昧去跟从学习</p>
<h3 id="没有人靠理财致富"><a href="#没有人靠理财致富" class="headerlink" title="没有人靠理财致富"></a>没有人靠理财致富</h3><p>总结：踏实靠努力和赚钱</p>
<ul>
<li>与其沉迷于投资理财，还不如把时间精力投入到自己的专业领域。</li>
<li>学理财还不如了解一下<strong>资金流管理</strong></li>
</ul>
<h3 id="不犯错比激进更重要"><a href="#不犯错比激进更重要" class="headerlink" title="不犯错比激进更重要"></a>不犯错比激进更重要</h3><p>理财的意义之一：制止盲目亏损，而非一夜暴富<br>对于更多的普通人而言，理财不是博取高收益，而是防止不犯错。<br>什么人适合激进的投资？两个极端：</p>
<ul>
<li>没有钱也没有积累的人</li>
<li>特别有钱的</li>
</ul>
<h3 id="乘着年轻犯错"><a href="#乘着年轻犯错" class="headerlink" title="乘着年轻犯错"></a>乘着年轻犯错</h3><p>乘着年轻，你还有犯错的成本，经历过社会的一顿毒打之后，老老实实的翻盘无偿不可！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>几个要点：</p>
<ul>
<li>克制贪欲</li>
<li>控制风险</li>
<li>分散投资标的</li>
<li>慢慢试错：找到让自己舒适的平衡点<br>毕竟割韭菜第一步：</li>
<li>简单的东西复杂化</li>
<li>清晰的东西模糊化</li>
<li>普通的东西高端化</li>
<li>质朴的东西神秘化</li>
</ul>
<h2 id="关键词解读"><a href="#关键词解读" class="headerlink" title="关键词解读"></a>关键词解读</h2><h3 id="投资标的"><a href="#投资标的" class="headerlink" title="投资标的"></a>投资标的</h3><h3 id="分散投资"><a href="#分散投资" class="headerlink" title="分散投资"></a>分散投资</h3><p><a href="https://en.wikipedia.org/wiki/Rebalancing_investments">https://en.wikipedia.org/wiki/Rebalancing_investments</a></p>
<h3 id="原油期货的交易机制和价格变动"><a href="#原油期货的交易机制和价格变动" class="headerlink" title="原油期货的交易机制和价格变动"></a>原油期货的交易机制和价格变动</h3><h3 id="平仓线"><a href="#平仓线" class="headerlink" title="平仓线"></a>平仓线</h3><h3 id="保证金"><a href="#保证金" class="headerlink" title="保证金"></a>保证金</h3><h3 id="区块链-amp-虚拟货币"><a href="#区块链-amp-虚拟货币" class="headerlink" title="区块链&amp;虚拟货币"></a>区块链&amp;虚拟货币</h3><h3 id="幸存者偏差"><a href="#幸存者偏差" class="headerlink" title="幸存者偏差"></a>幸存者偏差</h3><h3 id="资金流管理"><a href="#资金流管理" class="headerlink" title="资金流管理"></a>资金流管理</h3><h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>RSS订阅测试</p>
]]></content>
      <categories>
        <category>B站</category>
      </categories>
      <tags>
        <tag>硬核的半佛仙人</tag>
        <tag>投资理财</tag>
      </tags>
  </entry>
  <entry>
    <title>VLOG观摩学习</title>
    <url>/post/f890a94d.html</url>
    <content><![CDATA[<h2 id="内容声明"><a href="#内容声明" class="headerlink" title="内容声明"></a>内容声明</h2><ul>
<li>本文分篇章节中会列出相关优秀的UP主的视频主页</li>
<li>学习视频章节会贴出具体视频引用主页</li>
<li>所有视频素材所有权均归各自UP主本身所有，本文仅以学习的态度学习制作技巧等相关，<strong>绝不会借此谋取我个人利益</strong></li>
<li>文章主体是记录关于各个优秀UP主下优秀的VLOG视频，我呢，会对这些视频，尽可能的逐帧去分析，这个在剪辑软件中怎么实现。先勾勒出思考的问题，再有针对性的去自己尝试做一些这些学习的实践内容。<em>当然不排除后期会将这些内容，以视频的方式输出到自己个人B站去</em></li>
<li><strong>涉及版面问题，文章中暂时不会考虑添加视频播放功能！</strong></li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己看VLOG，学剪辑也小有一段时间了，但是都还没有迈出实质性的一步。最主要的原因可能是，自己没有有一个系统的直观认识，换句话说，没有一个适合自己的IDEA！<br>当然其余的，便是自己的后期剪辑技能还没有达到一定水平。<br>写这篇文章的主要目的就一个：<strong>观摩与练习</strong><br>综合当下个人的综合情况分析来看，下面的这个学习思路还算是适合我的：</p>
<span id="more"></span>
<ul>
<li>先不要追求画面的精而美，这个精而美的过程，可能来源于下面几个方面：<ul>
<li>硬件的加持（一台不错的单反和镜头）</li>
<li>好的后期调色</li>
<li>出色的运镜与构图</li>
<li>等等</li>
</ul>
</li>
<li>构建好属于自己的VLOG风格</li>
<li>扎实的剪辑功底<br>后两点则是当下自己比较看中的，更重要的是第二点，思路！思路！思路！画面的精而美是等待好的思路与扎实的剪辑功底，这两项都有一定积累之后，再通过硬解的加持得到进一步的提升。<br>就当下而言，我还是个“小白”，目前投资硬解，暂时还不需要，当然时机还不成熟。<br>故而，写此篇目的主要有二：</li>
<li><strong>夯实剪辑功底：</strong>这部分可能主要围绕Final Cut Pro而展开，观摩<strong>自己喜欢</strong>的VLOG的同时，我会去思考，这块片段，在剪辑的过程中要怎么实现？带着疑问去寻找答案并与之赋予实践</li>
<li><strong>提炼属于自己的VLOG IDEA</strong></li>
</ul>
<p>一切的一切，从模仿做起！<br>我相信功夫不负有心人！<br>加油！</p>
<h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><h3 id="内容排版"><a href="#内容排版" class="headerlink" title="内容排版"></a>内容排版</h3><p>主要观摩的篇章，答题涉及下面几个环节：</p>
<ul>
<li>观后感：写一下大体上的观后感</li>
<li>关键场景解读（含后期）：这部分不管自己知道也好，不知道也罢，对的也好，错的也罢，只要是自己感兴趣的，都会记录下来。当然，我会标出具体时间播放范围的。</li>
<li>实战学习：自己尝试，哪怕最简单的，用自己的手机拍一个场景下来（先不考虑画面构图相关的操作），用同样的方式，看看能不能做出同样效果出来</li>
<li>后期升华：这部分可能就要放很久了，更多的会考虑，构图、运镜啊等等相关的知识</li>
</ul>
<h2 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h2><p>VLOG关注主要来源两个网站：一个B站，一个YouTube。</p>
<ul>
<li><strong>AUXOUT</strong> YouTube主站首页：<a href="https://www.youtube.com/channel/UCUHpXxtOHFBOsrRzovZ0fKA">https://www.youtube.com/channel/UCUHpXxtOHFBOsrRzovZ0fKA</a></li>
<li><strong>小鹿Lawrence</strong> B站首页：<a href="https://space.bilibili.com/37029661">https://space.bilibili.com/37029661</a></li>
</ul>
<h2 id="AUXOUT（A神）"><a href="#AUXOUT（A神）" class="headerlink" title="AUXOUT（A神）"></a>AUXOUT（A神）</h2><h3 id="WITH-YOU-CINEMATIC-VLOG-SHOT-BY-SONY-A7III"><a href="#WITH-YOU-CINEMATIC-VLOG-SHOT-BY-SONY-A7III" class="headerlink" title="WITH YOU | CINEMATIC VLOG SHOT BY SONY A7III"></a>WITH YOU | CINEMATIC VLOG SHOT BY SONY A7III</h3><p><strong>原视频地址：</strong><a href="https://www.youtube.com/watch?v=3KaVUpzGkDw">https://www.youtube.com/watch?v=3KaVUpzGkDw</a></p>
<h4 id="观后感"><a href="#观后感" class="headerlink" title="观后感"></a>观后感</h4><p>这篇VLOG前前后后看了不知道多少遍了，至少总体的风格是自己喜欢的，没有那些频繁的镜头转换。<br>简单说一下这个VLOG的特点，在下一个小节的关键场景解读部分，我会具体说，我是怎么读到的（当然，我的解读可能并不是完全正确！）：</p>
<ul>
<li>精准的踩点</li>
<li>出色的调色（不懂是怎么调出来的，这就是A神的风格）</li>
<li>百看不腻的升格画面（有网友戏称A神是“升格怪”，233333）</li>
<li>全程16:9画面</li>
</ul>
<p>调色这块先不说技术细节，我这会儿还不懂，整体上偏绿偏暗一点？总之我喜欢就是了。<br>画面上，全长4分钟左右的VLOG，主要有下面几个场景：</p>
<ul>
<li>无人机的长镜头</li>
<li>人物的近景升格画面（女主的多一点）</li>
</ul>
<p>开篇淡入长镜头，开局大气。<br>人物，特别是女主，A神大部分的构图都是女主居中的。<br>升格就更不用说了，特别是部分拍女主的镜头，看下来，一个字：美！<br>画面切换：由于踩点精准，所以瞬间切过去，我是没有感到什么突兀。没有踩点的，A神是用淡入淡出过度的。<br>具体的，进入下一节，看看自己注意到了哪些感兴趣的细节~~</p>
<h4 id="关键场景解读"><a href="#关键场景解读" class="headerlink" title="关键场景解读"></a>关键场景解读</h4><h5 id="踩点"><a href="#踩点" class="headerlink" title="踩点"></a>踩点</h5><p>A神的踩点简直了，精准到自己都叹息了！<br>就拿一个场景说一下，连BGM的回响都踩准了。<br>在02:07-02:11秒之间，BGM副歌的几声wu…wu…wu…，都踩的很准，具体可以看一下下面的GIF片段。<br><img data-src="f890a94d/with_you_1.gif" alt="踩点场景1"></p>
<h5 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h5><p>开头和结尾，以及中间几个大的场景切换，都是通过淡入淡出过度的。例如：</p>
<ul>
<li>开篇~06秒：开篇淡入，引出主题，背景是一个大的长镜头</li>
<li>12秒左右，淡入进入VLOG主题，第一篇章节</li>
<li></li>
</ul>
<h4 id="实战学习"><a href="#实战学习" class="headerlink" title="实战学习"></a>实战学习</h4><h4 id="后期升华"><a href="#后期升华" class="headerlink" title="后期升华"></a>后期升华</h4><h2 id="小鹿Lawrence"><a href="#小鹿Lawrence" class="headerlink" title="小鹿Lawrence"></a>小鹿Lawrence</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2>]]></content>
      <categories>
        <category>影视后期</category>
      </categories>
      <tags>
        <tag>VLOG</tag>
        <tag>AUXOUT</tag>
        <tag>小鹿Lawrence</tag>
      </tags>
  </entry>
  <entry>
    <title>Adobe Audition不完整教程</title>
    <url>/post/7a4fe646.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="认识AU的历史"><a href="#认识AU的历史" class="headerlink" title="认识AU的历史"></a>认识AU的历史</h4><p>今年早些时候，入手了《Adobe Audition CC经典教程》这本书，打算系统的补充一下AU相关的知识。<br>认识AU不短，早在自己高二时代（距今11年了），就认识了，那时候还是3.0时代。那时候记得托付兄长在亚马逊（当时还是卓越）上买过教程书籍。<br>但是，由于那时候环境条件有限，没有办法延展开来学习。<br>直到上大学，有了自己个人的笔记本，那时候才算是弄了起来。<br>早在大一的时候，那时候还加入了学生会，哈哈哈。记得非常清楚，大一的迎新晚会，我是作为后台的音效师角色，负责整场晚会的前期音频、音效素材的收集，晚会现场后台音频的播放控制相关。也算是得益于早年很早接触AU相关后的一次实战吧。</p>
<span id="more"></span>
<h4 id="现在认识的AU"><a href="#现在认识的AU" class="headerlink" title="现在认识的AU"></a>现在认识的AU</h4><p>工作这么多年了，现在日常生活中，着实对VLOG感兴趣，也入手了MAC，也有FinalCutPro这样优秀的视频剪辑工具有过了解。Windows平台的嘛，自然Adobe全家桶（Emm，我买不起正版，所以~你懂得）。<br>其中一个AU，也想重新拾起来，再系统的看看处理的细节相关，特别是一些特效啊，一些控制曲线啊什么的，都巩固一下吧。以前确实没有系统的学。<br>总体上，也算是多丰富一下个人的技能吧，也相信在日后自己做VLOG的时候，多少会用到一点。</p>
<p>正文开始~</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>受各平台硬件环境因素相关，本文中处理相关时效均为个人WindowsPC工作环境下所得，详细环境如下：</p>
<ul>
<li>Au版本：Adobe Audition CC 2020(内部版本：13.0.0.519)<br><img data-src="7a4fe646/audition_version.jpg" alt="Audition版本号"></li>
<li>Windows 10 Professional（版本：10.0.18363.778）</li>
<li>CPU：Intel i9-9900ks</li>
<li>内存：32GB</li>
</ul>
<h3 id="教程相关"><a href="#教程相关" class="headerlink" title="教程相关"></a>教程相关</h3><p>本章主要记录《Adobe Audition CC经典教程》这本书中记录的相关知识点，供后续自己查阅所用。<br>文中部分片段，是个人心得体会的，会加一个“注：”标记。</p>
<h3 id="Audition操作环境"><a href="#Audition操作环境" class="headerlink" title="Audition操作环境"></a>Audition操作环境</h3><h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><h5 id="媒体浏览器导航"><a href="#媒体浏览器导航" class="headerlink" title="媒体浏览器导航"></a>媒体浏览器导航</h5><ul>
<li>在选中“媒体浏览器”面板之后，可以通过按<strong>英文的重音符号“`”快速最大化或者最小化窗口</strong>，以方便查看详细的媒体资源信息。</li>
<li>可以通过添加快捷键，快速打开资源文件夹：<br><img data-src="7a4fe646/resource_control_pannel_add_shortcuts.jpg" alt="在媒体浏览器中添加文件夹快捷键"></li>
<li>“预览传输”可以快速预览资源文件<br>“媒体浏览器”面板右侧下拉菜单中，有这个选项。复选之后在下方的面板有个小喇叭，单击开启后，每次点“媒体浏览器”中的音频资源后，会自动播放，从而达到快速浏览的目的。如下图所示：<br><img data-src="7a4fe646/resource_control_pannel_preview_switch.jpg" alt="预览传输开关"><br>下拉菜单中还有其它几个选项</li>
</ul>
<p><em>循环播放</em>，就是预览的时候要不要循环播放。<br><em>自动播放</em>，预览的时候是否自动播放<br><img data-src="7a4fe646/resource_control_pannel_enable_preview.jpg" alt="启用后的预览传输状态"></p>
<h5 id="使用标记导航"><a href="#使用标记导航" class="headerlink" title="使用标记导航"></a>使用标记导航</h5><p>位置：“窗口-&gt;标记”面板<br>通过选取指定音轨/指定范围时间下添加标记。达到快速导航的目的<br><img data-src="7a4fe646/AutoCapture_2020-05-04_001346.jpg" alt="标记面板"></p>
<h5 id="使用传输导航"><a href="#使用传输导航" class="headerlink" title="使用传输导航"></a>使用传输导航</h5><p>位置：“窗口-&gt;传输”面板<br>与标记同时使用，配合传输的快捷键，可以快速切换标记点。<br><img data-src="7a4fe646/AutoCapture_2020-05-04_001640.jpg" alt="传输面板"><br><img data-src="7a4fe646/transfer_mark.gif" alt="传输快速切换标记"><br>快捷键：ALT + 左右方向键（Windows平台）</p>
<h3 id="编辑基础"><a href="#编辑基础" class="headerlink" title="编辑基础"></a>编辑基础</h3><p>使用Audition可以轻松地对音频文件进行剪切、复制、修饰、淡化以及其它操作。也可以放大音频文件进行精细化处理，与此同时还可以从顶部的总览窗口看到音频文件的全貌。</p>
<h4 id="选择一个区域改变其电平"><a href="#选择一个区域改变其电平" class="headerlink" title="选择一个区域改变其电平"></a>选择一个区域改变其电平</h4><p>先来看一个demo截图：<br><img data-src="7a4fe646/AutoCapture_2020-05-04_002833.jpg" alt="示例demo截图"><br>从上面截图中红色方框圈起来的这部分音频，明显音量要弱一点（音量大小，直观的可以从波形的宽幅体现）<br>此时我们鼠标左键选中这部分音频后，就像下图所示：<br><img data-src="7a4fe646/AutoCapture_2020-05-04_003156.jpg" alt="选择音频片段"><br>注意图中，多出来一个小Tip窗口，这个窗口叫：<strong>平视显示器（HUD）</strong>，可以通过视图菜单下的“显示HUD”或者快捷键：${label primary@Shift + U%}，来控制这个显示器的显示与否<br><strong>紧接着，可以通过在HUB窗口中的旋钮或者音量波形，旋动来改变音量大小</strong></p>
<h3 id="剪切过程"><a href="#剪切过程" class="headerlink" title="剪切过程"></a>剪切过程</h3><p>在定义一段波形的时候，如果截取的边界其电平值不是0，则在播放时可能引起卡塔声。如下图所示。<br><img data-src="7a4fe646/over_past_zero.jpg" alt="过零场景"><br>如果边界恰好穿过零点，即波形的电平值由正到负或者由负到正的位置。这种情况下没有明显的电平变化，所以不会有明显的咔嗒声。就像这样：<br><img data-src="7a4fe646/AutoCapture_2020-05-04_095830.jpg" alt="不过零场景"><br><strong>在AU中，“编辑-&gt;过零”菜单，可以让AU自动选择优化区域边界</strong></p>
<h4 id="多剪贴板应用"><a href="#多剪贴板应用" class="headerlink" title="多剪贴板应用"></a>多剪贴板应用</h4><p>在AU中可以通过设置当前剪贴板，来实现同时剪贴多段文件的应用。<br><img data-src="7a4fe646/AutoCapture_2020-05-04_103244.jpg" alt="多剪贴板菜单"></p>
<h4 id="延长或缩短音乐选取"><a href="#延长或缩短音乐选取" class="headerlink" title="延长或缩短音乐选取"></a>延长或缩短音乐选取</h4><h5 id="对齐功能"><a href="#对齐功能" class="headerlink" title="对齐功能"></a>对齐功能</h5><p>在菜单“编辑-&gt;对齐”下，有几个选项，这个对齐的主要功能是：<em>使得在选择相邻标记间的音频时，标记具有模拟“磁场”的吸附功能，把靠近标记的选区边界直接吸附到标记处</em>。<br>菜单如下所示：<br><img data-src="7a4fe646/AutoCapture_2020-05-04_103840.jpg" alt="对齐菜单"><br>默认情况下都是开启的，至少得：开启对齐功能和“对齐到标记”这两项，才会出现吸附的效果。具体演示如下图所示：<br><img data-src="7a4fe646/adsorption.gif" alt="吸附效果演示"></p>
<h4 id="混合粘贴"><a href="#混合粘贴" class="headerlink" title="混合粘贴"></a>混合粘贴</h4><p>有时候我们需要在当前音轨粘贴外部的音频文件，此时就要用到混合粘贴的场景。<br>在复制好一段音频之后，回到待处理的音频界面，通过打开菜单：“编辑&gt;混合粘贴”（快捷键：Ctrl+Shift+V）,打开混合粘贴对话框。<br><img data-src="7a4fe646/AutoCapture_2020-05-04_105540.jpg" alt="混合粘贴对话框"><br><strong>注意</strong>，在这张图中，是要从标记02处插入复制的音频片段。<br>在混合粘贴对话框中：</p>
<ul>
<li>音量区域，可以设置针对剪贴板中的音频和现有的音频音量选项</li>
<li>粘贴类型，则是针对当前剪贴板中的音频片段不同的处理选项<ul>
<li>插入就是在当前选择处插入</li>
<li>重叠（混合）：在当前选择处，以相同的剪贴板长度混合覆盖当前音频（注：你可以理解为多轨混缩）。</li>
<li>覆盖：就是以相同的长度替换原有音频</li>
<li>调制：使复制的音频改变现有的音频的波形，同时还将两个文件混合。（注：老实讲，还不知道这个有什么用，盲猜可能在一些高级的音频效果中可能会用到）</li>
</ul>
</li>
</ul>
<p><img data-src="7a4fe646/AutoCapture_2020-05-04_105643.jpg" alt="插入后的音频图"><br><img data-src="7a4fe646/AutoCapture_2020-05-04_110847.jpg" alt="重叠（混合）后的音频图"><br><img data-src="7a4fe646/AutoCapture_2020-05-04_110904.jpg" alt="覆盖后的音频图"><br><img data-src="7a4fe646/AutoCapture_2020-05-04_110913.jpg" alt="调制后的音频图"><br>从上面几个操作后的音频图来看，覆盖跟调制很像，但是实际调制的过程比覆盖要跟复杂一点。“调和”过了，而不是单单的覆盖。<br>在教程中，同样提到了：<br>调整复制音频与现有音频的混合，是为了避免失真。如果视图将两个音频都以100%或者最大音量混合，必须将每一个音频音量降低至少50%来避免失真，否则混合后的电平将超出可用的最大限值。</p>
<h4 id="重复波形的一部分创建一个循环乐段"><a href="#重复波形的一部分创建一个循环乐段" class="headerlink" title="重复波形的一部分创建一个循环乐段"></a>重复波形的一部分创建一个循环乐段</h4><p>许多时候，很多音乐元素都是重复的。循环乐段是一段自身不断重复的乐曲，如鼓节奏等等。<br>在选取创建循环乐段前，为了方便听取，可以打开传输面板中的“循环播放”按钮，快捷键：Ctrl+L（Loop）<br><img data-src="7a4fe646/AutoCapture_2020-05-04_111824.jpg" alt="传输面板中的循环播放按钮"><br>开启后，你就可以选取你想要循环的片段。<br>选取好之后，你可以通过：</p>
<ul>
<li>“编辑&gt;复制到新文件”，快捷键：Ctrl+Alt+C(Shift + Option + C)，来将选区的片段复制到新的编辑器中</li>
<li>“编辑&gt;另存为”，直接将选区片段另存为文件</li>
<li>也可以通过“文件&gt;将选区保存为”，可以立刻将选区保存在独立文件到本地磁盘上</li>
</ul>
<h4 id="淡入淡出效果"><a href="#淡入淡出效果" class="headerlink" title="淡入淡出效果"></a>淡入淡出效果</h4><p>在主编辑区的左右上角，分别有一个小三角的图片，这俩图标分别控制音频的淡入淡出效果。如下图所示：<br><img data-src="7a4fe646/AutoCapture_2020-05-04_113013.jpg" alt="淡入操作按钮"><br>通过拖动改按钮可以改变当前音频的淡入，淡出实现。</p>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>在信号处理器中，可以有很多种方法使得音频更为“平滑”：音道均衡，动态调整，添加环绕或者特殊效果等。<br>注：这一章内容中，具体探索多种效果器的实践。是个重点。更多的可能是需要积累不同效果的直观的感受吧，从理论上可能，如果不寻找一些专业资料，可能是搞不懂具体的效果实际能带来感受是什么。最直接的，还是感受。</p>
<h4 id="使用效果组"><a href="#使用效果组" class="headerlink" title="使用效果组"></a>使用效果组</h4><p>效果组允许创建一个效果链，可以加载多达16种效果。</p>
<h5 id="增益配置（Gain-staging）效果"><a href="#增益配置（Gain-staging）效果" class="headerlink" title="增益配置（Gain-staging）效果"></a>增益配置（Gain-staging）效果</h5><p>有时候，串联多个效果会导致某种程度的频率“叠加”，可能使得电平值超过允许限值。例如，强化中频的滤波器可能使得电平超出可用的范围而导致失真。<br>如下图所示，就是打开了“参数均衡器效果”，并配置了图中，标记为3的小方块，拖动到顶端之后，也就是中频增益拉到最大后导致的输出失真。<br>失真的一个直观表现是：在效果组的“输出”仪表的红色过载指示灯会一直闪亮。<br><img data-src="7a4fe646/distortion.gif" alt="配置参数均衡器后的失真场景"><br>解决方法：</p>
<ul>
<li>调整主动增益的范围</li>
<li>降低“输入”电平，直到波形的极大值不再触发红色失真指示灯。</li>
</ul>
<h5 id="调整效果的干声-湿声混合"><a href="#调整效果的干声-湿声混合" class="headerlink" title="调整效果的干声/湿声混合"></a>调整效果的干声/湿声混合</h5><p>未经处理的信号为“干声”，添加效果的信号为“湿声”。相对于单纯的“干声”信号或者“湿声”信号，跟多的时候是两者的混合。<br>上一个小节中提到的两种处理失真信号的方法，这里也可以通过调整干/湿声信号的比重来减弱效果的输出。如下图所示：<br><img data-src="7a4fe646/AutoCapture_2020-05-04_150708.jpg" alt="效果组中的混合控制条"></p>
<h3 id="振幅与压限效果"><a href="#振幅与压限效果" class="headerlink" title="振幅与压限效果"></a>振幅与压限效果</h3><p>振幅与压限效果可以改变电平或调整动态。</p>
<h4 id="增幅"><a href="#增幅" class="headerlink" title="增幅"></a>增幅</h4><p>“增幅”使声音更响亮或更柔和。要通过增加振幅的方式使音频声音变得更大，那么需要选择一个<strong>较低放大率</strong>，低到是的文件保持不失真。<br>“增幅”菜单：效果组中的“振幅与压限&gt;增幅”，如下图所示：<br><img data-src="7a4fe646/AutoCapture_2020-05-04_151301.jpg" alt="增幅调制窗口"><br>其中“链接滑块”勾选与否，表示是否需要同时改变左右声道的增益，如果不勾选则可以针对左右声道单独调整，反之则是同时变动。</p>
<h5 id="声道混合器"><a href="#声道混合器" class="headerlink" title="声道混合器"></a>声道混合器</h5><p>“声道混合器”调整左声道与右声道信号在左右声道的播放量。可用于立体声到单声道的转换，以及对调左右声道的信号。<br>“声道混合器”菜单：“振幅与压限&gt;声道混合器”<br><img data-src="7a4fe646/AutoCapture_2020-05-04_152834.jpg" alt="配置左声道输出为0，转变为右单声道"><br>在配置中的一个预设：所有声道50%，这是一个将立体声声道转化为单声道的操作。如下图所示：<br><img data-src="7a4fe646/AutoCapture_2020-05-04_153745.jpg" alt="立体声转单声道"><br>注：在课程中的这个demo：Drum+Bass+Arp110.wav中，很难听出有什么具体实质性的变化。但是可以从下面两个细节观察一下</p>
<ul>
<li>先观察一下原始音频<br><img data-src="7a4fe646/AutoCapture_2020-05-04_153836.jpg" alt="立体声音频"><br>左右声道是不同的</li>
<li>当我们通过声道混合器设置所有都50%之后，看一下效果组中“输出”电平，变得一致了，这点也能很明显看出来变成单声道了。看下面两段GIF，设置前后的变化就能看出<br><img data-src="7a4fe646/channel_mixed_before.gif" alt="转换前"><br><img data-src="7a4fe646/channel_mixed_after.gif" alt="转换后"><br>从转换后的“输入”与“输出”两个电平也能直接看出来变化</li>
</ul>
<h4 id="消除齿音（DeEsser）"><a href="#消除齿音（DeEsser）" class="headerlink" title="消除齿音（DeEsser）"></a>消除齿音（DeEsser）</h4><p>消除齿音由三个步骤构成：确定齿音存在的频率，定义范围，然后设定一个阈值，如果齿音超过了阈值，则会自动降低其增益到指定的范围内。使得齿音变得不那么冲突</p>
<h5 id="什么是齿音？"><a href="#什么是齿音？" class="headerlink" title="什么是齿音？"></a>什么是齿音？</h5><p>在英语中，例如: “s”, “z”, “ch”, “j” 和 “sh”这些发音<sup>[1]</sup>，汉语拼音中，例如：zhi、chi、hi、zi、ci、iquo这些发音。这些发音多半会经过舌尖在上门牙和下门牙之间。这些音频的介于2-10kHz不等，取决于个人语音程度。<br>而在一段音频中，频繁出现这类音，尤其是在使用耳塞或者耳机时，会干扰经过调制的令人愉悦的音频，进而影响整个收听的感受。<br>那么消除齿音，就是通过某种方法，动态的去解析并最大化消除<strong>过度出现的齿音</strong></p>
<p>“消除齿音” 菜单：“振幅与压限&gt;消除齿音”<br>如下图所示：在这段音频的播放过程中，发现最高峰值达到了-10db（10kHz）左右。这个就表明了，这段音频中，齿音还是很高的。<br><img data-src="7a4fe646/AutoCapture_2020-05-04_161645.jpg" alt="峰值齿音效果"><br>在这个过程中，可以通过降低“阈值”、改变“带宽”后，微调“中置频率”来达到“消除齿音”的效果<br>注：在实际操作的时候，可能是由于提供的范例并不能完整体现消除齿音后，有多少效果。老实说：我并没有听出来有多少变化。</p>
<h4 id="动态处理"><a href="#动态处理" class="headerlink" title="动态处理"></a>动态处理</h4><p>对于一个标准的放大器，其输入与输出之间的关系是线性的。如果增益是1，则输出信号与输入信号相同。如果增益为2，则输出信号的电平是输入信号电平的两倍，无论输入信号电平是多大。<br><strong>动态处理</strong>效果就是改变输入输出的线性关系。</p>
<h5 id="压限与扩展的概念"><a href="#压限与扩展的概念" class="headerlink" title="压限与扩展的概念"></a>压限与扩展的概念</h5><p>当输入信号的大幅增加转换为输出信号的小幅增加时，这种变化称为“压限”<br>当输入信号的小幅增加转换为输出信号的大幅增加时，这种变为称为“扩展”。<br>两种模式可以同时存在，可以在一个电平区间内扩展信号，在另一个电平区间内压缩信号。<br>压限器使人们主观上感觉声音更加突出；扩展器用的倒不是很普遍，主要用于放大令人厌恶的低电平信号（如嘶嘶声），进一步降低其电平值。</p>
<p>示例中的一个设置，主要是突出音频中的鼓声听起来，更加有力量，如下图所示：<br><img data-src="7a4fe646/AutoCapture_2020-05-04_164224.jpg" alt="动态处理过程"><br>注：这个处理过程，很复杂，现在也就是听个响，大概知道是怎么回事。具体能搞出什么花样，得慢慢实践。</p>
<h4 id="单段压限器"><a href="#单段压限器" class="headerlink" title="单段压限器"></a>单段压限器</h4><p>“单段压限器”是一个用于动态区域压缩的“经典”压限器，可用于了解压限器的工作流程。<br>压限器改变输出信号与输入信号之间的关系。两个最重要的参数是“阈值”（电平高于此值压限器开始工作）和“比例”（用于设置输出信号变化与输入信号变化的关系）。例如：比例为4:1时，4dB的输入增幅产生1dB的输出增幅。<br>“单段压限器”菜单：“振幅与压限&gt;单频段压限器”<br>注：太菜，没啥好电平的，找一段音频素材，完了挨个预设效果体验一哈便是。但是有一个效果，表示还真体验到一个场景，预设中的“画外音”，很明显录旁白的时候，如果需要用到BGM，是可以这么做的。</p>
<h4 id="电子管压限器"><a href="#电子管压限器" class="headerlink" title="电子管压限器"></a>电子管压限器</h4><p>跟单段类似</p>
<h4 id="多段压限器"><a href="#多段压限器" class="headerlink" title="多段压限器"></a>多段压限器</h4><p>“多段压限器”是对单段的一个扩充，将频谱分为四段，每一段都有自己的压限器。因此，可以实现对不同的部分进行不同程度的压缩，例如对低频部分视角较多的压缩，而对中频上半段仅施加适量的压缩。<br>注：整体配置比较复杂，但是，每段的限制器都提供了S（独奏）的按钮。可以在实践的时候，通过改变预设完了只独奏一段，来体会不同预设之间的差距。<br>如下面两端GIF所示：一个是默认预设（图中显示成自定义了），另外一种是广播的预设。<br><img data-src="7a4fe646/muti_compassor_default.gif" alt="多段压限器示例_默认预设"><br><img data-src="7a4fe646/muti_compassor_radio.gif" alt="多段压限器示例_广播预设"><br>都同时只独奏了低音段的压限器，<strong>很明显能感觉到，广播预设在低音这块的增益要比默认强，最明显的感觉就是在广播预设下的低音区，输出要更底，更沉</strong><br>具体的，必须上手去体验一把就能感受到了</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><img data-src="7a4fe646/1.gif" alt="测试GIF"></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1] De-essing:[EB/OL]. 2020. <a href="https://en.wikipedia.org/wiki/De-essing">https://en.wikipedia.org/wiki/De-essing</a></p>
]]></content>
      <categories>
        <category>影视后期</category>
      </categories>
      <tags>
        <tag>音频剪辑</tag>
        <tag>剪辑工具</tag>
      </tags>
  </entry>
  <entry>
    <title>B站-半佛仙人-谁才是手机圈里最扫的钢铁直男</title>
    <url>/post/667d5e1a.html</url>
    <content><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ul>
<li>视频上传日期：2020-04-17 18:26:51</li>
<li>视频地址：<a href="https://www.bilibili.com/video/BV1jK411j7dV">【半佛】谁才是手机圈里最骚的钢铁直男</a><br>本期半佛老师主要针对手机厂商：一加，作为切入点，说了一堆，emmm。。<br>前排不排除有“软广硬恰”的嫌疑。。。<span id="more"></span>

</li>
</ul>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p>本篇笔记完全记录一下视频中所陈述的观点，先不讨论其它与否。</p>
<h4 id="导图全图"><a href="#导图全图" class="headerlink" title="导图全图"></a>导图全图</h4><p><img data-src="667d5e1a/%E6%9C%8B%E5%85%8B%E6%89%8B%E6%9C%BA%E4%B8%8D%E9%9C%80%E8%A6%81%E9%A5%AD%E5%9C%88%E6%96%87%E5%8C%96.jpg" alt="朋克手机不需要饭圈文化"></p>
<h4 id="思维导图附件"><a href="#思维导图附件" class="headerlink" title="思维导图附件"></a>思维导图附件</h4><p>基于视频整理<br>[XMind附件下载](667d5e1a/朋克手机不需要饭圈文化（by 半佛仙人）.xmind)</p>
<h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><h4 id="什么是“饭圈”？"><a href="#什么是“饭圈”？" class="headerlink" title="什么是“饭圈”？"></a>什么是“饭圈”？</h4><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3>]]></content>
      <categories>
        <category>B站</category>
      </categories>
      <tags>
        <tag>硬核的半佛仙人</tag>
        <tag>一加</tag>
        <tag>手机饭圈</tag>
      </tags>
  </entry>
  <entry>
    <title>B站-半佛仙人-MCN商业合同篇</title>
    <url>/post/e3d04027.html</url>
    <content><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>记录源自B站半佛仙人 VOL.33期，半佛老师本期主要内容介绍了：</p>
<ul>
<li>UP主签约MCN遇到的坑</li>
<li>如何避免必要的坑（注意事项）</li>
</ul>
<p><strong>不做好笔记的观众不是好观众，喵~</strong></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="什么是MCN"><a href="#什么是MCN" class="headerlink" title="什么是MCN"></a>什么是MCN</h4><p>摘录来自Wikipedia的解释：<a href="https://en.wikipedia.org/wiki/Multi-channel_network">原文地址</a></p>
<blockquote class="blockquote-center">
<p>A multi-channel network (MCN) is an organization that works with video platforms to offer assistance to a channel owner in areas such as “product, programming, funding, cross-promotion, partner management, digital rights management, monetization/sales, and/or audience development” in exchange for a percentage of the ad revenue from the channel.</p>

</blockquote>

<p>这段概括很精髓形容了MCN是啥，当中有几个关键词，我摘录如下：</p>
<ul>
<li>an organization</li>
<li>offer assistance to</li>
<li>exchange for</li>
<li>the ad revenue</li>
</ul>
<span id="more"></span>

<p>从上述关键词中，提炼一下：经纪公司？</p>
<h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>起源于油管(YouTube)，最早在14年很多公司用不同的名字注册了不同的频道，进而形成了官方频道。</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>我的概括是：帮你做你做不了的事情，例如：流量、版权著作保护等。可以看一下wiki里面的描述：<br><a href="https://en.wikipedia.org/wiki/Multi-channel_network#Purpose">Multi-channel_network#Purpose</a></p>
<h3 id="半佛老师视频文稿"><a href="#半佛老师视频文稿" class="headerlink" title="半佛老师视频文稿"></a>半佛老师视频文稿</h3><p>先上截图：<br><img data-src="e3d04027/mcn_xmind.jpg" alt="xmind截图"><br>文稿基于半佛老师视频截图，加上部分个人格式上的整理而出，添加了一些剪切画，如：数字序号等<br><a href="e3d04027/MCN%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97.jpg">文稿全图</a><br><a href="e3d04027/MCN%E9%97%AD%E5%9D%91%E6%8C%87%E5%8D%97.xmind">XMind附件下载</a><br><a href="e3d04027/MCN%E9%97%AD%E5%9D%91%E6%8C%87%E5%8D%97.mmap">Mindmanager版本下载</a><br>Mindmanager在线预览图</p>
<h3 id="视频个人解读"><a href="#视频个人解读" class="headerlink" title="视频个人解读"></a>视频个人解读</h3><p>啊，里面有很多法律、合同相关的知识，表示啊，确实没怎么太看懂。很多硬核的内容</p>
]]></content>
      <categories>
        <category>B站</category>
      </categories>
      <tags>
        <tag>硬核的半佛仙人</tag>
        <tag>MCN</tag>
        <tag>商业合同</tag>
        <tag>互联网B面</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间-设计模式</title>
    <url>/post/f7ba4a56.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>你要问我设计模式是干嘛的？我的总结就是：构建“大厦”的一套成熟的经验理论，是一套成熟的构建理论。<br>本篇文章记录，在极客时间课程学习之下的一些纪实与感悟，记录学习的过程。为日后复习、查询所用。<br>文章纪实部分代码片段来自课程文稿。</p>
<h3 id="课程纪实"><a href="#课程纪实" class="headerlink" title="课程纪实"></a>课程纪实</h3><p>原课程链接：<a href="https://time.geekbang.org/column/article/179607">https://time.geekbang.org/column/article/179607</a></p>
<h4 id="学习导读"><a href="#学习导读" class="headerlink" title="学习导读"></a>学习导读</h4><span id="more"></span>
<h4 id="设计原则与思想：面向对象"><a href="#设计原则与思想：面向对象" class="headerlink" title="设计原则与思想：面向对象"></a>设计原则与思想：面向对象</h4><h4 id="设计原则与思想：设计原则"><a href="#设计原则与思想：设计原则" class="headerlink" title="设计原则与思想：设计原则"></a>设计原则与思想：设计原则</h4><h5 id="21-重复的代码就一定违背DRY吗？如何提高代码的复用性？"><a href="#21-重复的代码就一定违背DRY吗？如何提高代码的复用性？" class="headerlink" title="21.重复的代码就一定违背DRY吗？如何提高代码的复用性？"></a>21.重复的代码就一定违背DRY吗？如何提高代码的复用性？</h5><p><strong>DRY原则</strong>（Don’t Repeat Yourself）</p>
<h6 id="实现逻辑重复"><a href="#实现逻辑重复" class="headerlink" title="实现逻辑重复"></a>实现逻辑重复</h6><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAuthenticator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">authenticate</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsername(username)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 看起来和下面的isValidPassword实现很类似！</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> username.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> username.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) || c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> password.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> password.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) || c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。<br>尽管代码实现逻辑是相同的，但是语义不同，我们判定它并不违反<strong>DRY原则</strong>。</p>
<h6 id="功能语义重复"><a href="#功能语义重复" class="headerlink" title="功能语义重复"></a>功能语义重复</h6><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidIp</span><span class="params">(String ipAddress)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkIfIpValid</span><span class="params">(String ipAddress)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  String[] ipUnits = StringUtils.split(ipAddress, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> ipUnitIntValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子跟上个例子正好相反。上一个例子是代码实现逻辑重复，但语义不重复，我们并不认为它违反了 DRY 原则。而在这个例子中，尽管两段代码的实现逻辑不重复，<strong>但语义重复</strong>，也就是功能重复，我们认为它违反了 DRY 原则</p>
<h6 id="代码执行重复"><a href="#代码执行重复" class="headerlink" title="代码执行重复"></a>代码执行重复</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">existed</span> <span class="operator">=</span> userRepo.checkIfUserExisted(email, password); <span class="comment">// 这里会操作一下</span></span><br><span class="line">    <span class="keyword">if</span> (!existed) &#123;</span><br><span class="line">      <span class="comment">// ... throw AuthenticationFailureException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepo.getUserByEmail(email); <span class="comment">// 这里又执行了一下</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkIfUserExisted</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidEmailException...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...query db to check if email&amp;password exists...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidEmailException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...query db to get user by email...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重构后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidEmailException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || !password.equals(user.getPassword()) &#123;</span><br><span class="line">      <span class="comment">// ... throw AuthenticationFailureException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkIfUserExisted</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//...query db to check if email&amp;password exists</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getUserByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="comment">//...query db to get user by email...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="代码复用性（Code-Reusability）"><a href="#代码复用性（Code-Reusability）" class="headerlink" title="代码复用性（Code Reusability）"></a>代码复用性（Code Reusability）</h6><p>有三个概念：代码复用性（Code Reusability）、代码复用（Code Resue）和 DRY 原则。<br><strong>“不重复”并不代表“可复用”</strong><br><strong>“复用”和“可复用性”关注角度不同</strong>：代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。</p>
<h6 id="怎么提高代码复用性？"><a href="#怎么提高代码复用性？" class="headerlink" title="怎么提高代码复用性？"></a>怎么提高代码复用性？</h6><ul>
<li>减少代码耦合</li>
<li>满足单一直责原则</li>
<li>模块化</li>
<li>业务与非业务逻辑分离</li>
<li>通用代码下沉</li>
<li>继承、多态、抽象、封装</li>
<li>应用模板等设计模式</li>
</ul>
<h4 id="设计原则与思想：规范与重构"><a href="#设计原则与思想：规范与重构" class="headerlink" title="设计原则与思想：规范与重构"></a>设计原则与思想：规范与重构</h4><h4 id="设计原则与思想：总结课"><a href="#设计原则与思想：总结课" class="headerlink" title="设计原则与思想：总结课"></a>设计原则与思想：总结课</h4><h4 id="设计模式与范式：创建型"><a href="#设计模式与范式：创建型" class="headerlink" title="设计模式与范式：创建型"></a>设计模式与范式：创建型</h4><h4 id="设计模式与范式：结构型"><a href="#设计模式与范式：结构型" class="headerlink" title="设计模式与范式：结构型"></a>设计模式与范式：结构型</h4><h4 id="设计模式与范式：行为型"><a href="#设计模式与范式：行为型" class="headerlink" title="设计模式与范式：行为型"></a>设计模式与范式：行为型</h4><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3>]]></content>
      <categories>
        <category>极客时间</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>finalcutprox教程实录</title>
    <url>/post/8218752b.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>视频剪辑向来都是个人兴趣所向，Mac平台有一个非常不错的视频剪辑工具，Final Cut Pro X。<br>藉由此，本篇文章记录一下所有的Final Cut Pro X 学习经历</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文第三小节，教程实录均来自B站UP主<a href="https://space.bilibili.com/72350590?spm_id_from=333.788.b_765f7570696e666f.2">十年怎么走</a>所发教程合集（合集链接文末引用已经贴出）<br>不会记录教程中所涉及的诸多细节，只是整体上记录某一块功能有什么用。等实际用到时候，需要针对性学习的时候，再去UP的相应视频中详细看一下即可。<br>感谢这位UP主所发。</p>
<h3 id="教程集合"><a href="#教程集合" class="headerlink" title="教程集合"></a>教程集合</h3><h4 id="B站“放牛班乌托邦”"><a href="#B站“放牛班乌托邦”" class="headerlink" title="B站“放牛班乌托邦”"></a>B站“放牛班乌托邦”</h4><p>这个系列视频，供快速了解，本身比较粗放的。</p>
<h5 id="剪辑概念、意识和基础知识"><a href="#剪辑概念、意识和基础知识" class="headerlink" title="剪辑概念、意识和基础知识"></a>剪辑概念、意识和基础知识</h5><p>通常情况下：</p>
<ul>
<li>从“素材管理窗口”开始工作，对素材进行整理，归纳和筛选</li>
<li>整理好的素材，依次拖到“时间线窗口”的轨道上</li>
<li>在“时间线窗口”对素材片段进行编辑，即选取、剔除与合并</li>
<li>通过“效果和转场管理窗口”，为时间线上的片段施加效果和转场</li>
<li>工作完成，导出时间线上已经完成的作品</li>
</ul>
<h5 id="粗剪阶段"><a href="#粗剪阶段" class="headerlink" title="粗剪阶段"></a>粗剪阶段</h5><p>通常情况下，在素材窗口，通过键盘“I”（initiate）与“O”（over）键，进行对原始素材的提取，将选中范围的素材拖动到时间线窗口中。<br>四种将素材添加到故事情节的方式：</p>
<ul>
<li>连接（快捷键Q）：将所选的素材片段放置到当前时间轴所处的位置，不抢站任何片段的位置</li>
<li>插入（快捷键W）：将所选素材片段插入到当前时间轴所处的位置，原有的片段会被自动切割下来</li>
<li>附加（快捷键E）：将所选素材片段附加（追加）到当前时间线最末尾的位置，不抢站任何片段的位置</li>
<li>覆盖（快捷键D）：将所选的片段，覆盖到当前时间轴所处的位置。<strong>原有片段的位置不变，但是内容会被裁切并覆盖</strong></li>
</ul>
<h5 id="精剪和磁性时间线"><a href="#精剪和磁性时间线" class="headerlink" title="精剪和磁性时间线"></a>精剪和磁性时间线</h5><p>快捷键“B”切割，快捷键“A”正常选择模式</p>
<h5 id="多轨剪辑"><a href="#多轨剪辑" class="headerlink" title="多轨剪辑"></a>多轨剪辑</h5><p>主序列的片段是所有片段的核心，其它的片段都是依附在主序列片段进行的。音频、图片，在前在后等等。</p>
<h5 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h5><p>第一个关键帧记录的片段属性和第二个关键帧记录的片段属性之间，之间有一个“渐进运动”的概念。</p>
<h5 id="聚焦、抠像和遮罩"><a href="#聚焦、抠像和遮罩" class="headerlink" title="聚焦、抠像和遮罩"></a>聚焦、抠像和遮罩</h5><ul>
<li>聚焦：在模糊分类下：制造出一个整体模糊而局部清晰的效果，从而实现某种程度的伪“景深”效果，弥补在画面拍摄中留下的遗憾或不足。</li>
<li>抠像：抠像的本质就是从画面中选取一部分，而将其它部分从画面中抹去。</li>
<li>遮罩：绘制遮罩</li>
</ul>
<h4 id="B站“十年怎么走”"><a href="#B站“十年怎么走”" class="headerlink" title="B站“十年怎么走”"></a>B站“十年怎么走”</h4><h5 id="教程实录"><a href="#教程实录" class="headerlink" title="教程实录"></a>教程实录</h5><span id="more"></span>
<h6 id="关键帧-17"><a href="#关键帧-17" class="headerlink" title="关键帧(17)"></a>关键帧(17)</h6><h6 id="遮罩-18"><a href="#遮罩-18" class="headerlink" title="遮罩(18)"></a>遮罩(18)</h6><h6 id="调色-19"><a href="#调色-19" class="headerlink" title="调色(19)"></a>调色(19)</h6><ul>
<li>整体调整视频中色调、色相、色温等基准（跟PS中的概念应该类似的）</li>
<li>色相/饱和度曲线1：可以针对视频中有针对性的颜色对应调整其：色相、饱和度</li>
<li>LUTS可以加载预设好的效果（效果-&gt;自定义LUT）</li>
</ul>
<h6 id="转场使用-20"><a href="#转场使用-20" class="headerlink" title="转场使用(20)"></a>转场使用(20)</h6><ul>
<li>转场效果在转场预览器中</li>
<li>实时预览效果的话，直接把鼠标放到相应的效果上来回拖动即可</li>
<li>转场需要额外<strong>媒体余量</strong>，因此必须要进入精确度编辑器（双击两个片段中间）中修改转场细节，不然就会损耗原有视频片段</li>
</ul>
<h6 id="调整视频速度-21"><a href="#调整视频速度-21" class="headerlink" title="调整视频速度(21)"></a>调整视频速度(21)</h6><p>在转场中，片段升/降格中是经常出现的</p>
<ul>
<li>Command + R可以打开自定义速度编辑条，可以前后拖动调整</li>
<li>自定义也可以通过Command + B进行切割，分片段编辑</li>
<li>保留音高：保证在视频快速/慢速见，音频不失真</li>
</ul>
<h6 id="自定义快捷键-22"><a href="#自定义快捷键-22" class="headerlink" title="自定义快捷键(22)"></a>自定义快捷键(22)</h6><p>最大的使用场景应该就是分组的概念了，可以针对不同的快捷键进行分组且不冲突</p>
<h6 id="渲染场景使用-23"><a href="#渲染场景使用-23" class="headerlink" title="渲染场景使用(23)"></a>渲染场景使用(23)</h6><ul>
<li>可以通过删除资源库缓存文件，删除已经渲染好的文件</li>
<li>项目不匹配的素材，就需要在剪辑过程中渲染</li>
</ul>
<h6 id="整理素材-24"><a href="#整理素材-24" class="headerlink" title="整理素材(24)"></a>整理素材(24)</h6><ul>
<li>通过素材窗口，i o f 快捷键，进行对个人喜欢的视频片段收藏</li>
<li>通过i o 选定片段后，Command + k，可以为选中的片段添加关键字</li>
<li>在收藏过滤器中，新建智能精选，可以将自定义筛选器中定义的规则保存起来</li>
</ul>
<h6 id="效果使用-25"><a href="#效果使用-25" class="headerlink" title="效果使用(25)"></a>效果使用(25)</h6><ul>
<li>视频效果可以直接在指定的视频效果上，通过移动鼠标指针可以实时预览</li>
<li>音频效果，选中片段，选中音效效果，按下空格</li>
<li>信箱模式效果：可以快速控制画面比例</li>
<li>删减效果：比如局部马赛克</li>
</ul>
<h6 id="裁剪工具使用-26"><a href="#裁剪工具使用-26" class="headerlink" title="裁剪工具使用(26)"></a>裁剪工具使用(26)</h6><ul>
<li>裁剪工具，可以配合关键帧，将静态的图片，类似于镜头一样动起来</li>
<li>也可以通过kenburns来完成上述效果，唯一区别，其作用于整个片段</li>
<li>修剪工具：哪里不要裁哪里</li>
</ul>
<h6 id="录制画外音-27"><a href="#录制画外音-27" class="headerlink" title="录制画外音(27)"></a>录制画外音(27)</h6><ul>
<li>窗口-&gt;录制</li>
</ul>
<h6 id="快捷键使用-28"><a href="#快捷键使用-28" class="headerlink" title="快捷键使用(28)"></a>快捷键使用(28)</h6><p>软件里面的快捷键巨多，只有多练多用了之后才会熟悉</p>
<h6 id="调整图层-29"><a href="#调整图层-29" class="headerlink" title="调整图层(29)"></a>调整图层(29)</h6><ul>
<li>教程中通过motion这个软件来完成多视频片段添加批量效果<ul>
<li>说白了就是一个效果的抽象</li>
</ul>
</li>
</ul>
<h6 id="自定义界面布局-30"><a href="#自定义界面布局-30" class="headerlink" title="自定义界面布局(30)"></a>自定义界面布局(30)</h6><ul>
<li>事件监听器：多出一个素材窗口预览</li>
<li>比较监视器：上一个片段编辑的最后一帧，下一个片段开始的第一帧</li>
<li>帧浏览器：快速浏览片段的每一帧，也可以存储收藏 </li>
<li>可以通过保存不通功能属性的工作区：调色、粗剪、整理啊等等</li>
</ul>
<h6 id="如何制作字幕-31"><a href="#如何制作字幕-31" class="headerlink" title="如何制作字幕(31)"></a>如何制作字幕(31)</h6><p>视频中结合的是motion搭配使用的</p>
<h6 id="字幕详细使用-32"><a href="#字幕详细使用-32" class="headerlink" title="字幕详细使用(32)"></a>字幕详细使用(32)</h6><p>将相应的字体存储，可以批量将剪辑轨上所有的字体批量的效果</p>
<ul>
<li>编辑-&gt;查找和替换：实现整个视频所有字幕的文字的批量替换</li>
</ul>
<h6 id="发生器使用-33"><a href="#发生器使用-33" class="headerlink" title="发生器使用(33)"></a>发生器使用(33)</h6><p>整体上发生器就是一个素材的模板：<br>比如在有外置黑边的情况下，可以通过发生器来添加整个背景的幕布效果。</p>
<h6 id="空间符合使用-36"><a href="#空间符合使用-36" class="headerlink" title="空间符合使用(36)"></a>空间符合使用(36)</h6><p>在不通分辨率下，是否通过设置，例如“适合”效果，是否自动填充效果<br>尽量在剪辑的时候，选择同比例的素材</p>
<h6 id="升格和降格的使用-40"><a href="#升格和降格的使用-40" class="headerlink" title="升格和降格的使用(40)"></a>升格和降格的使用(40)</h6><p>升降格总体目的：在差异化帧融合剪辑过程中，完美显示出每一帧画面的操作。</p>
<ul>
<li>低帧率素材放到高帧率的素材中，会出现素材复制的效果<ul>
<li>速率符合效果栏中：向下取整和近邻都是复制帧的效果。其余的都是通过模拟计算的</li>
</ul>
</li>
<li>降格：就是低（帧）到高（帧）的过程中，通过快速播放，来达到完整展现的效果。感官体验就是快速播放了</li>
<li>升格：反过来，高（帧）到低（帧）的过程中，会自动删除部分帧。感官体验上就是慢放的过程。</li>
</ul>
<h6 id="转场概念-42"><a href="#转场概念-42" class="headerlink" title="转场概念(42)"></a>转场概念(42)</h6><p>####### 遮罩转场<br>在视频教程中，演示了一个，人物运动时字幕不要挡住人物的一个场景，网友总结：遮罩-&gt;反选-&gt;K帧-&gt;控制节点-&gt;固定帧</p>
<ul>
<li>如果是要给字幕加遮罩转场效果：需要<strong>复合片段</strong>来操作</li>
<li>绘制遮罩，所有的锚点必须闭合</li>
</ul>
<h6 id="试演-43"><a href="#试演-43" class="headerlink" title="试演(43)"></a>试演(43)</h6><p>多片段剪辑时，类似于PPT？快速筛选？实行</p>
<h6 id="多机位片段"><a href="#多机位片段" class="headerlink" title="多机位片段"></a>多机位片段</h6><p>多个片段，可以同时加到剪辑轨中，其实就是一个多轨编辑的场景。</p>
<ul>
<li>有一个音频同步功能：就是音轨自动对齐的场景</li>
<li>角度窗口的切换：进入到角度窗口，可以随意按照不同机位的片段，切换不同的机位角度</li>
</ul>
<h3 id="实战体会"><a href="#实战体会" class="headerlink" title="实战体会"></a>实战体会</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.bilibili.com/video/BV1Kt411S7TX">B站：十年怎么走，视频教程合集</a></p>
]]></content>
      <categories>
        <category>影视后期</category>
      </categories>
      <tags>
        <tag>剪辑工具</tag>
        <tag>视频剪辑</tag>
      </tags>
  </entry>
  <entry>
    <title>TotalCommander常规使用总结</title>
    <url>/post/6b8bb59.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>TotalCommander是一个老牌的文件管理器(下文简称：TC)。从Wikipedia首页介绍<a href="https://en.wikipedia.org/wiki/Total_Commander"></a>就能看出，首发版本从1993年开始到现在已经快30年。<br>TC的强大与震撼，确实令每位使用过或者经常使用的用户来说，非常了不起的。个人觉得，在Windows平台下，TC是最强大的文件管理器，没有之一！<br>另外一点，就是这是一款等同于免费的软件。<br>为什么说是等同于呢？实际上，如果你不付费，一种你大可寻找网上D版的授权认证，另外一种，也就是一个弹框而已，正常功能使用完全不受影响。从其它渠道了解他人对TC软件作者的采访得知，作者的对D版的态度是不反对的，完全看你自己。<strong>这一点精神，着实令我敬佩！</strong><br>也正因为这点，早在很多年前（15-16年之间）就付费购买了授权认证，也从那时候开始，个人对于付费软件的态度就是：<strong>在力所能及的情况下能付费的就付费。</strong><br>这么多年下来了，从早年大学时代玩的D版游戏，到后来工作之后，所有的游戏全部正版化。个人游戏平台涵盖了所有：Steam、Ubisoft、Origin、Epic都付费购买过游戏。<br>从使用的操作系统，Windows Professional(付费购买)、Office 365，从黑苹果、黑群晖，再到白苹果，白群晖。等等等等，太多了，无一例外，很多我也践行了我的承诺：力所能及的情况下。<br>这一点也正是TC软件的作者影响着我。<br>废话不多说~<br>本文主要记录一下日常使用TC过程中的一些经验、技巧相关。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><span id="more"></span>
<h3 id="TC基本功能介绍"><a href="#TC基本功能介绍" class="headerlink" title="TC基本功能介绍"></a>TC基本功能介绍</h3><h3 id="TC常规使用场景"><a href="#TC常规使用场景" class="headerlink" title="TC常规使用场景"></a>TC常规使用场景</h3><h4 id="快速定位"><a href="#快速定位" class="headerlink" title="快速定位"></a>快速定位</h4><p>【快捷键】 Ctrl + D</p>
<ul>
<li>打开收藏栏，收藏栏可以收藏本地文件夹 OR 本地文件、远程网站等等。</li>
<li>打开菜单后，如果是新需要添加的文件夹，直接选择“添加当前文件夹”即可。</li>
<li>新菜单文件夹弹出时：可以命名菜单名称，<strong>也可以同时命名快捷键</strong><br><img data-src="6b8bb59/bookmark1.jpg" alt="命名收藏名称"><br>添加成功后，如果你有命名快捷键，此后的快速打开快捷键就是：Ctrl + D + [你命名的快捷键]</li>
</ul>
<h5 id="组合子菜单"><a href="#组合子菜单" class="headerlink" title="组合子菜单"></a>组合子菜单</h5><p>在配置菜单中，你可以添加子菜单用于管理分类，相当于建立一个“一级目录”，如图所示：<br><img data-src="6b8bb59/bookmark2.jpg" alt="一级收藏菜单"><br>同时也可以命名快捷键，就像上图中，我要跳转到Downloads目录，组合快捷键就是：Ctrl + D + D + S</p>
<h4 id="颜色管理"><a href="#颜色管理" class="headerlink" title="颜色管理"></a>颜色管理</h4><p>菜单配置路径：配置-&gt;选项-&gt;颜色<br>总体上可以通过组合条件设置，灵活配置各种各样规则，最终标记文件颜色。<br><em>在配置页面可以通过调整匹配顺序，设置匹配优先级，我的优先级是：时间第一，文件扩展名第二</em><br>设置完之后就是这样的<br><img data-src="6b8bb59/color4.jpg" alt="颜色管理配置预览页面"></p>
<h5 id="按时间"><a href="#按时间" class="headerlink" title="按时间"></a>按时间</h5><p>如下图所示，选择定义，在“定义选择类型”窗口中，选择“高级”选项卡，下面列举了很多场景<br><img data-src="6b8bb59/color1.jpg" alt="按时间配置"></p>
<h6 id="三天以内"><a href="#三天以内" class="headerlink" title="三天以内"></a>三天以内</h6><p>勾选“不早于”，并选择3天。确定之后，选择红色，即用于标记：<strong>凡是三天以内修改过的，用红色标记</strong></p>
<h6 id="一年以前"><a href="#一年以前" class="headerlink" title="一年以前"></a>一年以前</h6><p>勾选“早于”，并选择1年。确定之后，选择蓝色，即用于标记：<strong>凡是一年以前修改过的，用蓝色标记</strong></p>
<h5 id="按文件类型"><a href="#按文件类型" class="headerlink" title="按文件类型"></a>按文件类型</h5><p>如图所示：<br><img data-src="6b8bb59/color2.jpg" alt="按文件类型区分颜色"><br>在指定文件类型输入框中，指定相应的文件类型，并且在确定之后，选择指定的一个颜色。<strong>配置好之后，在后续文件浏览的过程中，就已配置好的颜色区分开来</strong><br>如下图所示，配置好的颜色<br><img data-src="6b8bb59/color3.jpg" alt="区分后预览界面"></p>
<h6 id="常用文件类型分类"><a href="#常用文件类型分类" class="headerlink" title="常用文件类型分类"></a>常用文件类型分类</h6><p>这里提供Windows下各种文件类型分类，需要使用的直接粘贴即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">视频</span></span><br><span class="line">*.ASF;*.AVI;*.MOV;*.MPEG;*.MPG;*.RAM;*.RM;*.WMV;*.MP4;*.MKV;*.SWF;*.TP;*.TS;*.FLV;*.F4V</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩</span></span><br><span class="line">*.ACE;*.ALZ;*.ARJ;*.CAB;*.GZ;*.LZH;*.RAR;*.TAR;*.ZIP;*.7Z;*.ISO;*.EGG</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">图片</span></span><br><span class="line">*.BMP;*.GIF;*.JPEG;*.JPG;*.PNG;*.PSD;*.PSP;*.TIF;*.WMF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令行</span></span><br><span class="line">*.BAT;*.LNK;*.PIF;*.CMD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份</span></span><br><span class="line">*.BAK;*.TMP</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文档</span></span><br><span class="line">*.CAP;*.DOC;*.DOCX;*.GAL;*.GUL;*.HWP;*.PDF;*.RTF;*.TXT;*.PPT;*.XLS;*.XLSX;*.PPTX</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编程</span></span><br><span class="line">*.C;*.CPP;*.AS;*.PHP;*.ASP;*.PAS;*.VB;*.CS;*.JSP;*.JS;*.PL;*.H;*.HPP</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件</span></span><br><span class="line">*.CFG;*.INF;*.INI</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">帮助文件</span></span><br><span class="line">*.CHM;*.HLP</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统文件</span></span><br><span class="line">*.DLL;*.SYS</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可执行文件</span></span><br><span class="line">*.EXE;*.MSI</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网页</span></span><br><span class="line">*.HTM;*.HTML;*.URL</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">音频</span></span><br><span class="line">*.MID;*.MP2;*.MP3;*.WAV;*.OGG;*.WMA;*.AMR</span><br></pre></td></tr></table></figure>

<h4 id="复制-amp-移动"><a href="#复制-amp-移动" class="headerlink" title="复制 &amp; 移动"></a>复制 &amp; 移动</h4><h5 id="带文件目录格式复制"><a href="#带文件目录格式复制" class="headerlink" title="带文件目录格式复制"></a>带文件目录格式复制</h5><h6 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h6><p>日常生活中，随着时间的推移，建多级文件夹分类管理是经常的事情。<br>在某些场景，你可能需要快速筛选这个文件夹下的某一类文件，如：图片。筛选过后，你可能需要copy到其它媒介，如：U盘等中。但是windows资源管理器中的搜索出的结果只能复制文件，而<strong>不能复制文件的路径</strong>，因而复制过后，你的文件分类结构就看不出来了。<br>就像下面这样：<br><img data-src="6b8bb59/copy1.jpg" alt="windows下文件搜索"><br><em>我现在需要复制文件的同时，文件所属的目录结构也要复制下来，怎么办？</em></p>
<h6 id="需要借助的工具"><a href="#需要借助的工具" class="headerlink" title="需要借助的工具"></a>需要借助的工具</h6><p>TC的一款插件：TreeCopyPlus，官方插件地址（页面搜索）：<a href="https://www.ghisler.com/plugins.htm">https://www.ghisler.com/plugins.htm</a><br>本文附件下载：<a href="6b8bb59/treecopyplus.zip">TreeCopyPlus 1.051</a><br>下载后，直接用TC打开，会有提示一路回车安装即可</p>
<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>假设现在我要查找我本地用户文件夹下内所有的JPG图片，带文件目录结构的方式复制到另外一个目的目录下，如下图所示：<br><img data-src="6b8bb59/copy2.jpg" alt="TC下初始界面"><br>左侧为用户目录，右侧为目标路径<br>快捷键：F5，打开搜索框，在搜索栏位键入匹配符，如下图所示：<br><img data-src="6b8bb59/copy3.jpg" alt="搜索文件"><br>搜索完成之后，点击“输出到列表”<br><img data-src="6b8bb59/copy4.jpg" alt="输出列表"><br>此时刚刚搜索的所有匹配的文件，会把结果输出到左侧列表中。<br>此时点击左侧列表：Ctrl + A全选结果后，点击：文件-&gt;压缩文件菜单（快捷键：ALT + F5）之后，弹出压缩文件窗口，默认选项如下图所示：<br><img data-src="6b8bb59/copy5.jpg" alt="默认压缩文件框"><br><strong>下面需要注意一下最终的选项</strong>，默认操作就如这个菜单名称所示，压缩文件。我们这里是拷贝文件，这里就需要选择使用我们刚刚安装的插件来进行拷贝。<br>选择“需要外部压缩程序”，下拉框中选择“TreeCopyPlus”。如下图所示：<br><img data-src="6b8bb59/copy6.jpg" alt="设置以TreeCopyPlus插件复制"><br>选择完成之后，如果没有其它需求，点击确认即可。<br>稍等片刻，完成之后，看一下目的路径下面的文件结构，是这样的：<br><img data-src="6b8bb59/copy7.jpg" alt="TC中预览目的路径下的文件结构"><br>点进去一看呢？就是这样的：<br><img data-src="6b8bb59/copy8.jpg" alt="Windows文件管理器下预览"></p>
<p><strong>很完美的解决了是不是！Excellent！</strong></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK初探之CentOS7环境搭建</title>
    <url>/post/39705835.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在早些时候就有了解ELK的鼎鼎大名，前一段时间也是组件了自己的软路由环境，有充足的硬件/软件资源，刚好开始学习一下ELK相关的东西。<br>搭建目的就是通过上手学习ELK相关的东西之外，也通过RouteOS内建的SNMP服务将路由器日志信息输出到ELK进而分析一下。<br>软路由搭建相关，直接查看本站的另一篇文章：<a href="https://nimbusk.cc/post/c07c0078.html">新手从零软路由系列</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文涉及Linux、ES、NodeJS等等相关技术，篇幅可能较长，需要具备一定shell基础，一些基本命令相关不过多介绍。<br>全文运行环境版本如下：</p>
<ul>
<li>Esxi: 6.7</li>
<li>虚拟OS: CentOS Linux release 7.7.1908 (Core)<ul>
<li>内存：4GB</li>
<li>硬盘：30GB</li>
</ul>
</li>
<li>ElasticSearch: 7.5.0</li>
<li>Logstash: 7.5.0</li>
<li>Kibana: 7.5.0</li>
<li>NodeJS: 4.4.7<span id="more"></span>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="何为ELK"><a href="#何为ELK" class="headerlink" title="何为ELK"></a>何为ELK</h4><h4 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h4><h4 id="Logstash简介"><a href="#Logstash简介" class="headerlink" title="Logstash简介"></a>Logstash简介</h4><h4 id="Kibana简介"><a href="#Kibana简介" class="headerlink" title="Kibana简介"></a>Kibana简介</h4><h3 id="搭建准备"><a href="#搭建准备" class="headerlink" title="搭建准备"></a>搭建准备</h3><h4 id="下载ELK相关包"><a href="#下载ELK相关包" class="headerlink" title="下载ELK相关包"></a>下载ELK相关包</h4>直接去官网：<a href="https://www.elastic.co/">https://www.elastic.co/</a> 下载，注意一点：ELK三个组件的版本必须一直，否则会出现很多意外的问题。<br>本次因为是单机搭建ElasticSearch集群，初始的master节点使用的rpm包的方式直接安装。<h4 id="SSH及FTP工具"><a href="#SSH及FTP工具" class="headerlink" title="SSH及FTP工具"></a>SSH及FTP工具</h4>由于常年个人用的一直是SecureCRT，所以这次搭建也是使用的这个版本。<br>FTP工具不是必须，因为要看你是通过何种方式安装ELK组件的。<h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3>所有搭建之前，必须在当前的CentOS安装好1.8版本的JDK，并配置好profile环境变量。如不清楚具体安装细节，可参考站内另一篇文章：<a href="https://nimbusk.cc/post/ca10a347.html">CentOS7基础操作相关</a><h4 id="ElasticSearch集群"><a href="#ElasticSearch集群" class="headerlink" title="ElasticSearch集群"></a>ElasticSearch集群</h4><h5 id="Master节点"><a href="#Master节点" class="headerlink" title="Master节点"></a>Master节点</h5>将从官网下载好的rpm包上传的CentOS指定目录下<br>运行如下命令直接安装elasticsearch：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i 安装rpm包，-v 可视化显示，-h 显示安装进度</span></span><br><span class="line">npm -ivh elasticsearch-7.5.0-x86_64.rpm</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过rpm安装的es，默认配置路径为： /etc/elasticsearch</p>
<h6 id="修改Master节点配置"><a href="#修改Master节点配置" class="headerlink" title="修改Master节点配置"></a>修改Master节点配置</h6><p>由于7.0+以上的es版本均需要在集群下工作，所以针对老版本而言，需要配置集群模式。<br>具体配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================== Elasticsearch Configuration =========================</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Elasticsearch comes with reasonable defaults for most settings.</span></span><br><span class="line"><span class="comment">#       Before you set out to tweak and tune the configuration, make sure you</span></span><br><span class="line"><span class="comment">#       understand what are you trying to accomplish and the consequences.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The primary way of configuring a node is via this file. This template lists</span></span><br><span class="line"><span class="comment"># the most important settings you may want to configure for a production cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please consult the documentation for further information on configuration options:</span></span><br><span class="line"><span class="comment"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for your cluster:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">nimbusk_es</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for the node:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">nimbusk-master</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Add custom attributes to the node:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#node.attr.rack: r1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Is master node</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Allow max numbuer nodes at local machine</span></span><br><span class="line"><span class="attr">node.max_local_storage_nodes:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to directory where to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/var/lib/elasticsearch</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to log files:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/var/log/elasticsearch</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Lock the memory on startup:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#bootstrap.memory_lock: true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make sure that the heap size is set to about half the memory available</span></span><br><span class="line"><span class="comment"># on the system and that the owner of the process is allowed to use this</span></span><br><span class="line"><span class="comment"># limit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Elasticsearch performs poorly when the system is swapping the memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="string">你的机器ip</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the network module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Pass an initial list of hosts to perform discovery when this node is started:</span></span><br><span class="line"><span class="comment"># The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#discovery.seed_hosts: [&quot;192.168.31.49&quot;]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Bootstrap the cluster using an initial set of master-eligible nodes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;nimbusk-master&quot;</span>]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the discovery and cluster formation module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Gateway -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Block initial recovery after a full cluster restart until N nodes are started:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#gateway.recover_after_nodes: 3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the gateway module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Various -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Require explicit names when deleting indices:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#action.destructive_requires_name: true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Add additional arguments for head plugin</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="启动es服务"><a href="#启动es服务" class="headerlink" title="启动es服务"></a>启动es服务</h6><p>通过rpm安装的方式，可以直接通过系统服务启动，运行如下命令即可，并且可以设置es服务开机自动启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start elasticsearch</span><br><span class="line">sudo systemctl enable elasticsearch</span><br></pre></td></tr></table></figure>
<p>看到下图所示started，则表明启动完成：<br><img data-src="39705835/start_es_successfully.jpg" alt="start_es_successfully"><br>启动完成后，可以通过tail查看默认日志路径/var/log/elasticsearch下的日志文件查看启动情况。</p>
<h5 id="其余两个从节点配置"><a href="#其余两个从节点配置" class="headerlink" title="其余两个从节点配置"></a>其余两个从节点配置</h5><p>上传tar.gz包到指定路径下并解压缩</p>
<h6 id="配置用户组和es配置文件"><a href="#配置用户组和es配置文件" class="headerlink" title="配置用户组和es配置文件"></a>配置用户组和es配置文件</h6><p>配置用户组的原因是因为，es不可以直接用root用户启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增elasticsearch1用户组</span></span><br><span class="line">groupadd elasticsearch1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增elasticsearch1用户并分组，结尾-p为设置密码</span></span><br><span class="line">useradd elasticsearch1 -g elasticsearch1 -p 123456</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">权限分配目录到指定用户和组</span></span><br><span class="line">chown -R elasticsearch1:elasticsearch1 /etc/elasticsearch-slave1</span><br></pre></td></tr></table></figure>

<p>slave1的es配置如下<br>特别注意：</p>
<ul>
<li>cluster.name 值必须与你master节点配置的值一致</li>
<li>http.port 值必须与其余节点唯一，我这里是slave1，所以就取值9201，以此类推，后续slave2就配置9202就好了</li>
<li>discovery.zen.ping.unicast.hosts 中间的IP地址必须填写你的master机器所在地址，我这里都在单机部署，所以地址都是本机ip地址。如果你部署的是不同机器的，就配置实际机器IP地址就好了。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================== Elasticsearch Configuration =========================</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Elasticsearch comes with reasonable defaults for most settings.</span></span><br><span class="line"><span class="comment">#       Before you set out to tweak and tune the configuration, make sure you</span></span><br><span class="line"><span class="comment">#       understand what are you trying to accomplish and the consequences.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The primary way of configuring a node is via this file. This template lists</span></span><br><span class="line"><span class="comment"># the most important settings you may want to configure for a production cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please consult the documentation for further information on configuration options:</span></span><br><span class="line"><span class="comment"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Cluster -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for your cluster:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">nimbusk_es</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ------------------------------------ Node ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use a descriptive name for the node:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">nimbusk-slave1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Add custom attributes to the node:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#node.attr.rack: r1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Paths ------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to directory where to store the data (separate multiple locations by comma):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/etc/elasticsearch-slave1/data</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Path to log files:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/etc/elasticsearch-slave1/logs</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------- Memory -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Lock the memory on startup:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#bootstrap.memory_lock: true</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make sure that the heap size is set to about half the memory available</span></span><br><span class="line"><span class="comment"># on the system and that the owner of the process is allowed to use this</span></span><br><span class="line"><span class="comment"># limit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Elasticsearch performs poorly when the system is swapping the memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Network -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="string">你的机器ip</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9201</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the network module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --------------------------------- Discovery ----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Pass an initial list of hosts to perform discovery when this node is started:</span></span><br><span class="line"><span class="comment"># The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Bootstrap the cluster using an initial set of master-eligible nodes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the discovery and cluster formation module documentation.</span></span><br><span class="line"><span class="comment"># Set your master node ip address</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;mater机器的ip&quot;</span>]</span><br><span class="line"><span class="attr">node.max_local_storage_nodes:</span> <span class="number">3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Gateway -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Block initial recovery after a full cluster restart until N nodes are started:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#gateway.recover_after_nodes: 3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, consult the gateway module documentation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ---------------------------------- Various -----------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Require explicit names when deleting indices:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#action.destructive_requires_name: true</span></span><br></pre></td></tr></table></figure>

<p>配置好之后，直接cd到bin目录下，后台启动即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./elasticsearch &amp;</span><br></pre></td></tr></table></figure>

<p>当然你也可以通过配置指定的service服务来实现开机启动等等。这里就从略了。</p>
<h4 id="ElasticSearch-head插件"><a href="#ElasticSearch-head插件" class="headerlink" title="ElasticSearch-head插件"></a>ElasticSearch-head插件</h4><p>这个插件es辅助可视化管理es集群的工具<br>安装好之后，通过浏览器页面浏览张这个样子：<br><img data-src="39705835/elasticsearch-head.jpg" alt="elasticsearch-head"></p>
<h5 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果提示找不到wget命令，yum install wget安装一下</span></span><br><span class="line">wget https://github.com/mobz/elasticsearch-head/archive/master.zip</span><br></pre></td></tr></table></figure>
<h5 id="准备nodejs环境"><a href="#准备nodejs环境" class="headerlink" title="准备nodejs环境"></a>准备nodejs环境</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://npm.taobao.org/mirrors/node/latest-v4.x/node-v4.4.7-linux-x64.tar.gz</span><br><span class="line">tar -zxvf node-v4.4.7-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<h5 id="配置nodejs环境变量"><a href="#配置nodejs环境变量" class="headerlink" title="配置nodejs环境变量"></a>配置nodejs环境变量</h5><p>直接附上自己完整的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_211</span><br><span class="line">export NODE_HOME=/usr/node-v4.4.7-linux-x64</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$NODE_HOME/bin</span><br><span class="line">export NODE_PATH=$NODE_HOME/lib/node_modules</span><br></pre></td></tr></table></figure>
<p>添加完成之后，不要忘了刷新一下source，使profile生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p>通过命令：<code>npm -v</code>可以查看是否配置成功</p>
<h5 id="安装grunt"><a href="#安装grunt" class="headerlink" title="安装grunt"></a>安装grunt</h5><p>接下来解压下载的master.zip，cd进入下载的elasticsearch-head-master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装grunt-cli</span></span><br><span class="line">npm install -g grunt-cli</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看grunt版本</span></span></span><br><span class="line">grunt -version</span><br></pre></td></tr></table></figure>
<h6 id="修改head插件源码"><a href="#修改head插件源码" class="headerlink" title="修改head插件源码"></a>修改head插件源码</h6><ol>
<li>修改服务器监听地址：Gruntfile.js<br>找到如下位置，新加一行hostname，如下图所示:<br><img data-src="39705835/modify_gruntjs_file.jpg" alt="modify_gruntjs_file"></li>
<li>修改连接地址：_site/app.js，大概位置在4374行<br><img data-src="39705835/modify_app_js.jpg" alt="modify_app_js"></li>
</ol>
<h6 id="head插件npm安装"><a href="#head插件npm安装" class="headerlink" title="head插件npm安装"></a>head插件npm安装</h6><p>直接在当前目录下执行如下命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g</span><br></pre></td></tr></table></figure>
<h6 id="head插件后台启动"><a href="#head插件后台启动" class="headerlink" title="head插件后台启动"></a>head插件后台启动</h6><p>由于这个插件，你肯定经常会浏览，所以肯定需要通过后台运行，在当前目录下执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup grunt server &amp;exit</span><br></pre></td></tr></table></figure>

<p>至此，启动完成之后，就可以通过浏览器，默认9100端口访问，就会得本小节前面的那张es集群图了。</p>
<h4 id="通过cerebro访问ElasticSearch集群"><a href="#通过cerebro访问ElasticSearch集群" class="headerlink" title="通过cerebro访问ElasticSearch集群"></a>通过cerebro访问ElasticSearch集群</h4><p>cerebro相对上一小节通过nodejs方式访问，就安装步骤而言，简单很多，不需要安装各种组件库。<br>cerebro是一款以来Scala、JS等相关技术编写的，其官方github有详细配置说明：<a href="https://github.com/lmenezes/cerebro">https://github.com/lmenezes/cerebro</a><br>下载release包，上传到服务器后台之后，可以不用配置conf目录下的配置文件，直接通过登录页面直接连接es集群。<br>运行截图如下：<br><img data-src="39705835/cerebro_run_capture.jpg" alt="cerebro_run_capture"></p>
<h4 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h4><p>通过rpm安装kibana非常简单，安装完成之后，可以通过如下命令寻找kibana服务的配置文件路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost _site]# rpm -qc kibana</span><br><span class="line">/etc/kibana/kibana.yml</span><br><span class="line">[root@localhost _site]# </span><br></pre></td></tr></table></figure>
<h5 id="修改kibana配置"><a href="#修改kibana配置" class="headerlink" title="修改kibana配置"></a>修改kibana配置</h5><p>直接vim过去，修改如下两行即可：</p>
<ul>
<li>server.host: “你的机器IP”</li>
<li>elasticsearch.url: “<a href="http://es/">http://es</a> master节点的IP:9200”<h5 id="启动kibana并设置开机启动"><a href="#启动kibana并设置开机启动" class="headerlink" title="启动kibana并设置开机启动"></a>启动kibana并设置开机启动</h5>就不需要多说什么了：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl start kibana</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> chkconfig kibana on</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>稍等片刻，通过浏览器，kibana默认端口是5601，直接访问，进去之后，就大致可以看到如下页面了，<br>初始化，进去会让你是否选择一个kibana示例，初始化一些es数据后展示的一个监控大盘，我点了一个，之后就如下图所示：<br><img data-src="39705835/kibana_dashborad.jpg" alt="kibanadashborad"></p>
<p>嗯，配色还是很好看的！</p>
<h4 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>通过rpm包安装同样很简单，直接安装就好了。不过多赘述</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><h6 id="通过标准输入输出来检验是否正常"><a href="#通过标准输入输出来检验是否正常" class="headerlink" title="通过标准输入输出来检验是否正常"></a>通过标准输入输出来检验是否正常</h6><p>输入下面命令，即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/share/logstash/bin/logstash -e &#x27;input &#123; stdin&#123;&#125; &#125; output &#123; stdout &#123;&#125; &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>等待光标等你键入之后，输入：Hello World!，回车<br>有正常json输出之后，说明正常的。</p>
<h6 id="通过标准输入向es发送"><a href="#通过标准输入向es发送" class="headerlink" title="通过标准输入向es发送"></a>通过标准输入向es发送</h6><p>输入下面命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/share/logstash/bin/logstash -e &#x27;input &#123; stdin&#123;&#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; [&quot;你的es masterip:9200&quot;] index =&gt; &quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot; &#125; &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>同样等待光标等你键入之后，输入：Hello World!，回车<br>可能发现并没有json回显，此时通过head检索一下，发现如下图，消息内容为正为你手工输入的，即表明正常发送到es：<br><img data-src="39705835/get_messages_from_standard_input.jpg" alt="标准输入输出"></p>
<h6 id="配置一个简单示例"><a href="#配置一个简单示例" class="headerlink" title="配置一个简单示例"></a>配置一个简单示例</h6><p>目标：通过监听centos系统日志文件，只要该日志文件中写入信息，就被logstash收集发送到es，最后通过配置kibana检索日志信息。</p>
<ol>
<li>配置一个简单的conf文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost conf.d]# vim /etc/logstash/conf.d/log-messages.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件中写入如下内容，其中esip为你的master节点ip，当然其余的slave节点ip也可以。</span></span><br><span class="line">input&#123;</span><br><span class="line">  file&#123;</span><br><span class="line">    path =&gt; [&quot;/var/log/messages&quot;]</span><br><span class="line">    type =&gt; &quot;system-log&quot;</span><br><span class="line">    start_position =&gt; &quot;beginning&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">filter&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">output&#123;</span><br><span class="line">  elasticsearch&#123;</span><br><span class="line">    hosts =&gt; [&quot;mater ip:9200&quot;]</span><br><span class="line">    index =&gt; &quot;system-log-%&#123;+YYYY.MM&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>通过如下命令可以检查该脚本是否配置正常：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost conf.d]# /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/log-messages.conf -t</span><br></pre></td></tr></table></figure>
<p>看到输出信息中包含Configuration OK字样，即表明配置成功。</p>
<p>后台启动这个配置的logstash</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost conf.d]# /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/log-messages.conf &amp;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动后，再去head查看一下，发现多出一列信息<br><img data-src="39705835/head_overview_after_configuring_system_log.jpg" alt="head_overview_after_configuring_system_log"><br>此时表明以及成功收集到系统信息了</li>
<li>配置一下kibana索引即可通过kibana搜索了<br>打开kibana的Management配置菜单（左侧菜单栏下方的小齿轮），点击 <strong>Index Patterns</strong>创建索引，如下图所示：<br><img data-src="39705835/config_kibana_index_1.jpg" alt="config_kibana_index_1"><br>创建新的索引，按下图配置<br><img data-src="39705835/config_kibana_index_2.jpg" alt="config_kibana_index_2"><br>生效之后，就可以再发现(Discovery)菜单中检索了，如下图所示：<br><img data-src="39705835/config_kibana_index_3.jpg" alt="config_kibana_index_3"></li>
</ol>
<p>至此，所有ELK组件搭建完毕，下一步就是进一步搜集我们需要的信息了！</p>
<h3 id="收集RouterOS软路由日志"><a href="#收集RouterOS软路由日志" class="headerlink" title="收集RouterOS软路由日志"></a>收集RouterOS软路由日志</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1] ELK之在CentOS7.5上使用rpm包安装配置ELK7版本.2019.05.30(2019.12). <a href="https://www.cnblogs.com/minseo/p/10948632.html">https://www.cnblogs.com/minseo/p/10948632.html</a><br>[2] Centos7 之安装Logstash ELK stack 日志管理系统.2016-05-23(2019.12). <a href="https://www.cnblogs.com/hanyifeng/p/5509985.html">https://www.cnblogs.com/hanyifeng/p/5509985.html</a></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>CentOS7</tag>
        <tag>ELK</tag>
        <tag>ElasticSearch Cluster</tag>
        <tag>Logstash</tag>
        <tag>Kibana</tag>
        <tag>Esxi 6.7</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言统计分析实战（RStudio）</title>
    <url>/post/a93eddc5.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>一位好友找我，问我有没有弄过RStudio，以前了解过R语言，用于统计分析的，但是实际没有实战过。所以嘛，就准备了一下，记录一下探索过程。 :)</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本片文章简单介绍一些RStudio相关以及少量统计学相关的知识，供上手学习使用。毕竟是一门编程语言，语法看了一下，不是很复杂，具备一定C语言即可，一些代码片段就可能看懂了。<br>如有相关错误，欢迎评论区留言指正，谢谢。<br>本文相关运行环境为：</p>
<ul>
<li>OS：Microsoft Windows [版本 10.0.18363.535]</li>
<li>内存：32GB</li>
<li>R版本：3.6.2</li>
<li>RStudio版本：1.2.5033.0<br>【注】 下文相关截图等数据均基于上述软件版本，如后期版本更新等，类推即可。</li>
</ul>
<h3 id="统计学相关理论（简要）"><a href="#统计学相关理论（简要）" class="headerlink" title="统计学相关理论（简要）"></a>统计学相关理论（简要）</h3><h3 id="相关概念介绍"><a href="#相关概念介绍" class="headerlink" title="相关概念介绍"></a>相关概念介绍</h3><h4 id="什么是R语言"><a href="#什么是R语言" class="headerlink" title="什么是R语言"></a>什么是R语言</h4><p>R是R统计计算基金支持的用于统计计算，图形编程的免费软件环境。R语言在统计学家和数据挖掘者中广泛用于数据分析软件和数据挖掘。数据挖掘和学术文献数据库研究表明其普及程度大幅度提高。截至到2019年11月，在TIOBE排行[一个知名的编程语言排行榜，用于衡量编程语言的热度]中，R语言排名第16位。<sup>[1]</sup></p>
<h4 id="什么是RStudio"><a href="#什么是RStudio" class="headerlink" title="什么是RStudio"></a>什么是RStudio</h4><p>RStudio是R语言的一款免费的IDE编写工具。为计算环境提供最灌灌的使用的开源和企业就绪型专业软件。提供了脚本调试、可视化等功能，支持纯R脚本、Rmarkdown（脚本文档混排）、Bookdown（脚本混排混排成书）、Shiny（交互式网络应用）等功能。<sup>[2]</sup></p>
<h4 id="R和RStudio之间的关系"><a href="#R和RStudio之间的关系" class="headerlink" title="R和RStudio之间的关系"></a>R和RStudio之间的关系</h4><p>R是一个基础的环境程序，是运行R语言脚本必须的基础运行时环境。类似的像其它的编程语言，类如：Java、C、Python等等，必须安装相关的运行时环境一样，否则你无法直接运行的。而RStudio只是一款可视化编辑工具而已。</p>
<span id="more"></span>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="安装R"><a href="#安装R" class="headerlink" title="安装R"></a>安装R</h4><h5 id="下载R安装包"><a href="#下载R安装包" class="headerlink" title="下载R安装包"></a>下载R安装包</h5><ol>
<li>打开R的官网：<a href="https://www.r-project.org/">https://www.r-project.org/</a></li>
<li>在左侧菜单栏中找到下载(download)，点击 <em>CRAN</em>，打开镜像网站列表页面，如下图所示：<br><img data-src="a93eddc5/mainsite_of_r_project.jpg" alt="R语言主站"></li>
<li>找到中国站点，列了很多国内大学及机构的站点，像清华、中科大、同济，随笔找一个点击连接，如下图所示：<br><img data-src="a93eddc5/mirror_site_of_r_download_page.jpg" alt="下载"></li>
<li>选择指定平台的R语言平台，如果是windows的就选择 <em>Download R for Windows</em>就是，如下图所示：<br><img data-src="a93eddc5/different_platform_of_r.jpg" alt="windows"></li>
<li>选择R的版本，直接单击<em>base</em>即可<br><img data-src="a93eddc5/different_version_of_r.jpg" alt="version"></li>
<li>直接单击<em>Download R 3.6.2 for Windows</em>开始下载</li>
</ol>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>基本一路 <strong>next</strong>下去即可，有三步提一下</p>
<ol>
<li>安装路径，默认C盘，选择你指定的盘路径即可：<br><img data-src="a93eddc5/install_select_install_path.jpg" alt="安装路径"></li>
<li>选择组件，默认全部勾选即可</li>
<li>启动选项，选择第二个：*No(接受默认选择)*即可<br><img data-src="a93eddc5/install_start_option.jpg" alt="启动选项"></li>
</ol>
<h4 id="安装RStudio"><a href="#安装RStudio" class="headerlink" title="安装RStudio"></a>安装RStudio</h4><h5 id="下载RStudio安装包"><a href="#下载RStudio安装包" class="headerlink" title="下载RStudio安装包"></a>下载RStudio安装包</h5><ol>
<li>打开RStudio官网：<a href="https://rstudio.com/products/rstudio/download/">https://rstudio.com/products/rstudio/download/</a></li>
<li>点击页面中 <em>Free</em>下的 <em>DOWNLOAD</em>按钮，跳转到下载页面<br><img data-src="a93eddc5/download_site_of_rstudio.jpg" alt="下载rstudio"></li>
<li>选择你需要的版本，如windows版本<br><img data-src="a93eddc5/select_different_version_of_rstudio.jpg" alt="选择指定版本"></li>
</ol>
<h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>过程很简单，除了第一步你需要选择安装路径之外，其余默认即可，过程3步就可以安装完成。<br>此过程就不贴安装过程了。</p>
<h5 id="基本运行调试"><a href="#基本运行调试" class="headerlink" title="基本运行调试"></a>基本运行调试</h5><p>运行RStudio（页面没有快捷方式的话，去开始菜单栏里找一下），如下图所示：<br><img data-src="a93eddc5/rstudio_main_page.jpg" alt="主界面"><br>在左侧的 <em>Console</em>选项卡下，闪烁的光标后输入：<em>1+1</em>后，按键盘 *回车(Enter)*，如果下一行显示[1] 2，证明安装好了。</p>
<h3 id="R语言语法操作相关"><a href="#R语言语法操作相关" class="headerlink" title="R语言语法操作相关"></a>R语言语法操作相关</h3><p>本语法小节参考R语言官方手册<sup>[3]</sup>中关于语法相关(基本上就是翻译了一下)，更多相关介绍直接请查阅手册其余内容。</p>
<h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="基础运算符-Simple-manipulations"><a href="#基础运算符-Simple-manipulations" class="headerlink" title="基础运算符(Simple manipulations)"></a>基础运算符(Simple manipulations)</h5><h5 id="对象模型和属性-Objects-their-modes-and-attributes"><a href="#对象模型和属性-Objects-their-modes-and-attributes" class="headerlink" title="对象模型和属性(Objects, their modes and attributes)"></a>对象模型和属性(Objects, their modes and attributes)</h5><h5 id="有序和无序操作符-Ordered-and-unordered-factors"><a href="#有序和无序操作符-Ordered-and-unordered-factors" class="headerlink" title="有序和无序操作符(Ordered and unordered factors)"></a>有序和无序操作符(Ordered and unordered factors)</h5><h5 id="数组和矩阵-Arrays-and-matrices"><a href="#数组和矩阵-Arrays-and-matrices" class="headerlink" title="数组和矩阵(Arrays and matrices)"></a>数组和矩阵(Arrays and matrices)</h5><h5 id="列表和数据片段-Lists-and-data-frames"><a href="#列表和数据片段-Lists-and-data-frames" class="headerlink" title="列表和数据片段(Lists and data frames)"></a>列表和数据片段(Lists and data frames)</h5><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><h5 id="从文件读取数据-Reading-data-from-files"><a href="#从文件读取数据-Reading-data-from-files" class="headerlink" title="从文件读取数据(Reading data from files)"></a>从文件读取数据(Reading data from files)</h5><h5 id="可能的数据分布-Probability-distributions"><a href="#可能的数据分布-Probability-distributions" class="headerlink" title="可能的数据分布(Probability distributions)"></a>可能的数据分布(Probability distributions)</h5><h5 id="数据分组、循环和条件运算-Grouping-loops-and-conditional-execution"><a href="#数据分组、循环和条件运算-Grouping-loops-and-conditional-execution" class="headerlink" title="数据分组、循环和条件运算(Grouping, loops and conditional execution)"></a>数据分组、循环和条件运算(Grouping, loops and conditional execution)</h5><h5 id="编写自己的运算函数-Writing-your-own-functions"><a href="#编写自己的运算函数-Writing-your-own-functions" class="headerlink" title="编写自己的运算函数(Writing your own functions)"></a>编写自己的运算函数(Writing your own functions)</h5><h5 id="R中的统计模型-Statistical-models-in-R"><a href="#R中的统计模型-Statistical-models-in-R" class="headerlink" title="R中的统计模型(Statistical models in R)"></a>R中的统计模型(Statistical models in R)</h5><h5 id="图形处理-Graphical-procedures"><a href="#图形处理-Graphical-procedures" class="headerlink" title="图形处理(Graphical procedures)"></a>图形处理(Graphical procedures)</h5><h3 id="RStudio使用教程"><a href="#RStudio使用教程" class="headerlink" title="RStudio使用教程"></a>RStudio使用教程</h3><h4 id="基本界面介绍"><a href="#基本界面介绍" class="headerlink" title="基本界面介绍"></a>基本界面介绍</h4><h4 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h4><h4 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h4><h3 id="样例实战"><a href="#样例实战" class="headerlink" title="样例实战"></a>样例实战</h3><h4 id="样例1：一例黑客团队邮箱列表分析"><a href="#样例1：一例黑客团队邮箱列表分析" class="headerlink" title="样例1：一例黑客团队邮箱列表分析"></a>样例1：一例黑客团队邮箱列表分析</h4><p>原始参考案例：<a href="http://rpubs.com/F789GH/HackingTeamEmails">http://rpubs.com/F789GH/HackingTeamEmails</a></p>
<h5 id="原文分析目的"><a href="#原文分析目的" class="headerlink" title="原文分析目的"></a>原文分析目的</h5><ul>
<li>统计列表中所有邮箱域名个数</li>
<li>统计邮箱域名所属区域，分析这些黑客邮件地址都来自什么地方<h5 id="获取数据源"><a href="#获取数据源" class="headerlink" title="获取数据源"></a>获取数据源</h5>直接从这个链接：<a href="https://wikileaks.org/hackingteam/emails/emailid/144932">黑客邮箱列表</a>，中获取黑客邮箱名单。<br>Copy邮箱列表到txt文件中，保存准备处理。需要简单处理一下里面的邮箱地址，列表中有#号和空白行等等。<br>处理后的列表文件，<a href="https://github.com/nimbusking/start_r_programming/blob/master/hack_team_email_list.txt">https://github.com/nimbusking/start_r_programming/blob/master/hack_team_email_list.txt</a><h5 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h5><h6 id="引用必要的类库"><a href="#引用必要的类库" class="headerlink" title="引用必要的类库"></a>引用必要的类库</h6>分析过程中使用了一些函数，因此需要引用相关类库<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>rvest<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># ggplot2绘图函数包</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>stringi<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>magrittr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>plyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
第一次运行，控制台中键入上述代码后，会自动联网下载相应类库并安装<h5 id="分析汇总域名频率分布柱状图"><a href="#分析汇总域名频率分布柱状图" class="headerlink" title="分析汇总域名频率分布柱状图"></a>分析汇总域名频率分布柱状图</h5>分析完成后的展示，如下图所示：<br><img data-src="a93eddc5/Histogram_email_domain_frequence.jpg" alt="柱状图1"><h5 id="分析域名对应国家出现频率"><a href="#分析域名对应国家出现频率" class="headerlink" title="分析域名对应国家出现频率"></a>分析域名对应国家出现频率</h5>分析完成后的展示，如下图所示：<br><img data-src="a93eddc5/Histogram_email_domain_site_frequence.jpg" alt="柱状图2"><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5>排名第一的居然是it（意大利），其次是德国、英国、美国、捷克…<h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入函数库</span></span><br><span class="line">library<span class="punctuation">(</span>rvest<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>stringi<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>magrittr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>plyr<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 从txt数据源中读取数据到变量email_list中</span></span><br><span class="line">email_list <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;hack_team_email_list.txt&quot;</span><span class="punctuation">,</span> header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 打印前6行数据</span></span><br><span class="line">head<span class="punctuation">(</span>email_list<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 按符号@分割电子邮件地址到变量splitted_email中</span></span><br><span class="line">splitted_email <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>stri_split_fixed<span class="punctuation">(</span>tolower<span class="punctuation">(</span>email_list<span class="operator">$</span>V1<span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;@&quot;</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> omit_empty <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> simplify <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 复制完整邮箱名到第三列</span></span><br><span class="line">splitted_email<span class="operator">$</span>X3 <span class="operator">&lt;-</span> paste<span class="punctuation">(</span>tolower<span class="punctuation">(</span>splitted_email<span class="operator">$</span>X1<span class="punctuation">)</span><span class="punctuation">,</span> tolower<span class="punctuation">(</span>splitted_email<span class="operator">$</span>X2<span class="punctuation">)</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;@&quot;</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>splitted_email<span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 绘制域名频率柱状图</span></span><br><span class="line"><span class="comment">## 表格转换数据帧</span></span><br><span class="line">splitted_email_freq <span class="operator">&lt;-</span> as.data.frame<span class="punctuation">(</span>table<span class="punctuation">(</span>splitted_email<span class="operator">$</span>X2<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 调用plyr函数包中的arrange方法进行排序</span></span><br><span class="line">splitted_email_freq <span class="operator">&lt;-</span> plyr<span class="operator">::</span>arrange<span class="punctuation">(</span>splitted_email_freq<span class="punctuation">,</span> desc<span class="punctuation">(</span>splitted_email_freq<span class="operator">$</span>Freq<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>splitted_email_freq<span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 绘制柱状图</span></span><br><span class="line">splitted_email_freq_plot <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data<span class="operator">=</span>splitted_email_freq<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">,</span> aes<span class="punctuation">(</span>x<span class="operator">=</span>reorder<span class="punctuation">(</span>Var1<span class="punctuation">,</span> Freq<span class="punctuation">)</span><span class="punctuation">,</span> y<span class="operator">=</span>Freq<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 设置图形展示样式</span></span><br><span class="line">splitted_email_freq_plot <span class="operator">&lt;-</span> splitted_email_freq_plot <span class="operator">+</span> geom_bar<span class="punctuation">(</span>stat <span class="operator">=</span> <span class="string">&quot;identity&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> coord_flip<span class="punctuation">(</span>ylim<span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">430</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> theme<span class="punctuation">(</span></span><br><span class="line">  axis.text.y <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">12</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">  axis.text.x <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">12</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 设置图形标题横纵坐标</span></span><br><span class="line">splitted_email_freq_plot <span class="operator">&lt;-</span> splitted_email_freq_plot <span class="operator">+</span> xlab<span class="punctuation">(</span><span class="string">&quot;域名&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> ylab<span class="punctuation">(</span><span class="string">&quot;各域名提供商所拥有的黑客数量&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> ggtitle<span class="punctuation">(</span><span class="string">&quot;从黑客邮件列表中能发现多少域名提供商？&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 图形坐标范围</span></span><br><span class="line">splitted_email_freq_plot <span class="operator">&lt;-</span> splitted_email_freq_plot <span class="operator">+</span> scale_y_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">430</span><span class="punctuation">,</span> <span class="number">30</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 生成图形</span></span><br><span class="line">splitted_email_freq_plot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制国家出现频率</span></span><br><span class="line"><span class="comment">## 先过滤一些公共域名</span></span><br><span class="line">blackListDomains <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;outlook|gmail|yahoo|live|hotmail|googlemail&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 过滤列表域名列表</span></span><br><span class="line">splitted_email_freq_bld <span class="operator">&lt;-</span> splitted_email<span class="punctuation">[</span><span class="operator">!</span>stri_detect_regex<span class="punctuation">(</span>splitted_email<span class="operator">$</span>X2<span class="punctuation">,</span> blackListDomains<span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line"><span class="comment">## 转换X2为数据帧</span></span><br><span class="line">splitted_email_freq_bld <span class="operator">&lt;-</span> as.data.frame<span class="punctuation">(</span>table<span class="punctuation">(</span>splitted_email_freq_bld<span class="operator">$</span>X2<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 排序</span></span><br><span class="line">splitted_email_freq_bld <span class="operator">&lt;-</span> plyr<span class="operator">::</span>arrange<span class="punctuation">(</span>splitted_email_freq_bld<span class="punctuation">,</span> desc<span class="punctuation">(</span>splitted_email_freq_bld<span class="operator">$</span>Freq<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 打印前15行</span></span><br><span class="line">head<span class="punctuation">(</span>splitted_email_freq_bld<span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 处理国家归属</span></span><br><span class="line">domain_list <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>stri_split_fixed<span class="punctuation">(</span>tolower<span class="punctuation">(</span>splitted_email_freq_bld<span class="operator">$</span>Var1<span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span> omit_empty <span class="operator">=</span> <span class="literal">NA</span><span class="punctuation">,</span> simplify <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">domain_list<span class="punctuation">[</span>domain_list <span class="operator">==</span> <span class="string">&quot;&quot;</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="literal">NA</span></span><br><span class="line">domain_list<span class="operator">$</span>X1 <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>domain_list<span class="operator">$</span>X1<span class="punctuation">)</span></span><br><span class="line">domain_list<span class="operator">$</span>X2 <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>domain_list<span class="operator">$</span>X2<span class="punctuation">)</span></span><br><span class="line">domain_list<span class="operator">$</span>X3 <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>domain_list<span class="operator">$</span>X3<span class="punctuation">)</span></span><br><span class="line">domain_list<span class="operator">$</span>X4 <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>domain_list<span class="operator">$</span>X4<span class="punctuation">)</span></span><br><span class="line">domain_list<span class="operator">$</span>X5 <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>domain_list<span class="operator">$</span>X5<span class="punctuation">)</span></span><br><span class="line">domain_list<span class="operator">$</span>new_NEW <span class="operator">&lt;-</span> domain_list<span class="punctuation">[</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">[</span>cbind<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>nrow<span class="punctuation">(</span>domain_list<span class="punctuation">)</span><span class="punctuation">,</span> max.col<span class="punctuation">(</span><span class="operator">!</span><span class="built_in">is.na</span><span class="punctuation">(</span>domain_list<span class="punctuation">[</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span> ties.method <span class="operator">=</span> <span class="string">&quot;last&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">## 合并行</span></span><br><span class="line">domain_list<span class="operator">$</span>new_NEW <span class="operator">&lt;-</span> domain_list<span class="punctuation">[</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">[</span>cbind<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>nrow<span class="punctuation">(</span>domain_list<span class="punctuation">)</span><span class="punctuation">,</span> max.col<span class="punctuation">(</span><span class="operator">!</span><span class="built_in">is.na</span><span class="punctuation">(</span>domain_list<span class="punctuation">[</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span> ties.method <span class="operator">=</span> <span class="string">&quot;last&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## freq again</span></span><br><span class="line">domain_list <span class="operator">&lt;-</span> as.data.frame<span class="punctuation">(</span>table<span class="punctuation">(</span>domain_list<span class="operator">$</span>new_NEW<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">domain_list <span class="operator">&lt;-</span> plyr<span class="operator">::</span>arrange<span class="punctuation">(</span>domain_list<span class="punctuation">,</span> desc<span class="punctuation">(</span>domain_list<span class="operator">$</span>Freq<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">domain_list <span class="operator">&lt;-</span> domain_list<span class="punctuation">[</span><span class="operator">!</span>stri_detect_regex<span class="punctuation">(</span>domain_list<span class="operator">$</span>Var1<span class="punctuation">,</span> <span class="string">&quot;com|org|net|edu|gov|mil&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line"><span class="comment">## 打印前10行</span></span><br><span class="line">head<span class="punctuation">(</span>domain_list<span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 绘制域名</span></span><br><span class="line">domain_list_plot <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data<span class="operator">=</span>domain_list<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">20</span><span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">,</span> aes<span class="punctuation">(</span>x<span class="operator">=</span>reorder<span class="punctuation">(</span>Var1<span class="punctuation">,</span> Freq<span class="punctuation">)</span><span class="punctuation">,</span> y<span class="operator">=</span>Freq<span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line">domain_list_plot <span class="operator">&lt;-</span> domain_list_plot <span class="operator">+</span> geom_bar<span class="punctuation">(</span>stat <span class="operator">=</span> <span class="string">&quot;identity&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> coord_flip<span class="punctuation">(</span>ylim<span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> theme<span class="punctuation">(</span></span><br><span class="line">  axis.text.y <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">14</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">  axis.text.x <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">14</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line">domain_list_plot <span class="operator">&lt;-</span> domain_list_plot <span class="operator">+</span> xlab<span class="punctuation">(</span><span class="string">&quot;域名Top数&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> ylab<span class="punctuation">(</span><span class="string">&quot;特殊域名数&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> ggtitle<span class="punctuation">(</span><span class="string">&quot;从黑客邮件列表中能发现多少域名分布？&quot;</span><span class="punctuation">)</span></span><br><span class="line">domain_list_plot <span class="operator">&lt;-</span> domain_list_plot <span class="operator">+</span> scale_y_continuous<span class="punctuation">(</span>breaks <span class="operator">=</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">100</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 生成图形</span></span><br><span class="line">domain_list_plot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从图形中看，cz（捷克Czech Republic）归属的比较特别，统计看一下</span></span><br><span class="line">splitted_email_czech <span class="operator">&lt;-</span> splitted_email<span class="punctuation">[</span>grepl<span class="punctuation">(</span><span class="string">&quot;.cz&quot;</span><span class="punctuation">,</span> splitted_email<span class="operator">$</span>X2<span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">head<span class="punctuation">(</span>splitted_email_czech<span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="样例2：贝叶斯统计理论探讨"><a href="#样例2：贝叶斯统计理论探讨" class="headerlink" title="样例2：贝叶斯统计理论探讨"></a>样例2：贝叶斯统计理论探讨</h4><p>原文参考：<a href="https://www.statsjoke.me/posts/philosophy-of-bayesian-statistics/">https://www.statsjoke.me/posts/philosophy-of-bayesian-statistics/</a></p>
<h5 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h5><h6 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h6><p><img data-src="a93eddc5/Bayes_Theorem.jpg" alt="贝叶斯定理"></p>
<h6 id="伯努利分布"><a href="#伯努利分布" class="headerlink" title="伯努利分布"></a>伯努利分布</h6><p><img data-src="a93eddc5/Bernoulli_distribution.jpg" alt="伯努利分布"></p>
<h6 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h6><p><img data-src="a93eddc5/Binomial_pdf.jpg" alt="二项式定理"></p>
<h6 id="β分布"><a href="#β分布" class="headerlink" title="β分布"></a>β分布</h6><p><img data-src="a93eddc5/Beta_pdf.jpg" alt="β定理"></p>
<h5 id="探究课题"><a href="#探究课题" class="headerlink" title="探究课题"></a>探究课题</h5><p>通过模拟硬币反转来绘制这项后验概率的更新图<br>代码片段如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置随机种子</span></span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">1234</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 随机样本次数</span></span><br><span class="line">n_trials <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">,</span> <span class="number">50</span><span class="punctuation">,</span> <span class="number">500</span><span class="punctuation">,</span> <span class="number">1000</span><span class="punctuation">,</span> <span class="number">2000</span><span class="punctuation">,</span> <span class="number">5000</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 设置二项分布</span></span><br><span class="line">data <span class="operator">&lt;-</span> rbinom<span class="punctuation">(</span>n_trials<span class="punctuation">[</span><span class="built_in">length</span><span class="punctuation">(</span>n_trials<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">)</span></span><br><span class="line">x <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> length.out<span class="operator">=</span><span class="number">100</span><span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>N <span class="keyword">in</span> n_trials<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  heads <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>data<span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span>N<span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># β</span></span><br><span class="line">  y <span class="operator">&lt;-</span> dbeta<span class="punctuation">(</span>x<span class="punctuation">,</span> <span class="number">1</span><span class="operator">+</span>heads<span class="punctuation">,</span> <span class="number">1</span><span class="operator">+</span>N<span class="operator">-</span>heads<span class="punctuation">)</span></span><br><span class="line">  plot<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&#x27;l&#x27;</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span></span><br><span class="line">  legend<span class="punctuation">(</span><span class="string">&#x27;topright&#x27;</span><span class="punctuation">,</span> sprintf<span class="punctuation">(</span><span class="string">&quot;observe %d tosses,\n %d heads&quot;</span><span class="punctuation">,</span> N<span class="punctuation">,</span> heads<span class="punctuation">)</span><span class="punctuation">,</span> bg<span class="operator">=</span><span class="string">&#x27;transparent&#x27;</span><span class="punctuation">,</span> box.lty<span class="operator">=</span><span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">  <span class="comment"># 绘制斜线</span></span><br><span class="line">  abline<span class="punctuation">(</span>v<span class="operator">=</span><span class="number">0.5</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> lwd<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>观察每次样本数后的的分布图<br><img data-src="a93eddc5/AutoCapture_2019-12-28_014018.jpg" alt="1"><br><img data-src="a93eddc5/AutoCapture_2019-12-28_014024.jpg" alt="2"><br><img data-src="a93eddc5/AutoCapture_2019-12-28_014028.jpg" alt="3"><br><img data-src="a93eddc5/AutoCapture_2019-12-28_014034.jpg" alt="4"><br><img data-src="a93eddc5/AutoCapture_2019-12-28_014039.jpg" alt="5"><br><img data-src="a93eddc5/AutoCapture_2019-12-28_014044.jpg" alt="6"><br><img data-src="a93eddc5/AutoCapture_2019-12-28_014049.jpg" alt="7"></p>
<p>可以看出，随着样本数的不断增加，可以得出概率越来越趋近p = 0.5，尽管不是全部。</p>
<p>一个简单的贝叶斯推断：</p>
<ul>
<li>先验概率：P(A) = p</li>
<li>后验概率：P(A|X)</li>
<li>P(X|A)</li>
<li>P(X)</li>
</ul>
<p>推理如下图所示：<br><img data-src="a93eddc5/Bayesian_Inference1.jpg" alt="Bayesian Inference1"></p>
<p>近似为：P(X| ~ A) = 0.5，因此：<br><img data-src="a93eddc5/Bayesian_Inference2.jpg" alt="Bayesian Inference2"></p>
<p>演示代码为：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> length.out <span class="operator">=</span> <span class="number">50</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>p<span class="punctuation">,</span> <span class="number">2</span><span class="operator">*</span>p<span class="operator">/</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">+</span>p<span class="punctuation">)</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="string">&#x27;blue&#x27;</span><span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;l&#x27;</span><span class="punctuation">,</span>xlab <span class="operator">=</span> <span class="string">&#x27;Prior&#x27;</span><span class="punctuation">,</span>ylab <span class="operator">=</span> <span class="string">&#x27;Posterior&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>RStudio中演示为<br><img data-src="a93eddc5/Bayesian_Inference3.jpg" alt="Bayesian Inference3"></p>
<h5 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h5><h6 id="概率质量函数"><a href="#概率质量函数" class="headerlink" title="概率质量函数"></a>概率质量函数</h6><p><img data-src="a93eddc5/probability_mass_function.jpg" alt="probability mass function"></p>
<p>示例代码：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a <span class="operator">&lt;-</span> 0<span class="operator">:</span><span class="number">15</span></span><br><span class="line">lambda <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1.5</span><span class="punctuation">,</span> <span class="number">4.25</span><span class="punctuation">)</span></span><br><span class="line">barplot<span class="punctuation">(</span>dpois<span class="punctuation">(</span>a<span class="punctuation">,</span> lambda<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span> names.arg <span class="operator">=</span> a<span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&#x27;#348ABD&#x27;</span><span class="punctuation">)</span></span><br><span class="line">barplot<span class="punctuation">(</span>dpois<span class="punctuation">(</span>a<span class="punctuation">,</span> lambda<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">,</span> names.arg <span class="operator">=</span> a<span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&#x27;#A60628&#x27;</span><span class="punctuation">,</span> add <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line">legend<span class="punctuation">(</span><span class="string">&#x27;topright&#x27;</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;lambda=1.5&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;lambda=4.25&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;#348ABD&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;#A60628&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img data-src="a93eddc5/Poisson_Distribution.jpg" alt="Poisson Distribution"></p>
<h5 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h5><h6 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h6><p><img data-src="a93eddc5/probability_density_function.jpg" alt="probability density function"></p>
<p>示例代码：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> length.out <span class="operator">=</span> <span class="number">100</span><span class="punctuation">)</span></span><br><span class="line">lambda <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>a<span class="punctuation">,</span> dexp<span class="punctuation">(</span>a<span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&#x27;#348ABD&#x27;</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&#x27;l&#x27;</span><span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="string">&#x27;z&#x27;</span><span class="punctuation">,</span> ylab <span class="operator">=</span> <span class="string">&#x27;PDF at z&#x27;</span><span class="punctuation">,</span> ylim <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">lines<span class="punctuation">(</span>a<span class="punctuation">,</span> dexp<span class="punctuation">(</span>a<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&#x27;#A60628&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img data-src="a93eddc5/Exponential_Distribution.jpg" alt="Exponential Distribution"></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1] R (programming language):[EB/OL]. 2004.10[2019-12]. <a href="https://en.wikipedia.org/wiki/R_(programming_language)">https://en.wikipedia.org/wiki/R_(programming_language)</a><br>[2] About RStudio:[EB/OL]. [2019-12]. <a href="https://rstudio.com/about/">https://rstudio.com/about/</a><br>[3] An Introduction to R:Notes On R: A Programming Environment for Data Analysis And Graphics.[EB/OL].2019.12.12[2019-12]. <a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/doc/manuals/r-release/R-intro.pdf">https://mirrors.tuna.tsinghua.edu.cn/CRAN/doc/manuals/r-release/R-intro.pdf</a></p>
]]></content>
      <categories>
        <category>统计分析</category>
      </categories>
      <tags>
        <tag>统计学</tag>
        <tag>R语言</tag>
        <tag>RStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习相关-词组</title>
    <url>/post/71e5bb42.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>看抖音有段时间了，上面有很多做英语的自媒体，关注的其中一个@Joey_The_Monster会罗列相关短语以及相关情景句子。这里搬到自己的博客里面，也算是为后续记忆背诵所用。</p>
<h3 id="正文大类"><a href="#正文大类" class="headerlink" title="正文大类"></a>正文大类</h3><h4 id="跟规则-rules-相关的谚语"><a href="#跟规则-rules-相关的谚语" class="headerlink" title="跟规则(rules)相关的谚语"></a>跟规则(rules)相关的谚语</h4><ol>
<li><em>a bird in the hand is worth two in the bush</em><br> <strong>翻译：</strong>两鸟在林不如一鸟在手<br> <em>Example1:</em> You know there’s such a saying that “a bird in the hand is worth two in the bush”, and so it’s a dividend in hand is worth a dividend stream farther along. </li>
<li><em>the exception proves the rule</em><br> <strong>翻译：</strong>足以证明普遍性的例外<br> <em>Example1:</em> I actually am intentionally disobeying my own rule right now. So, the exception proves the rule.</li>
<li><em>rules are made to be broken</em><br> <em>Example1:</em> The normal rules have gone out the window.<br> <em>Example2:</em> You know the rules are made be broken, if you like.</li>
<li><em>early to bed and early to rise wakes a man, healthey, wealthy and wise</em><br> <em>Example1:</em> And the forth myth is early to bed and early to rise wakes a man, healthey, wealthy and wise.</li>
</ol>
<h4 id="跟机会-opportunities-相关的谚语"><a href="#跟机会-opportunities-相关的谚语" class="headerlink" title="跟机会(opportunities)相关的谚语"></a>跟机会(opportunities)相关的谚语</h4><ol>
<li><em>make hay while the sun shines</em><br> <strong>翻译:</strong> 趁热打铁，勿失良机<br> <em>Example1:</em> We should go, let’s make hay while the sun shines.</li>
<li><em>While the going gets tough, the tough get going</em><br> <strong>翻译:</strong> 艰难之路，唯勇者行<br> <em>example1:</em> But I do remember Vince Lombardi saying that When the going gets tough, the tough get going.</li>
<li><em>When the cat is away, the mice will play</em><br> <strong>翻译：</strong> 阎王不在，小鬼跳梁<br> <em>example1:</em> When the cat is away, the mice will play. And this weeks sees “July days” at home chaos in the stress of Petrograd.</li>
<li><em>eat, drink, and be merry</em><br> <strong>翻译：</strong> 及时行乐<br> <em>example1:</em> And I would say to my soul: Soul, you have may goods laid up for many years. Take your ease, eat, drink and be merry.</li>
<li><em>strike while the iron is hot</em><br> <strong>翻译：</strong> 趁热打铁<br> <em>example:</em> Everyone is telling me, You gotta strike while the iron is hot. Sign with the label, put out an album in two weeks. And milk it while it’s hot.</li>
<li><em>Every cloud has a silver lining</em><br> <strong>翻译:</strong> 黑暗中总有一丝曙光<br> <em>example:</em> Good thing is by then the Earth won’t even be inhabitable due to our sun expanding. Every cloud has a silver lining, I guess.</li>
</ol>
<span id="more"></span>

<h4 id="跟复仇-revenge-相关的谚语"><a href="#跟复仇-revenge-相关的谚语" class="headerlink" title="跟复仇(revenge)相关的谚语"></a>跟复仇(revenge)相关的谚语</h4><ol>
<li><em>Don’t cut your nose off to spite your face</em><br> <strong>翻译:</strong> 别跟自己过不去<br> <em>example:</em> She said basically “Don’t cut your nose off to spite your face before he’s got the funding”.</li>
<li><em>Dead men tell no tables</em><br> <strong>翻译：</strong> 死无对证<br> <em>example:</em> <Dead men tell no tales> is set to be released in 2017.</li>
<li><em>He who laughs last laughs best</em><br> <strong>翻译：</strong> 不要高兴的太早<br> <em>example:</em> He who laughs last laughs best they say. So I actually don’t know yet.</li>
<li><em>Don’t get mad get even</em><br> <strong>翻译：</strong> 持其志毋暴其气<br> <em>example:</em> If somebody wrongs you, sue them. You know, don’t get mad, get even.</li>
<li><em>Revenge is sweet</em><br> <strong>翻译：</strong> 大块人心<br> <em>example:</em> And it was Alfred Hitchcock who rejoiced that revenge is sweet.</li>
<li><em>If you sit by the river long enough</em><br> <strong>翻译：</strong> 按兵不动<br> <em>example:</em> “If you sit by the river long enough, the bodies of your enemies will float by.” - Sun Tzu</li>
</ol>
<h4 id="跟起止-beginnings-and-endings-相关的谚语"><a href="#跟起止-beginnings-and-endings-相关的谚语" class="headerlink" title="跟起止(beginnings and endings)相关的谚语"></a>跟起止(beginnings and endings)相关的谚语</h4><ol>
<li><em>There’s always a first time</em><br> <strong>翻译：</strong>凡事都有第一次<br> <em>example:</em> But so what? There’s always a first time.</li>
<li><em>Great oaks from little acorns grow</em><br> <strong>翻译：</strong>万丈高楼平地起<br> <em>example:</em> In science, great oaks from little acorns grow.</li>
<li><em>A/The journey of a thousand miles begins with a single step</em><br> **翻译:**千里之行始于足下1<br> <em>example:</em> </li>
<li><em>All’s well that ends well</em><br> **翻译:**结果好一切都好<br> <em>example:</em></li>
<li><em>What you sow you will reap</em><br> <strong>翻译：</strong>种瓜得瓜，种豆得豆</li>
</ol>
<h4 id="同义替换之-I-can-and-I-can’t"><a href="#同义替换之-I-can-and-I-can’t" class="headerlink" title="同义替换之- I can and I can’t"></a>同义替换之- I can and I can’t</h4><ol>
<li><em>I’m an expert at doing sth.</em><br> <strong>翻译：</strong>我在某方面是个专家<br> <em>example:</em> I’m an expert at managing my time</li>
<li><em>I can’t … to save my life.</em><br> <strong>翻译：</strong>我完全做不了某事<br> <em>example1:</em> I can’t draw things, you know to save my life.<br> <em>example2:</em> I can’t do “UI” to save my life.</li>
<li><em>I can … in my sleep.</em><br> **翻译:**我闭着眼睛都能做谋事<br> <em>example:</em> I can write in my sleep.</li>
<li><em>I don’t know the first thing about …</em><br> <strong>翻译:</strong> 关于 … 我一窍不通<br> <em>example:</em> because I thought I don’t know the first thing about this.</li>
<li><em>I have a knack for …</em><br> <strong>翻译：</strong> 我掌握做 … 的要领<br> <em>example:</em> I don’t know if I have a knack for this.</li>
<li><em>I’m not much of a …</em><br> <strong>翻译：</strong> 我算不上是个 …<br> <em>example1:</em> My wife will tell you, I’m not much of cook.<br> <em>example2:</em> Now I am not much of a photographer, But as a You-tuber I have to learn the ins and outs of Photoshop to create my thumbnails.</li>
</ol>
<h4 id="同义词替换之-different"><a href="#同义词替换之-different" class="headerlink" title="同义词替换之-different"></a>同义词替换之-different</h4><ol>
<li><em>chalk and cheese</em><br> <strong>翻译：</strong> 截然不同<br> <em>example:</em> But the two bikes feel like chalk and cheese</li>
<li><em>There’s a world of difference between A and B</em><br> <strong>翻译：</strong> A与B有着天壤之别<br> <em>example:</em> But there’s a world of difference between stress and disappointment.</li>
<li><em>A bears no relation to B</em><br> <strong>翻译:</strong> A与B毫无关系<br> <em>example:</em> The Council Tax is regressive, because it bears no relation to the person’s ablility to pay.</li>
<li><em>What A apart from B is</em><br> <strong>翻译:</strong> A与B的不同之处在于<br> <em>example:</em> Try to pinpoint what it is that sets them apart from their miserable neighbors and friends.</li>
<li><em>one of the distinguishing features is</em><br> <strong>翻译:</strong> 其中一个最不同之处在于…<br> <em>example:</em> One of the most distinguishing features is Kenyanthripist platyops is that is has the smallest upper M2</li>
<li><em>A bears a strking resemblance to B</em><br> <strong>翻译:</strong> A与B有一点极为相似<br> <em>example:</em> What always struck me interesting about the transcript is that bears a striking resemblance one of these.</li>
</ol>
<h4 id="如何更好的回答之“频率篇（how-often）”"><a href="#如何更好的回答之“频率篇（how-often）”" class="headerlink" title="如何更好的回答之“频率篇（how often）”"></a>如何更好的回答之“频率篇（how often）”</h4><ol>
<li><em>I’ve never been known to *<br> *</em>翻译:** 我从来没做过<br> <em>example:</em> And it even brought me to speak out against a teacher. Something I’ve never been known to do.</li>
<li><em>Once in a blun moon</em><br> <strong>翻译:</strong> 几乎不可能做<br> <em>example:</em> And once in a blue moon, you’ll think about it.</li>
<li><em>on and off</em><br> <strong>翻译：</strong> 断断续续地做<br> <em>example:</em> They were chatting a little bit on and off. You know, that happens sometimes.</li>
<li><em>every now and again</em><br> <strong>翻译:</strong> 偶尔做<br> <em>example:</em> I tell them a few stories every now and again.</li>
<li><em>every so offen</em><br> <strong>翻译：</strong> 经常做<br> <em>example:</em> So I have to compromise every so ofen? We all do</li>
<li><em>whenever I get the chance</em><br> <strong>翻译：</strong> Whenever I get the chance, I encourage colleagues</li>
<li><em>hundreds of times</em><br> <strong>翻译：</strong> There’s too much rain water, whick happens hundreds of times a year.</li>
</ol>
<h4 id="地道表达“排名最高篇（the-highest-ranking）”"><a href="#地道表达“排名最高篇（the-highest-ranking）”" class="headerlink" title="地道表达“排名最高篇（the highest ranking）”"></a>地道表达“排名最高篇（the highest ranking）”</h4><ol>
<li><em>the pick of the bunch</em><br> <strong>翻译：</strong> 最好的东西<br> <em>example:</em> In my opinion, the throne seats are the pick of the bunch.</li>
<li><em>head and shoulders above the rest</em><br> <strong>翻译：</strong> 远远超过其他的<br> <em>example1:</em> CDW stands head and shoulders above the rest.<br> <em>example2:</em> One that stands head and shoulders above the rest in terms of quality. </li>
<li><em>streets ahead of everyone else</em><br> <strong>翻译：</strong> 甩其他几条街<br> <em>example:</em> The Chinese were streets ahead of everyone else.</li>
<li><em>You can’t beat sth. for …</em><br> <strong>翻译：</strong> 就…而言，sth.是无法超越的<br> <em>example:</em> You can’t beat if for the deep violet color.</li>
<li><em>nothing compares to …</em><br> <strong>翻译：</strong> 没什么能和…相提并论<br> <em>example:</em> Nothing compares to the love that I have for my 2-year-old daughter.</li>
<li><em>sth. takes the cake</em><br> <strong>翻译：</strong> 说做好事的时候：名列第一；讲坏事的时候：坏到极点。<br> <em>example1:</em> Language is awesome and that takes the cake.<br> <em>example2:</em> These take the cake for the worst.  </li>
</ol>
<h4 id="同义词替换之如果（if）"><a href="#同义词替换之如果（if）" class="headerlink" title="同义词替换之如果（if）"></a>同义词替换之如果（if）</h4><ol>
<li><em>Provided that</em><br> <strong>翻译：</strong> 如果，只要<br> <em>example:</em> We are going to be able to have a pretty good estimation again, provided that the child gets proper heath care.</li>
<li><em>On condition that</em><br> <strong>翻译：</strong> 若是，前提是<br> <em>example:</em> Austria-Hungary agreed to its terms on condition that the Empire gets part of the food supplies.</li>
<li><em>supposing that</em><br> <strong>翻译：</strong> 假设<br> <em>example:</em> Now supposing that one of you is a national of another member state.</li>
<li><em>as long as</em><br> <strong>翻译：</strong> 只要…<br> <em>example:</em> As long as it was extra-curricular and not my focus it felt safe.</li>
</ol>
<h4 id="跟“违法相关（criminal-activities）”的习语表达"><a href="#跟“违法相关（criminal-activities）”的习语表达" class="headerlink" title="跟“违法相关（criminal activities）”的习语表达"></a>跟“违法相关（criminal activities）”的习语表达</h4><ol>
<li><em>pull the wool over somebody’s eyes</em><br> <strong>翻译：</strong> 欺骗某人眼睛<br> <em>example:</em> We can see how some normal people have the wool totally pulled over their eyes. </li>
<li><em>an inside job</em><br> <strong>翻译：</strong> 有内鬼<br> <em>example:</em> Consipiracy theory that 9-11 attacks were an inside job.</li>
<li><em>be talking someone for a ride</em><br> <strong>翻译：</strong> 欺骗某人<br> <em>example:</em> This guy was taking us for a ride.</li>
<li><em>be lining someones’ own pockets</em><br> <strong>翻译：</strong> 用不光彩的手段肥了某人自己的腰包<br> <em>example:</em> Many of its leaders have apparently been lining their own pockets</li>
<li><em>do a runner</em><br> <strong>翻译：</strong> 为了躲避而逃跑<br> <em>example:</em> The schemer will take off with everybody’s money and do a runner.</li>
<li><em>under the counter</em><br> <strong>翻译：</strong> 秘密地、非法地<br> <em>example:</em> Lucy was arrested after she was found selling things under the counter last year.</li>
</ol>
<h4 id="跟“智慧（wisdom）”相关的表达"><a href="#跟“智慧（wisdom）”相关的表达" class="headerlink" title="跟“智慧（wisdom）”相关的表达"></a>跟“智慧（wisdom）”相关的表达</h4><ol>
<li><em>penny wise and pound foolish</em><br> <strong>翻译：</strong> 省小钱，花大钱<br> <em>example:</em> It’s one of these sorta penny wise pound foolish measures.</li>
<li><em>misery loves company</em><br> <strong>翻译：</strong> 不快乐的人也喜欢别人不快乐<br> <em>example:</em> You’re assuming that misery loves company and that may not be true.</li>
<li><em>the more, the merrier</em><br> <strong>翻译：</strong> 人越多越有意思<br> <em>example:</em> We actually look forward to the volatility, The more, The merrier.</li>
<li><em>laughter is the best medicine</em><br> <strong>翻译：</strong> 欢笑是良药<br> <em>example1:</em> Of course, we all know laughter is the best medicine.<br> <em>example2:</em> Laughter is the best medicine,  it’s definitely good advice to live by. </li>
<li><em>What’s sauce for the goose is the sauce for the gander</em><br> <strong>翻译：</strong> 适用于此着也应适用于彼，应该一视同仁<br> <em>example:</em> What’s the sauce for the goose is sauce for the gander later on.</li>
</ol>
<h4 id="老话说得好之“行为篇”"><a href="#老话说得好之“行为篇”" class="headerlink" title="老话说得好之“行为篇”"></a>老话说得好之“行为篇”</h4><ol>
<li><em>Honesty is the best policy</em><br> <strong>翻译：</strong> 诚实是上策<br> <em>example:</em> </li>
<li><em>You can’t please everyone</em><br> <strong>翻译：</strong> 你不可能讨好每个人<br> <em>example:</em> Everyone has their’s opition and you can’t please everyone.</li>
<li><em>When in Rome, do as the Romans do</em><br> <strong>翻译：</strong> 入乡随俗<br> <em>example:</em> Somehow the mindset that When in Romes, do as the Romans do is accepted in this part of the world.</li>
<li><em>If the shoe fits, wear it; OR, if the shoe fits, kick it off</em><br> <strong>翻译：</strong> 如果这样就接收，或者，如果是这样就踢开<br> <em>example:</em> </li>
<li><em>One might as well be hanged for a sheep as a lamb</em><br> <strong>翻译：</strong> 一不做二不休<br> <em>example:</em> I’m gonna get it anyway as well be hanged for a sheep as a lamb.</li>
<li><em>Evil communications corrupt good manners</em><br> <strong>翻译：</strong> 近朱者赤近墨者黑<br> <em>example:</em> </li>
</ol>
<h4 id="老话说得好之“谨言慎行篇-discretion-and-caution-”"><a href="#老话说得好之“谨言慎行篇-discretion-and-caution-”" class="headerlink" title="老话说得好之“谨言慎行篇(discretion and caution)”"></a>老话说得好之“谨言慎行篇(discretion and caution)”</h4><ol>
<li><em>Discretion is the better part of valor</em><br> <strong>翻译：</strong> 勇者贵在谨慎<br> <em>example:</em> John hears about the assassionation attempt and he decides that discretion is the better part of valor.</li>
<li><em>least said, soonest mended</em><br> <strong>翻译：</strong> （对于坏事）议论越少，忘得越快<br> <em>example:</em> </li>
<li><em>See no evil, hear no evil, speak no evil</em><br> <strong>翻译：</strong> 非礼勿视，非礼勿听，非礼勿言</li>
<li><em>let the buyer beware</em><br> <strong>翻译：</strong> 货已售出，责任买家字符<br> <em>example:</em> Today I’d like to talk to you about “Caveat Emptor”, Let the buyer beware.</li>
<li><em>Be careful what you pray for. You might just get it</em><br> <strong>翻译：</strong> 注意你的所愿，很有可能就会实现<br> <em>example:</em> </li>
<li><em>Measure twice, cut once</em><br> <strong>翻译：</strong> 三思而后行<br> <em>example:</em> </li>
</ol>
<h4 id="智者曾云之“勤奋篇”"><a href="#智者曾云之“勤奋篇”" class="headerlink" title="智者曾云之“勤奋篇”"></a>智者曾云之“勤奋篇”</h4><p>A wise man once said - diligence</p>
<ol>
<li><em>A bad workman always blames his tools</em><br> <strong>翻译：</strong> 人笨怪刀钝<br> <em>example:</em> The chimney isn’t drying properly the oven’s not hot enough. - Oh, a bad workman always blames his tools. –<Downton Abbey></li>
<li><em>Never send a boy to do a man’s job</em><br> <strong>翻译：</strong> 把工作留给能胜任的人去做吧<br> <em>example:</em> </li>
<li><em>Cannot make bricks without clay</em><br> <strong>翻译：</strong> 巧妇难为无米之炊<br> <em>example:</em> </li>
<li><em>The laborer is worthy of this hire</em><br> <strong>翻译：</strong> 做了工，就该得了报酬<br> <em>example:</em> </li>
<li><em>If it is worth doing, it is worth doing well</em><br> <strong>翻译：</strong> 值得做的事，就要把它做好<br> <em>example:</em> - Three is quite a lot. That’s pretty potent stuff. - If a thing’s worth doing, it’s worth doing well. –<Gentlemen Prefer Blondes>(1953)</li>
<li><em>business before pleasure</em><br> <strong>翻译：</strong> 事业在先，享乐在后<br> <em>example:</em> </li>
</ol>
<h4 id="智者曾云之“身体健康篇”"><a href="#智者曾云之“身体健康篇”" class="headerlink" title="智者曾云之“身体健康篇”"></a>智者曾云之“身体健康篇”</h4><p>A wise man once said - physical wellbeing</p>
<ol>
<li><em>A stitch in time saves nine</em><br> <strong>翻译：</strong> 及时行事，事半功倍<br> <em>example:</em> Another one is that a stitch in time saves nine</li>
<li><em>You are what you eat</em><br> <strong>翻译：</strong> 人如其食<br> <em>example:</em> You are what you eat refers to food one it has entered the body</li>
<li><em>Feed a cold and starve a fever</em><br> <strong>翻译：</strong> 伤风时宜吃，发热时宜饿<br> <em>example:</em> </li>
<li><em>Never let the sun go down on your anger</em><br> <strong>翻译：</strong> 不要含怒到日落<br> <em>example:</em> You should never let the sun go down on your anger.</li>
<li><em>Hunger is the best sauce</em><br> <strong>翻译：</strong> 饥饿是最好的调料（饥不择食）<br> <em>example:</em> </li>
<li><em>Appetite comes with eating</em><br> <strong>翻译：</strong> 开吃才会有食欲（事情做了，才能知道它的乐趣）<br> <em>example:</em> </li>
</ol>
<h4 id="智者曾云之“做了错事之人篇”"><a href="#智者曾云之“做了错事之人篇”" class="headerlink" title="智者曾云之“做了错事之人篇”"></a>智者曾云之“做了错事之人篇”</h4><p>A wise man once said wrong-doers</p>
<ol>
<li><em>To err is human to forgive divine</em><br> <strong>翻译：</strong> 人非圣贤，孰能无过<br> <em>example:</em> </li>
<li><em>A guilty conscience needs no accuser</em><br> <strong>翻译：</strong> 做贼心虚<br> <em>example:</em> The he started to ovethingk things. - A guity conscience needs no accuser.</li>
<li><em>Set a thief to catch a thief</em><br> <strong>翻译：</strong> 以毒攻毒<br> <em>example:</em> That’s why you come in, Set a thief to catch a theif. - I am NOT a theaf.</li>
<li><em>Old sins cast long shadows</em><br> <strong>翻译：</strong> 罪孽贻害，世世代代<br> <em>example:</em> </li>
<li><em>A bad penny always turns up</em><br> <strong>翻译：</strong> 阴魂不散<br> <em>example:</em> -I’ve never expected to see you agian. -I’m like a bad penny, I always turn up.</li>
<li><em>Cheates never prosper</em><br> <strong>翻译：</strong> 骗子必将遭报应<br> <em>example:</em>  </li>
</ol>
<h4 id="老话说得好之“半边天篇”"><a href="#老话说得好之“半边天篇”" class="headerlink" title="老话说得好之“半边天篇”"></a>老话说得好之“半边天篇”</h4><p>As the proverb goes - half the sky</p>
<ol>
<li><em>The hand that rocks the cradle rules the world</em><br> <strong>翻译：</strong> 摇摇篮的手统治者世界（强调母亲对孩子的深远影响）<br> <em>example:</em> </li>
<li><em>A woman’s work is never done</em><br> <strong>翻译：</strong> 女人总在相夫教子，勤俭持家<br> <em>example:</em> A man’s wokr is till set of sun, but a woman’s work is never done.</li>
<li><em>Always a bridesmaid, never a bird</em><br> <strong>翻译：</strong> 总是绿叶，何时才能当红花<br> <em>example:</em> </li>
<li><em>You can’t lose what you never had</em><br> <strong>翻译：</strong> 不曾拥有，就谈不上失去<br> <em>example:</em> You can’t lose what you never had or never would’ve had</li>
<li><em>You can’t win them all</em><br> <strong>翻译：</strong> 有得必有失<br> <em>example:</em> </li>
</ol>
<h4 id="智者曾云之“神神叨叨篇”"><a href="#智者曾云之“神神叨叨篇”" class="headerlink" title="智者曾云之“神神叨叨篇”"></a>智者曾云之“神神叨叨篇”</h4><p>A wise man said - superstition</p>
<ol>
<li><em>one for sorrow, two for mirth/joy</em><br> <strong>翻译：</strong> 一只报忧，两只报喜<br> <em>example:</em> </li>
<li><em>Bad things come in three</em><br> <strong>翻译：</strong> 祸不单行<br> <em>example:</em> What’s wrong with me? Do I have to sign on my head that says “Cheat on Me”? I mean no surprise from Ashely, but Kyle. And since bad things come in threes.</li>
<li><em>third time lucky</em><br> <strong>翻译：</strong> 好事第三次<br> <em>example:</em> </li>
<li><em>Success has many fathers</em><br> <strong>翻译：</strong> 得道多助<br> <em>example:</em> Success has many fathers, failure is an orphan.</li>
<li><em>Lucky in cards, unlucky in love</em><br> <strong>翻译：</strong> 赌场得意，情场失意</li>
<li><em>Walls have ears</em><br> <strong>翻译：</strong> 隔墙有耳<br> <em>example:</em> -You don’t think I would betray you anyway? -Walls have ears.</li>
</ol>
<h4 id="老话说得好之“宅家真好篇”"><a href="#老话说得好之“宅家真好篇”" class="headerlink" title="老话说得好之“宅家真好篇”"></a>老话说得好之“宅家真好篇”</h4><p>As the old saying goes - home sweet home</p>
<ol>
<li><em>Charity begins at home</em><br> <strong>翻译：</strong> 仁爱始于家庭<br> <em>example:</em> </li>
<li><em>A Englishmans’ house is his castle</em><br> <strong>翻译：</strong> 英国人的家就是他的城堡（英国人人为在自己家里有权做自己想做的事情）<br> <em>example:</em> </li>
<li><em>Home is where the heart is</em><br> <strong>翻译：</strong> 心安即是家<br> <em>example:</em> Till the light in your eyes showed me, I was almost, home is where the heart is, And my heart is goes with you.</li>
<li><em>There is no place like home</em><br> <strong>翻译：</strong> 金窝银窝不如狗窝<br> <em>example:</em> </li>
<li><em>East or West, home is the best</em><br> <strong>翻译：</strong> 走东串西，还是家里最好<br> <em>example:</em> </li>
<li><em>The chicken have come home to roost</em><br> <strong>翻译：</strong> 恶因结恶果<br> <em>example:</em> </li>
<li><em>A house divided against itself cannot stand</em><br> <strong>翻译：</strong> 家和万事兴<br> <em>example:</em> </li>
</ol>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>词组</tag>
        <tag>短句</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7基础操作相关</title>
    <url>/post/ca10a347.html</url>
    <content><![CDATA[<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure>

<h4 id="安装网络工具"><a href="#安装网络工具" class="headerlink" title="安装网络工具"></a>安装网络工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install net-tools</span><br></pre></td></tr></table></figure>
<h4 id="找不到yum-config-manager"><a href="#找不到yum-config-manager" class="headerlink" title="找不到yum-config-manager"></a>找不到yum-config-manager</h4><p>直接安装：yum-utils即可</p>
<h3 id="环境相关"><a href="#环境相关" class="headerlink" title="环境相关"></a>环境相关</h3><h4 id="配置Java8"><a href="#配置Java8" class="headerlink" title="配置Java8"></a>配置Java8</h4><ol>
<li>从Oracle官网下载相应版本的64位JDK压缩包，通常是<strong>tar.gz</strong>结尾</li>
<li>通过SFTP工具上传至CentOS后台指定目录下，如：<strong>\usr\java</strong></li>
<li>解压目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u211-linux-x64.tar.gz </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="4">
<li>配置环境变量：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例解压在/usr/java/jdk1.8.0_211目录下</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结尾添加</span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_211</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存退出后</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="修改IP地址"><a href="#修改IP地址" class="headerlink" title="修改IP地址"></a>修改IP地址</h4><p>直接修改<strong>ifcfg-ens**</strong>相关文件即可，表示通配，实际值需要在实际环境中观察。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens192</span><br></pre></td></tr></table></figure>

<p>如同下图所示，将<strong>BOOTPROTO</strong>改为static(静态路由)，在结尾添加指定的静态IP、子网掩码、默认网关以及DNS信息。<br><img data-src="ca10a347/config_ipv4.jpg" alt="设置IP地址"></p>
<h4 id="修改更新源"><a href="#修改更新源" class="headerlink" title="修改更新源"></a>修改更新源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份原有系统源</span></span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取阿里云repo</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果发现wget找不到，那是没有安装wget，此时repo已经重名吧了，再次通过yum安装失败的，只需要反过来在将backup文件重命名为原来的repo即可</span></span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行yum makecache生成缓存</span></span><br><span class="line">yum makecache</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新</span></span><br><span class="line">yum -y update</span><br></pre></td></tr></table></figure>


<h3 id="基础服务相关"><a href="#基础服务相关" class="headerlink" title="基础服务相关"></a>基础服务相关</h3><h4 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h4><h5 id="添加MySQL-YUM存储库"><a href="#添加MySQL-YUM存储库" class="headerlink" title="添加MySQL YUM存储库"></a>添加MySQL YUM存储库</h5><p>将MySQL Yum存储库添加到系统的存储库列表中。这是一次性操作，可以通过安装MySQL提供的RPM来执行。跟着下面步骤：</p>
<ol>
<li>到MySQL官网下载指定的MySQL Yum存储库，<a href="https://dev.mysql.com/downloads/repo/yum/">MySQL Yum存储库下载地址</a><br>下载你指定的需要的版本，Linux 8对应CentOS 8，Linux 7对应CentOS 7</li>
</ol>
<p><strong>注：</strong>官网下载需要登录一个已有的oracle官网帐号<br><img data-src="ca10a347/download_mysql_yum_resouces__or_centos7.jpg" alt="MySQL Yum存储库"><br>2. 选择并下载适用于你所需要的平台发行包。将下载的rpm包上传到你的centos服务器中<br>3. cd到rpm包所在目录，使用以下命令来安装下载的发行包，替换<em>platform-and-version-specific-package-name</em>为下再的rpm包的名称：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum localinstall platform-and-version-specific-package-name.rpm</span><br></pre></td></tr></table></figure>

<h5 id="选择需要安装的发布版本"><a href="#选择需要安装的发布版本" class="headerlink" title="选择需要安装的发布版本"></a>选择需要安装的发布版本</h5><p>如果你需要直接安装最新版本的MySQL，可以直接略过本步骤，直接通过yum一次性安装。相反，如果你要安装指定版本，则需要手工配置安装版本。<br>通过命令，来查看当前安装库中mysql的版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum repolist all | grep mysql</span><br></pre></td></tr></table></figure>

<p>可以看到如下图所示的内容：<br><img data-src="ca10a347/after_config_mysql_yum_install.jpg" alt="yum repolist all"><br>这是修改后的效果，修改之前<strong>mysql80-community/x86_64</strong>这项状态是<strong>enable</strong>的。<br>通过如下命令，修改需要安装的版本信息：<br>注：如果提示yum-config-manager不存在，看上文小结中，直接安装<strong>yum-utils</strong>即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭MySQL 8</span></span><br><span class="line">sudo yum-config-manager --disable mysql80-community</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭MySQL 5.7，如果之前看到的是已经关闭的状态，这步则不用关闭</span></span><br><span class="line">sudo yum-config-manager --disable mysql57-community</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用MySQL 5.6</span></span><br><span class="line">sudo yum-config-manager --enable mysql56-community</span><br></pre></td></tr></table></figure>

<h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><p>通过以下命令安装MySQL:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure>

<p>在这个过程中，这将安装MySQL server（mysql-community-server）的包以及运行服务器所需组件的包，包括client（mysql-community-client）的包，客户端和服务器的常见错误消息和字符集（mysql-community-common）以及共享客户端库（mysql-community-libs） 。</p>
<h5 id="启动MySQL服务器"><a href="#启动MySQL服务器" class="headerlink" title="启动MySQL服务器"></a>启动MySQL服务器</h5><p>通过以下命令启动MySQL服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>

<p>与之相对应的，停止(stop)，重启(restart)，直接修改后面的参数即可</p>
<h5 id="配置MySQL相关参数"><a href="#配置MySQL相关参数" class="headerlink" title="配置MySQL相关参数"></a>配置MySQL相关参数</h5><h6 id="本地连接MySQL数据库"><a href="#本地连接MySQL数据库" class="headerlink" title="本地连接MySQL数据库"></a>本地连接MySQL数据库</h6><p>通过以下命令连接MySQL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>出现<strong>Enter password</strong>，输入密码。由于刚安装，没有设置密码，直接回车 Enter 进入<br><img data-src="ca10a347/ConnectToMySQLThroughCommand.jpg" alt="连接MySQL"><br>输入命令**show databases;**查看默认安装的数据库<br><img data-src="ca10a347/ShowDatabases.jpg" alt="查看安装的数据库Schemal"></p>
<h6 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h6><p>依次通过以下命令修改root用户名密码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> password<span class="operator">=</span>password(<span class="string">&#x27;your password&#x27;</span>) <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span>flush privileges;</span><br></pre></td></tr></table></figure>

<p><strong>your password</strong>为你需要设置的密码<br>输入<strong>quit</strong>命令退出当前登录，用新的密码重新连接 mysql。</p>
<h6 id="设置远程登录"><a href="#设置远程登录" class="headerlink" title="设置远程登录"></a>设置远程登录</h6><p>mysql默认只能本机登录，通过以下命令，设置允许远程登录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;your username&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;your password&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure>

<p><strong>your username</strong>和<strong>your password</strong>改成 mysql 数据库的用户和密码</p>
<h6 id="高版本5-7-更改root密码"><a href="#高版本5-7-更改root密码" class="headerlink" title="高版本5.7+更改root密码"></a>高版本5.7+更改root密码</h6><p>在开启mysql服务之后，简单密码切记仅供本地自我学习使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//获取临时密码</span><br><span class="line">grep &quot;password&quot; /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line">//进入数据库</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">//修改密码验证规则</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="built_in">set</span> global validate_password_policy=0;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="built_in">set</span> global validate_password_length=1;</span></span><br><span class="line"></span><br><span class="line">//设置简单密码</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span></span><br></pre></td></tr></table></figure>

<p>到此，在 CentOS 7上安装 MySQL 5.6 完成，CentOS 6 也是类似操作。<br>用一个客户端工具连接一下试试，</p>
<p>猜测一下，可能你会发现通过工具远程并无法连接 :)<br>原因是：CentOS中默认防火墙策略是禁止所有远程访问的，可以通过如下命令来开放端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前防火墙策略</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开放3306端口</span></span><br><span class="line">firewall-cmd --permanent --add-port=3306/tcp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 或者</span></span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看防火墙是否开放3306端口，返回<span class="built_in">yes</span>就OK了，当然也可以再次通过list-all来查看</span></span><br><span class="line">firewall-cmd --query-port=3306/tcp</span><br></pre></td></tr></table></figure>

<p>再次回到工具中，测试连接，连接成功 :)<br><img data-src="ca10a347/ConnetMySQLSuccesfully.jpg" alt="工具远程测试连接"><br>至此就真的结束啦….</p>
<h4 id="Redis单机安装"><a href="#Redis单机安装" class="headerlink" title="Redis单机安装"></a>Redis单机安装</h4><p>安装版本是redis 5.0.7稳定版本</p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><h6 id="下载redis包"><a href="#下载redis包" class="headerlink" title="下载redis包"></a>下载redis包</h6><p>直接运行wget <a href="http://download.redis.io/releases/redis-5.0.7.tar.gz%E5%8D%B3%E5%8F%AF">http://download.redis.io/releases/redis-5.0.7.tar.gz即可</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# wget http://download.redis.io/releases/redis-5.0.7.tar.gz</span><br><span class="line">--2020-01-08 20:46:22--  http://download.redis.io/releases/redis-5.0.7.tar.gz</span><br><span class="line">Resolving download.redis.io (download.redis.io)... 109.74.203.151</span><br><span class="line">Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 1984203 (1.9M) [application/x-gzip]</span><br><span class="line">Saving to: ‘redis-5.0.7.tar.gz’</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">100%</span><span class="language-bash">[========================================================================================================================================&gt;] 1,984,203    355KB/s   <span class="keyword">in</span> 5.5s</span>   </span><br><span class="line"></span><br><span class="line">2020-01-08 20:46:29 (355 KB/s) - ‘redis-5.0.7.tar.gz’ saved [1984203/1984203]</span><br></pre></td></tr></table></figure>

<h6 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-5.0.7.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><h6 id="安装GCC"><a href="#安装GCC" class="headerlink" title="安装GCC"></a>安装GCC</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没啥遇到确认的直接y</span></span><br><span class="line">yum install gcc</span><br></pre></td></tr></table></figure>

<h6 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-5.0.7]# make MALLOC=libc</span><br><span class="line">[root@localhost redis-5.0.7]# cd src &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h6 id="设置环境变量等"><a href="#设置环境变量等" class="headerlink" title="设置环境变量等"></a>设置环境变量等</h6><p>任意通过redis-service直接启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/redis/bin</span><br><span class="line">cp src/redis-server /usr/local/redis/bin</span><br><span class="line">cp src/redis-cli /usr/local/redis/bin</span><br><span class="line">cp src/redis-sentinel /usr/local/redis/bin</span><br><span class="line">cp src/redis-trib.rb /usr/local/redis/bin</span><br><span class="line">cp src/redis-check-aof /usr/local/redis/bin</span><br><span class="line">cp src/redis-check-rdb /usr/local/redis/bin</span><br><span class="line">cp src/redis-benchmark /usr/local/redis/bin</span><br><span class="line">echo &#x27;export PATH=$PATH:/usr/local/redis/bin&#x27; &gt;&gt; .bash_profile</span><br><span class="line">. .bash_profile</span><br></pre></td></tr></table></figure>

<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><h6 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h6><p>cd到src目录后，直接./redis-server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost src]# ./redis-server </span><br><span class="line">12725:C 08 Jan 2020 20:53:33.796 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">12725:C 08 Jan 2020 20:53:33.796 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=12725, just started</span><br><span class="line">12725:C 08 Jan 2020 20:53:33.796 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &#x27;&#x27;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 5.0.7 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._                                   </span><br><span class="line"> (    &#x27;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-&#x27;    |     PID: 12725</span><br><span class="line">  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">      `-._    `-.__.-&#x27;    _.-&#x27;                                       </span><br><span class="line">          `-._        _.-&#x27;                                           </span><br><span class="line">              `-.__.-&#x27;                                               </span><br><span class="line"></span><br><span class="line">12725:M 08 Jan 2020 20:53:33.798 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">12725:M 08 Jan 2020 20:53:33.798 # Server initialized</span><br><span class="line">12725:M 08 Jan 2020 20:53:33.798 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span><br><span class="line">12725:M 08 Jan 2020 20:53:33.798 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">12725:M 08 Jan 2020 20:53:33.798 * Ready to accept connections</span><br></pre></td></tr></table></figure>

<p>不方便，原因是这个窗口需要一直运行，ctrl + c直接退出</p>
<h6 id="后台进程方式运行"><a href="#后台进程方式运行" class="headerlink" title="后台进程方式运行"></a>后台进程方式运行</h6><p>如果你需要外部客户端直接访问的话，修改下面三行配置：<br>/# bind 127.0.0.1<br>protected-mode no<br>/# 后台运行<br>daemonize yes<br>直接运行redis-server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>

<h4 id="redis伪集群安装"><a href="#redis伪集群安装" class="headerlink" title="redis伪集群安装"></a>redis伪集群安装</h4><p>顾名思义，伪集群安装，实际集群应该分布在不同的redis服务器上的，这里个人使用，就在单服务器上实现了</p>
<h5 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h5><p>配置文件目录随意，这里我就在redis编译好的路径下配置了<br>单个配置修改如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">7001</span></span><br><span class="line"><span class="comment"># 监听 ip</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 指定文件存放路径 （ .rdb .aof nodes-xxxx.conf 这样的文件都会在此路径下）</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/opt/redis-7001</span></span><br><span class="line"><span class="comment"># 启动集群模式 </span></span><br><span class="line"><span class="attr">cluster-enabled</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 集群节点配置文件</span></span><br><span class="line"><span class="attr">cluster-config-file</span> <span class="string">nodes-7001.conf</span></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 集群节点超时时间​</span></span><br><span class="line"><span class="attr">cluster-node-timeout</span> <span class="string">5000</span></span><br><span class="line"><span class="comment"># 指定持久化方式，开启 AOF 模式</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 非保护模式</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<p>其余的文件直接copy上述配置好的7001配置文件就好了。创建6个配置文件（redis集群最低6个节点）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /etc/redis-cluster</span><br><span class="line">cp redis.conf /etc/redis-cluster/redis-7001.conf</span><br><span class="line">cp redis.conf /etc/redis-cluster/redis-7002.conf</span><br><span class="line">cp redis.conf /etc/redis-cluster/redis-7003.conf</span><br><span class="line">cp redis.conf /etc/redis-cluster/redis-7004.conf</span><br><span class="line">cp redis.conf /etc/redis-cluster/redis-7005.conf </span><br><span class="line">cp redis.conf /etc/redis-cluster/redis-7006.conf</span><br><span class="line">mkdir /opt/redis-7001</span><br><span class="line">mkdir /opt/redis-7002</span><br><span class="line">mkdir /opt/redis-7003</span><br><span class="line">mkdir /opt/redis-7004</span><br><span class="line">mkdir /opt/redis-7005</span><br><span class="line">mkdir /opt/redis-7006</span><br></pre></td></tr></table></figure>

<p>copy之后，可以直接通过sed命令替换配置文件中的相关端口信息，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以此类推，分别修改，当然你也可以写到一个shell脚本里，一次性全部执行。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认修改是否完成，grep <span class="string">&#x27;7001&#x27;</span> nodes-7001.conf，你应该看到有3行</span></span><br><span class="line">sed -i &#x27;s/7001/7002/&#x27; nodes-7002.conf</span><br></pre></td></tr></table></figure>

<h5 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h5><p>按单机启动方式启动所有节点，注意配置文件路径就是。<br>启动之后，ps查看redis信息，可以看到如下信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">redis-server /etc/redis-cluster/redis-7001.conf</span><br><span class="line">redis-server /etc/redis-cluster/redis-7002.conf</span><br><span class="line">redis-server /etc/redis-cluster/redis-7003.conf</span><br><span class="line">redis-server /etc/redis-cluster/redis-7004.conf</span><br><span class="line">redis-server /etc/redis-cluster/redis-7005.conf</span><br><span class="line">redis-server /etc/redis-cluster/redis-7006.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动之后</span></span><br><span class="line">[root@localhost redis-5.0.7]# ps -ef | grep redis</span><br><span class="line">root      7635     1  0 10:34 ?        00:00:00 redis-server 192.168.31.49:7001 [cluster]</span><br><span class="line">root      7642     1  0 10:34 ?        00:00:00 redis-server 192.168.31.49:7002 [cluster]</span><br><span class="line">root      7647     1  0 10:34 ?        00:00:00 redis-server 192.168.31.49:7003 [cluster]</span><br><span class="line">root      7652     1  0 10:34 ?        00:00:00 redis-server 192.168.31.49:7004 [cluster]</span><br><span class="line">root      7657     1  0 10:34 ?        00:00:00 redis-server 192.168.31.49:7005 [cluster]</span><br><span class="line">root      7662     1  0 10:34 ?        00:00:00 redis-server 192.168.31.49:7006 [cluster]</span><br></pre></td></tr></table></figure>

<p>说明启动成功了<br>接下来直接通过redis-cli启动集群即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.31.49:7001 192.168.31.49:7002 192.168.31.49:7003 192.168.31.49:7004 192.168.31.49:7005 192.168.31.49:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<p>启动完成之后，会看到如下信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.31.49:7005 to 192.168.31.49:7001</span><br><span class="line">Adding replica 192.168.31.49:7006 to 192.168.31.49:7002</span><br><span class="line">Adding replica 192.168.31.49:7004 to 192.168.31.49:7003</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span></span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: 4a14d7fad92c4bd5cca5a5a5b620fe63979f6345 192.168.31.49:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: f31ae790a628511807e7a00182844d67da8a68aa 192.168.31.49:7002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: fbb2295a6c7c27cf031a392f7b4d80ea2a58fc86 192.168.31.49:7003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 469631e70b417d6f2f32d400cb78a2d948adc22f 192.168.31.49:7004</span><br><span class="line">   replicates f31ae790a628511807e7a00182844d67da8a68aa</span><br><span class="line">S: f6d19acd0462b08f5f3b044d114fff7a215f4a2f 192.168.31.49:7005</span><br><span class="line">   replicates fbb2295a6c7c27cf031a392f7b4d80ea2a58fc86</span><br><span class="line">S: efcf9038cf9251ab8b8e53fca31b604f2bb399e1 192.168.31.49:7006</span><br><span class="line">   replicates 4a14d7fad92c4bd5cca5a5a5b620fe63979f6345</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node 192.168.31.49:7001)</span></span><br><span class="line">M: 4a14d7fad92c4bd5cca5a5a5b620fe63979f6345 192.168.31.49:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 469631e70b417d6f2f32d400cb78a2d948adc22f 192.168.31.49:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates f31ae790a628511807e7a00182844d67da8a68aa</span><br><span class="line">S: f6d19acd0462b08f5f3b044d114fff7a215f4a2f 192.168.31.49:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates fbb2295a6c7c27cf031a392f7b4d80ea2a58fc86</span><br><span class="line">M: f31ae790a628511807e7a00182844d67da8a68aa 192.168.31.49:7002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: efcf9038cf9251ab8b8e53fca31b604f2bb399e1 192.168.31.49:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 4a14d7fad92c4bd5cca5a5a5b620fe63979f6345</span><br><span class="line">M: fbb2295a6c7c27cf031a392f7b4d80ea2a58fc86 192.168.31.49:7003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>说明启动完成了，所有主从节点信息也显示出来了。</p>
<h5 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@microservice redis-cluster]# redis-cli -c -h 192.168.31.49 -p 7001</span><br><span class="line">192.168.31.49:7001&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:457</span><br><span class="line">cluster_stats_messages_pong_sent:458</span><br><span class="line">cluster_stats_messages_sent:915</span><br><span class="line">cluster_stats_messages_ping_received:453</span><br><span class="line">cluster_stats_messages_pong_received:457</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:915</span><br></pre></td></tr></table></figure>

<h5 id="查看节点信息"><a href="#查看节点信息" class="headerlink" title="查看节点信息"></a>查看节点信息</h5><h5 id="遇到redis-cli集群加载失败"><a href="#遇到redis-cli集群加载失败" class="headerlink" title="遇到redis-cli集群加载失败"></a>遇到redis-cli集群加载失败</h5><p>这种情况通常遇到上一次redis未正常退出导致的。<br>通过redis-cli –cluster create时，提示下述错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Node 192.168.31.49:7001 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0</span><br></pre></td></tr></table></figure>

<p>此时，使用下述命令，直接清空异常redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-cli -h ip地址 -p 端口</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt; flushdb</span></span><br></pre></td></tr></table></figure>
<p>如果在清空之后仍然无效，尝试将当前启动的所有节点重新kill调，重新运行后再执行创建集群命令看看</p>
<h4 id="zookeeper安装"><a href="#zookeeper安装" class="headerlink" title="zookeeper安装"></a>zookeeper安装</h4><h5 id="下载zk"><a href="#下载zk" class="headerlink" title="下载zk"></a>下载zk</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>解压后，cd到conf目录下，copy sample配置文件为zoo.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]# vim zoo.cfg </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The number of milliseconds of each tick</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The number of ticks that the initial</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The number of ticks that can pass between</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the directory <span class="built_in">where</span> the snapshot is stored.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">do</span> not use /tmp <span class="keyword">for</span> storage, /tmp here is just</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">example sakes.</span></span><br><span class="line">dataDir=/etc/apache-zookeeper-3.6.2/data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the port at <span class="built_in">which</span> the clients will connect</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the maximum number of client connections.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">increase this <span class="keyword">if</span> you need to handle more clients</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">maxClientCnxns=60</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Be sure to read the maintenance section of the</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># The number of snapshots to retain in dataDir</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Purge task interval <span class="keyword">in</span> hours</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set to <span class="string">&quot;0&quot;</span> to <span class="built_in">disable</span> auto purge feature</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">autopurge.purgeInterval=1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Metrics Providers</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># https://prometheus.io Metrics Exporter</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">metricsProvider.httpPort=7000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">metricsProvider.exportJvmInfo=<span class="literal">true</span></span></span><br></pre></td></tr></table></figure>

<h5 id="配置service开机启动"><a href="#配置service开机启动" class="headerlink" title="配置service开机启动"></a>配置service开机启动</h5><p>cd 到 /etc/init.d/目录下<br>新建名为zookeeper文件，文件内容如下，注意ZK_PATH和JAVA_HOME填写实际路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost init.d]# vim zookeeper</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">chkconfig:2345 20 90</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">description:zookeeper</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">processname:zookeeper</span></span><br><span class="line">ZK_PATH=/etc/apache-zookeeper-3.6.2</span><br><span class="line">export JAVA_HOME=/etc/java/jdk1.8.0_211</span><br><span class="line">case $1 in</span><br><span class="line">         start) sh  $ZK_PATH/bin/zkServer.sh start;;</span><br><span class="line">         stop)  sh  $ZK_PATH/bin/zkServer.sh stop;;</span><br><span class="line">         status) sh  $ZK_PATH/bin/zkServer.sh status;;</span><br><span class="line">         restart) sh $ZK_PATH/bin/zkServer.sh restart;;</span><br><span class="line">         *)  echo &quot;require start|stop|status|restart&quot;  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>检查服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加服务</span></span><br><span class="line">chkconfig --add zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改执行权限</span></span><br><span class="line">chmod 755 zookeeper</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先停止服务</span></span><br><span class="line">service zookeeper stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在启动服务</span></span><br><span class="line">service zookeeper start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询服务状态</span></span><br><span class="line">service zookeeper status</span><br></pre></td></tr></table></figure>

<h4 id="kafka伪集群部署"><a href="#kafka伪集群部署" class="headerlink" title="kafka伪集群部署"></a>kafka伪集群部署</h4><h5 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h5><p>通过官网下载kafka二进制客户端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://downloads.apache.org/kafka/2.4.1/kafka_2.11-2.4.1.tgz</span><br></pre></td></tr></table></figure>
<h5 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h5><h6 id="配置KAFKA-HOME"><a href="#配置KAFKA-HOME" class="headerlink" title="配置KAFKA_HOME"></a>配置KAFKA_HOME</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">末尾添加，<span class="built_in">export</span> PATH如果有JAVA_HOME，类似在后面添加冒号</span></span><br><span class="line">export KAFKA_HOME=/usr/kafka/kafka_2.11-2.4.1</span><br><span class="line">export PATH=$PATH:$KAFKA_HOME/bin</span><br></pre></td></tr></table></figure>

<h6 id="配置KAFKA集群文件"><a href="#配置KAFKA集群文件" class="headerlink" title="配置KAFKA集群文件"></a>配置KAFKA集群文件</h6><p>直接cd到config目录下，复制三个<strong>server.properties</strong>文件<br>每个文件中的配置修改如下几项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">broker.id=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 填你实际机器IP</span></span></span><br><span class="line">listeners=PLAINTEXT://192.168.**.***:9092</span><br><span class="line">log.dirs=/usr/local/src/kafka_2.11-2.1.0/tmp/kafka-logs1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 填你zk服务的地址</span></span></span><br><span class="line">zookeeper.connect=192.168.**.***:2182</span><br></pre></td></tr></table></figure>

<h5 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server1.properties &amp;</span><br><span class="line">./bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server2.properties &amp;</span><br><span class="line">./bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server3.properties &amp;</span><br></pre></td></tr></table></figure>

<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><h6 id="创建一个topic"><a href="#创建一个topic" class="headerlink" title="创建一个topic"></a>创建一个topic</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建topic，包含一个分区，3个副本</span></span><br><span class="line">./bin/kafka-topics.sh --create --zookeeper 192.168.31.49:2181 --replication-factor 3 --partitions 1 --topic test_topic</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">WARNING: Due to limitations <span class="keyword">in</span> metric names, topics with a period (<span class="string">&#x27;.&#x27;</span>) or underscore (<span class="string">&#x27;_&#x27;</span>) could collide. To avoid issues it is best to use either, but not both.</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Created topic test_topic.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看topic</span></span><br><span class="line">./bin/kafka-topics.sh --list --zookeeper 192.168.31.49:2181</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">test_topic</span></span><br></pre></td></tr></table></figure>

<h6 id="创建生产者-amp-消费者"><a href="#创建生产者-amp-消费者" class="headerlink" title="创建生产者&amp;消费者"></a>创建生产者&amp;消费者</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建生产者</span></span><br><span class="line">./bin/kafka-console-producer.sh --broker-list master:9092,master:9093,master:9094 --topic test_topic</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建消费者</span></span><br><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server master:9092,master:9093,master:9094 --from-beginning --topic test_topic</span><br></pre></td></tr></table></figure>

<h6 id="通过指定consumer-properties文件创建topic"><a href="#通过指定consumer-properties文件创建topic" class="headerlink" title="通过指定consumer.properties文件创建topic"></a>通过指定consumer.properties文件创建topic</h6><p>先在config文件夹下copy consumer.properties，假定命名为：cc.nimbusk.consumer.properties</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过kafka-console-consumer.sh指定分组下的topic</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bin/kafka-console-consumer.sh --new-consumer --bootstrap-server localhost:9092 --topic test_topic --from-beginning --consumer.config config/cc.nimbusk.consumer.properties --delete-consumer-offsets</span></span><br></pre></td></tr></table></figure>




<h3 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h3><ul>
<li><a href="https://www.cnblogs.com/leffss/p/11996580.html">Redis 5.0.7 讲解，单机、集群模式搭建</a></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>新手从零软路由系列</title>
    <url>/post/c07c0078.html</url>
    <content><![CDATA[<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>9012年了，对于像我这种，平时没事会去折腾一些硬件。比如一些装机、数码之类的。关注了很多新鲜的东西，当然其中一个就是软路由。<br>在了解软路由之前，可以去了解一下软路由具体是干嘛的？完了再了解了解下文中具体配置相关的东西。</p>
<h3 id="需要准备"><a href="#需要准备" class="headerlink" title="需要准备"></a>需要准备</h3><ul>
<li>一台软路由设备<ul>
<li>底层安装好ESXi或者LEDE</li>
<li>至少拥有两个物理网口</li>
<li>内存按个人实际分配使用，如果纯软路由场景2~4G足以；如果辅助需要安装其它操作系统，如Linux或者Windows乃至黑苹果等，等同划分需要扩展相应的内存</li>
</ul>
</li>
<li>Mikrotkit OS镜像</li>
<li>OpenWRT镜像</li>
</ul>
<span id="more"></span>

<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="Mikrotkit-OS"><a href="#Mikrotkit-OS" class="headerlink" title="Mikrotkit OS"></a>Mikrotkit OS</h4><h4 id="OpenWRT"><a href="#OpenWRT" class="headerlink" title="OpenWRT"></a>OpenWRT</h4><h5 id="自编译OpenWRT"><a href="#自编译OpenWRT" class="headerlink" title="自编译OpenWRT"></a>自编译OpenWRT</h5><p>初始编辑可参考如下博客文中所述：<a href="https://imgki.com/archives/openwrt-lean.html">编译Lean的Openwrt固件全攻略</a><br>基本上没有什么问题，可以通过公有云编译，也可以通过虚拟机本地编译都可以。<br>自编译要注意下面几个问题：</p>
<ol>
<li>极端情况，编译失败可能是因为网络问题</li>
<li>自编译，磁盘空间需要保留足够，目前初略看，至少得50G。曾经本地编译过一次，居然最后是因为磁盘空间不足导致最终编译失败了。</li>
<li>如果本地编译出现失败，又无法确定是否是网络原因。采取反证法，到公有云上再编译，如果还是出现同样的失败错误。<strong>注意了</strong> 很有可能是你选择的<strong>LUCI插件冲突</strong>了，少选几个再重新试一下看看。</li>
</ol>
<h6 id="怎么在ESXi中用"><a href="#怎么在ESXi中用" class="headerlink" title="怎么在ESXi中用"></a>怎么在ESXi中用</h6><p>编译好的文件，默认配置会输出两个文件，如下所示：</p>
<ul>
<li>openwrt-x86-64-combined-squashfs.img</li>
<li>openwrt-x86-64-combined-squashfs.vmdk</li>
</ul>
<p>但是这俩文件，是无法直接在ESXi后台控制页面，通过添加虚拟机的方式使用的。这里以vmdk文件为例，通过ESXi后台自带的<strong>vmkfstools</strong>转换一下之后，就可以了。</p>
<ol>
<li><p>先将上述编译好的vmdk文件，通过“数据库存储浏览器”上传到指定目录下，如下图所示：<br><img data-src="c07c0078/upload_vmdk.jpg" alt="upload_vmdk"></p>
</li>
<li><p>打开ESXi的SSH：主机-&gt;操作-&gt;服务-&gt;启用安全的Shell</p>
</li>
<li><p>通过SSH客户端工具，远程连接到ESXi后台</p>
</li>
<li><p>cd到第一步上传的目录</p>
<ul>
<li>这里注意一下：我的vmdk存放的数据仓库的名称为“datastore1”，则实际路径为：/vmfs/volumes/datastore1，以此类推</li>
</ul>
</li>
<li><p>键入如下命令开始转换</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法为：vmkfstools -i [原始文件] [目的文件] -d thin</span></span><br><span class="line">vmkfstools -i openwrt-x86-64-combined-squashfs.vmdk openwrt_new-x86-64-combined-squashfs.vmdk -d thin</span><br></pre></td></tr></table></figure>

<p>如下图所示，转换完成：<br><img data-src="c07c0078/convert_done.jpg" alt="转换完成"></p>
<p>转换完成后的vmdk文件就可以直接正常通过ESXi创建虚拟机了。</p>
<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>与正常安装Windows过程大体相同，将ESXi对应的ISO文件（这里我安装的是6.7U3b版本），用第三方工具写入U盘即可<br>这里推荐rufus，rufus官网下载最新的版本(<a href="http://rufus.ie/)%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">http://rufus.ie/)，如下图所示：</a><br><img data-src="c07c0078/AutoCapture_2021-01-03_235940.jpg" alt="rufus"></p>
<ul>
<li>设备选择你的U盘，不要选错了。</li>
<li>点击选择，选择指定路径下的ESXi的ISO镜像文件</li>
<li>分区类型和目标系统类型保持默认即可，如图分别为MBR和BIOS或UEFI</li>
<li>剩下的直接点击开始即可</li>
</ul>
<p>后续插入到目标物理机上，通过U盘启动即可。如果是裸机的话，直接插上去，开机就行了。<br>具体安装过程很简单，输入root密码的时候，正常输入即可。<br>安装完毕之后，会提示机器重启。</p>
<h4 id="安装异常问题"><a href="#安装异常问题" class="headerlink" title="安装异常问题"></a>安装异常问题</h4><h5 id="提示Using-‘simple-offset’-UEFI-RTS-napping-policy"><a href="#提示Using-‘simple-offset’-UEFI-RTS-napping-policy" class="headerlink" title="提示Using ‘simple offset’ UEFI RTS napping policy"></a>提示Using ‘simple offset’ UEFI RTS napping policy</h5><p>这种一般在较为新的主板上会遇到，尤其是强制使用安全认证模式的UEFI模式启动的模式。<br>我在我的Intel的<strong>NUC10i7FNH</strong>主机上遇到了这个情况，涉及安全启动运行的给关了。<br>一方面，我升级了这个主板的BIOS版本，具体到指定主板的厂商的官网支持都会有最新的BIOS固件，按照官网提示的步骤升级即可。</p>
<h6 id="插曲：NUC10i7FNH对应的最新的固件更新说明"><a href="#插曲：NUC10i7FNH对应的最新的固件更新说明" class="headerlink" title="插曲：NUC10i7FNH对应的最新的固件更新说明"></a>插曲：NUC10i7FNH对应的最新的固件更新说明</h6><p><strong>注意：</strong>如果你是用F7 &amp; U盘方式更新BIOS的，<strong>不要格式化U盘为extFAT</strong>格式，BIOS会找不到的，格式化成NTFS或者FAT32都行。<br>官网说明：<a href="https://www.intel.cn/content/www/cn/zh/support/articles/000033291/intel-nuc.html">https://www.intel.cn/content/www/cn/zh/support/articles/000033291/intel-nuc.html</a><br>如下：</p>
<ul>
<li>(Intel PTT)Security &gt; Security Features: Intel Platform Trust Technology: Disabled</li>
<li>Boot &gt; Secure Boot &gt; Secure Boot: Disabled</li>
</ul>
<p>更多关于在NUC10i7FNH下建议的BIOS设置，可以参考如下相关链接：<br><a href="https://www.virten.net/2020/03/intel-nuc-recommended-bios-settings-for-vmware-esxi/">intel-nuc-recommended-bios-settings-for-vmware-esxi</a></p>
<h5 id="安装时自检提示找不到网卡驱动"><a href="#安装时自检提示找不到网卡驱动" class="headerlink" title="安装时自检提示找不到网卡驱动"></a>安装时自检提示找不到网卡驱动</h5><p>安装的时候提示“No Network Adapters”，正如这个提示所示，找不到网络驱动器，导致这个原因一般就是当前安装版本的ESXi要么你网卡较新，要么比较小众，官网没有相应的默认维护进ESXi驱动，此时提供两种解决方案：</p>
<ul>
<li>在网上找别人封装好的驱动的ESXi的ISO镜像</li>
<li>自己通过VMWare的离线bundle包打驱动</li>
</ul>
<p>在virten上的一篇文章介绍了在线模式的打包整合驱动的方法<a href="https://www.virten.net/2020/03/esxi-on-10th-gen-intel-nuc-comet-lake-frost-canyon/">esxi-on-10th-gen-intel-nuc-comet-lake-frost-canyon</a>，不推荐，因为依赖网络环境（你懂的）中间失败了，你可能又会遇到新的问题，完了来回折腾，搞了一大圈最后发现是网络问题，费时费力。但是这里面介绍的安装步骤，还是值得参考的</p>
<p>这里针对离线方式说明一下，用的封装命令，在下面这个网站里面有详细说明：<br><a href="https://www.v-front.de/p/esxi-customizer-ps.html#download">https://www.v-front.de/p/esxi-customizer-ps.html#download</a><br>这里安装物理机硬件如下：</p>
<ul>
<li>Intel NUC10I7FNH</li>
<li>网卡：I219-V</li>
<li>ESXi 6.7U3b</li>
<li>内存：威刚万紫千红 32GB * 2</li>
<li>SSD：恺侠 RD10 500GB</li>
</ul>
<h6 id="下载VMware-PowerCLI-6-5-0和ESXi-Customizer-PS"><a href="#下载VMware-PowerCLI-6-5-0和ESXi-Customizer-PS" class="headerlink" title="下载VMware-PowerCLI-6.5.0和ESXi-Customizer-PS"></a>下载VMware-PowerCLI-6.5.0和ESXi-Customizer-PS</h6><p>在这里贴一下两个文件的下载地址，其中PowerCLI我在百度云分流了：<br><em>VMware-PowerCLI-6.5.0：</em><br>MD5值：1B7A5378835C6158CFB63C3D10BB9E18<br><a href="http://down.whsir.com/downloads/VMware-PowerCLI-6.5.0-4624819.exe">http://down.whsir.com/downloads/VMware-PowerCLI-6.5.0-4624819.exe</a><br>备份下载：链接: <a href="https://pan.baidu.com/s/1L-Yeq0-ohyFwQB9lFRwiGQ">https://pan.baidu.com/s/1L-Yeq0-ohyFwQB9lFRwiGQ</a> 提取码: tf38<br><em>ESXi-Customizer-PS：</em><br><a href="http://vibsdepot.v-front.de/tools/ESXi-Customizer-PS-v2.6.0.ps1">http://vibsdepot.v-front.de/tools/ESXi-Customizer-PS-v2.6.0.ps1</a></p>
<h6 id="下载离线6-7的bundle包"><a href="#下载离线6-7的bundle包" class="headerlink" title="下载离线6.7的bundle包"></a>下载离线6.7的bundle包</h6><p><a href="https://my.vmware.com/zh/web/vmware/evalcenter?p=free-esxi6">官网VMware vSphere Hypervisor 6.7</a><br>需要登录，建议提前注册一个vmware账号，注册流程略。<br>这里下载最新的6.7U3b版本即可，如下图所示：<br><img data-src="c07c0078/AutoCapture_2021-01-04_000640.jpg" alt="ESXi670-201912001"><br>MD5值：153EA9DE288D1CC2518E747F3806F929<br>备用下载：<br>链接: <a href="https://pan.baidu.com/s/1ScNhiCr0BqKTIhJJsbgHwQ">https://pan.baidu.com/s/1ScNhiCr0BqKTIhJJsbgHwQ</a> 提取码: 7j9r</p>
<h6 id="下载好指定驱动"><a href="#下载好指定驱动" class="headerlink" title="下载好指定驱动"></a>下载好指定驱动</h6><p>支持列表<a href="https://vibsdepot.v-front.de/wiki/index.php/List_of_currently_available_ESXi_packages">vibsdepot.v-front</a><br>比如我的NUC10i7FNH这个设备上网卡是I219-V，上面网站中没有列出，在官网有提供：<br><a href="https://download3.vmware.com/software/vmw-tools/ESXi670-NE1000-32543355-offline_bundle-15486963.zip">ESXi670-NE1000</a></p>
<h6 id="开始bundle"><a href="#开始bundle" class="headerlink" title="开始bundle"></a>开始bundle</h6><ul>
<li>在本地任一磁盘根目录新建文件夹，例如我的是在G盘，建了一个名为newesxi的文件夹，文件夹内容目录如下，把上述下载的东西放进去。<br><img data-src="c07c0078/AutoCapture_2021-01-04_005334.jpg" alt="目录结构"></li>
<li>其中offline文件夹内，提取上述ESXi670-NE1000压缩包中的VIB文件</li>
<li>运行PowerCLI<br>CD到上述newesxi目录下<br>键入如下命令：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\ESXi-Customizer-PS-v2.6.0.ps1 -izip .\ESXi670-201912001.zip -load net-e1000e -pkgDir .\offline -outDir .\out -nsc</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>注意：</strong>上述命令中的<em>net-e1000e</em>就是指定网卡型号，这个型号就在上述vibsdepot.v-front网站中，有列出。<br>同时，如果你要 <strong>同时</strong>制作其它网卡型号，在后面添加英文逗号”,”即可。<br>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\ESXi-Customizer-PS-v2.6.0.ps1 -izip .\ESXi670-201912001.zip -load net-e1000e,net51-r8169,net55-r8168,net-atl1e,net-r8101 -pkgDir .\offline -outDir .\out -nsc</span><br></pre></td></tr></table></figure>

<p>稍等片刻之后，看到如下提示则表示bundle完成。<br><img data-src="c07c0078/AutoCapture_2021-01-04_011047.jpg" alt="打包过程"></p>
<p>至此离线驱动镜像包就制作好了，接下来就可以正常写入U盘安装了。<br>这里分享自己打包好的多驱动集成ISO镜像包。<br>MD5值：2EC7F4417E8C233F4F36B52DF6D564CD<br>链接: <a href="https://pan.baidu.com/s/19aJ_FZqQLmsk5jqaNQ8EBA">https://pan.baidu.com/s/19aJ_FZqQLmsk5jqaNQ8EBA</a> 提取码: yyj7<br>已集成驱动列表：</p>
<ul>
<li>net-e1000e(包含I219-V网卡)</li>
<li>net51-r8169</li>
<li>net55-r8168</li>
<li>net-atl1e</li>
<li>net-r8101</li>
</ul>
<h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><h4 id="ESXI后台设置"><a href="#ESXI后台设置" class="headerlink" title="ESXI后台设置"></a>ESXI后台设置</h4><h5 id="设置网络适配器（Network-Adapters）"><a href="#设置网络适配器（Network-Adapters）" class="headerlink" title="设置网络适配器（Network Adapters）"></a>设置网络适配器（Network Adapters）</h5><h5 id="IPv4设置"><a href="#IPv4设置" class="headerlink" title="IPv4设置"></a>IPv4设置</h5><h5 id="替换ESXI登录HTTPS证书"><a href="#替换ESXI登录HTTPS证书" class="headerlink" title="替换ESXI登录HTTPS证书"></a>替换ESXI登录HTTPS证书</h5><p>通常在刚安装好esxi之后，默认后台登录控制台，会提示你当前访问的链接不安全的提示，就像下面那样：<br><img data-src="c07c0078/AutoCapture_2021-01-30_211415.jpg" alt="不安全的链接"><br>这种问题本质就是，你当前通过https访问的地址并未签发相应的SSL证书导致的。<br>因此，找到一个免费的SSL证书，并替换esxi后台的默认ssl证书即可。<br>由于我本站博客域名国内的DNS解析加速选择的是dnspod，所以这里就以腾讯DNSpod申请免费证书为例，其它国内诸如阿里云、七牛云等等，都有提供免费申请SSL证书的渠道，不过目前来看，似乎腾讯的dnspod审批的比较快。<br>dnspod免费的ssl证书提供商是亚信，自己本地玩无所谓的。</p>
<h6 id="mkcert（推荐）"><a href="#mkcert（推荐）" class="headerlink" title="mkcert（推荐）"></a>mkcert（推荐）</h6><p>严格意义上来说，这种exsi服务器，不对公网，其实完全自签证书就可以了，不需要搞那么多费神的东西。<br>使用github上一个开源工具：<a href="https://github.com/FiloSottile/mkcert">mkcert地址</a><br>这里的自签一次是2年3个月的（主要原因是考虑到mac和ios限制），如果你想一次10年，可以使用我这个找到的 <a href="c07c0078/mkcert_10years.zip">直接右键下载</a></p>
<ol>
<li>下载下来使用命令行（管理员权限）执行下面两个命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkcert_10years.exe 192.168.**.**【替换成你的IP】</span><br><span class="line">mkcert_10years.exe -install</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如下图所示：<br><img data-src="c07c0078/mkcert_10_years.png" alt="执行命令"></p>
<ol start="2">
<li>准备exsi证书文件<br>经过上述命令行执行过后，会在对应目录下生成两个文件，<strong>并依次替换</strong>（别整错了）：</li>
</ol>
<ul>
<li>[你的ip].pem –&gt; rui.crt</li>
<li>[你的ip]-key.pem –&gt; rui.key</li>
</ul>
<ol start="3">
<li>rui.crt和rui.key丢到exsi后台，路径： <code>/etc/vmware/ssl/</code></li>
<li>重启服务：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/hostd restart</span><br><span class="line">/etc/init.d/vpxa restart</span><br></pre></td></tr></table></figure></li>
<li>此时再访问后台，就不会再提示ssl证书问题了</li>
<li>如果需要在其它电脑上，只需要把证书导出后，安装即可，如下图所示：<br><img data-src="c07c0078/mkcert_install.png" alt="证书管理器页面"></li>
</ol>
<h6 id="dnspod申请免费SSL证书"><a href="#dnspod申请免费SSL证书" class="headerlink" title="dnspod申请免费SSL证书"></a>dnspod申请免费SSL证书</h6><p>登录到DNSPOD控制台：<a href="https://console.dnspod.cn/">https://console.dnspod.cn/</a><br>搜索SSL证书，或直接访问URL：<a href="https://console.cloud.tencent.com/ssl">https://console.cloud.tencent.com/ssl</a> 如下图所示：<br>点击“申请免费证书”<br><img data-src="c07c0078/AutoCapture_2021-01-30_212517.jpg" alt="购买证书第一页"><br>默认，点击确认即可，选择其它的ssl证书提供商，会收费。<br><img data-src="c07c0078/AutoCapture_2021-01-30_212701.jpg" alt="提交资料"><br>在提交资料页面：</p>
<ul>
<li>算法选择：默认即可</li>
<li>证书绑定域名：填写你要申请绑定证书的域名地址，例如我的就是esxi.nimbusk.cc</li>
<li>申请邮箱：填写自己的邮箱就好</li>
<li>证书名备注：备注这个证书是绑定什么域名干嘛用的就好</li>
<li>私钥密码：自己本地玩，不需要填写</li>
</ul>
<p>填完之后，下一步，选择验证方式：<br><img data-src="c07c0078/AutoCapture_2021-01-30_213052.jpg" alt="选择验证方式"><br>选择第一个，第一个会自动在你当前匹配的域名下增加一条TXT记录<br>第三步验证的时候，dnspod会验证你的解析域名下是否包含相应的记录，进而会影响你最终审核结果。</p>
<p>在下一步之后，<strong>验证域名步骤中，可能会显示当前顶级域名验证失败</strong>，等收到验证通过消息（邮件/短信）之后，再次点击查看域名验证状态就好。</p>
<p>签发成功之后，直接下载。会下载一个压缩包，等待后续使用。</p>
<h6 id="替换exsi后台默认证书"><a href="#替换exsi后台默认证书" class="headerlink" title="替换exsi后台默认证书"></a>替换exsi后台默认证书</h6><p>将上述步骤下载下来的zip压缩包中的 <strong>nginx</strong>文件夹内的两个文件，一个crt一个key文件，均重命名为rui。<br>通过linux文件传输工具，将下载重命名后的文件覆盖上传的如下路径下（当然覆盖之前你也可以备份原来的俩文件）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/vmware/ssl/rui.crt</span><br><span class="line">/etc/vmware/ssl/rui.key</span><br></pre></td></tr></table></figure>

<p>覆盖替换完成之后，在SSH后台键入：services.sh restart<br>重启服务</p>
<p>之后，在浏览器，通过HTTPS域名的方式访问esxi后台即可。</p>
<p>当然，你在windows下浏览器下直接这么访问，可能会提示你根本无法访问，那是通过这种方式，你本地esxi后台ip是没有跟你的域名证书绑定在一起的。最简单的解决方案就是，在你windows的host文件加上一条域名解析记录即可。</p>
<p>完事之后，再通过浏览器https访问就好了，如下图所示：<br><img data-src="c07c0078/AutoCapture_2021-01-30_215000.jpg" alt="https访问esxi后台"></p>
<h6 id="Let’s-Encrypt自签"><a href="#Let’s-Encrypt自签" class="headerlink" title="Let’s Encrypt自签"></a>Let’s Encrypt自签</h6><p>在网上找到一段脚本，先贴在这里，主要是用的linux的certbot来自签的，<strong>目前我还没有自己实践过，暂时还不知脚本的准确性如何</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">## -----------------------------=[ WARNING ]=-------------------------------- ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script is now woefully out of date due to which accounts ESXi allows to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh into the box as well as sticky folders/file flags.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">I<span class="string">&#x27;ve since ported the whole thing to python with a lot of bells and whistles</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">and if i get around to making it public, i&#x27;</span>ll put a <span class="built_in">link</span> here.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">## -------------------------------=[ Info ]=--------------------------------- ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Generate letsencrypt cert on local server and scp to esxi target.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Designed and tested on Ubuntu 16.04LTS.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Assumes you have upnp control over <span class="built_in">local</span> network. Tested with Ubiquiti USG.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Dependencies:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">miniupnpc (<span class="built_in">sudo</span> apt install miniupnpc)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">certbot (<span class="built_in">sudo</span> apt install certbot)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">## -=[ Author ]=------------------------------------------------------------- ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># shr00mie</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">9.21.2018</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">v0.5</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">## -=[ Use Case ]=----------------------------------------------------------- ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Allows for the generation of certificates on a separate host which can then</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">be securely copied to target esxi host.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">## -=[ Breakdown ]=---------------------------------------------------------- ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 1. Prompt for esxi target FQDN, reminder email, and esxi admin username</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. Check <span class="keyword">if</span> ssh keys exist <span class="keyword">for</span> target.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    - If keys exist, <span class="built_in">continue</span>.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    - If keys don<span class="string">&#x27;t exist:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      - Silently generate 4096 RSA key, no passphrase, user@target as comment.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      - Add key to ssh-agent</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      - Create target folder/file structure for scp automation</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">      - Restart SSH service on target.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">3. Enable port forwarding.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">4. Generate 4096 bit letsencrypt cert</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">5. Backup existing cert with datetime suffix</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">6. Copy cert to target</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">7. Restart target services</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">8. Remove port forwarding</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash">## -=[ To-Do ]=-------------------------------------------------------------- ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"># change: PermitRootLogin yes -&gt; PermitRootLogin no</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">add: ChallengeResponseAuthentication no</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">add: PasswordAuthentication no</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash">## -=[ Functions ]=---------------------------------------------------------- ##</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Usage: status &quot;Status Text&quot;</span></span></span><br><span class="line">function status() &#123;</span><br><span class="line">  GREEN=&#x27;\033[00;32m&#x27;</span><br><span class="line">  RESTORE=&#x27;\033[0m&#x27;</span><br><span class="line">  echo -e &quot;\n...$&#123;GREEN&#125;$1$&#123;RESTORE&#125;...\n&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Usage: input &quot;Prompt Text&quot; &quot;Variable Name&quot;</span></span></span><br><span class="line">function input() &#123;</span><br><span class="line">  GREEN=&#x27;\033[00;32m&#x27;</span><br><span class="line">  RESTORE=&#x27;\033[0m&#x27;</span><br><span class="line">  echo -en &quot;\n...$&#123;GREEN&#125;$1$&#123;RESTORE&#125;: &quot;</span><br><span class="line">  read $2</span><br><span class="line">  echo -e &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function pressanykey()&#123;</span><br><span class="line">  GREEN=&#x27;\033[00;32m&#x27;</span><br><span class="line">  RESTORE=&#x27;\033[0m&#x27;</span><br><span class="line">  echo -en &quot;\n...$&#123;GREEN&#125;$1. Press any key to continue.$&#123;RESTORE&#125;...&quot;</span><br><span class="line">  read -r -p &quot;&quot; -n 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string"># ---------------------------=[ Script Start ]=----------------------------- ##</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Importing Variables</span></span></span><br><span class="line">status &quot;Importing Variables&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Read ESXiHost</span></span></span><br><span class="line">input &quot;Enter the FQDN for the certificate/host in host.domain.tld format&quot; &quot;ESXiHost&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Read Email</span></span></span><br><span class="line">input &quot;Enter the email for confirmation &amp; renewal notifications&quot; &quot;Email&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Read ESXiUser</span></span></span><br><span class="line">input &quot;Enter ESXi target admin username&quot; &quot;ESXiUser&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Prompt user to confirm/enable SSH on ESXi target</span></span></span><br><span class="line">pressanykey &quot;Confirm/Enable SSH access on $ESXiHost.&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Check for existing ssh keys for esxi host</span></span></span><br><span class="line">status &quot;Checking for existing ssh keys for $ESXiHost&quot;</span><br><span class="line"></span><br><span class="line">if [[ -e ~/.ssh/$ESXiHost&#x27;_rsa&#x27; ]]</span><br><span class="line">    then</span><br><span class="line">    status &quot;Keys for $ESXiHost exist. Continuing&quot;</span><br><span class="line">else</span><br><span class="line">  status &quot;Keys for $ESXiHost not found. Generating 4096 bit keys&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Generate 4096 bit key for user@target</span></span></span><br><span class="line">    ssh-keygen -b 4096 -t rsa -f ~/.ssh/$ESXiHost&#x27;_rsa&#x27; -q -N &quot;&quot; -C &quot;$ESXiUser@$HOSTNAME LetsEncrypt&quot;</span><br><span class="line">  status &quot;Adding new key to ssh-agent&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Add key to agent</span></span></span><br><span class="line">    eval `ssh-agent` &amp;&amp; ssh-add ~/.ssh/$ESXiHost&#x27;_rsa&#x27;</span><br><span class="line">  status &quot;Configuring $ESXiHost for ssh access&quot;</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Store key as variable</span></span></span><br><span class="line">  pubkey=`cat ~/.ssh/$ESXiHost&#x27;_rsa.pub&#x27;`</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">Create directory for authorized user, copy key to target, set permissions,</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="string">and restart ssh service on target.</span></span></span><br><span class="line">  ssh $ESXiUser@$ESXiHost &quot;mkdir -p /etc/ssh/keys-$ESXiUser &amp;&amp;</span><br><span class="line">  echo $pubkey &gt; /etc/ssh/keys-$ESXiUser/authorized_keys &amp;&amp;</span><br><span class="line">  chmod 700 -R /etc/ssh/keys-$ESXiUser &amp;&amp;</span><br><span class="line">  chmod 600 /etc/ssh/keys-$ESXiUser/authorized_keys &amp;&amp;</span><br><span class="line">  chown -R $ESXiUser /etc/ssh/keys-$ESXiUser &amp;&amp;</span><br><span class="line">  /etc/init.d/SSH restart&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Enable UPnP http(s) port forward for requesting device</span></span></span><br><span class="line">status &quot;Enabling http(s) port forwarding to client for letsencrypt verification&quot;</span><br><span class="line">upnpc -e &quot;letsencrypt http&quot; -r 80 tcp</span><br><span class="line">upnpc -e &quot;letsencrypt https&quot; -r 443 tcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Acquire letsencrypt cert</span></span></span><br><span class="line">status &quot;Requesting 4096 bit certificate for $ESXiHost&quot;</span><br><span class="line">sudo certbot certonly --standalone --preferred-challenges tls-sni --agree-tos -m $Email -d $ESXiHost --rsa-key-size 4096</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Backup existing SSL components on ESXi target</span></span></span><br><span class="line">status &quot;Backing up existing certificates on $ESXiHost&quot;</span><br><span class="line">time=$(date +%Y.%m.%d_%H:%M:%S)</span><br><span class="line">ssh $ESXiUser@$ESXiHost &quot;cp /etc/vmware/ssl/castore.pem /etc/vmware/ssl/castore.pem.back.$time&quot;</span><br><span class="line">ssh $ESXiUser@$ESXiHost &quot;cp /etc/vmware/ssl/rui.crt /etc/vmware/ssl/rui.crt.back.$time&quot;</span><br><span class="line">ssh $ESXiUser@$ESXiHost &quot;cp /etc/vmware/ssl/rui.key /etc/vmware/ssl/rui.key.back.$time&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Copy letsencrypt cert to ESXi target</span></span></span><br><span class="line">status &quot;Coping letsencrypt cert to $ESXiHost&quot;</span><br><span class="line">sudo scp /etc/letsencrypt/live/$ESXiHost/fullchain.pem $ESXiUser@$ESXiHost:/etc/vmware/ssl/castore.pem</span><br><span class="line">sudo scp /etc/letsencrypt/live/$ESXiHost/cert.pem $ESXiUser@$ESXiHost:/etc/vmware/ssl/rui.crt</span><br><span class="line">sudo scp /etc/letsencrypt/live/$ESXiHost/privkey.pem $ESXiUser@$ESXiHost:/etc/vmware/ssl/rui.key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Restart services on ESXi target</span></span></span><br><span class="line">status &quot;Restarting services on $ESXiHost&quot;</span><br><span class="line">ssh $ESXiUser@$ESXiHost &quot;services.sh restart&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Disable UPnP http(s) port forward</span></span></span><br><span class="line">status &quot;Removing http(s) port forwarding&quot;</span><br><span class="line">upnpc -d 80 tcp</span><br><span class="line">upnpc -d 443 tcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Prompt user to confirm/disable SSH on ESXi target</span></span></span><br><span class="line">pressanykey &quot;Remember to disable SSH service on $ESXiHost&quot;</span><br></pre></td></tr></table></figure>

<h3 id="引用相关"><a href="#引用相关" class="headerlink" title="引用相关"></a>引用相关</h3><ul>
<li><a href="https://www.mikrotik.com/aboutus">Mikrotkit About us</a></li>
<li><a href="https://www.jianshu.com/p/f989606a0331">ESXi6.7安装流程(2019.7重编版)</a></li>
<li><a href="https://www.virten.net/2020/03/esxi-on-10th-gen-intel-nuc-comet-lake-frost-canyon/">esxi-on-10th-gen-intel-nuc-comet-lake-frost-canyon</a></li>
</ul>
]]></content>
      <categories>
        <category>软路由</category>
      </categories>
      <tags>
        <tag>软路由</tag>
        <tag>SoftRouting</tag>
        <tag>RouterOS</tag>
        <tag>OpenWRT</tag>
        <tag>LEDE</tag>
        <tag>ESXi 6.7</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/post/a0df4ec2.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h3><h3 id="UML建模"><a href="#UML建模" class="headerlink" title="UML建模"></a>UML建模</h3><h2 id="设计模式概论"><a href="#设计模式概论" class="headerlink" title="设计模式概论"></a>设计模式概论</h2><h2 id="设计模式目的"><a href="#设计模式目的" class="headerlink" title="设计模式目的"></a>设计模式目的</h2><h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL相关读书笔记</title>
    <url>/post/35e48191.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>Good code is its own best documentation. As you’re about to add a comment, ask yourself, “How can I improve the code so that this comment isn’t needed?”<br>Steve McConnell</p>

</blockquote>

<h1 id="Effective-MySQL之SQL语句最优化"><a href="#Effective-MySQL之SQL语句最优化" class="headerlink" title="Effective MySQL之SQL语句最优化"></a>Effective MySQL之SQL语句最优化</h1><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p>MySQL主要用到的索引数据结构有：</p>
<ul>
<li>B-树：<a href="http://en.wikipedia.org/wiki/Btree">B-树</a></li>
<li>B+树:<a href="http://en.wikipedia.org/wiki/B%2B_tree">B+树</a></li>
<li>散列：<a href="http://en.wikipedia.org/wiki/Hash_table">散列</a></li>
<li>通信R-树：<a href="http://en.wikipedia.org/wiki/R-tree">R-树</a></li>
<li>全文本:<a href="http://en.wikipedia.org/wiki/Full_text_search">全文本</a><h3 id="MySQL不同存储引擎数据结构"><a href="#MySQL不同存储引擎数据结构" class="headerlink" title="MySQL不同存储引擎数据结构"></a>MySQL不同存储引擎数据结构</h3><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4>MyISAM存储引擎使用B-树数据结构来实现<strong>主码索引</strong>、<strong>唯一索引</strong>以及<strong>非主码索引</strong>。<br>MyISAM索引是在内存的一个公共键缓存中管理的，这个缓存大小可以通过<code>key_buffer_size</code>或者其他命名键缓存来定义。<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><h5 id="B-树聚簇主码"><a href="#B-树聚簇主码" class="headerlink" title="B+树聚簇主码"></a>B+树聚簇主码</h5>InnoDB用聚簇主码存储数据，底层信息占用的磁盘空间的大小很大程度上取决于页面的填充因子；所有InnoDB数据和索引都是在内存中通过<code>innodb_buffer_pool_size</code>设置选项定义InnoDB缓冲池进行管理。<h5 id="B-树非主码"><a href="#B-树非主码" class="headerlink" title="B-树非主码"></a>B-树非主码</h5>非主码索引使用B-树数据结构，与MyISAM区别在于，InnoDB中，非主码索引存储的是主码实际值，而在MyISAM中，非主码索引存储的是包含主码值的数据的指针。<h4 id="内存散列索引"><a href="#内存散列索引" class="headerlink" title="内存散列索引"></a>内存散列索引</h4>只有MEMORY引擎支持散列的数据结构。<span id="more"></span>
<h2 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h2>从5.1版本起的ＭｙＳＱＬ开始支持通往范围、列表、散列、键以及散列等对表进行分区。<em>分区的实现对索引的使用和优化有一些帮助。</em><br>一个已分区的表不支持全文本索引、空间索引以及外键索引。分区表上的主索引和唯一索引必须包含分区表达式中用到的所有列。</li>
</ul>
<p><strong>MySQL可以通过控制分区来实现只扫描一些用到的索引，而不是扫描所有索引</strong></p>
<h2 id="MySQL索引创建"><a href="#MySQL索引创建" class="headerlink" title="MySQL索引创建"></a>MySQL索引创建</h2><p>创建索引并不是优化SQL语句的唯一方式。选择一种好的方式对数据库模式或者SQL语句中数据的应用程序的用法进行优化，通常可以对系统整体性能产生更加深远的影响。</p>
<h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>单列索引是最基础的索引，这是一种建立在数据库表中特定列上的索引。MySQL并没有限制在一个表的索引数量，然而创建索引还是会对性能有影响。</p>
<h4 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h4><p>非主码索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span><span class="keyword">table</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] KEY<span class="operator">|</span>INDEX [index<span class="operator">-</span>name]</span><br><span class="line">    (<span class="operator">&lt;</span><span class="keyword">column</span><span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>
<p>主码索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span><span class="keyword">table</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] KEY [index<span class="operator">-</span>name]</span><br><span class="line">    (<span class="operator">&lt;</span><span class="keyword">column</span><span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="利用索引限制查询读取的行数"><a href="#利用索引限制查询读取的行数" class="headerlink" title="利用索引限制查询读取的行数"></a>利用索引限制查询读取的行数</h4><h4 id="使用索引连接表"><a href="#使用索引连接表" class="headerlink" title="使用索引连接表"></a>使用索引连接表</h4><p>关联表键设置索引</p>
<h4 id="理解索引的基数"><a href="#理解索引的基数" class="headerlink" title="理解索引的基数"></a>理解索引的基数</h4><p>这里的基数(Cardinality[/ˌkärdəˈnalədē/])数值，如果某个索引的基数越高，反映该列中的唯一值的数量越多，那么越有可能在选用这个索引时以更少的读操作中找到需要的记录。<br>一个优秀选择性的索引意味着有着更少的相同值的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEXES <span class="keyword">FROM</span> some_key</span><br></pre></td></tr></table></figure>
<h4 id="使用索引进行模式匹配"><a href="#使用索引进行模式匹配" class="headerlink" title="使用索引进行模式匹配"></a>使用索引进行模式匹配</h4><p>【技巧】 如果经常需要一个以<strong>通配符</strong>开头的查询，常用的方法是在数据库中保持需要查询的值的反序值。例如：<br>假设查询以<code>.com</code>结尾的电子邮件地址，当搜索<code>email like &#39;%.com&#39;</code>时MySQL不能使用索引；而搜索<code>reverse_email like reverse(&#39;%.com&#39;)</code>就可以使用定义在<code>reverse_eamil</code>列上的索引。</p>
<h4 id="选择唯一的行"><a href="#选择唯一的行" class="headerlink" title="选择唯一的行"></a>选择唯一的行</h4><p>如果想要保证每个艺人都有一个唯一的名字，可以创建唯一的索引。唯一索引有两个目的：</p>
<ul>
<li>提供数据完整性以保证列中任何值都只出现一次</li>
<li>告知优化器对给定的记录最多只可能有一行结果返回；这点很重要，因为有了这些信息就可以避免额外的索引扫描</li>
</ul>
<p>【技巧】 在可以为空的列上定义唯一索引也是可行的。这种情况下，NULL的值被认为是一个未知的值，并且NULL!=NULL。这就是三态逻辑的好处，它避免了使用默认值或者一个空字符串值。</p>
<h4 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h4><p>使用基于索引的排序方法，可以免去分类的过程</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><h4 id="创建更好的索引"><a href="#创建更好的索引" class="headerlink" title="创建更好的索引"></a>创建更好的索引</h4><p>假设表album中存在下述两个索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> album <span class="keyword">ADD</span> INDEX m1(country_id, album_type_id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> album <span class="keyword">ADD</span> INDEX m2(album_type_id,country_id);</span><br></pre></td></tr></table></figure>
<p>争对一个查询SQL EXPLAIN后的结果如下：<br>建立索引m1之后的：<br><img data-src="35e48191/EXPLAIN_SQL1.jpg" alt="EXPLAIN_SQL1"><br>建立索引m2之后的：<br><img data-src="35e48191/EXPLAIN_SQL2.jpg" alt="EXPLAIN_SQL2"><br>查看所有状态：<br><img data-src="35e48191/SHOW_INDEX_STATUS.jpg" alt="SHOW_INDEX_STATUS"></p>
<p>【技巧】 当在对一个交集表使用多列索引时，尤其是在每一列都有指定值时，交换列的顺序可能会创建出更好的索引。<br>多列索引除了优化限制返回的行之外还有更重要的用途。多列索引中最左边的列也可以被当作单一列索引来高效的使用。当这些列被频繁用于聚合操作（即GROUP BY）和排序操作（即ORDER BY操作）时，最左边的列可能也同样可以显著提升性能。</p>
<h4 id="多列上的索引"><a href="#多列上的索引" class="headerlink" title="多列上的索引"></a>多列上的索引</h4><p>索引的行的宽度应该尽可能的短，这样就可以在一个索引数据页面中包含更多的索引记录。<strong>这样做的好处是可以读取尽量少的数据，从而快地遍历索引。</strong>如果还能保证索引的高效，这样能使系统内存的使用率最大化。EXPLAIN命令结果中的<code>key_len</code>和<code>ref</code>两个属性的值可以用来判断选中的索引的列使用率。</p>
<h4 id="合并WHERE和ORDER-BY语句"><a href="#合并WHERE和ORDER-BY语句" class="headerlink" title="合并WHERE和ORDER BY语句"></a>合并WHERE和ORDER BY语句</h4><p>【技巧】 创建一个能够用于对结果排序时的索引是有难度的；然而在某些频繁地（例如每秒100次）对相同数据进行排序的应用程序中，这样做将会带来很多益处。从使用<code>PROCESSLIST</code>命令查看<code>sorting results</code>的值中，明显可以看出对CPU的影响，以及对一个经过优化的模式和SQL设计的参考方案的强烈需求。</p>
<h3 id="添加索引造成的影响"><a href="#添加索引造成的影响" class="headerlink" title="添加索引造成的影响"></a>添加索引造成的影响</h3><h4 id="DML影响"><a href="#DML影响" class="headerlink" title="DML影响"></a>DML影响</h4><p>示例中表明，包含更多索引的表中插入数据比原始表中插入慢了4倍。虽然是粗略的测试，但是足够表明在<strong>表上添加索引对写操作的性能有直接的影响</strong></p>
<h5 id="重复索引"><a href="#重复索引" class="headerlink" title="重复索引"></a>重复索引</h5><p>在众多索引优化技术中，最简单的就是删除重复索引。例如：一个索引与主码或者某些其他索引的子集相匹配。任何包含在其他索引的最左边部分中的索引都属于重复索引，且不会被使用。示例：<br><img data-src="35e48191/duplicate_index.jpg" alt="duplicate_index"></p>
<h4 id="DDL影响"><a href="#DDL影响" class="headerlink" title="DDL影响"></a>DDL影响</h4><p>随着表大小的不断增长，对性能的影响也不断加大。根据标准的升级法则，任何DML操作都会导致所有语句被阻塞；档在InnoDB中使用默认的公共表空间配置的时候。MySQL会为你的表创建一份备份。如果表的大小有200GB，那么在执行ALTER TABLE时你需要至少200GB额外的磁盘空间。使用InnoDB时，在执行期间这些额外的磁盘空间会被添加到公共表空间中。这部分磁盘空间在命令完成之后不会被文件系统回收，而是当InnoDB需要额外磁盘空间时在内部被重复利用。<br>【技巧】 有一些技巧可以让阻塞操作减少到最低限度。你可以选择使用一个高可用性的容错度搞的<strong>主表复制</strong>技术来支持在线变更表结构。</p>
<h4 id="磁盘空间的影响"><a href="#磁盘空间的影响" class="headerlink" title="磁盘空间的影响"></a>磁盘空间的影响</h4><p>使用InnoDB也会对磁盘使用空间产生直接影响，这些影响取决于所选择的主码以及如何使用这些主码。对于非主码索引，总是有一个主码索引附在非主码索引的记录后面。因此对于InnoDB表，一定要在主码中使用尽可能小的数据类型。</p>
<h5 id="页面的填充因子"><a href="#页面的填充因子" class="headerlink" title="页面的填充因子"></a>页面的填充因子</h5><p>选择用现实中存在的属性做主码而不是用现实中无意义的编码会对默认页面的填充因子产生直接影响。</p>
<h5 id="非主码索引"><a href="#非主码索引" class="headerlink" title="非主码索引"></a>非主码索引</h5><p>InnoDB在非主码索引中使用了主码的值，而不是一个指向主码的指针。在每个索引记录后面都附上了一个可应用的主码的副本。当数据库表有一个长度为40字节的主码，并且你还拥有15个索引时，引入一个更短的主码可以大幅减少索引的空间占用量。<strong>这种使用主码的值的实现方式与InnoDB内部的主码散列算法结合使用能够改善性能。</strong></p>
<h4 id="MySQL的限制和不足"><a href="#MySQL的限制和不足" class="headerlink" title="MySQL的限制和不足"></a>MySQL的限制和不足</h4><h5 id="基于开销的优化器"><a href="#基于开销的优化器" class="headerlink" title="基于开销的优化器"></a>基于开销的优化器</h5><h5 id="指定QEP"><a href="#指定QEP" class="headerlink" title="指定QEP"></a>指定QEP</h5><h5 id="索引的统计信息"><a href="#索引的统计信息" class="headerlink" title="索引的统计信息"></a>索引的统计信息</h5><h5 id="基于函数的索引"><a href="#基于函数的索引" class="headerlink" title="基于函数的索引"></a>基于函数的索引</h5><h5 id="一个表上的多个索引"><a href="#一个表上的多个索引" class="headerlink" title="一个表上的多个索引"></a>一个表上的多个索引</h5><h2 id="创建更好的MySQL索引"><a href="#创建更好的MySQL索引" class="headerlink" title="创建更好的MySQL索引"></a>创建更好的MySQL索引</h2><ul>
<li>创建覆盖索引</li>
<li>创建局部列的索引</li>
</ul>
<h3 id="更好的索引"><a href="#更好的索引" class="headerlink" title="更好的索引"></a>更好的索引</h3><p>合理的调整你的索引对于优化来说是非常重要的，尤其是对于高吞吐量的应用程序。及时对执行时间的改进仅仅是数毫秒，蛋对于一个每秒执行1000次的查询来说这也非常有意义的性能提升。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>示例：针对一个表只有大约500,000行的数据的一个查询。<br>查询示例：<img data-src="35e48191/covered_index_sample1.jpg" alt="covered_index_sample1"><br>增加一列索引之后：<br><img data-src="35e48191/covered_index_sample2.jpg" alt="covered_index_sample2"><br>增加覆盖索引之后：<br><img data-src="35e48191/covered_index_sample3.jpg" alt="covered_index_sample3"><br>上述QEP在Extra列中显示了<code>Using Index</code>时，这并不意味着在访问底层表数据时使用到了索引，这表示只有这个索引才是满足查询所有需求的。这种索引可以为大型查询或者频繁执行的查询带来显著的性能提升，它被称之为覆盖索引。<br>【技巧】 有很多理由可以说服用户不要在SQL查询中使用<code>SELECT *</code>。如果在select语句中只包含那些真正需要的列，就能通过创建合适的索引来获得更好的SQL优化。<br>【警告】 创建这些索引只是用来描述确认覆盖索引的过程，但在生产环境中它们可能并不是理想的索引。有余数据集大小有限，我们在这些例子中使用了一个长字符列。随着数据容量的增加，尤其是超过内存和磁盘最大容量的时候，为一个大型列创建索引可能会对系统整体性能有影响。<strong>覆盖索引对于那些使用了很多较小长度的主码和外键约束的大型规范化模式来说是理想的优化方式。</strong></p>
<h4 id="局部索引"><a href="#局部索引" class="headerlink" title="局部索引"></a>局部索引</h4><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ALETER <span class="keyword">TABLE</span> album</span><br><span class="line">    <span class="keyword">DROP</span> INDEX name,</span><br><span class="line">    <span class="keyword">ADD</span> INDEX (name(<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<p>创建一个更小的索引意味着更少的磁盘IO开销，而这又意味着能更快地访问到需要访问的行，尤其是当磁盘上的索引和数据列远大于可用的系统内存时。这样获得的性能改进将会超过一个非唯一的并且拥有低基数的索引带来的影响。</p>
<h2 id="MySQL配置选项"><a href="#MySQL配置选项" class="headerlink" title="MySQL配置选项"></a>MySQL配置选项</h2><ul>
<li>内存相关的系统变量</li>
<li>日志和工具系统变量</li>
<li>各种查询相关的系统变量</li>
</ul>
<h3 id="内存相关的系统变量"><a href="#内存相关的系统变量" class="headerlink" title="内存相关的系统变量"></a>内存相关的系统变量</h3><p>全局内存缓冲区<br><img data-src="35e48191/whole_memory_buffer.jpg" alt="whole_memory_buffer"><br>全局/会话内存缓冲区<br><img data-src="35e48191/whole_session_buffer.jpg" alt="whole_session_buffer"><br>会话缓冲区<br><img data-src="35e48191/session_buffer.jpg" alt="session_buffer"><br>【警告】 这4个缓冲区是以每个线程为基础定义的。在MySQL 5.1以及更高的版本中，<code>sort_buffer_size</code>缓冲区的默认值可以在128K/256K~2M之间变化。如果一个缓冲区的大小定义为10M或者100M的话，就会对查询和系统性能产线相反的影响。在没有证据能证明性能提升的情况下，最好的方法时恢复这4个变量的默认值来保证总体内存利用率最大。</p>
<h2 id="SQL的生命周期"><a href="#SQL的生命周期" class="headerlink" title="SQL的生命周期"></a>SQL的生命周期</h2><p>优化SQL语句的生命周期涉及6个独立的部分，这包括如何截取SQL语句、识别有问题的SQL语句以及在开始分析前如何确认SQL语句。</p>
<ul>
<li>截取SQL语句</li>
<li>识别并分类有问题的SQL语句</li>
<li>确认SQL语句的当前操作</li>
<li>分析SQL语句和辅助信息</li>
<li>优化SQL语句</li>
<li>验证SQL优化的结果</li>
</ul>
<h3 id="截取SQL语句"><a href="#截取SQL语句" class="headerlink" title="截取SQL语句"></a>截取SQL语句</h3><p>可以通过一个采样过程来收集所有执行过语句的一部分；或者也可以通过详细收集进程收集一段时间内所有执行过的语句。下面列出的是MySQL中各种流行的SQL语句截取技术：</p>
<ul>
<li>全面查询日志</li>
<li>慢查询日志</li>
<li>二进制查询</li>
<li>进程列表</li>
<li>引擎状态</li>
<li>MySQL连接器</li>
<li>应用程序代码</li>
<li>INFORMATION_SCHEMA</li>
<li>PERFORMANCE_SCHEMA</li>
<li>SQL语句统计信息插件</li>
<li>MySQL代理</li>
<li>TCP/IP<br>这里并没有列出所有可能的SQL截取技术。<h4 id="全面查询日志"><a href="#全面查询日志" class="headerlink" title="全面查询日志"></a>全面查询日志</h4>MySQL全面查询日志允许你截取所有在这个数据库实例上运行的SQL语句。从5.1版本开始，可以配置这个日志输出到文件或者数据库表中。全面查询日志功能，只有启用或者禁用两种状态，没有其他控制粒度。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log=1</span><br><span class="line">general_log_file=/path/to/file</span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>【注意】 全面查询日志很适合提供所有连续的SQL查询语句顺序，但他并不提供执行时间。在开发环境或者小容量数据的测试环境中启用全面日志功能是不错的审查SQL语句的方式，<strong>但永远不要在生产环境中启用这个功能。</strong></p>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>MySQL的慢查询日志用于提供那些在指令数据库实例上执行时间超过一定限制的那些查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log=1</span><br><span class="line">general_log_file=/path/to/file</span><br><span class="line">long_query_time=0.2</span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure>

<p>可以通过SLEEP()出来方便的测试慢查询日志的有效性，这个函数也支持毫秒单位。<br><img data-src="35e48191/function_sleep.jpg" alt="function_sleep"><br>从结果中可以看到，第一个SELECT SLEEP(0.1)语句没有被记录在慢查询日志中，因为他的执行时间小于long_query_time的阀值。</p>
<h4 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h4><p>MySQL的二进制日志涵盖了所有非SELECT语句，其中包括DML和DDL语句。这个日志功能可以来提供表级别粒度的语句容量的历史分析。UPDATE和DELETE语句的截取内容能够揭示出潜在的可优化索引。二进制日志功能可以通过下面的MySQL配置命令来启用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=/path/to/file</span><br></pre></td></tr></table></figure>

<p>MySQL提供了mysqlbinlog命令来创建MySQL二进制日志中信息的纯文本版本。生成的输出结果包含很多额外的文本信息，如果只关注DML语句的话，这些信息可以忽略。</p>
<h4 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h4><p>这个样例进程可以找出当前运行的这些时间很长的或者常用的查询。另外，这个命令还可以提供一些执行SQL语句的内部步骤信息。他还是一个找出执行时间很长从而阻塞了其他SQL语句的DML语句的简单方法。<br>以上可以通过State的值为<code>Locked</code>来判断<br><img data-src="35e48191/show_full_processlist.jpg" alt="show_full_processlist"><br>你也可以通过命令行工具<code>mysqladmin</code>来获得进程列表的信息，语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqladmin -uroot -p [-v] processlist</span></span><br></pre></td></tr></table></figure>

<p>使用如下的SQL语句同样可以从INFORMATION_SCHEMA(从5.1版本开始)中获得这些信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.PROCESSLIST;</span><br></pre></td></tr></table></figure>

<h4 id="引擎状态"><a href="#引擎状态" class="headerlink" title="引擎状态"></a>引擎状态</h4><p>存储引擎持有的SHOW ENGINE[引擎]STATUS命令提供一些额外的SQL信息。默认包含的MySQL存储引擎中，使用这个命令的是InnoDB。这不是一个理想的SQL语句来源，因为它主要展现其他系统的特性；但出于完整性考虑，还是要有这个功能，<strong>因为这是展示出由于某类错误而执行的SQL语句的唯一途径</strong>。<br><code>SHOW ENGINE INNODB STATUS</code>命令可以提供SQL语句的详细信息，包括那些运行的SQL语句以及那些导致外键验证失败或者造成死锁的SQL语句。请看下面示例：<br><img data-src="35e48191/show_engine_innodb_status.jpg" alt="show_engine_innodb_status"></p>
<h4 id="MySQL连接器"><a href="#MySQL连接器" class="headerlink" title="MySQL连接器"></a>MySQL连接器</h4><p>很多种类的MySQL连接器提供了截取SQL语句的简便方法，例如：Connector/J<br>可以参考以下Connector/J数据源配置的属性：</p>
<ul>
<li>logSlowQueries</li>
<li>slowQueryThresholdMillis</li>
<li>useNanosForElaspsedTime</li>
<li>slowQueryThresholdNanos</li>
<li>autoSlowLog</li>
</ul>
<h4 id="应用程序代码"><a href="#应用程序代码" class="headerlink" title="应用程序代码"></a>应用程序代码</h4><p>在你的应用程序代码中使用抽象类来实现所有数据库的访问是一种理想的截取详细SQL信息的方式，可以截取他的信息包括实际的SQL语句、查询的执行时间以及SQL语句的执行顺序。</p>
<h3 id="识别有问题的语句"><a href="#识别有问题的语句" class="headerlink" title="识别有问题的语句"></a>识别有问题的语句</h3><p>从上一步截取下来的SQL语句中找到有问题的语句，也是有优先级顺序的。<em>关注运行最慢的SQL查询并不是SQL语句优化的唯一技术要求。**</em>优化执行频率高的语句，同样能够显著改进系统性能。一条每秒执行成百上千次的查询，获得10毫秒的速度提升带来的益处远远大于一条每秒仅仅执行几次的查询，得到1秒的速度，提升的好处。**<br>【注意】 频繁执行且速度很快的SQL语句通常被认为不是必须要调整的。但提升这些查询的速度，能够为系统资源带来非常大的益处，这些资源使得你的数据库系统能够处理更多的SQL语句。<br>识别的过程可以用流水线的方式进行，通过在SQL语句中添加C语言风格的注释来实现。请看下面的示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/* 5m cache */</span> ...</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/* AddPost */</span> ...</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/* CustomerReport */</span> ...</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/* EOM processing */</span> ...</span><br></pre></td></tr></table></figure>

<p>该技术再识别那些，原本就需要很长的运行时间并且定位和分类的优先级要求都比较低的查询时很有用。例如，在一个集合了线程事务处理(OLTP)、批处理、报表以及缓存查询功能与一生的应用程序中，找到那些重要但第一优先级的，且运行时间长的SQL语句，能够为我们指出其他语句，应该被优先审查和优化。</p>
<h4 id="慢查询日志分析"><a href="#慢查询日志分析" class="headerlink" title="慢查询日志分析"></a>慢查询日志分析</h4><p>通过一些第三方开源工具，分析慢查询日志</p>
<h3 id="确认语句执行"><a href="#确认语句执行" class="headerlink" title="确认语句执行"></a>确认语句执行</h3><p>在确认sql语句的精确返回时间时应该考虑到因素包括：当前系统的负载、查询并发程度、网络开销、MySQL查询缓存以及否在内存内部访问必要的表索引和数据。</p>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>你的最终目标是使用一种可以重现的方式来确认你发现的SQL语句。这种情况将允许你为后面的优化重现这些信息。</p>
<h4 id="时间统计"><a href="#时间统计" class="headerlink" title="时间统计"></a>时间统计</h4><p>启用会话时<code>SHOW PROFILES</code>命令后可以提供SQL语句的微秒级别粒度。一个定义良好且在SQL性能方面很积极的基础架构能够主动收集很多信息，不仅仅包括SQL语句、QEP、查询执行时间，还包括很多其他的查询细节，例如获取到的行数、结果集大小、底层有代表性的表数据大小及查询分析中用到的MySQL配置信息。</p>
<h3 id="语句分析"><a href="#语句分析" class="headerlink" title="语句分析"></a>语句分析</h3><p>相关命令和工具来分析SQL语句</p>
<h3 id="语句优化"><a href="#语句优化" class="headerlink" title="语句优化"></a>语句优化</h3><p>一种是通过索引来优化SQL语句的过程，其他优化sql语句的技术也可以提供更好的性能改进，包括通过去除连接操作或减少列的数目来简化SQL语句，还有精简数据类型和约束条件（比如是否可以为空）来改进表的结构。</p>
<h3 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h3><h2 id="性能优化之隐藏秘籍"><a href="#性能优化之隐藏秘籍" class="headerlink" title="性能优化之隐藏秘籍"></a>性能优化之隐藏秘籍</h2><p>有多种技术可以用于简化或者减少SQL语句，从而对性能和吞吐量提升带来立竿见影的效果。</p>
<ul>
<li>去除重复的索引</li>
<li>找到没有被使用或者无效的索引</li>
<li>改进索引</li>
<li>减少SQL语句</li>
<li>简化SQL语句</li>
<li>缓存选项</li>
</ul>
<h3 id="索引优化管理"><a href="#索引优化管理" class="headerlink" title="索引优化管理"></a>索引优化管理</h3><p>索引的管理过程，即索引创建和维护的方式，能够影响到SQL语句的性能。</p>
<h4 id="整合DDL语句"><a href="#整合DDL语句" class="headerlink" title="整合DDL语句"></a>整合DDL语句</h4><p>把多条ALERT语句整合成一条SQL语句是一种简单的优化改进。</p>
<h4 id="去除重复索引"><a href="#去除重复索引" class="headerlink" title="去除重复索引"></a>去除重复索引</h4><p>重复索引主要有两个影响：第一，所有DML语句都会运行的很慢，需要做更多工作来保持数据和索引的一致性；第二，数据库的磁盘占用量将会更大，这将导致备份和恢复需要的时间增加。其简单的情况会导致索引重复。<strong>MySQL不要求主码所在的列也被索引。</strong></p>
<h4 id="删除不用的索引"><a href="#删除不用的索引" class="headerlink" title="删除不用的索引"></a>删除不用的索引</h4><p>除了重复索引没有被用到之外，还有其他索引可能也没有被用到。这些索引和重复索引一样会影响性的。</p>
<h4 id="监控无效的索引"><a href="#监控无效的索引" class="headerlink" title="监控无效的索引"></a>监控无效的索引</h4><p>当定义多列索引时，一定要注意确定所指定的每一列是否真的有效。可以通过分析指定表上的所有SQL语句的<code>key_len</code>列找到那些可能包含没有使用到的列的索引。</p>
<h3 id="索引列的改进"><a href="#索引列的改进" class="headerlink" title="索引列的改进"></a>索引列的改进</h3><p>除了创建新的索引来改进查询性能之外，还可以通过其他模式优化的方法来改进数据库的性能，包括使用特定的数据类型以及/或者列的类型。这样做的好处是可以使用更小的磁盘空间，从而减少了IO的开销，且使得更多的索引数据可以被打包装载进入可用的系统内存中。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>有几种数据类型可以被替换或修改的，而且这样做几乎不会对已有的模式造成任何影响。</p>
<h4 id="BIGINT和INT"><a href="#BIGINT和INT" class="headerlink" title="BIGINT和INT"></a>BIGINT和INT</h4><p>当一个主码被定义为<code>BIGINT AUTO_INCREMENT</code>数据类型时，一般来说不需要搞清楚这个数据类型存在的原因。<br>【技巧】 在<code>AUTO_INCREMENT</code>列上把数据类型从<code>BIGINT</code>改成<code>INT UNSIGNED</code>是最有效的模式改进方法之一，尤其是对那些只有有限的内存同时具有高度规范化的数据模型的数据库服务器。</p>
<h4 id="DATETIME和TIMESTAMP"><a href="#DATETIME和TIMESTAMP" class="headerlink" title="DATETIME和TIMESTAMP"></a>DATETIME和TIMESTAMP</h4><p>如果所存储的只是只是一个纪元值，那么一个TIMESTAMP列支持所有必须的值。一个DATETIME列支持所有可能的日期/时间的值。一个DATETIME数据类型占用8字节，而一个TIMESTAMP类型占用4字节。</p>
<h4 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h4><p>MySQL提供了ENUM数据类型，这个类型适合存储静态的代码值。例如，当然要记录性别的值时，可以选择以下方法中的任意一种来定义：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">gender1 <span class="type">VARCHAR</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">gender2 ENUM (<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<p>使用ENUM数据类型有3个优点：</p>
<ul>
<li>一个ENUM列利用隐含的检查限制，提供了额外的数据完整性支持</li>
<li>一个ENUM列仅使用1字节来存储255个不同的值</li>
<li>ENUM列的值更具有可读性。例如，如果你有一个状态字段，使用ENUM类型会使数据容量更加紧凑，并且为每一列的值提供更有意义的说明。</li>
</ul>
<h4 id="NULL和NOT-NULL"><a href="#NULL和NOT-NULL" class="headerlink" title="NULL和NOT NULL"></a>NULL和NOT NULL</h4><p>除非你确定一个列能包含一个未知的值（一个NULL值），否则最好把这一列定义为NOT NULL。</p>
<h4 id="隐含的变换"><a href="#隐含的变换" class="headerlink" title="隐含的变换"></a>隐含的变换</h4><p>当你为表连接选择一个索引数据类型时，一定要确保这个数据类型是相同的。隐含的类型转换将带来不必要的开销。对于整数类型的列，要确保SIGNED和UNSIGNED类型是统一的。对于可变的数据类型，会出现字符集和“逻辑与”运算的复杂情况。当为表连接定义索引列时，要确保这些都匹配。这里经常出现在LATIN1和UTF8字符集之间的隐含转换的问题。</p>
<h3 id="列的类型"><a href="#列的类型" class="headerlink" title="列的类型"></a>列的类型</h3><p>有几种数据类型发现广泛的用在一些并不高效的列类型中。这些列的数据类型能够带来更高效的存储，尤其是当这些列属于某个索引时。下面就是一些常见的示例：</p>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p><strong>一个IPv4地址可以被定义成INT UNSIGNED数据类型，只占用4字节。</strong>通常情况下将列定义为VARCHAR(15)，这样平均要占用12字节。<code>INET_ATON()</code>和<code>INET_NTOA()</code>函数可以管理IP地址在字符串和数字值之间的转换。</p>
<h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>用CHAR(32)来存储MD5值是一个常见的技巧。如果你的应用程序使用VARCHAR(32)，则对每个值的字符串长度都要花费额外的不必要的开销。这个16进制的值可以使用<code>UNHEX()</code>和<code>HEX()</code>函数来存储在BINARY(16)数据类型中且更为高效。用这种转换可以让每行占用的存储空间从32字节减少到16字节。</p>
<h3 id="其他SQL优化"><a href="#其他SQL优化" class="headerlink" title="其他SQL优化"></a>其他SQL优化</h3><p>添加索引能够带来显著的性能提升。然而，对关系型数据库来说，最有效的SQL优化方法是完全删除不需要执行的SQL语句。对于一个高度优化的应用程序来说，占总执行时间最大比重的是网络开销。去除sql语句能够减少应用程序的处理时间。对于sql语句来说，其他必要的步骤还包括解析语句、安全许可检查以及生成查询执行计划。如果其中有不必要的语句，那么这些都会为数据库服务器不必要的负担。可以使用分析功能，在查询执行过程中获得这些步骤的详细时间统计。请看下面的例子：<br><img data-src="35e48191/show_profile_source_for_query.jpg" alt="show_profile_source_for_query"></p>
<h4 id="减少SQL语句"><a href="#减少SQL语句" class="headerlink" title="减少SQL语句"></a>减少SQL语句</h4><p>有一些简单的技巧可以用来减少SQL语句：</p>
<ul>
<li>删除内容重复的SQL语句</li>
<li>删除重复执行的SQL语句</li>
<li>删除不必要的SQL语句</li>
<li>缓存SQL语句的返回结果</li>
</ul>
<h5 id="删除内容重复的SQL语句"><a href="#删除内容重复的SQL语句" class="headerlink" title="删除内容重复的SQL语句"></a>删除内容重复的SQL语句</h5><p>指定函数或者进程的所有SQL语句的结果表明那些为了完成一个特定请求而重复执行的SQL语句。最好的做法是在开发环境中启用全面查询日志。</p>
<h5 id="删除重复执行的SQL语句"><a href="#删除重复执行的SQL语句" class="headerlink" title="删除重复执行的SQL语句"></a>删除重复执行的SQL语句</h5><p>很多应用程序遇到过每次一行(Row At a Time, RAT)的处理方式，这个问题也被叫做N+1问题，导致这个问题的原因是外层循环为每一行都生成一个SQL语句。这会导致成百上千的重复执行SQL语句。<br>通常情况下，用一条SQL语句来实现每次一块(Chunk At a Time, CAT)的处理方式能够减少重复SQL语句。使用SQL的强项-集合处理能力可以有效的改善性能。</p>
<h5 id="删除不必要的SQL语句"><a href="#删除不必要的SQL语句" class="headerlink" title="删除不必要的SQL语句"></a>删除不必要的SQL语句</h5><p>随着时间的推移，应用程序会不断修改和增加功能，这可能产生不必要的SQL语句，例如：</p>
<ul>
<li>不再需要的选择信息</li>
<li>仅仅在给定函数的某些路径上用到的选择信息</li>
<li>可以从之前的SQL语句中选择的信息</li>
</ul>
<p>应用程序的功能模块在时间推移的过程中很容易遇到这些问题。</p>
<h5 id="缓存SQL结果"><a href="#缓存SQL结果" class="headerlink" title="缓存SQL结果"></a>缓存SQL结果</h5><p>当普通数据的变化率相对较低时，缓存SQL结果够为你的应用程序带来性能提升和对数据库服务器的可扩展性。</p>
<h5 id="MySQL缓存"><a href="#MySQL缓存" class="headerlink" title="MySQL缓存"></a>MySQL缓存</h5><p>MySQL查询缓存能够为毒操作频繁的环境带来性能提升，且在不需要其他应用程序开销的情况下就可以实现。</p>
<h5 id="应用程序缓存"><a href="#应用程序缓存" class="headerlink" title="应用程序缓存"></a>应用程序缓存</h5><p>在应用程序级别添加缓存，能够大幅减少不必要的SQL语句的执行。</p>
<h4 id="简化SQL语句"><a href="#简化SQL语句" class="headerlink" title="简化SQL语句"></a>简化SQL语句</h4><p>当进一步减少SQL语句已无可能时，还可以简化SQL语句。简化语句时需要考虑以下问题：</p>
<ul>
<li>查询中所有的列都是必须的吗？</li>
<li>表的连接操作能被省去吗？</li>
<li>在给定的函数中，连接或WHERE条件限制的对其他SQL语句是必要的吗？</li>
</ul>
<h5 id="改进列"><a href="#改进列" class="headerlink" title="改进列"></a>改进列</h5><p>改进的过程一个重要要求就是按顺序截取指定函数中的所有SQL语句。<br><img data-src="35e48191/2019-08-25_105114_ScreenShot013.jpg" alt="改进列"></p>
<h5 id="改进连接操作"><a href="#改进连接操作" class="headerlink" title="改进连接操作"></a>改进连接操作</h5><p><img data-src="35e48191/2019-08-25_105224_ScreenShot014.jpg" alt="改进连接操作"></p>
<h5 id="重写子查询"><a href="#重写子查询" class="headerlink" title="重写子查询"></a>重写子查询</h5><p>在某些环境下，查询的性能比直接使用一般的表连接要慢的多。请看下面的示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,label</span><br><span class="line"><span class="keyword">FROM</span> code_opts</span><br><span class="line"><span class="keyword">WHERE</span> code_id<span class="operator">=</span>(<span class="keyword">SELECT</span> id FORM codes <span class="keyword">WHERE</span> typ<span class="operator">=</span><span class="string">&#x27;CATEGORIES&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> seq</span><br></pre></td></tr></table></figure>
<p>这条SQL语句能够简单的重写成以下语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.id,o.label</span><br><span class="line"><span class="keyword">FROM</span> code_opts o INNER_JOIN codes c <span class="keyword">ON</span> o.code_id <span class="operator">=</span> c.id</span><br><span class="line"><span class="keyword">WHERE</span> c.typ<span class="operator">=</span><span class="string">&#x27;CATEGORIES&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> o.seq</span><br></pre></td></tr></table></figure>
<h5 id="理解试图-views-所带来的影响"><a href="#理解试图-views-所带来的影响" class="headerlink" title="理解试图(views)所带来的影响"></a>理解试图(views)所带来的影响</h5><p>开发人员应该知道SQL语句中所使用的表的真正类别。如果这个对象实际上是一个视图，那么SQL优化的影响将会被试图定义的连接条件的复杂性掩盖。</p>
<h4 id="使用MySQL的复制功能"><a href="#使用MySQL的复制功能" class="headerlink" title="使用MySQL的复制功能"></a>使用MySQL的复制功能</h4><p>在多台服务器中可以使用MySQL的附属扩展节点(slaves)来增强读扩展性。这个原理在对读操作要求很高的应用程序中是很常见的。</p>
<h2 id="MySQL-EXPLAIN命令详解"><a href="#MySQL-EXPLAIN命令详解" class="headerlink" title="MySQL EXPLAIN命令详解"></a>MySQL EXPLAIN命令详解</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN [EXTENDED <span class="operator">|</span> PARTITIONS]</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> ...</span><br><span class="line">或者</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">table</span></span><br></pre></td></tr></table></figure>

<p>例如：<br><img data-src="35e48191/explain_sample.jpg" alt="explain_sample"><br>QEP中每个行的所有列表如下所示：</p>
<ul>
<li>id</li>
<li>select_type</li>
<li>table</li>
<li>partitions(这一列只有在EXPLAIN PARTITIONS语法中才会出现)</li>
<li>possible_keys</li>
<li>key</li>
<li>key_len</li>
<li>ref</li>
<li>rows</li>
<li>filtered(这一列只有在EXPLAIN PARTITIONS语法中才会出现)</li>
<li>Extra</li>
</ul>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>key列指出优化器选择使用的索引。一般来说SQL查询中的每个表都仅使用一个索引。也存在索引合并的少数例外情况，如给定表上用到了两个或者更多索引。</p>
<h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>rows提供了试图分析所有存在于累计结果集中的行数目的MySQL优化器估值。QEP很容易描述这个很困难的统计量。查询中总的读操作数量是基于合并之前的每一行的rows值的连续累积而得出的。</p>
<h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>possible_keys列指出优化器为查询选定的索引。一个会列出大量可能的索引（例如多于3个）的QEP意味着备选索引数量太多了，同时也可能提示存在一个无效的单列索引。</p>
<h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>key_len列定义列用于SQL语句连接条的键的长度。此列值对于确认索引的有效性以及多列索引中用到的列的数目很重要。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">key_len: 4  // INT NOT NULL</span><br><span class="line">key_len: 5  // INT NULL</span><br><span class="line">key_len: 30 // CHAR(30) NOT NULL</span><br><span class="line">key_len: 32 // VARCHAR(30) NOT NULL</span><br><span class="line">key_len: 92 // VARCHAR(30) NULL CHARSET=utf8</span><br></pre></td></tr></table></figure>

<p>从这些事例中可以看出，是否可以为空、可变长度的列以及字符集都会影响到表索引的内部内存大小。</p>
<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>table列是EXPLAIN命令输出结果中的一个单独行的唯一标识符。</p>
<h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>select_type列提供了各种表示table列引用的使用方式的类型。最常见的值包括<code>SIMPLE</code>、<code>PRIMARY</code>、<code>DERIVED</code>和<code>UNION</code>。</p>
<h5 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h5><p>对于不包含此查询和其他复杂语法的简单查询，这是一个常见的类型。</p>
<h5 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h5><p>这是为更复杂的查询而创建的首要表（也就是最外层的表）。这个类型通常可以在DERIVED和UNION类型混合使用时见到。</p>
<h5 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h5><p>当一个表是一个物理表时，那么就被叫做DERIVED。</p>
<h5 id="DEPENDENT-SUBQUERY"><a href="#DEPENDENT-SUBQUERY" class="headerlink" title="DEPENDENT SUBQUERY"></a>DEPENDENT SUBQUERY</h5><p>这个select-type值是为使用子查询而定义的。下面的SQL语句提供列这个值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> p.<span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> parent p</span><br><span class="line">    <span class="keyword">WHERE</span> p.id <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="keyword">SELECT</span> c.praent_id <span class="keyword">FROM</span> child c);</span><br></pre></td></tr></table></figure>

<h5 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h5><p>这个UNION语句其中的一个SQL元素。</p>
<h5 id="UNION-RESULT"><a href="#UNION-RESULT" class="headerlink" title="UNION RESULT"></a>UNION RESULT</h5><p>这是一系列定义在UNION语句中的表的返回结果。当select_type为这个值时，经常可以看到table的值是&lt;unionN,M&gt;,这说明匹配的id行是这个集合的一部分。</p>
<h4 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h4><p>partitions列代表给定表所使用的分区。</p>
<h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>Extra列提供列有关不同种类的MySQL优化器路径的一系列额外信息。</p>
<h5 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h5><p>这个值表示查询使用了where语句来处理结果，例如：之前全表扫描。如果引用到了索引，那么行的限制条件是通过获取必要的数据之后，处理读缓冲区来实现的。</p>
<h5 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a>Using temporary</h5><p>这个只是表示使用了内部临时(基于内存的)表。一个查询可能用到多个临时表。有很多原因会导致MySQL在执行查询期间创建临时表。两个常见的原因是来自不同表的列上使用的DISTINCT，或者使用了不同的ORDER BY和GROUP BY列。</p>
<h5 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h5><p>这是ORDER BY语句的结果。这可能是一个CPU密集型的过程。</p>
<h5 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h5><p>这个只是重点强调了只需要使用，所以就可以满足查询表的要求，不需要直接访问数据表。</p>
<h5 id="Using-join-buffer"><a href="#Using-join-buffer" class="headerlink" title="Using join buffer"></a>Using join buffer</h5><p>这个值强调了在获取连接条件时没有索引，并且需要连接缓冲区来存储中间结果。<em>如果出现了这个值，那应该注意，根据查询的具体情况，可能需要添加索引来改进性能。</em></p>
<h5 id="Impossible-where"><a href="#Impossible-where" class="headerlink" title="Impossible where"></a>Impossible where</h5><p>这个值强调了where语句会导致没有符合条件的行。请看下面的示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h5 id="Select-tables-optimized-away"><a href="#Select-tables-optimized-away" class="headerlink" title="Select tables optimized away"></a>Select tables optimized away</h5><p>这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行。请看下面示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPALIN <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">FROM</span> (SEELCT id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">first</span> <span class="operator">=</span> <span class="string">&#x27;west&#x27;</span>) c</span><br></pre></td></tr></table></figure>

<h5 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h5><p>这个值意味着MySQL在找到第1个匹配的行之后就会停止搜索其他行。</p>
<h5 id="Index-merges"><a href="#Index-merges" class="headerlink" title="Index merges"></a>Index merges</h5><p>当MySQL决定要在一个给定的表上使用超过一个索引的时候，就会出现以下格式中的一个，详细说明使用索引以及合并的类型：</p>
<ul>
<li>Using sort_union(…)</li>
<li>Using union(…)</li>
<li>Using intersect(…)</li>
</ul>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>id列是在QEP中展示的表的连续引用。</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>ref列可以被用来标识那些来进行索引比较的列或者常量。</p>
<h5 id="fitered"><a href="#fitered" class="headerlink" title="fitered"></a>fitered</h5><p>fitered列给出了一个百分比的值，这个百分比值和rows列的值一起使用，可以估计出那些将要和QEP中的前一个表进行连接的行的数目。前一个表就是指id列的值你当前表的id小的表。</p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>type列代表QEP中指的表使用的连接方式。下面是最常用的几种连接方式：</p>
<ul>
<li>const 当这个表最多只有一行匹配的行时出现</li>
<li>system 这是const的特例，当表只有一个row时会出现</li>
<li>eq_ref 这个只表示有一行是为了每个之前确定的表而读取的</li>
<li>ref 这个值表示所有具备匹配的索引值的行都被用到</li>
<li>range 这个值表示所有符合一定给定范围值的索引行都被用到。</li>
<li>ALL 这个只表示需要一次全表扫描</li>
</ul>
<p>其他类型的值还有fulltext、ref_or_null、index_merge、unique_subquery、index_subquery以及index。</p>
]]></content>
      <categories>
        <category>数据相关</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CAT监控学习与使用</title>
    <url>/post/93780ad2.html</url>
    <content><![CDATA[<p>测试部署</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CAT打点</tag>
        <tag>CAT监控</tag>
        <tag>美团CAT</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu相关系列</title>
    <url>/post/145818e1.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>又是一个熬夜的夜晚，凌晨2点半，新晋小备机工作站基本搞定了。 Yeah!</p>
<h2 id="Ubuntu安装与初始化配置"><a href="#Ubuntu安装与初始化配置" class="headerlink" title="Ubuntu安装与初始化配置"></a>Ubuntu安装与初始化配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h3 id="机械硬盘挂载"><a href="#机械硬盘挂载" class="headerlink" title="机械硬盘挂载"></a>机械硬盘挂载</h3><h3 id="切换数据源为阿里云"><a href="#切换数据源为阿里云" class="headerlink" title="切换数据源为阿里云"></a>切换数据源为阿里云</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">备份source.list</span></span><br><span class="line">cp -f /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>

<p>通过vi/vim修改sources.list<br>将原有的都注释了，把下面的数据源新增在文件末尾即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>保存之后，记得：<strong>sudo apt-get update</strong><br>更新数据源即可</p>
<h3 id="首次登录设置root密码"><a href="#首次登录设置root密码" class="headerlink" title="首次登录设置root密码"></a>首次登录设置root密码</h3><ul>
<li><p>打开终端，输入<strong>sudo passwd root</strong>，<br>在[sudo] password for wheat:后输入当前用户的密码</p>
</li>
<li><p>当前用户密码验证通过后<br>输入需要设置的root超级管理员账户密码Enter new UNIX password:<br>验证输入的密码Retype new UNIX password:</p>
</li>
<li><p>出现<strong>passwd: password updated successfully</strong>字样，表示超级管理员root账户密码设置成功</p>
</li>
<li><p>验证：输入su，后输入超级管理员账户的密码，验证通过则成功切换到root账户root</p>
</li>
</ul>
<h2 id="系列话题"><a href="#系列话题" class="headerlink" title="系列话题"></a>系列话题</h2><h3 id="在ubuntu下编译openjdk"><a href="#在ubuntu下编译openjdk" class="headerlink" title="在ubuntu下编译openjdk"></a>在ubuntu下编译openjdk</h3><p>编译方法来自于《深入理解JAVA虚拟机 第三版》，详细请参考该书中第一章，1.6小节的相关说明</p>
<h4 id="准备源码包"><a href="#准备源码包" class="headerlink" title="准备源码包"></a>准备源码包</h4><p>根据书中的说明，推荐直接通过网页下载，具体方法如下：<br>去链接<strong><a href="https://hg.openjdk.java.net/jdk/jdk12/">https://hg.openjdk.java.net/jdk/jdk12/</a></strong> 访问，点击左侧的<strong>Browse</strong>后，在下方有个zip压缩包，直接点击下载即可。如下图所示：<br><img data-src="145818e1/2021-05-08_165324.png" alt="下载openjdk12源码压缩包"></p>
<h4 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h4><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot实战读书笔记</title>
    <url>/post/322bf04b.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以历代Spring Framework的进步为基础，Spring Boot实现了自动配置，这让Spring能够智能探<br>测正在构建何种应用程序，自动配置必要的组件以满足应用程序的需要。对于那些常见的配置场<br>景，不再需要显式地编写配置了，Spring会替你料理好一切。</p>
<h3 id="第一章-入门"><a href="#第一章-入门" class="headerlink" title="第一章 入门"></a>第一章 入门</h3><h4 id="Spring-Boot-精要"><a href="#Spring-Boot-精要" class="headerlink" title="Spring Boot 精要"></a>Spring Boot 精要</h4><ul>
<li>自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置。</li>
<li>起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。</li>
<li>命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，<br>无需传统项目构建。</li>
<li>Actuator：让你能够深入运行中的Spring Boot应用程序，一探究竟。</li>
</ul>
<h5 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h5><p>Spring Boot的自动配置远不止嵌入式数据库和JdbcTemplate，它有大把的办法帮你减轻配置负担，这些自动配置涉及Java持久化API（Java Persistence API，JPA）、Thymeleaf模板、安全和Spring MVC。</p>
<h5 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h5><p>起步依赖其实就是特殊的<code>Maven</code>依赖和```Gradle``依赖，利用了传递依赖解析，把常用库聚合在一起，组成了几个为特定功能而定制的依赖。</p>
<h5 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h5><p>Spring Boot CLI利用了起步依赖和自动配置，让你专注于代码本身。</p>
<h5 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h5><p>Spring Boot的最后一块“拼图”是Actuator，其他几个部分旨在简化Spring开发，而Actuator则要提供在运行时检视应用程序内部情况的能力。提供如下细节：</p>
<ul>
<li>Spring应用程序上下文里配置的Bean</li>
<li>Spring Boot的自动配置做的决策</li>
<li>应用程序取到的环境变量、系统属性、配置属性和命令行参数</li>
<li>应用程序里线程的当前状态</li>
<li>应用程序最近处理过的HTTP请求的追踪情况</li>
<li>各种和内存用量、垃圾回收、Web请求以及数据源用量相关的指标</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot实战</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式架构（消息模式Actor实现与Scala、Akka应用集成）</title>
    <url>/post/483443e6.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>原书《Reactive Messaging Patterns with the Actor Model Applications and Integration in Scala and Akka》，作者：Vaughn Vernon，是《实现领域驱动设计》（Implementing Domain Driven Design）一书的作者。因而，本书值得一看。本文随笔笔记，记录本书中的主要点，以便后续查看翻阅。</p>
<h3 id="书章节小记"><a href="#书章节小记" class="headerlink" title="书章节小记"></a>书章节小记</h3><h4 id="推荐序"><a href="#推荐序" class="headerlink" title="推荐序"></a>推荐序</h4><p><em>注：</em>本书推荐序是由Akka项目创始人所作。</p>
<ul>
<li>Actor是异步驱动、可以并行和分布式部署及运行的最小颗粒。</li>
<li>Akka的Acotr模式本身可以保证单个Actor实例中每个行为的原子性，并行的粒度可以细化到单个Actor实例。</li>
<li>从架构层面看，Actor能同时担当实体Beans和中间缓存的角色，并且是异步驱动的，且具备分片集群下的水平扩展能力。</li>
<li>从业务领域来看，Actor可以非常自然地直接对应到业务实体。</li>
</ul>
<h4 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h4><p>Actor模型拥有以下优点：</p>
<ul>
<li>大幅度降低应用程序内部的耦合性</li>
<li>Actor模型的消息传递形式简化了并行程序的开发工作，使开发人员无须与并发编程基础元素打交道</li>
<li>在高动态环境中，Actor模型既可以利用顺序编程技巧，也可以利用函数编程技巧</li>
<li>Actor模型可以解决许多并发编程难题，如死锁、活锁、互斥体等等</li>
<li>Actor模型能够大幅度提高调用方法的安全性和速度</li>
</ul>
<h4 id="第一章-Actor模型和企业级软件概述"><a href="#第一章-Actor模型和企业级软件概述" class="headerlink" title="第一章 Actor模型和企业级软件概述"></a>第一章 Actor模型和企业级软件概述</h4>]]></content>
      <categories>
        <category>Akka系列</category>
      </categories>
      <tags>
        <tag>Akka</tag>
      </tags>
  </entry>
  <entry>
    <title>effective-javascript</title>
    <url>/post/ad5d9134.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>本文默认JS即为JavaScript语言</li>
<li>“注：”为本人理解内容</li>
</ul>
<h4 id="第2条：理解JavaScript的浮点数"><a href="#第2条：理解JavaScript的浮点数" class="headerlink" title="第2条：理解JavaScript的浮点数"></a>第2条：理解JavaScript的浮点数</h4><ul>
<li>不管是整数还是浮点数，JavaScript都将它们简单归类为数字。事实上，所有的数字都是<strong>双精度浮点数</strong></li>
<li>位运算符将数字视为32位的有符号整数</li>
<li>当心浮点运算中的精度陷阱</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">0.1</span> + <span class="number">0.2</span>) + <span class="number">0.3</span>; <span class="comment">// 0.6000000000000001</span></span><br><span class="line"><span class="number">0.1</span> + (<span class="number">0.2</span> + <span class="number">0.3</span>); <span class="comment">// 0.6</span></span><br><span class="line"><span class="comment">// 一个有效的解决方式是将浮点数转化为整数运算，例如上例中可以转换为</span></span><br><span class="line">(<span class="number">10</span> + <span class="number">20</span>) + <span class="number">30</span>; <span class="comment">// 60</span></span><br><span class="line"><span class="number">10</span> + (<span class="number">20</span> + <span class="number">30</span>); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>
<h4 id="第3条-当心隐式强制转换"><a href="#第3条-当心隐式强制转换" class="headerlink" title="第3条 当心隐式强制转换"></a>第3条 当心隐式强制转换</h4><ul>
<li>特别注意字符强制转换的问题：结果为null的变量在算术运算中不会导致失败，而是被隐式转换为0</li>
<li>测试某个值是否是NaN，在JS中唯一一个不等于其自身的值，因此，可以随时通过检查一个值是否等于其自身的方式来测试该值是否是NaN</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">NaN</span>;</span><br><span class="line">a !== a; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">b != b; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="第5条：避免对混合类型使用-运算符"><a href="#第5条：避免对混合类型使用-运算符" class="headerlink" title="第5条：避免对混合类型使用==运算符"></a>第5条：避免对混合类型使用==运算符</h4><p>一个好的替代方法是使用严格相等运算符<br><img data-src="ad5d9134/table1.1.jpg" alt="==运算符的强制转换规则"></p>
<span id="more"></span>
<h4 id="分号插入局限性"><a href="#分号插入局限性" class="headerlink" title="分号插入局限性"></a>分号插入局限性</h4><p>分号插入第一条规则：分号仅在|标记之前、一个或多个换行之后和程序输入的结尾被插入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> n = +x</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">r</span>) &#123; r = +r; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * r * r&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x + <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">r</span>) &#123; r = +r <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * r * r &#125;</span><br></pre></td></tr></table></figure>
<p>分号插入第二条规则：分号仅在随后的输入标记不能解析时插入，也可以理解为是一种错误矫正机制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="title function_">b</span></span><br><span class="line">(<span class="title function_">f</span>());</span><br><span class="line"><span class="comment">// 能正确解析为一条单独的语句，等价于：a = b(f());</span></span><br><span class="line">a = b</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// 则会解析为两条独立的语句</span></span><br></pre></td></tr></table></figure>
<p>注：完全没必要用这个特性，知道有这么个玩意儿就行，但是在实际开发过程中，不要有这种特性的东西，不容易理解，还容易出错。</p>
<h4 id="第8条：尽量少用全局对象"><a href="#第8条：尽量少用全局对象" class="headerlink" title="第8条：尽量少用全局对象"></a>第8条：尽量少用全局对象</h4><h4 id="第9条：避免使用with语句"><a href="#第9条：避免使用with语句" class="headerlink" title="第9条：避免使用with语句"></a>第9条：避免使用with语句</h4><h4 id="熟练掌握闭包"><a href="#熟练掌握闭包" class="headerlink" title="熟练掌握闭包"></a>熟练掌握闭包</h4><p>闭包第一个基本事实：JS允许你引用在当前函数意外定义的变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeSandwich</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> magicIngredient = <span class="string">&quot;peanut butter&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">filling</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> magicIngredient + <span class="string">&quot; and &quot;</span> + filling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">make</span>(<span class="string">&quot;jelly&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">makeSandwich</span>(); <span class="comment">// &quot;reanut butter and jelly&quot;</span></span><br></pre></td></tr></table></figure>
<p>第二个事实：即使外部函数返回，当前函数仍然可以引用在外部函数所定义的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sandwichMaker</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> magicIngredient = <span class="string">&quot;peanut butter&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">filling</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> magicIngredient + <span class="string">&quot; and &quot;</span> + filling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> make;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">sandwichMaker</span>();</span><br><span class="line"><span class="title function_">f</span>(<span class="string">&quot;jelly&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进版本</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sandwichMaker</span>(<span class="params">magicIngredient</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">filling</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> magicIngredient + <span class="string">&quot; and &quot;</span> + filling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> make;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hamAnd = <span class="title function_">sandwichMaker</span>(<span class="string">&quot;ham&quot;</span>);</span><br><span class="line"><span class="title function_">hamAnd</span>(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line"><span class="comment">// 提供直接匿名返回的方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sandwichMaker</span>(<span class="params">magicIngredient</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">filling</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> magicIngredient + <span class="string">&quot; and &quot;</span> + filling;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三个事实：闭包可以更新外部变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">box</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> val = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newVal</span>) &#123; val = newVal; &#125;,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> val; &#125;,</span><br><span class="line">        <span class="attr">type</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="keyword">typeof</span> val; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">box</span>();</span><br><span class="line">b.<span class="title function_">type</span>(); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">b.<span class="title function_">set</span>(<span class="number">98.6</span>);</span><br><span class="line">b.<span class="title function_">get</span>(); <span class="comment">// 98.6</span></span><br><span class="line">b.<span class="title function_">type</span>(); <span class="comment">// &quot;number&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="第12条：理解变量声明提升"><a href="#第12条：理解变量声明提升" class="headerlink" title="第12条：理解变量声明提升"></a>第12条：理解变量声明提升</h4><p>JS不支持块级作用域，即变量定义的作用域不是离其最近的封闭语句或代码块中，而是包含它们的函数。当然try…catch语句是一个例外。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;var&quot;</span>, result = [];</span><br><span class="line">    result.<span class="title function_">push</span>(x);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;exception&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">        x = <span class="string">&quot;catch&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">push</span>(x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript系列</category>
      </categories>
      <tags>
        <tag>Effective JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala编程</title>
    <url>/post/f73b2f1e.html</url>
    <content><![CDATA[<h3 id="第一章-可伸展的语言"><a href="#第一章-可伸展的语言" class="headerlink" title="第一章 可伸展的语言"></a>第一章 可伸展的语言</h3><p>Scala提供了一个实质上实现了Erlang的actor模型的附加库，用于实现线程模型之上的并发抽象。可以通过彼此间传递消息来实现通信。<br>actor可以执行两种基本操作：消息的发送和接受。发送操作，用惊叹号表示，如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">recipient ! msg</span><br></pre></td></tr></table></figure>
<p>发送是异步的。<br>每个actor都有信箱（mailbox）把进入的消息排成队列。actor通过receive代码块处理信箱中收到的消息：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">receive &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Msg1</span> =&gt; ... <span class="comment">// 处理Msg1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Msg2</span> =&gt; ... <span class="comment">// 处理Msg2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在Scala里，函数就是对象。</strong></p>
]]></content>
      <categories>
        <category>Scala系列</category>
      </categories>
      <tags>
        <tag>Scala Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala&amp;Akka学习纪要</title>
    <url>/post/b709cacd.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前一段时间，公司小组内调整，我被安插到一个在线客服的项目下。人不多，就我一个人作为主开发。其主要原因是，项目整体大的需求少数，总体趋于稳定，故而开发很少。<br>但是，从我接手到目前（2018-8-16），总共也就不到1个半月，前前后后遇到产线事件不下数10起，其中2~3起事件，定位不到问题。<br>本片发稿日（2018-8-16），白日再次被公司上集领导层点名批评，说这个系统不好用，怎么怎么样。<br>确实，从我接手看，这个系统很成问题，为什么说很？经常性出问题！<br>反观自己，确实，对于这套东西本省就很不熟，当初答应接下来，就是因为想挑战挑战。但是从目前看，效果并不明显。<br>总结开来：<strong>遇到这些所谓奇怪的问题，总结开来就是：无从下手排查。导致平凡出现问题后，解决问题的失效，本质性有没有解决问题等等。客户并不满意！</strong></p>
<p>这套在线客服系统，大体用到的技术包含，如下：</p>
<ul>
<li>Java</li>
<li>Scala</li>
<li>Akka</li>
<li>SocketIO</li>
<li>Redis</li>
<li>Java Web一套</li>
</ul>
<p>其中，Scala、Akka、Redis在此之前的工作中并没有很好的接触。特别是Scala、Akka根本碰都没碰过，然而在这套系统里面，这俩又是核心骨架。</p>
<p>先从Scala、Akka这两个陌生的东西开始看起！</p>
<h1 id="书籍笔记"><a href="#书籍笔记" class="headerlink" title="书籍笔记"></a>书籍笔记</h1><h2 id="Akka入门实战"><a href="#Akka入门实战" class="headerlink" title="Akka入门实战"></a>Akka入门实战</h2><p>这本书是翻译的，讲实话，翻译质量不高，当中有不少细节不能接受。比如ActorSystem本来就是Akka框架中一个核心类，非要硬翻译成Actor系统，额。。。这有点未免有点“门外汉”的意思了吧。不过作为入门书籍，基本类介绍的还是非常详细的。英文水平不错的可以直接去阅读英文版书籍吧。<br>这本书年代还是有点久远，15年，在那前后akka的稳定版还是处在2.3.6版本前后，故而对于2021年的akka版本（2.16.5）来说，可能有部分场景的类，并不能发很好的适配。解释需要参阅官方的API进行调整。</p>
<h3 id="第二章-Actor与并发"><a href="#第二章-Actor与并发" class="headerlink" title="第二章 Actor与并发"></a>第二章 Actor与并发</h3><p>书中写的很有意思：如果读者早已熟稔Scala 的Future，Play 的Promise或是Java8的CompletableFuture，那么可以跳过本章。如果曾经使用过Guava 或Spring 的ListenableFuture，可能需要了解本章所介绍API的不同之处。如果从来没有使用过monadic风格的Future，那就需要花点时间学习一下本章了。<br>对于我来说，还真是一个都不懂。。。</p>
<h4 id="响应式系统设计"><a href="#响应式系统设计" class="headerlink" title="响应式系统设计"></a>响应式系统设计</h4><p>源自一个响应式宣言（Reactive Manifesto /ˌmanəˈfestō/，有些地方翻译为反应时宣言，一个意思。），原文在这里<a href="b709cacd/the-reactive-manifesto-2.0.pdf">the-reactive-manifesto-2.0</a> ，这里面提到了四个准则：</p>
<h5 id="灵敏性"><a href="#灵敏性" class="headerlink" title="灵敏性"></a>灵敏性</h5><p>应用程序应该尽可能快地对请求做出响应。</p>
<h5 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h5><p>应用程序应该能够根据不同的工作负载进行伸缩扩展（尤其是通过增加计算资源来\进行扩展）。为了提供伸缩性，系统应该努力消除瓶颈。</p>
<h5 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h5><p>应用程序应该考虑到错误发生的情况，并且从容地对错误情况做出响应。</p>
<h5 id="事件驱动-消息驱动"><a href="#事件驱动-消息驱动" class="headerlink" title="事件驱动/消息驱动"></a>事件驱动/消息驱动</h5><p>使用消息而不直接进行方法调用提供了一种帮助我们满足另外3 个响应式准则的方法。消息驱动的系统着重于控制何时、何地以及如何对请求做出响应，允许做出响应的组件进行路由以及负载均。</p>
<h4 id="剖析Actor"><a href="#剖析Actor" class="headerlink" title="剖析Actor"></a>剖析Actor</h4><p>书中提到：Java 和Scala 的API 差别很大，因此需要分别介绍。</p>
<h5 id="Java-Actor-API"><a href="#Java-Actor-API" class="headerlink" title="Java Actor API"></a>Java Actor API</h5><p>先看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaPongActor</span> <span class="keyword">extends</span> <span class="title class_">AbstractActor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> PartialFunction <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ReceiveBuilder</span><br><span class="line">                .matchEquals(<span class="string">&quot;Ping&quot;</span>, s -&gt; sender().tell(<span class="string">&quot;Pong&quot;</span>, ActorRef.noSender()))</span><br><span class="line">                .matchAny(x -&gt; sender().tell(<span class="keyword">new</span> <span class="title class_">Status</span>.Failure(<span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;unknown message&quot;</span>)), self()))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，有几个关键性的点：</p>
<ul>
<li>AbstractActor：首先，我们继承了AbstractActor。这是一个Java 8特有的API，利用了Java 8 的匿名函数（lambda）的特性。与之对应的还有一个 <code>UntypedActor</code> 这是一个较为古老的API，其内部需要通过原始的if来判断消息类型。</li>
<li>Receive：receive方法返回的类型是PartialFunction，这个类来自Scala API。在Java 中，并没有提供任何原生方法来构造Scala 的PartialFunction（并不对所有可能输入进行处理的函数），因此Akka 为我们提供了一个抽象的构造方法类ReceiveBuilder，用于生成PartialFunction 作为返回值。</li>
<li>ReceiveBuilder：先匹配消息，再通过build()方法生成需要返回的PartialFunction。</li>
<li>Match：<ul>
<li>match(class, function)：描述了对于任何尚未匹配的该类型的示例，应该如何响应。<br><code>match(String.class, s -&gt; &#123;if(s.equals(&quot;Ping&quot;)) respondToPing(s);&#125;)</code></li>
<li>match(class, predicate, function)：描述了对于predicate 条件函数为真的某特定类型的消息，应该如何响应。<br>  <code>match(String.class, s -&gt; s.equals(&quot;Ping&quot;), s -&gt; respondToPing(s))</code></li>
<li>matchEquals(object, function)：描述了对于和传入的第一个参数相等的消息，应该如何响应。<br>  <code>matchEquals(&quot;Ping&quot;, s -&gt; respondToPing(s))</code></li>
<li>matchAny(function)：该函数匹配所有尚未匹配的消息。通常来说，最佳实践是返回错误信息，或者至少将错误信息记录到日志，帮助开发过程中的错误调试。</li>
</ul>
</li>
<li>向sender()返回消息：调用了sender()方法后，我们就可以返回所收到的消息的响应了。响应的对象既可能是一个Actor，也可能是来自于Actor 系统外部的请求。第一种情况相当直接：返回的消息会直接发送到该Actor 的收件信箱中。</li>
<li>tell()：sender()函数会返回一个ActorRef。在上面的例子中，我们调用了sender().tell()。而tell()是最基本的单向消息传输模式。<strong>第一个参数是我们想要发送至对方信箱的消息。第二个参数则是希望对方Actor 看到的发送者。</strong>具体描述的是：接收到的消息是String时应该做出的响应。由于需要检查接收到的字符串是否为“Ping”，因此需要进行判断，然后描述响应行为：<em>通过tell()方法向sender()返回一条消息。我们返回的消息是字符串“Pong”。Java 的tell方法要求提供消息发送者的身份：这里使用ActorRef.noSender()表示没有返回地址。</em></li>
<li> 返回 <code>akka.actor.Status.Failure</code>：为了向发送方报告错误信息，需要向其发送一条消息。如果Actor 中抛出了异常，就会通知对其进行监督的Actor。不过无论如何，如果想要报告错误消息，需要将错误发送给发送方。如果发送方使用Future 来接收响应，那么返回错误消息会导致Future的结果为失败。<h5 id="Scala-Actor-API"><a href="#Scala-Actor-API" class="headerlink" title="Scala Actor API"></a>Scala Actor API</h5>贴代码：<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaPongActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;Ping&quot;</span> =&gt; sender() ! <span class="string">&quot;Pong&quot;</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">    sender() ! <span class="type">Status</span>.<span class="type">Failure</span>(<span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;unknown message&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
首先写法上，确实要少了不少东西：</li>
<li>Actor：要定义一个Actor，首先要继承Actor 基类。Actor基类是基本的Scala ActorAPI，非常简单，并且符合Scala语言的特性。</li>
<li>Receive：在Actor 中重写基类的receive 方法。并且返回一个PartialFunction。要注意的是，receive 方法的返回类型是Receive。Receive 只不过是定义的一种类型，表示 <code>scala.PartialFunction[scala.Any, scala.Unit]</code> (注：有关scala中相关 <strong>偏函数</strong>的介绍，可以参考引用1，更多需要查阅相关专业书籍进行更深入的探索)。如果读者不是非常熟悉ScalaAPI 中的PartialFunction，也不必担心，只需要构造一些模式匹配的case 语句，每个语句都返回Unit，并且知道这些语句并不一定要覆盖所有的可能情况即可。</li>
<li>向sender()返回消息：在示例Actor 代码中，我们接着通过sender()方法获取了发送者的ActorRef。我们可以向该ActorRef 发送消息，对发送者做出响应。在这个例子中，返回了“Pong”。</li>
<li>tell 方法（!）：我们使用tell方法向发送方发送响应消息。在Scala中，通过“！”来调用tell 方法。如果读者看了Java的部分，那么会注意到在Java API 的tell方法中必须指定消息的发送者，不过在Scala中，消息发送者是隐式传入的，因此我们不需要再显式传入消息发送者的引用。在tell 方法“！”的方法签名中，有一个隐式的ActorRef参数。如果在Actor外部调用tell 方法的话，该参数的默认值会设为noSender。下面就是该方法的签名：<br><code>def !(message: Any)(implicit sender: ActorRef = Actor.noSender): Unit</code></li>
<li>Actor 中有一个隐式的变量self，Actor 通过self 得到消息发送者的值。因此Actor中tell 方法的消息发送者永远是self。</li>
</ul>
<h4 id="Actor的创建"><a href="#Actor的创建" class="headerlink" title="Actor的创建"></a>Actor的创建</h4><p>通过使用基于消息的方法，我们可以相当完整地将Actor的实例封装起来。如果只通过消息进行相互通信的话，那么永远都不会需要获取Actor 的实例。我们只需要一种机制来支持向Actor发送消息并接收响应。<br>在Akka中，这个指向Actor实例的引用叫做ActorRef。ActorRef是一个无类型的引用，将其指向的Actor 封装起来，提供了更高层的抽象，并且给用户提供了一种与Actor进行通信的机制。上文已经介绍过，ActorSystem就是包含所有Actor 的地方。有一点可能相当明显：我们也正是在ActorSystem中创建新的Actor并获取指向Actor的引用。actorOf方法会生成一个新的Actor，并返回指向该Actor的引用。<br>例如：<br>在java中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ActorRef</span> <span class="variable">actor</span> <span class="operator">=</span> actorSystem.actorOf(Props.create(JavaPongActor.class));</span><br></pre></td></tr></table></figure>
<p>在sacala中：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> actor: <span class="type">ActorRef</span> = actorSystem.actorOf(<span class="type">Props</span>(classOf[<span class="type">ScalaPongActor</span>]))</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>这里我们实际上并没有新建Actor，例如，我们没有调用 <strong>actorOf(new PongActor)。</strong></p>
<h5 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h5><p>为了保证能够将Actor 的实例封装起来，不让其被外部直接访问，我们将所有构造函数的参数传给一个Props的实例。Props 允许我们传入Actor 的类型以及一个变长的参数列表。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Props.create(PongActor.class, arg1, arg2, argn);</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Props</span>(classOf[<span class="type">PongActor</span>], arg1, arg2, argn)</span><br></pre></td></tr></table></figure>
<p>如果Actor 的构造函数有参数，那么推荐的做法是通过一个工厂方法来创建Props。假如我们不希望Pong Actor 返回“Pong”，而是希望其返回另一条消息，那么可能就会需要这样的构造参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Props <span class="title function_">props</span><span class="params">(String response)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Props.create(<span class="built_in">this</span>.class, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaPongActor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">props</span></span>(response: <span class="type">String</span>): <span class="type">Props</span> = &#123;</span><br><span class="line">    <span class="type">Props</span>(classOf[<span class="type">ScalaPongActor</span>], response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以使用Props 的工厂方法来创建Actor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ActorRef</span> <span class="variable">actor</span> <span class="operator">=</span> actorSystem.actorOf(JavaPongActor.props(<span class="string">&quot;PongFoo&quot;</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> actor: <span class="type">ActorRef</span> = actorSystem.actorOf(<span class="type">ScalaPongActor</span> <span class="string">props&quot;PongFoo&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>actorOf创建一个Actor，并返回指向该Actor的引用ActorRef。除此之外，还有另一种方法可以获取指向Actor的引用： <code>actorSelection</code>。<br>为了理解actorSelection，我们需要先来看一下Actor的路径。每个Actor在创建时都会有一个路径，我们可以通过ActorRef.path 来查看该路径。该路径看上去如下所示：<br><strong>akka://default/user/BruceWillis</strong><br>该路径是一个URI，它甚至可以指向使用akka.tcp协议的远程Actor。<br><strong>akka.tcp://my-sys@remotehost:5678/user/CharlieChaplin</strong><br>要注意的是，路径的前缀说明使用的协议是akka.tcp，并且指定了远程ActorSystem的主机名和端口号。如果知道Actor的路径，就可以使用actorSelection来获取指向该Actor引用的ActorSelection（无论该Actor 在本地还是远程）。<br><strong>ActorSelection selection = system.actorSelection(“akka.tcp://actorSystem@host.jason-goodwin.com:5678/user/KeanuReeves”);</strong></p>
<h4 id="Promise、Future和事件驱动的编程模型"><a href="#Promise、Future和事件驱动的编程模型" class="headerlink" title="Promise、Future和事件驱动的编程模型"></a>Promise、Future和事件驱动的编程模型</h4><h5 id="阻塞与事件驱动API"><a href="#阻塞与事件驱动API" class="headerlink" title="阻塞与事件驱动API"></a>阻塞与事件驱动API</h5><p>要转而使用事件驱动的模型，我们需要在代码中用不同的方法来表示结果。我们需要用一个占位符来表示最终将会返回的结果：Future。然后注册事件完成时应该进行的操作：打印结果。我们注册的代码会在Future占位符的值真正返回可用时被调用执行。“事件驱动”这个术语正是描述了这种方法：在发生某些特定事件时，就执行某些对应的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java版本</span></span><br><span class="line">CompletableFuture&lt;String&gt; usernameFuture = getUsernameFromDatabaseAsync(userId);</span><br><span class="line">usernameFuture.thenRun(username -&gt;</span><br><span class="line">  <span class="comment">//executed somewhere else</span></span><br><span class="line">  System.out.println(username)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scala版本</span></span><br><span class="line"><span class="keyword">val</span> future = getUsernameFromDatabaseAsync(userId)</span><br><span class="line">future.onComplete(username =&gt;</span><br><span class="line">  <span class="comment">//executed somewhere else</span></span><br><span class="line">  println(username)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>从线程的角度来看，代码首先会调用方法，然后进入该方法内部，接着几乎立即返回一个Future/CompletableFuture。返回的这个结果只是一个占位符，真正的值在未来某个时刻最终会返回到这个占位符内。<br>需要理解的是：<strong>该方法会立即返回，而数据库调用及结果的生成是在另一个线程上执行的。ExecutionContext 表示了执行这些操作的线程，我们将在本书后面的章节中对此进行介绍。（在Akka 中，可以看到ActorSystem 中有一个dispatcher，就是ExecutionContext 的一种实现。）</strong><br>方法返回Future之后，我们只得到了一个承诺，表示真正的值最终会返回到Future中。我们并不希望发起调用的线程等待返回结果，而是希望其在真正的结果返回后再执行特定的操作（打印到控制台）。<strong>在一个事件驱动的系统中，需要做的就是描述某个事件发生时需要执行的代码。</strong>在Actor中，描述接收到某个消息时进行的操作。同样地，在Future中，我们描述Future 的值真正可用时进行的操作。在Java 8中，使用thenRun来注册事件成功完成时需要执行的代码；而在Scala中，使用onComplete。<br><img data-src="b709cacd/non-blocking-IO.jpg" alt="non-blocking-IO"><br><strong>打印语句并不会运行在进行事件注册的线程上。它会运行在另一个线程上，该线程信息由ExecutionContext 维护。Future 永远是通过Execution Context来创建的，因此我们可以选择在哪里运行Future 中真正需要执行的代码。</strong></p>
<p>在书中提到了，如果你对Java8的Lambda表达式不是很清楚，可以参考oracle官方的教程，来学习一下：<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html">Java SE 8: Lambda Quick Start</a></p>
<h5 id="使用Future进行响应的Actor"><a href="#使用Future进行响应的Actor" class="headerlink" title="使用Future进行响应的Actor"></a>使用Future进行响应的Actor</h5><h6 id="Java示例"><a href="#Java示例" class="headerlink" title="Java示例"></a>Java示例</h6><p>所有返回Future的异步方法返回的所有返回Future 的异步方法返回的都是Scala的scala.concurrent.Future</p>
<p><strong>创建Actor</strong><br>首先创建一个ActorSystem，然后通过actorOf在刚创建的Actor系统中创建一个Actor，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ActorSystem</span> <span class="variable">system</span> <span class="operator">=</span> ActorSystem.create();</span><br><span class="line"><span class="type">ActorRef</span> <span class="variable">actorRef</span> <span class="operator">=</span> system.actorOf(Props.create(JavaPongActor.class));</span><br></pre></td></tr></table></figure>
<p>现在向Actor询问其对于某个消息的响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Future</span> <span class="variable">sFuture</span> <span class="operator">=</span> ask(actorRef, <span class="string">&quot;Ping&quot;</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>这一做法相当直接，我们调用ask方法，传入以下参数：</p>
<ul>
<li>消息发送至的Actor 引用；</li>
<li>想要发送给Actor 的消息；</li>
<li>Future的超时参数：等待结果多久以后就认为询问失败。<br>ask会返回一个Scala Future，作为响应的占位符。在Actor的代码中，Actor会向sender()发送回一条消息，这条消息就是在ask 返回的Scala Future中将接收到的响应。<br>虽然我们无法在Java 8中使用Scala Future，但是可以通过之前导入的库将其转换为CompletableFuture：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletionStage&lt;String&gt; cs = toJava(sFuture);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;String&gt; jFuture = (CompletableFuture&lt;String&gt;) cs;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>首先使用 <code>scala.compat.java8.FutureConverters.toJava</code> 对Scala Future 进行转换，该方法会返回一个CompletionStage。CompletionStage是CompletableFuture 实现的接口，而且这是一个只读的接口。为了调用get 方法，我们将结果的类型转换为CompletableFuture。在测试用例外部，我们并不需要进行该转换。</p>
<p><strong>要注意的是，</strong> 我们在Future内存放的数据类型是String，而Actor 是无类型的，会返回Object，因此读者可能会觉得这种无限制的类型转换有问题。当然，<strong>在ActorSystem外部与Actor 进行通信的时候需要在这方面多加小心。</strong></p>
<h6 id="Scala示例"><a href="#Scala示例" class="headerlink" title="Scala示例"></a>Scala示例</h6><h5 id="理解Future和Promise"><a href="#理解Future和Promise" class="headerlink" title="理解Future和Promise"></a>理解Future和Promise</h5><p>Future隐式地处理了两种情况：<strong>失败与延迟</strong>。要了解如何把阻塞式的IO转为非阻塞式IO，需要学习 <strong>一些不同的表示失败处理和延时处理的抽象概念。</strong></p>
<p><strong>Future-在类型中表达失败与延迟</strong><br>像ask模式这样的异步API会返回一个占位符，类似前面提到的Future类型。<br>准备一个简单的Java示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个封装Future方法的示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletionStage&lt;String&gt; <span class="title function_">askPong</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="type">Future</span> <span class="variable">sFuture</span> <span class="operator">=</span> ask(actorRef, message, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 调用toJava转换CompletionStage</span></span><br><span class="line">    <span class="keyword">final</span> CompletionStage&lt;String&gt; cs = toJava(sFuture);</span><br><span class="line">    <span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Future Examples，在里面调用askPong</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldPrintToConsole</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    askPong(<span class="string">&quot;Ping&quot;</span>).thenAccept(x -&gt; System.out.println(<span class="string">&quot;replied with: &quot;</span> + x));</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//no assertion - just prints to console. Try to complete a CompletableFuture instead.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scala示例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askPong</span></span>(message: <span class="type">String</span>): <span class="type">Future</span>[<span class="type">String</span>] = (pongActor ? message).mapTo[<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;FutureExamples&quot;</span>)&#123;</span><br><span class="line">  <span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line">  it(<span class="string">&quot;should print to console&quot;</span>)&#123;</span><br><span class="line">    (pongActor ? <span class="string">&quot;Ping&quot;</span>).onSuccess(&#123;</span><br><span class="line">      <span class="keyword">case</span> x: <span class="type">String</span> =&gt; println(<span class="string">&quot;replied with: &quot;</span> + x)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="剖析Future"><a href="#剖析Future" class="headerlink" title="剖析Future"></a>剖析Future</h6><p>Future[T]/CompletableFuture<T>成功时会返回一个类型为T 的值，失败时则会返回Throwable。我们将分别学习如何处理这两种情况（成功与失败），以及如何将Future的值转换成有用的结果。</p>
<p><strong>成功情况的处理</strong><br>就像上面的例子中那样，在Java 8中，可以使用thenAccept来操作返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">askPong(<span class="string">&quot;Ping&quot;</span>).thenAccept(x -&gt; System.out.println(<span class="string">&quot;replied with: &quot;</span> + x));</span><br></pre></td></tr></table></figure>

<p>而在Scala中，可以使用onSuccess：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(pongActor ? <span class="string">&quot;Ping&quot;</span>).onSuccess()&#123;</span><br><span class="line">  <span class="keyword">case</span> x: <span class="type">String</span> =&gt; println(<span class="string">&quot;replied with: &quot;</span> + x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>失败情况的处理</strong><br>失败情况是有可能发生的，而我们也需要去处理这些失败情况。所有的失败情况最终都会由一个Throwable 来表示。和成功的情况类似，有许多方法可以帮助我们来处理失败情况，甚至是从失败中恢复。</p>
<h5 id="在失败情况下执行代码"><a href="#在失败情况下执行代码" class="headerlink" title="在失败情况下执行代码"></a>在失败情况下执行代码</h5><p>很多时候，我们都想要在失败情况下做些什么。最基本的就是在失败情况下向日志中打印一些信息。在Scala中，有一种很简单的方法支持这种需求：onFailure。这个方法接受一个部分函数作为参数，而这个部分函数接受一个Throwable。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">askPong(<span class="string">&quot;causeError&quot;</span>).onFailure &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; println(<span class="string">&quot;Got exception&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不幸的是，在Java 8中，没有面向用户的用于失败处理的方法，因此我们在这里引入handle()来处理这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这一点是在异常场景中，需要特别注意的</span></span><br><span class="line">askPong(<span class="string">&quot;cause error&quot;</span>).handle((x, t) -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Error: &quot;</span> + t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>对于这个场景的java代码的说明：</strong><br>handle 接受一个BiFunction 作为参数，该函数会对成功或失败情况进行转换。handle中的函数在成功情况下会提供结果，在失败情况下则会提供Throwable，因此需要检查Throwable 是否存在（结果和Throwable 中只有一个不是null）。如果Throwable 存在，就向日志输出一条语句。由于我们需要在该函数中返回一个值，而失败情况下又不需要对返回值做任何操作，因此直接返回null。</p>
<h5 id="从失败中恢复"><a href="#从失败中恢复" class="headerlink" title="从失败中恢复"></a>从失败中恢复</h5><p>很多时候，在发生错误的时候我们仍然想要使用某个结果值。如果想要从错误中恢复的话，可以对该Future 进行转换，使之包含一个成功的结果值。<br>在Java中，可以使用exceptionally将Throwable 转换为一个可用的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletionStage&lt;String&gt; cs = askPong(<span class="string">&quot;cause error&quot;</span>)</span><br><span class="line">  .exceptionally(t -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在Scala中，有一个recover方法提供相同的功能。同样地，recover方法也接受一个PartialFunction 作为参数，所以我们可以对异常的类型进行模式匹配：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> f = askPong(<span class="string">&quot;causeError&quot;</span>).recover &#123;</span><br><span class="line">  <span class="keyword">case</span> t: <span class="type">Exception</span> =&gt; <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="异步地从失败中恢复"><a href="#异步地从失败中恢复" class="headerlink" title="异步地从失败中恢复"></a>异步地从失败中恢复</h5><p>我们经常需要在发生错误时使用另一个异步方法来恢复，例如下面是两个用例：</p>
<ul>
<li>重试某个失败的操作。</li>
<li>没有命中缓存时，需要调用另一个服务的操作。</li>
</ul>
<p>例如一则Java示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">askPong(<span class="string">&quot;cause error&quot;</span>)</span><br><span class="line">  .handle( (pong, ex) -&gt; ex == <span class="literal">null</span></span><br><span class="line">    ? CompletableFuture.completedFuture(pong)</span><br><span class="line">    : askPong(<span class="string">&quot;Ping&quot;</span>)</span><br><span class="line">  ).thenCompose(x -&gt; x);</span><br></pre></td></tr></table></figure>
<p>首先，检查exception是否为null。如果为null，就返回包含结果的Future，否则返回重试的Future。接着，调用thenCompose将CompletionStage[CompletionStage[String]]扁平化。<br>而在Scala中，我们要调用的函数是recoverWith：类似专门用于错误情况的flatMap。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">askPong(<span class="string">&quot;causeError&quot;</span>).recoverWith(&#123;</span><br><span class="line">  <span class="keyword">case</span> t: <span class="type">Exception</span> =&gt; askPong(<span class="string">&quot;Ping&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="组合Future"><a href="#组合Future" class="headerlink" title="组合Future"></a>组合Future</h5><p>在Java 中，可以使用CompletableFuture的thenCombine方法，在Future的值可用时访问到这些值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">askPong(<span class="string">&quot;Ping&quot;</span>)</span><br><span class="line">  .thenCombine(askPong(<span class="string">&quot;Ping&quot;</span>), (a,b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">//&quot;PongPong&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在Scala 中，也可以使用for推导式将多个Future组合起来。我们能够像处理任何其他集合一样，解析出两个Future 的结果并对它们进行处理。（要注意的是，这只不过是flatMap的一个“语法糖”）</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注：在scala中，这种语法非常灵活</span></span><br><span class="line"><span class="keyword">val</span> f1 = <span class="type">Future</span> &#123;<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">val</span> f2 = <span class="type">Future</span> &#123;<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">val</span> futureAddition: <span class="type">Future</span>[<span class="type">Int</span>] =</span><br><span class="line"><span class="keyword">for</span> (</span><br><span class="line">  res1 &lt;- f1;</span><br><span class="line">  res2 &lt;- f2</span><br><span class="line">) <span class="keyword">yield</span> res1 + res2</span><br></pre></td></tr></table></figure>

<h5 id="处理Future-List"><a href="#处理Future-List" class="headerlink" title="处理Future List"></a>处理Future List</h5><p><strong>注：</strong> 这个场景，我真没想到什么情况下会使用，暂时先跳过本小节阅读，记得在scala中有这么一种反转的处理方式</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listOfFutures: <span class="type">List</span>[<span class="type">Future</span>[<span class="type">String</span>]] = <span class="type">List</span>(<span class="string">&quot;Pong&quot;</span>, <span class="string">&quot;Pong&quot;</span>, <span class="string">&quot;failed&quot;</span>).map(x =&gt; askPong(x))</span><br><span class="line"><span class="keyword">val</span> futureOfList: <span class="type">Future</span>[<span class="type">List</span>[<span class="type">String</span>]] = <span class="type">Future</span>.sequence(listOfFutures)</span><br></pre></td></tr></table></figure>

<h5 id="Future速查表"><a href="#Future速查表" class="headerlink" title="Future速查表"></a>Future速查表</h5><p><strong>注：</strong> 在书中提到的本小节涉及的一些Future操作<br><img data-src="b709cacd/future_collection_scala_java.png" alt="Future操作对应表"></p>
<h3 id="第三章-传递消息"><a href="#第三章-传递消息" class="headerlink" title="第三章 传递消息"></a>第三章 传递消息</h3><p>了解不同的消息模式，也就是在不同Actor 之间传递消息的不同方法。</p>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>有4种核心的Actor消息模式：tell、ask、forward 和pipe。我们已经了解过tell和ask，不过sender()都不是Actor。在这里，将从Actor之间发送消息的角度来介绍所有关于消息传递的概念。</p>
<ul>
<li>Ask：向Actor发送一条消息，返回一个Future。当Actor 返回响应时，会完成Future。不会向消息发送者的邮箱返回任何消息。</li>
<li>Tell：向Actor发送一条消息。所有发送至sender()的响应都会返回给发送消息的Actor。</li>
<li>Forward：将接收到的消息再发送给另一个Actor。所有发送至sender()的响应都会返回给原始消息的发送者。</li>
<li>Pipe：用于将Future的结果返回给sender()或另一个Actor。如果正在使用Ask或是处理一个Future，那么使用Pipe 可以正确地返回Future 的结果。</li>
</ul>
<h5 id="Ask消息模式"><a href="#Ask消息模式" class="headerlink" title="Ask消息模式"></a>Ask消息模式</h5><p>Ask模式会生成一个Future，表示Actor返回的响应。ActorSystem外部的普通对象与Actor进行通信时经常会使用这种模式。<br><strong>实际运作模式</strong><br>在调用ask 向Actor 发起请求时，Akka 实际上会在Actor 系统中创建一个临时Actor。接收请求的Actor 在返回响应时使用的sender()引用就是这个临时Actor。当一个Actor接收到ask 请求发来的消息并返回响应时，这个临时Actor 会使用返回的响应来完成Future。如下图所示：<br><img data-src="b709cacd/ask_communication.png" alt="Ask模式"><br>Ask模式要求定义一个超时参数，如果对方没有在超时参数限定的时间内返回这个ask的响应，那么Future就会返回失败。在Java中可以使用akka.util.Timeout来定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">import</span> akka.pattern.Patterns.ask;</span><br><span class="line"><span class="type">Timeout</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">akka</span>.util.Timeout(</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  java.util.concurrent.TimeUnit.SECONDS</span><br><span class="line">);</span><br><span class="line"><span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> ask(actor, message, timeout);</span><br></pre></td></tr></table></figure>
<p>在Scala中，则可以使用scala.concurrent.duration来定义Timeout。Scala的duration领域特定语言（Domain Specific Languages，DSL）很强大，允许用户直接使用1 second这样的方式来定义一段时间。在Scala中，ask 的超时参数是隐式传入的，这样有助于简化ask的语义，并且使得ask语句更为简洁：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"><span class="keyword">import</span> akka.pattern.ask</span><br><span class="line"><span class="comment">// 隐式写法</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> timeout = akka.util.<span class="type">Timeout</span>(<span class="number">1</span> second)</span><br><span class="line"><span class="keyword">val</span> future = actorRef ? <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="Tell"><a href="#Tell" class="headerlink" title="Tell"></a>Tell</h5><p>Tell是最简单的消息模式，不过要花上一些时间才能够学会这种模式的最佳实践。这也是为什么我们先介绍ask，再介绍tell的原因。Tell 通常被看做是一种“fire and forget”消息传递机制，无需指定发送者。不过通过一些巧妙的方法，也可以使用tell来完成“request/reply”风格的消息传递。如下图所示：<br><img data-src="b709cacd/tell_communication.png" alt="Tell模式"><br><strong>Tell是ActorRef/ActorSelection 类的一个方法。它也可以接受一个响应地址作为参数，接收消息的Actor 中的sender()其实就是这个响应地址。</strong> 在Scala 中，默认情况下，sender会被隐式定义为发送消息的Actor。如果没有sender（如在Actor 外部发起请求），那么响应地址不会默认设置为任何邮箱（叫做DeadLetters）。</p>
<p><strong>使用Tell处理响应</strong><br>由于在返回消息时可以访问到指向发送者的引用，所以要对某条消息做出响应是很容易的。不过，<em>在处理响应的时候，我们需要知道Actor收到的是哪一条消息的响应。</em> 如果我们在Actor中存储一些状态，记录Actor 希望收到响应的消息，那么就能够高效地向Actor发送请求，解决前面提到的ask模式的问题。</p>
<p><strong>我们可以在Actor中将一些上下文信息存储在一个map中，将map的key 放在消息中一起发送。然后，当有着相同key的消息返回时，就可以恢复上下文，完成消息的处理了。</strong><br><img data-src="b709cacd/actor_with_map_parameters.png" alt="Actor中传递Map参数"></p>
<h5 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h5><p>Tell在语义上是用于将一条消息发送至另一个Actor，并将响应地址设置为当前的Actor。而Forward 和邮件转发非常类似：<strong>初始发送者保持不变，只不过新增了一个收件人。</strong><br>在使用tell时，我们指定了一个响应地址，或是将响应地址隐式设为发送消息的Actor。而使用forward传递消息时，响应地址就是原始消息的发送者，如下图所示：<br><img data-src="b709cacd/actor_forword.png" alt="Forword模式"><br>有时候我们需要将接受到的消息传递给另一个Actor来处理，<strong>而最终的处理结果需要传回给初始发起请求的一方</strong>。此时forward是很有用的。<br><strong>处理过程：</strong> 处理中间步骤的Actor转发接收到的消息，或是发送一条新消息，但是仍然会将初始发送者与新消息一起发送。</p>
<h3 id="第四章-Actor的生命周期——处理状态与错误"><a href="#第四章-Actor的生命周期——处理状态与错误" class="headerlink" title="第四章 Actor的生命周期——处理状态与错误"></a>第四章 Actor的生命周期——处理状态与错误</h3><p>这一节介绍了几个有意思的点，这些点都是在目前工作中经常会遇到会涉及到，不排除需要着手去处理的场景</p>
<ul>
<li>分布式计算的误区（The Fallacies of Distributed Computing）</li>
<li>当Actor 运行失败时会发生什么；</li>
<li>如何通过监督Actor 来处理失败；</li>
<li>如何利用become()以及有限自动机来修改Actor 的行为。</li>
</ul>
<h4 id="分布式计算的8个误区"><a href="#分布式计算的8个误区" class="headerlink" title="分布式计算的8个误区"></a>分布式计算的8个误区</h4><p>分布式计算误区由Sun Microsystems的一个团队总结出来，包含缺乏经验的开发者对于在网络上通信的系统的一些错误的假设。<br>具体场景可以参考维基百科上具体细节<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">Fallacies_of_distributed_computing</a></p>
<h5 id="网络是可靠的（The-network-is-reliable）"><a href="#网络是可靠的（The-network-is-reliable）" class="headerlink" title="网络是可靠的（The network is reliable）"></a>网络是可靠的（The network is reliable）</h5><p>我们很容易会用和处理本地系统相同的方式来处理远程系统，也就会像跟本地Actor进行交互一样和远程Actor 进行交互。而Akka在这个错误的假设上更进一步，通过提高网络通信的抽象层次为我们提供了位置透明性。</p>
<h5 id="没有延迟（Latency-is-zero）"><a href="#没有延迟（Latency-is-zero）" class="headerlink" title="没有延迟（Latency is zero）"></a>没有延迟（Latency is zero）</h5><h5 id="带宽是无限的（Bandwidth-is-infinite）"><a href="#带宽是无限的（Bandwidth-is-infinite）" class="headerlink" title="带宽是无限的（Bandwidth is infinite）"></a>带宽是无限的（Bandwidth is infinite）</h5><p>在大型的分布式系统中，经常会使用能够在CPU上快速执行的压缩算法，比如Snappy和LZO（例如，Cassandra将LZO 用于节点内部的通信）。如果要将对这一点的考虑实际应用到数据库中，就要通过压缩来减少消息的大小。压缩也是有开销的：它会消耗CPU 资源。有一些专用的算法把重点放在压缩效率，而非压缩比上。<strong>我们可以使用其中之一（比如Snappy），在将序列化后的消息发送到远程Actor前先对其进行压缩，接收到消息后先解压缩，再反序列化。</strong></p>
<h5 id="网络是安全的（The-network-is-secure）"><a href="#网络是安全的（The-network-is-secure）" class="headerlink" title="网络是安全的（The network is secure）"></a>网络是安全的（The network is secure）</h5><h5 id="网络拓扑不会改变（Topology-doesn’t-change）"><a href="#网络拓扑不会改变（Topology-doesn’t-change）" class="headerlink" title="网络拓扑不会改变（Topology doesn’t change）"></a>网络拓扑不会改变（Topology doesn’t change）</h5><h5 id="只有一个管理员（There-is-one-administrator）"><a href="#只有一个管理员（There-is-one-administrator）" class="headerlink" title="只有一个管理员（There is one administrator）"></a>只有一个管理员（There is one administrator）</h5><h5 id="网络传输没有开销（Transport-cost-is-zero）"><a href="#网络传输没有开销（Transport-cost-is-zero）" class="headerlink" title="网络传输没有开销（Transport cost is zero）"></a>网络传输没有开销（Transport cost is zero）</h5><h5 id="网络是同构的（The-network-is-homogeneous）"><a href="#网络是同构的（The-network-is-homogeneous）" class="headerlink" title="网络是同构的（The network is homogeneous）"></a>网络是同构的（The network is homogeneous）</h5><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>使用Akka的一个附带的好处就是容错性。（oh，笔者在目前老框架架构下，似乎并没有很好的处理好相应的功能）</p>
<h5 id="隔离错误"><a href="#隔离错误" class="headerlink" title="隔离错误"></a>隔离错误</h5><p>先了解一些在分布式应用程序中都应该遵循的通用策略：<strong>隔离错误。</strong><br>假设每个组件都是一个定时炸弹，那么我们希望能够确保无论其中任何一个发生爆炸，都不会引发链式反应，导致其他组件也爆炸。也可以说，我们希望能够隔离错误，或是将可能引发失败情况的组件分离开来。</p>
<p><strong>冗余</strong><br>保持系统在发生错误时仍能运行的方法之一就是实现各组件的冗余性，确保不存在单点故障。假设我们有一个服务，那么有多种方法可以通过冗余设计来保证服务的高可用性。</p>
<h4 id="监督"><a href="#监督" class="headerlink" title="监督"></a>监督</h4><p><strong>Erlang将容错性引入了Actor模型，它使用的概念叫做监督（supervision）</strong>。监督的核心思想就是把对于失败的响应和可能引起失败的组件分隔开，并且把可能发生错误的组件通过层级结构来组织，以便管理。<br><strong>监督的层级结构</strong><br>Akka使用Actor层级结构来描述监督。当我们创建Actor时，新建的Actor都是作为另一个Actor的子Actor，父Actor负责监督子Actor。Actor的路径结构就展示了它的层级结构，所以和文件系统中的文件夹有点像。<br><strong>监督策略</strong></p>
<ul>
<li>继续（resume）：Actor继续处理下一条消息</li>
<li>停止（stop）：停止Actor，不再做任何操作</li>
<li>重启（restart）：新建一个Actor，代替原来的Actor</li>
<li>向上反映（escalate）：将异常信息传递给下一个监督者。</li>
</ul>
<h5 id="定义监督策略"><a href="#定义监督策略" class="headerlink" title="定义监督策略"></a>定义监督策略</h5><p>Actor有默认的监督策略。如果没有修改监督策略，那么监督Actor的行为基本上和如下场景：</p>
<ul>
<li>Actor 运行过程中抛出异常：restart()；</li>
<li>Actor 运行过程中发生错误：escalate()；</li>
<li>Actor 初始化过程中发生异常：stop()。</li>
</ul>
<p>在默认监督策略中还定义了另一种情况：ActorKilledException。如果Actor 被“杀”（kill）了，那么这个Actor 的监督者会接收到一个ActorKilledException，执行stop()会接收到该异常。</p>
<p>在Java中定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java中通过DeciderBuilder来创建一个Scala的PartialFunction，用于表示策略。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> akka.actor.SupervisorStrategy <span class="title function_">supervisorStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OneForOneStrategy</span>(<span class="number">5</span>, Duration.create(<span class="string">&quot;1 minute&quot;</span>),</span><br><span class="line">    akka.japi.pf.DeciderBuilder</span><br><span class="line">    .match(BrokenPlateException.class, e -&gt; SupervisorStrategy.resume())</span><br><span class="line">    .match(DrunkenFoolException.class, e -&gt; SupervisorStrategy.restart())</span><br><span class="line">    .match(RestaurantFireError.class, e -&gt; SupervisorStrategy.escalate())</span><br><span class="line">    .match(TiredChefException.class, e -&gt; SupervisorStrategy.stop())</span><br><span class="line">    .matchAny(e -&gt; SupervisorStrategy.escalate())</span><br><span class="line">    .build()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在scala中要相对简洁一点：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Scala的例子中，我们还是重写Actor的supervisorStrategy方法，然后定义一个PartialFunction，匹配抛出的异常，并返回Directive</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">supervisorStrategy</span> </span>= &#123;</span><br><span class="line">  <span class="type">OneForOneStrategy</span>() &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">BrokenPlateException</span> =&gt; <span class="type">Resume</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">DrunkenFoolException</span> =&gt; <span class="type">Restart</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">RestaurantFireError</span> =&gt;<span class="type">Escalate</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">TiredChefException</span> =&gt; <span class="type">Stop</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">Escalate</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Actor生命周期"><a href="#Actor生命周期" class="headerlink" title="Actor生命周期"></a>Actor生命周期</h5><p>在Actor 的生命周期中会调用几个方法，我们在需要时可以重写这些方法:</p>
<ul>
<li>prestart()：在构造函数之后调用。</li>
<li>postStop()：在重启之前调用。</li>
<li>preRestart(reason, message)：默认情况下会调用postStop()。</li>
<li>postRestart()：默认情况下会调用preStart()。</li>
</ul>
<p>在Actor生命周期中个事件的发生顺序如下图所示：<br><a href="b709cacd/actor_lifecycle.png">Actor生命周期调用</a><br><strong>注意</strong><br>要注意的是preRestart和postRestart只在重启的时候才会被调用。它们默认调用了preStart和postStop，但是调用它们的时候就不再直接调用preStart和postStop了。这样我们就能够决定，到底是只在Actor启动或停止的时候调用一次preStart和postStop，还是每次重启一个Actor的时候就调用preStart和postStop。</p>
<p><strong>重启和停止时的消息处理</strong><br>我们可以定义监督策略，在抛出异常前重新尝试发送失败的消息，重试次数没有限制。也可以设置时间限制，比如最多重试10 次或1 分钟，只要达到其中任一限制就停止重试：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">OneForOneStrategy</span>(<span class="number">2</span>, <span class="type">Duration</span>.create(<span class="string">&quot;1 minute&quot;</span>), <span class="type">PartialFunction</span>)</span><br><span class="line">  <span class="type">OneForOneStrategy</span>(</span><br><span class="line">  maxNrOfRetries = <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">IOException</span> =&gt; <span class="type">Restart</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>终止或kill一个Actor</strong><br>有多种不同的方法可以用来停止一个Actor。下面任一方法都可以停止Actor：</p>
<ul>
<li>调用ActorSystem.stop(actorRef)；</li>
<li>调用ActorContext.stop(actorRef)；</li>
<li>给Actor发送一条PoisonPill消息，会在Actor完成消息处理后将其停止；</li>
<li>给Actor发送一条kill消息，会导致Actor抛出ActorKilledException异常</li>
</ul>
<p><strong>生命周期监控和DeathWatch</strong><br>监督机制描述了如何对子Actor的状态进行响应。而Actor也可以对其他任何Actor进行监督。通过调用context.watch(actorRef)注册后，Actor就能够监控另一个Actor的终止，而调用context.unwatch(actorRef)就可以取消监控注册。如果被监控的Actor停止了，负责监控的Actor就会收到一条Terminated(ActorRef)消息。</p>
<p><strong>安全重启</strong><br>有时候：有一种情况是：如果Actor已经处在运行中，那么就能够安全地重新启动；但是如果无法完成初始化，我们就必须编写额外的代码实现监督策略，来处理Actor无法在启动时连接到数据库的情况。</p>
<p>很多时候，我们不希望Actor在初始化的过程中发生错误，而是会给Actor发送一条初始化消息，然后在Actor运行的过程中处理状态的变化。可以在preStart()中向Actor自己发送一条Connect消息来达到这一效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preStart</span><span class="params">()</span> &#123;</span><br><span class="line">  self().tell(<span class="keyword">new</span> <span class="title class_">Connect</span>(), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span> </span>= self ! <span class="type">Connect</span></span><br></pre></td></tr></table></figure>
<p>这样一来，Actor 只在运行中才可能会出现错误，而且能够成功重启。所以就可以不断尝试连接数据库直到连上为止了。</p>
<p>有一个很重要的地方需要注意：上面的介绍中还没有涉及到一些细节和问题。<strong>首先，我们没有处理Actor 在连接成功之前接收到的消息；其次，如果Actor长时间无法连接的话，邮箱可能会被填满。</strong></p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>我们可以使用几种不同的机制来改变Actor的行为：</p>
<ul>
<li>基于Actor 状态的条件语句；</li>
<li>热交换（Hotswap）：become()和unbecome()；</li>
<li>有限自动机</li>
</ul>
<h5 id="在线-离线状态"><a href="#在线-离线状态" class="headerlink" title="在线/离线状态"></a>在线/离线状态</h5><p><strong>在状态之间暂存消息（stash）</strong><br>Actor也经常会处在一个无法处理某些消息的状态。如果数据库客户端离线了，那么在重新上线之前，它都无法处理任何消息。我们可以选择不断重新建立客户端的连接，直到连接成功为止。在这种情况下，在成功连接之前，客户端会丢弃收到的所有消息。另一种做法是把客户端无法处理的消息先放在一旁，等到客户端恢复连接状态之后再做处理。</p>
<p>Akka提供了一种叫做 <strong>stash的机制</strong> 来支持这一功能。stash 消息会把消息暂存到一个独立的队列中，该队列中存储目前无法处理的消息，例如下面的java伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(cantHandleMessage) &#123;</span><br><span class="line">  <span class="comment">// 通过stash来进行消息暂存在队列中</span></span><br><span class="line">  stash();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  handleMessage(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unstash则把消息从暂存队列中取出，放回邮箱队列中，Actor就能继续处理这些消息了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">changeStateToOnline();</span><br><span class="line">unstash();</span><br><span class="line">To use stash in Java, your Actor will extend AbstractActorWithStash:</span><br><span class="line">class RemoteActorProxy extends AbstractActorWithStash &#123;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br><span class="line">To use stash in Scala, you mix in the stash trait:</span><br><span class="line">class RemoteActorProxy extends Actor with Stash &#123;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>虽然stash()和unstash()在希望快速改变状态的时候使用起来非常方便，但是stash消息的状态一定要和某个时间限制进行绑定，否则就有可能填满邮箱。</p>
<h5 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h5><p>在这个示例中，展示了怎么通过一个条件语句判断的方式，结合stash和unstatsh方法来处理未处理的消息。<br>java示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">online</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> PartialFunction <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> RecieveBuilder</span><br><span class="line">    .match(GetRequest.class, x -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(online) &#123;</span><br><span class="line">          <span class="comment">// 如果连接成功了，直接处理消息</span></span><br><span class="line">          processMessage(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 否则将消息statsh到队列中</span></span><br><span class="line">          stash();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    .match(Connected.class, x -&gt; &#123;</span><br><span class="line">      online = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 等到连接成功之后，在进行unstash操作，处理之前未处理的消息</span></span><br><span class="line">      unstash();</span><br><span class="line">    &#125;)</span><br><span class="line">    .match(Disconnected.class, x -&gt; online = <span class="literal">false</span>)</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相比java代码需要减少很多</span></span><br><span class="line"><span class="keyword">var</span> online = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">case</span> x: <span class="type">GetRequest</span> =&gt;</span><br><span class="line">    <span class="keyword">if</span>(online)</span><br><span class="line">      processMessage(x)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      stash()</span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">Connected</span> =&gt;</span><br><span class="line">    online = <span class="literal">true</span></span><br><span class="line">    unstash()</span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">Disconnected</span> =&gt;</span><br><span class="line">    online = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多时候，Actor会存储状态，然后根据这个状态值的不同会有不同的行为。使用条件语句是一种非常过程化的用于处理行为和状态的方法。 <em>幸运的是，Akka还提供了一些更好的选择。</em></p>
<h5 id="热交换（Hotswap）：Become-Unbecome"><a href="#热交换（Hotswap）：Become-Unbecome" class="headerlink" title="热交换（Hotswap）：Become/Unbecome"></a>热交换（Hotswap）：Become/Unbecome</h5><p>使用条件语句的代码 <strong>并不是很优雅</strong>，这种写法显然不是声明式的。Akka 提供了become()和unbecome()，用于管理不同的行为，这一用法可以大大改善代码的可读性。在Actor的context()中，有两个方法：</p>
<ul>
<li>become(PartialFunction behavior)：这个方法将receive块中定义的行为修改为一个新的PartialFunction。</li>
<li>unbecome()：这个方法将Actor的行为修改回默认行为。</li>
</ul>
<p>前面那个数据库链接的例子优化之后，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PartialFunction <span class="title function_">receive</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> RecieveBuilder</span><br><span class="line">    .match(GetRequest.class, x -&gt; stash())</span><br><span class="line">    .match(Connected.class, x -&gt; &#123;</span><br><span class="line">      context().become(online);</span><br><span class="line">      unstash();</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> PartialFunction&lt;Object, BoxedUnit&gt; <span class="title function_">online</span><span class="params">(<span class="keyword">final</span> ActorRef another)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> RecieveBuilder</span><br><span class="line">    .match(GetRequest.class, x -&gt; processMessage(x))</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同功能的scala代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">case</span> x: <span class="type">GetRequest</span> =&gt;</span><br><span class="line">    stash()</span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">Connected</span> =&gt;</span><br><span class="line">    become(online)</span><br><span class="line">    unstash()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">online</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">  <span class="keyword">case</span> x: <span class="type">GetRequest</span> =&gt;</span><br><span class="line">    processMessage(x)</span><br><span class="line">  <span class="keyword">case</span> _: <span class="type">Disconnected</span> =&gt;</span><br><span class="line">    unbecome()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于条件语句，这种写法可读性更高。每个状态的行为都定义在自己独立的PartialFunction中。在PartialFunction 中，使用模式匹配来定义不同的行为。这样我们就能够互不影响地阅读Actor中不同状态的行为。</p>
<p><strong>stash泄露</strong><br>上面使用stash 的例子有一个问题：如果要花很长时间才能接收到Connected消息，或者压根就收不到Connected消息，那么Actor就会不断地stash消息，最终导致应用程序内存耗尽，或者导致邮箱开始丢弃消息（后面的章节中会介绍邮箱）。<br>我们可以在Actor的构造函数或preStart方法中调度执行这个消息。接收到这个消息之后，就检查Actor是否已经连接。如果还没有连接，那么Actor就可以向上反映问题，由监督者来采取措施：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">system.scheduler().scheduleOnce(</span><br><span class="line">  Duration.create(<span class="number">1000</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">  self(),</span><br><span class="line">  CheckConnected,</span><br><span class="line">  system.dispatcher(),</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果Actor接收到消息时已经在线，那么就忽略该消息。如果Actor接收到消息处在离线状态，就会抛出一个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.match(CheckConnected.class, msg -&gt;throw new ConnectTimeoutException())</span><br><span class="line">case _:</span><br><span class="line">  CheckConnected =&gt; throw new ConnectTimeoutException</span><br></pre></td></tr></table></figure>

<p><strong>有限自动机（Finite State Machine，FSM）</strong><br>还有另一个工具可以用来处理Actor 中的状态：有限自动机（Finite State Machine,FSM）。和热交换很相似的是，FSM中也有状态以及基于状态的行为变化。跟热交换比起来，FSM是一个更重量级的抽象概念，需要更多的代码和类型才能够实现并运行。所以通常来说，<strong>热交换是一个更简单、可读性更高的选择</strong>。<br><strong>注：</strong> 暂时先了解，akka支持比较重的这种控制actor状态的方式。</p>
<h3 id="纵向扩展"><a href="#纵向扩展" class="headerlink" title="纵向扩展"></a>纵向扩展</h3><h4 id="使用Dispatcher"><a href="#使用Dispatcher" class="headerlink" title="使用Dispatcher"></a>使用Dispatcher</h4><h5 id="Dispatcher解析"><a href="#Dispatcher解析" class="headerlink" title="Dispatcher解析"></a>Dispatcher解析</h5><p>Dispatcher将如何执行任务与何时运行任务两者解耦。一般来说，Dispatcher会包含一些线程，这些线程会负责调度并运行任务，比如处理Actor的消息以及线程中的Future事件。Dispatcher是Akka 能够支持响应式编程的关键，是负责完成任务的机制。<br>Dispatcher负责将工作分配给Actor。除此之外Dispatcher还可以分配资源用于处理Future的回调函数。我们会发现Future API 接受Executor/ExecutionContext作为参数。由于Akka的Dispatcher扩展了这些API，因此Dispatcher具备双重功能。</p>
<h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>ThreadPool Executor有一个工作队列，队列中包含了要分配给各线程的工作。线程空闲时就会从队列中认领工作。由于线程资源的创建和销毁开销很大，而ThreadPool允许线程的重用，所以就可以减少创建和销毁线程的次数，提高效率。<br>ForkJoinPool Executor使用一种 <strong>分治算法，递归地将任务分割成更小的子任务</strong>，然后把子任务分配给不同的线程运行。接着再把运行结果组合起来。由于提交的任务不一定都能够被递归地分割成ForkJoinTask，所以ForkJoinPool Executor 有一个工作窃取算法，允许空闲的线程“窃取”分配给另一个线程的工作。由于工作可能无法平均分配并完成，所以工作窃取算法能够更高效地利用硬件资源。</p>
<h5 id="创建Dispatcher"><a href="#创建Dispatcher" class="headerlink" title="创建Dispatcher"></a>创建Dispatcher</h5><p><strong>注：</strong> 这一小节介绍的东西非常进阶，实际可能有很少实际业务场景会用到，但是从框架层面，会经常看到<br>有四种类型的Dispatcher可以用于描述如何在Actor之间共享线程：</p>
<ul>
<li>Dispatcher：默认的Dispatcher类型。将会使用定义的Executor，在Actor中处理消息。在大多数情况下，这种类型能够提供最好的性能。</li>
<li>PinnedDispatcher：给每个Actor都分配自己独有的线程。这种类型的Dispatcher为每个Actor都创建一个ThreadPoolExecutor，每个Executor中都包含一个线程。如果希望确保每个Actor都能够立即响应，那么这似乎是个不错的方法。不过PinnedDispatcher比其他共享资源的方法效率更高的情况其实并不多。可以在单个Actor必须处理很多重要工作的时候试试这种类型的Dispatcher，否则的话不推荐使用。</li>
<li>CallingThreadDispatcher：这个Dispatcher比较特殊，它没有Executor，而是在发起调用的线程上执行工作。这种Dispatcher主要用于测试，特别是调试。由于发起调用的线程负责完成工作，所以清楚地看到栈追踪信息，了解所执行方法的完整上下文。这对于理解异常是非常有用的。每个Actor会获取一个锁，所以每次只有一个线程可以在Actor中执行代码，而如果多个线程向一个Actor发送信息的话，就会导致除了拥有锁的线程之外的所有线程处于等待状态。本书前面介绍过的TestActorRef就是基于CallingThreadDispatcher实现支持在测试中同步执行工作的。</li>
<li>BalancingDispatcher：我们会在一些Akka文档中看到BalancingDispatcher。<strong>现在已经不推荐直接使用BalancingDispatcher了</strong>，应该使用前面介绍过的BalancingPoolRouter。不过Akka中仍然使用了BalancingDispatcher，但是只会通过Router间接使用。我们会在“用于解析文章的Dispatcher”小节中介绍BalancingPool的实际用法。BalancingDispatcher有一点很特殊：Pool中的所有Actor都共享同一个邮箱，并且会为Pool中的每个Actor都创建一个线程。使用BalancingDispatcher的Actor从邮箱中拉取消息，所以只要有Actor处于空闲状态，就不会有任何Actor的工作队列中存在任务。这是工作窃取的一个变种，所有Actor都会从一个共享的邮箱中拉取任务。两者在性能上的优点也类似。</li>
</ul>
<h5 id="决定何时使用哪种Dispatcher"><a href="#决定何时使用哪种Dispatcher" class="headerlink" title="决定何时使用哪种Dispatcher"></a>决定何时使用哪种Dispatcher</h5><p>进行纵向扩展的第一步是理解哪 <strong>些情况的响应即时性最重要</strong>，以及对这些重要的请求做出响应时可 <strong>能会发生资源竞争的地方</strong>。</p>
<p><strong>可以把用于运行高风险任务的资源和运行重要任务的资源隔离开来。</strong> 如果我们新建一些Dispatcher，把运行时间较长或是会阻塞线程的任务都分配给这些Dispatcher，就可以确保应用程序的剩余部分仍然能够保持响应的即时性。我们希望能够把所有需要大量计算、运行时间较长的任务分离到单独的Dispatcher中，确保在糟糕的情况下仍然能够有资源去运行其他任务。</p>
<p>要创建或使用默认Dispatcher/ThreadPool 的话，其实不需要做什么。如果需要的话，只要在classpath内的application.conf文件中定义并配置默认Dispatche 即可。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    default-dispatcher &#123;</span><br><span class="line">      # Min number of threads to cap factor-based parallelism number to</span><br><span class="line">      parallelism-min = 8</span><br><span class="line">      # The parallelism factor is used to determine thread pool size using the</span><br><span class="line">      # following formula: ceil(available processors * factor). Resulting size</span><br><span class="line">      # is then bounded by the parallelism-min and parallelism-max values.</span><br><span class="line">      parallelism-factor = 3.0</span><br><span class="line">      # Max number of threads to cap factor-based parallelism number to</span><br><span class="line">      parallelism-max = 64</span><br><span class="line">      # Throughput for default Dispatcher, set to 1 for as fair as possible</span><br><span class="line">      throughput = 10</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在自己的application.conf文件中定义任意值，覆盖默认配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    default-dispatcher &#123;</span><br><span class="line">      # Throughput for default Dispatcher, set to 1 for as fair as possible</span><br><span class="line">      throughput = 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，Actor完成的所有工作都会在这个Dispatcher中执行。如果需要回去ExecutionContext 并在其中创建Future，那么可以通过ActorSystem访问到默认的线程池，然后将其传递给Future：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">ActorSystem</span> system = <span class="type">ActorSystem</span>.create();</span><br><span class="line"><span class="type">CompletableFuture</span>.runAsync(() -&gt;<span class="type">System</span>.out.println(<span class="string">&quot;run in ec&quot;</span>), system.dispatcher());</span><br><span class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> ec = system.dispatcher</span><br><span class="line"><span class="keyword">val</span> future = <span class="type">Future</span>(() =&gt; println(<span class="string">&quot;run in ec&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 对于在默认Dispatcher中的Future执行的操作要小心，这些操作会消耗Actor 自身的时间。在下一小节中，我们将介绍如何解决这个问题。</p>
<p>在Scala中，<strong>扩展了Actor的类中已经包含了一个implicit val的Dispatcher，所以在Actor中使用Future 的时候就不需要再指定Dispatcher了。</strong> 不过在Actor 中使用Future 的情况其实不是很多，要记住相对于ask，应该优先使用tell。所以如果发现有好多在Actor中使用Future 的情况，那么可能需要衡量一下方法是否合理。</p>
<h5 id="使用Future的阻塞IO-Dispatcher"><a href="#使用Future的阻塞IO-Dispatcher" class="headerlink" title="使用Future的阻塞IO Dispatcher"></a>使用Future的阻塞IO Dispatcher</h5><h3 id="第6章-横向扩展——集群化"><a href="#第6章-横向扩展——集群化" class="headerlink" title="第6章 横向扩展——集群化"></a>第6章 横向扩展——集群化</h3><h4 id="集群定义"><a href="#集群定义" class="headerlink" title="集群定义"></a>集群定义</h4><p>集群就是一组可以互相通信的服务器。集群中的每台服务器成为一个节点或成员。集群可以动态修改大小，并且在发生错误情况时继续运行，把影响降到最低。所以集群需要具备两个功能：<strong>失败发现以及使得集群中的所有成员最终能够提供一致的视图。</strong></p>
<h5 id="失败检测"><a href="#失败检测" class="headerlink" title="失败检测"></a>失败检测</h5><p>如果集群中的每台服务器都需要和其他所有服务器进行通信，那么集群的性能不会随着节点的增加而线性提高。原因在于每增加一个节点，需要的通信开销都会指数增加。为了降低监控其他节点健康程度的复杂度，<strong>Akka中的失败检测只会监控</strong> 某个节点附近特定数目的节点。<br><strong>检测过程</strong><br>在Akka中，失败检测是通过在节点间发送心跳消息并接收响应来完成的。Akka会根据 <strong>心跳的历史记录</strong> 以及当前的心跳信息计算出某个节点可用的可能性。Akka会依照这些数据和配置的容错限制得到计算结果，然后将节点标记为可用或不可用。</p>
<h5 id="通过gossip协议达到最终一致性"><a href="#通过gossip协议达到最终一致性" class="headerlink" title="通过gossip协议达到最终一致性"></a>通过gossip协议达到最终一致性</h5><p>这种最终把状态传递给整个集群的机制叫做gossip协议或是epidemic协议（因为信息在集群中的传播就像病毒一样！）。许多最终一致性的数据库（比如Riak 和Cassandra）的实现方式都非常类似。在这些数据库中，Amazon发表的关于Dynamo 的论文影响力非常大。</p>
<h4 id="使用Akka-Cluster构建系统"><a href="#使用Akka-Cluster构建系统" class="headerlink" title="使用Akka Cluster构建系统"></a>使用Akka Cluster构建系统</h4><h5 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h5><p>两个引用包：akka-cluster、akka-contrib（一个非官方扩展工具包），一则默认使用配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    provider = &quot;akka.cluster.ClusterActorRefProvider&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  remote &#123;</span><br><span class="line">    netty.tcp &#123;</span><br><span class="line">      hostname = &quot;127.0.0.1&quot;</span><br><span class="line">      port = 2552</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cluster &#123;</span><br><span class="line">    seed-nodes = [</span><br><span class="line">      &quot;akka.tcp://Akkademy@127.0.0.1:2552&quot;,</span><br><span class="line">      &quot;akka.tcp://Akkademy@127.0.0.1:2551&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">  // contrib包中cluster客户端支持</span><br><span class="line">  extensions = [&quot;akka.contrib.pattern.ClusterReceptionistExtension&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>种子节点</strong><br><strong>点加入集群的方式</strong>。当一个新节点加入集群时，该节点会尝试连接第一个种子节点。如果成功连接种子节点，新节点就会发布其地址（主机和端口）。种子节点会负责通过gossip协议将新节点的地址最终通知整个集群。如果连接第一个种子节点失败，新节点就会尝试连接第二个种子节点。只要成功连接任何一个种子节点，那么任何节点加入或离开集群时，我们都不需要对配置进行任何修改。</p>
<p>当部署到生产环境时，应该至少定义两个拥有固定IP的种子节点，并且保证任何时候都至少有一个种子节点可用。当一个节点尝试加入集群时，会试图顺序连接种子节点。如果所有的种子节点都不可用，那么新节点将无法加入到集群。</p>
<p><strong>订阅集群事件</strong></p>
<h3 id="第7章-处理邮箱问题"><a href="#第7章-处理邮箱问题" class="headerlink" title="第7章 处理邮箱问题"></a>第7章 处理邮箱问题</h3><p><strong>注：</strong> 本章是对于极端场景，Actor邮箱优化的具体实践，暂时不作具体深入了解。</p>
<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul>
<li>《Scala编程》</li>
<li>《响应式架构 消息模式Actor实现与ScalaAkka应用集成》</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/20832218">Scala中的Partial Function</a></p>
]]></content>
      <categories>
        <category>Scala系列</category>
      </categories>
      <tags>
        <tag>Akka</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo建站</title>
    <url>/post/178a5861.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>至于为什么要自建博客，想必你能找到这篇hexo教程，之前肯定检索过不少信息了 :) 就不过多赘述了。</p>
<span id="more"></span>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>如果你没有从事过开发相关工作/没有学习过计算机编程、网络相关知识，下面提到的，建议还是花点时间了解一下，不必了解那么深。</p>
<ul>
<li>nodejs/npm相关语法</li>
<li>hexo及hexo相关语法，这个参考官网文档相关说明即可：<a href="https://hexo.io/docs/">https://hexo.io/docs/</a></li>
<li>git仓库/github</li>
<li>域名/域名CDN记录</li>
<li>CDN加速</li>
<li>HTTPS</li>
</ul>
<h3 id="我的目前的方案"><a href="#我的目前的方案" class="headerlink" title="我的目前的方案"></a>我的目前的方案</h3><ul>
<li>markdown源文章、相关配置文件，托管在 <strong>Github</strong></li>
<li>Hexo自动编译&amp;部署相关，托管在 <strong><del>TravisCI</del></strong> <strong>GitHub Actions</strong></li>
<li>站点、站点https证书等部署相关，托管在 <strong>Netlify</strong><h4 id="这个方案目前的优点"><a href="#这个方案目前的优点" class="headerlink" title="这个方案目前的优点"></a>这个方案目前的优点</h4></li>
<li>编译环境不再依赖你的本地环境，你只需要关注你的文章。即便是换了电脑，你只需要把你的文章，从github上clone下来即可。</li>
<li>站点不需要你关系细节，什么HTTPS、什么证书等等<h4 id="我的Hexo站点使用到的插件"><a href="#我的Hexo站点使用到的插件" class="headerlink" title="我的Hexo站点使用到的插件"></a>我的Hexo站点使用到的插件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed</span><br><span class="line">npm install hexo-wordcount --save</span><br><span class="line">npm install hexo-abbrlink --save</span><br><span class="line">npm install lozad --save</span><br><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br><span class="line">npm install hexo-algolia --save</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="开始建站"><a href="#开始建站" class="headerlink" title="开始建站"></a>开始建站</h3><p>关于hexo语法，插件什么的，这里不再赘述，瞅瞅官网什么，再本地init一个测试blog即可，语法不是很复杂。常用的，就那么几个。</p>
<h4 id="github托管源码"><a href="#github托管源码" class="headerlink" title="github托管源码"></a>github托管源码</h4><p>先上我的仓库的图：<br><img data-src="178a5861/github.png" alt="我的博客源码目录结构"></p>
<p>最主要的就是：source目录下的文章<br>其余有几个配置文件，分别说明一下：</p>
<ul>
<li>.gitignore，git提交的忽略配置文件</li>
<li>.travis.yml, travis的部署脚本</li>
<li>config.next.yml next主题的配置文件</li>
<li>config.yml 博客的主体配置文件</li>
</ul>
<h5 id="已经更新托管到Github-Actions了"><a href="#已经更新托管到Github-Actions了" class="headerlink" title="已经更新托管到Github Actions了"></a>已经更新托管到Github Actions了</h5><h5 id="travis部署脚本"><a href="#travis部署脚本" class="headerlink" title="travis部署脚本"></a><del>travis部署脚本</del></h5><p><del>在这里贴一下，细节看我另外一篇文章</del></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span> <span class="string">npm</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># build master branch only</span></span><br><span class="line"><span class="comment"># 设置缓存文件</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-theme-next</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line">  <span class="comment"># - npm install hexo-generator-searchdb --save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-feed</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-wordcount</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-abbrlink</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">lozad</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">uninstall</span> <span class="string">hexo-generator-index</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-index-pin-top</span> <span class="string">--save</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-algolia</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="comment"># 替换同目录下的_config.yml文件中github_token字符串为travis后台刚才配置的变量，注&gt;意此处sed命令用了双引号。单引号无效！</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/algolia_applicationID/$&#123;ALGOLIA_APPLICATIONID&#125;/g&quot;</span> <span class="string">./_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/algolia_apiKey/$&#123;ALGOLIA_APIKEY&#125;/g&quot;</span> <span class="string">./_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/algolia_indexName/$&#123;ALGOLIA_INDEXNAME&#125;/g&quot;</span> <span class="string">./_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/gitalk_client_id/$&#123;GITALK_CLIENT_ID&#125;/g&quot;</span> <span class="string">./_config.next.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/gitalk_client_secret/$&#123;GITALK_CLIENT_SECRET&#125;/g&quot;</span> <span class="string">./_config.next.yml</span></span><br><span class="line">  <span class="comment"># - pwd</span></span><br><span class="line">  <span class="comment"># clone自定义配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">-b</span> <span class="string">customer_config</span> <span class="string">https://github.com/nimbusking/nimbusking.github.io.git</span> <span class="string">temp</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-f</span> <span class="string">./temp/post-meta.njk</span> <span class="string">./node_modules/hexo-theme-next/layout/_partials/post</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">./temp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="comment"># - hexo clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">algolia</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>
<h4 id="TravisCI"><a href="#TravisCI" class="headerlink" title="TravisCI"></a><del>TravisCI</del></h4><p>细节不再这里说明，可以看我另一篇文章中的详细说明：<a href="https://nimbusk.cc/post/e62993b1.html">Hexo与TravisCI持续集成</a></p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>原理基本上基于放弃使用github.io托管博客静态页面，寻找第三方支持全站启用https的站点。<br>参考<a href="https://juejin.im/entry/5a8bd9f25188257a5911cfc6">掘金网</a>对比比较内容</p>
<h4 id="Netlify"><a href="#Netlify" class="headerlink" title="Netlify"></a>Netlify</h4><p>官网：<a href="https://www.netlify.com/">https://www.netlify.com</a><br>最大的特点：支持同步Github仓库数据、免费启用Let’s Encrypt SSL证书<br>截止目前（2024年10月）的免费方案：</p>
<ul>
<li>带宽：100GB/月</li>
<li>编译时长配额：300分钟/月</li>
<li>并发构建配合：1条（同一时间运行的上线）</li>
</ul>
<p>作为一个自建博客，免费方案的这个流量绰绰有余。</p>
<h4 id="配置大体流程"><a href="#配置大体流程" class="headerlink" title="配置大体流程"></a>配置大体流程</h4><p>注册进入之后，点击左侧Sites选项卡，下面“Add new site”，按照步骤关联github指定仓库接口。<br><img data-src="178a5861/netlify_add_site.png" alt="新建站点"></p>
<p>随后需要在左侧的Domains新增你需要关联的域名，也非常简单，跟着填就行了：<br><img data-src="178a5861/netlify_add_domain1.png" alt="新建域名"><br>创建好之后，点击进来会看到你的dns记录，这个记录如果你要有其它使用，譬如CDN加速啥的，你可能会用到<br><img data-src="178a5861/netlify_add_site.png" alt="DNS记录"></p>
<h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><h3 id="关于升级"><a href="#关于升级" class="headerlink" title="关于升级"></a>关于升级</h3><p>多数升级的，基本上围绕两部分内容：</p>
<ul>
<li>hexo组件本身升级</li>
<li>相关hexo插件升级</li>
</ul>
<p>本站19年建立，中间经历过一次升级，当时主要使用的两块版本是：</p>
<ul>
<li>hexo: 5.3.0</li>
<li>hexo-theme-next: 8.11.0<h4 id="本地环境升级"><a href="#本地环境升级" class="headerlink" title="本地环境升级"></a>本地环境升级</h4>近日查看了一下，可以升级了，本地升级很简单，直接通过npm命令升级即可<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo@7.3.0</span><br><span class="line">npm install hexo-theme-next@8.21.0</span><br></pre></td></tr></table></figure>
有其它的插件需要升级的类似步骤。<h4 id="引用依赖升级"><a href="#引用依赖升级" class="headerlink" title="引用依赖升级"></a>引用依赖升级</h4>把博客源码根目录下的package.json文件中的相关版本号升级了<br>这里贴个我的：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo-site&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7.3.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hexo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.3.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-abbrlink&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-algolia&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.3.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.3.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-deployer-git&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-archive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-index-pin-top&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.2.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-searchdb&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.4.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-generator-tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-ejs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-marked&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-renderer-stylus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-theme-landscape&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.0.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-theme-next&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.21.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hexo-wordcount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lozad&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.16.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="远端升级"><a href="#远端升级" class="headerlink" title="远端升级"></a>远端升级</h4><p>远程升级，由于现在都托管在GitHub Actions那里了，而且相关编译脚本中，我没有指定插件安装版本。<br>所以基本上不用改，唯一需要该的是nodejs版本，因为最新的hexo插件，至少需要node版本在14以上才行。苏哟i，我升级了一下。</p>
<p>其它的没啥了。</p>
]]></content>
      <categories>
        <category>站点</category>
      </categories>
      <tags>
        <tag>站点</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能JavaScript读书笔记</title>
    <url>/post/88143aa7.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本书发行较早，研究讨论的范畴也停留在html4时代，不排除当中有些规则<strong>现如今已经不适用</strong>，但是依然有参考意义。故而看一遍，记录一下。<br>争对原生的老的JavaScript语法，平时较少使用的，本篇不作记录。具体可参考本书中的相关章节作参考。</p>
<h3 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h3><h4 id="第一章-加载和执行"><a href="#第一章-加载和执行" class="headerlink" title="第一章 加载和执行"></a>第一章 加载和执行</h4><h5 id="脚本位置"><a href="#脚本位置" class="headerlink" title="脚本位置"></a>脚本位置</h5><p>推荐将所有的script标签尽可能放到body标签的底部，以尽可能减少对整个页面下载的影响</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Script Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Example of recommended script positioning --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="组织脚本"><a href="#组织脚本" class="headerlink" title="组织脚本"></a>组织脚本</h5><p>可以把多个文件合并成一个，只需要引用一个script标签，就可以减少性能消耗</p>
<span id="more"></span>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Script Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Example of recommended script positioning --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file1.js&amp;file2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://yui.yahoopis.com/combo?2.7.0/build/yahoo-min.js&amp;2.7.0/build/event/event-min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="无阻塞的脚本"><a href="#无阻塞的脚本" class="headerlink" title="无阻塞的脚本"></a>无阻塞的脚本</h5><p>在页面加载完成之后才加载JavaScript代码</p>
<h6 id="延迟的脚本"><a href="#延迟的脚本" class="headerlink" title="延迟的脚本"></a>延迟的脚本</h6><ul>
<li>defer属性指明本元素所含的脚本不会修改DOM，因此代码能安全地延迟执行。</li>
<li>任何带有defer属性的script元素在DOM完成之前都不会执行，无论是内嵌或外链脚本都是如此。</li>
<li>带有defer属性的script元素实在windows.onload事件处理器执行前被调用</li>
</ul>
<h6 id="动态脚本元素"><a href="#动态脚本元素" class="headerlink" title="动态脚本元素"></a>动态脚本元素</h6><p>利用标准的DOM方法创建一个新的script元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;file1.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>
<h6 id="推荐无阻塞的模式"><a href="#推荐无阻塞的模式" class="headerlink" title="推荐无阻塞的模式"></a>推荐无阻塞的模式</h6><p>向页面中添加大量JavaScript的推荐做法只需两步：</p>
<ul>
<li>先添加动态加载所需的代码</li>
<li>然后加载初始化页面所需的剩下的代码</li>
</ul>
<p>老的一些框架：</p>
<ul>
<li>YUI3的方式：由页面中少量的代码来加载丰富的功能组件。**（雅虎团队于2014年停止更新）</li>
<li>LazyLoad类库：还是要建议尽量减少文件数，每次加载依然是一个独立的HTTP请求</li>
<li>LABjs</li>
</ul>
<p>模块化框架</p>
<ul>
<li>sea.js：CMD规范</li>
<li>requre.js：AMD规范</li>
</ul>
<h4 id="第二章-数据存取"><a href="#第二章-数据存取" class="headerlink" title="第二章 数据存取"></a>第二章 数据存取</h4><h5 id="管理作用域"><a href="#管理作用域" class="headerlink" title="管理作用域"></a>管理作用域</h5><p>作用域概念是理解JavaScript的关键所在，不仅仅从性能角度，还包括从功能的角度。 作用域对JavaScript有许多影响，从确定哪些变量可以被函数访问，到确定this的赋值。JavaScript作用域同样关系到性能，要理解速度和作用域的关系，首先要正确地理解作用域的工作原理。</p>
<h6 id="作用域链和标识符解析"><a href="#作用域链和标识符解析" class="headerlink" title="作用域链和标识符解析"></a>作用域链和标识符解析</h6><p>每一个JavaScript函数都表示为一个对象，更确切地说，是Function对象的一个实例。Function对象同其他对象一样，拥有可以编程访问的属性， 和一系列不能通过代码访问而仅供JavaScript引擎存取的内部属性。其中一个内部属性是[[Scope]]。内部属性[[Scope]]包含了 一个函数被创建的作用域中对象的集合。这个集合被称为函数的作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scope作用域链<br><img data-src="88143aa7/scope.jpg" alt="函数addscope作用域链"></p>
<h6 id="标识符解析的性能"><a href="#标识符解析的性能" class="headerlink" title="标识符解析的性能"></a>标识符解析的性能</h6><p>如果某个垮作用域的值在函数中被引用一次已上，那么就把它存到局部变量里。可行的方法是：将全局变量的引用存储在一个局部变量中，然后使用这个局部变量代替全局变量。</p>
<h6 id="改变作用域链"><a href="#改变作用域链" class="headerlink" title="改变作用域链"></a>改变作用域链</h6><p>with语句和try-catch语句可以临时改变执行环境的作用域链。<br>注：with语句不推荐使用；try-catch语句慎用，catch子句中最好委托专门函数处理异常情况。</p>
<h6 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h6><p>无论是with语句还是try-catch语句的catch子句，或是包含eval()的函数，都是被认为动态作用域。动态作用域只存在于代码执行过程中，因此无法查看代码结构而查看出来具体的执行结果。<br>在确实有必要时才推荐使用动态作用域。</p>
<h6 id="闭包、作用域和内存"><a href="#闭包、作用域和内存" class="headerlink" title="闭包、作用域和内存"></a>闭包、作用域和内存</h6><p>使用闭包可能会导致性能问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="string">&quot;xdi9592&quot;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;save-btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="title function_">saveDocument</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上述代码中用到两个标识符，id和saveDocument，它们的位置在作用域链第一个对象之后。<strong>这就是使用闭包最需要关注的性能点：在频繁访问跨作用域的标识符时，每次访问都会带来性能损失。</strong></p>
<h5 id="对象成员"><a href="#对象成员" class="headerlink" title="对象成员"></a>对象成员</h5><h6 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h6><p>JavaScript中的对象是基于原型（Prototype）的。原型是其它对象的基础，它的定义并实现了一个新建的对象所必须包含的成员列表<br>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;High Performance JavaScript&quot;</span>,</span><br><span class="line">    <span class="attr">publisher</span>: <span class="string">&quot;Yahoo! Press&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>(book.<span class="title function_">toString</span>()); <span class="comment">// &quot;[Object, Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>book对象中并没有定义toString方法，但是alert的时候并没有报错，原因toString方法是继承原型而来。<br>实例和原型的关系，如下图所示：<br><img data-src="88143aa7/extendsprototype.jpg" alt="实例和原型的关系"><br>可以用<strong>hasOwnProperty()**方法来判断对象中是否包含特定的实例成员。<br>要确定对象是否包含特定的属性，可以使用</strong>in**操作符。</p>
<h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><p>可以定义并使用构造函数来创建另一种类型的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params">title, publisher</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = title;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">publisher</span> = publisher;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayTitle</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">title</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> book1 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;High Performance JavaScript&quot;</span>, <span class="string">&quot;Yahoo! Press&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> book2 = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;JavaScript: The Good Parts&quot;</span>, <span class="string">&quot;Yahoo! Press&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(book1 <span class="keyword">instanceof</span> <span class="title class_">Book</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(book1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">book1.<span class="title function_">sayTitle</span>(); <span class="comment">// High Performance JavaScript</span></span><br><span class="line"><span class="title function_">alert</span>(book1.<span class="title function_">toString</span>()); <span class="comment">// &quot;[Object, Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>上述俩实例共享原型链，如下图所示：<br><img data-src="88143aa7/shareprototypelinked.jpg" alt="共享原型链"><br>但是，对象在原型链中存在的位置越深，搜索的速度就会越慢。也就是说，搜索实例成员比从字面量或局部变量中读取的数据代价更高。因而也会影响性能消耗。</p>
<h6 id="嵌套成员"><a href="#嵌套成员" class="headerlink" title="嵌套成员"></a>嵌套成员</h6><p>由于对象成员可能包含其他成员，例如：window.location.href，对象成员嵌套的越深，读取速度就会越慢。</p>
<h6 id="缓存对象成员值"><a href="#缓存对象成员值" class="headerlink" title="缓存对象成员值"></a>缓存对象成员值</h6><p>应当注意，只在必要时使用对象成员。例如：在同一个函数中没有必要多次读取同一个对象成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasEitherClass</span>(<span class="params">element, className1, className2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> element.<span class="property">className</span> == className1 || element.<span class="property">className</span> == className2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已上代码中，elment.className被读取了两次。此时就可以将该元素的值保存在一个临时变量中，以减少查找的开销。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式：字面量、变量、数组项、对象成员。它们有着各自的性能特点。</p>
<ul>
<li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li>
<li>由于局部变量存在于作用域链的起始位置，因此出问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。</li>
<li>避免使用with语句，因为它会改变执行环境作用域链。同样，try-catch语句中的catch子句也有同样的影响，因此也要小心使用。</li>
<li>嵌套的对象成员会明显影响性能，尽量少用。</li>
<li>属性或方挂在原型链中的位置越深，访问它的速度也越慢。</li>
<li>通常来说，你可以通过吧常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。</li>
</ul>
<h4 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h4><h5 id="DOM访问与修改"><a href="#DOM访问与修改" class="headerlink" title="DOM访问与修改"></a>DOM访问与修改</h5><h6 id="innerHtml对比DOM方法"><a href="#innerHtml对比DOM方法" class="headerlink" title="innerHtml对比DOM方法"></a>innerHtml对比DOM方法</h6><p>在一个对性能有着苛刻要求的操作中更新一大段HTML，推荐使用innerHTML，因为它在绝大部分浏览器中都运行的更快。</p>
<h6 id="节点克隆"><a href="#节点克隆" class="headerlink" title="节点克隆"></a>节点克隆</h6><p>使用DOM方法更新页面内容的另一个途径就是克隆已有元素，而不是创建新元素-换句话说，就是使用element.cloneNode()(element表示已有节点)替代document.createElement()。</p>
<h6 id="HTML集合（HTML-Collections）"><a href="#HTML集合（HTML-Collections）" class="headerlink" title="HTML集合（HTML Collections）"></a>HTML集合（HTML Collections）</h6><p>HTML集合是包含了DOM节点引用的类型数组对象。以下方法的返回值就是一个集合：</p>
<ul>
<li>document.getElementByName()</li>
<li>document.getElementByClassName()</li>
<li>document.getElementByTagName()</li>
<li>document.images 页面中所有img元素</li>
<li>document.links 所有a元素</li>
<li>document.forms 所有表单元素</li>
<li>document.forms[0].elements 页面中第一个表单的所有字段</li>
</ul>
<p>上述方法返回的HTML集合一直与文档保持着连接，每次你需要最新的信息时，都会重复执行查询的过程！<br>例如，一个意外的死循环<br>注：本实例个人编写，非书中示例，代码注释行为书中事例。补了一个JQuery选择器选择结果，JQuery选择器返回的不是HTML集合，而是JQuery封装的对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试一段JS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>  <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-2.2.4.min.js&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">integrity</span>=<span class="string">&quot;sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> alldivs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> alldivsByJquery = $(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// for (var i = 0; i &lt; alldivs.length; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JavaScript length = &quot;</span> + alldivs.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JQuery length = &quot;</span> + alldivsByJquery.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出：<br>JavaScript length = 1<br>test.html:14 JQuery length = 1<br>test.html:13 JavaScript length = 2<br>test.html:14 JQuery length = 1<br>test.html:13 JavaScript length = 3<br>test.html:14 JQuery length = 1<br>test.html:13 JavaScript length = 4<br>test.html:14 JQuery length = 1<br>test.html:13 JavaScript length = 5<br>test.html:14 JQuery length = 1<br>test.html:13 JavaScript length = 6<br>test.html:14 JQuery length = 1<br>test.html:13 JavaScript length = 7<br>test.html:14 JQuery length = 1<br>test.html:13 JavaScript length = 8<br>test.html:14 JQuery length = 1<br>test.html:13 JavaScript length = 9<br>test.html:14 JQuery length = 1<br>test.html:13 JavaScript length = 10<br>test.html:14 JQuery length = 1<br>上述死循环示例的解决方案：<strong>将获取的HTML集合的长度存在临时变量中即可。</strong><br>同样，<strong>多次集合元素时使用局部变量</strong></p>
<h5 id="遍历DOM"><a href="#遍历DOM" class="headerlink" title="遍历DOM"></a>遍历DOM</h5><p>DOM API提供了多种方法来读取文档结构中的特定部分。当你需要从多种方案中选择时，最后为特定的操作选择最高效的API。</p>
<h6 id="获取DOM元素"><a href="#获取DOM元素" class="headerlink" title="获取DOM元素"></a>获取DOM元素</h6><p>通常你需要从某一个DOM元素开始，操作周围的元素，或者递归查找所有子节点。你可以使用childNodes得到元素集合，或者使用nextSibling来获取每个相邻元素。</p>
<h6 id="重绘和重排"><a href="#重绘和重排" class="headerlink" title="重绘和重排"></a>重绘和重排</h6><p>当页面布局和几何属性改变时就需要“重排”。下述情况中会发生重排：</p>
<ul>
<li>添加或删除可见的DOM元素</li>
<li>元素位置改变</li>
<li>元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）、</li>
<li>内容改变，例如：文本改变或图片被另一个不同尺寸的图片替代。</li>
<li>页面渲染器初始化。</li>
<li>浏览器窗口尺寸改变</li>
</ul>
<h6 id="渲染树变化的排队与刷新"><a href="#渲染树变化的排队与刷新" class="headerlink" title="渲染树变化的排队与刷新"></a>渲染树变化的排队与刷新</h6><p>由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排过程。获取布局信息的操作会导致队列刷新，比如以下方法：</p>
<ul>
<li>offsetTop，offsetLeft，OffsetWidth，offsetHeight</li>
<li>scrollTop，scrollLeft，scrollWidth，scrollHeight</li>
<li>clientTop，clientLeft，clientWidth，clientHeight</li>
<li>getComputedStyle()</li>
</ul>
<p>在修改样式的过程中，最好避免使用上面列出的属性。它们都会属性渲染队列，即使你是在获取最近未发生改变的或者与最新改变无关的布局信息。</p>
<h6 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h6><p>重绘和重排可能代价非常昂贵，因此一个好的提高程序响应速度的策略就是减少此类操作的发生。为了减少发生次数，<strong>应该合并多次对DOM和样式的修改，然后一次处理掉</strong>。</p>
<h6 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改DOM</h6><p>当你需要对DOM元素进行一系列操作时，可以通过以下步骤来减少重绘和重排次数：</p>
<ul>
<li>使元素脱离文档流。</li>
<li>对其应用多重改变。</li>
<li>把元素带回文档中。</li>
</ul>
<p>有三种基本方法可以使DOM脱离文档：</p>
<ul>
<li>隐藏元素，应用修改，重新显示。</li>
<li>使用文档片段（document fragment）在当前DOM之外构建一个子树，再把它拷贝到文档。</li>
<li>将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素。</li>
</ul>
<p>文档片段：<br>注：JQuery内部append方法就是文档碎片插入的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line"><span class="title function_">appendDataToElement</span>(fragment, data);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mylist&quot;</span>).<span class="title function_">appendChild</span>(fragment);</span><br></pre></td></tr></table></figure>
<p>节点备份：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> old = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mylist&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> clone = old.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="title function_">appendDataToElement</span>(clone, data);</span><br><span class="line">old.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(clone, old);</span><br></pre></td></tr></table></figure>
<h6 id="缓存布局信息"><a href="#缓存布局信息" class="headerlink" title="缓存布局信息"></a>缓存布局信息</h6><p>一段低效的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myElement.<span class="property">style</span>.<span class="property">left</span> = <span class="number">1</span> + myElement.<span class="property">offsetLeft</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">myElement.<span class="property">style</span>.<span class="property">top</span> = <span class="number">1</span> + myElement.<span class="property">offsetTop</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (myElement.<span class="property">offsetLeft</span> &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">    <span class="title function_">stopAnimation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法低效的原因：元素每次移动时都会查询偏移量，导致浏览器属性渲染队列而不利于优化。<br>改进的方案是：<strong>获取一次起始位置的值，然后将其赋值给一个变量</strong></p>
<h6 id="让元素脱离动画流"><a href="#让元素脱离动画流" class="headerlink" title="让元素脱离动画流"></a>让元素脱离动画流</h6><p>展开/折叠的方式来显示和隐藏部分页面是一种常见的交互模式。但是当页面顶部的一个动画推移页面整个余下的部分时，会导致一次代价昂贵的大规模重排。当这个渲染树中需要重新计算的节点越多，情况就会越糟糕。<br>使用以下步骤可以避免页面中大部分重排：</p>
<ul>
<li>使用绝对位置定位页面上的动画元素，将其脱离文档流。</li>
<li>让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。</li>
<li>当动画结束时恢复定位，从而只会下移一次文档的其它元素。</li>
</ul>
<h6 id="IE和-hover"><a href="#IE和-hover" class="headerlink" title="IE和:hover"></a>IE和:hover</h6><p>当元素很多时，应避免使用这种效果，比如很大的表格或者很长的列表。</p>
<h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p>当页面中存在大量元素，而且每一个都要一次或多次绑定事件处理器（比如onclick）时，这种情况可能会影响性能。每绑定一个事件处理器都是有代价的，它约么是加重了页面负担（更多的标签或JavaScript代码），要么是增加了运行期的执行时间。<br><strong>一个简单而优雅的处理DOM事件的技术是事件委托</strong><br>例如，在一组id=’menu’的ul列表，下有若干li标签，其中一些li标签中是链接a标签，此时要点击a标签之后，Ajax动态请求数据，填充其余。<br>此时可以使用事件委托，而无需针对每一个a标签绑定事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;menu&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 浏览器 taget</span></span><br><span class="line">    e = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">    <span class="keyword">var</span> target = e.<span class="property">target</span> || e.<span class="property">srcElement</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pageid, hrefparts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只关心hrefs，非链接点击则退出</span></span><br><span class="line">    <span class="keyword">if</span> (target.<span class="property">nodeName</span> != <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链接中找出页面ID</span></span><br><span class="line">    hrefparts = target.<span class="property">href</span>.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    pageid = hrefparts[hrefparts.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    pageid = pageid.<span class="title function_">replace</span>(<span class="string">&#x27;.html&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新页面</span></span><br><span class="line">    <span class="title function_">ajaxRequest</span>(<span class="string">&#x27;xhr.php?page=&#x27;</span> + id, updatePageContents);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浏览器组织默认行为并取消冒泡</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> e.<span class="property">preventDefault</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        e.<span class="title function_">preventDefault</span>();</span><br><span class="line">        e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.<span class="property">returnValue</span> = <span class="literal">false</span>;</span><br><span class="line">        e.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>访问和操作DOM是现代Web应用的重要部分。但每次穿越连接ECMAScript和DOM两个岛屿之间的桥梁，都会被收取 “过桥费”。为了减少DOM编程带来的性能损失， 请记住以下几点：</p>
<ul>
<li>最小化DOM访问次数，尽可能在JavaScript端处理。</li>
<li>如果需要多次访问某个DOM节点，请使用局部变量存储色的引用。</li>
<li>小心处理HTML集合，因为它实时连系着底层文档。把集合的长度缓存到一个变量中，并在选代中使用它。 如果需要经常操作集合， 建议把它拷贝到一个数组中。</li>
<li>如果可能的话，使用速度更快的APl，比如querySelectorAll()和firstElementChild</li>
<li>要留意重绘和重排s批量修改样式时, “离线” 操作DOM树，使用缓存，并减少访 问布局信息的次数。</li>
<li>动画中使用绝对定位，使用拖放代理。</li>
<li>使用事件委托来减少事件处理器的数量。</li>
</ul>
<h4 id="第四章-算法和流程控制"><a href="#第四章-算法和流程控制" class="headerlink" title="第四章 算法和流程控制"></a>第四章 算法和流程控制</h4><h5 id="循环性能"><a href="#循环性能" class="headerlink" title="循环性能"></a>循环性能</h5><p>for-in循环要比其它几种明显要慢。除非明确需要迭代一个属性数量未知的对象，否则应该避免使用for-in循环。<br>注意：<strong>不要使用for-in来遍历数组成员</strong></p>
<h6 id="最小化属性查找："><a href="#最小化属性查找：" class="headerlink" title="最小化属性查找："></a>最小化属性查找：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = items.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="title function_">process</span>(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span>, count = items.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; count) &#123;</span><br><span class="line">    <span class="title function_">process</span>(items[j++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> k = <span class="number">0</span>, num = items.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="title function_">process</span>(items[k++]);</span><br><span class="line">&#125; <span class="keyword">while</span> (k &lt; num);</span><br></pre></td></tr></table></figure>
<p>也可以倒序循环，例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = items.<span class="property">length</span>; i--; ) &#123;</span><br><span class="line">    process[items[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，控制条件与true值比较时，任何非零数会自动转换为true，而零值等同于false；</p>
<h6 id="减少迭代次数：“达夫设备（Duff’s-Device）”"><a href="#减少迭代次数：“达夫设备（Duff’s-Device）”" class="headerlink" title="减少迭代次数：“达夫设备（Duff’s Device）”"></a>减少迭代次数：“达夫设备（Duff’s Device）”</h6><p>典型实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// credit: Jeff Greeberg</span></span><br><span class="line"><span class="keyword">var</span> iterations = <span class="title class_">Math</span>.<span class="title function_">floor</span>(items.<span class="property">length</span> / <span class="number">8</span>),</span><br><span class="line">    startAt    = items.<span class="property">length</span> % <span class="number">8</span>,</span><br><span class="line">    i          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (startAt) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: process[items[i++]];</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: process[items[i++]];</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: process[items[i++]];</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: process[items[i++]];</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: process[items[i++]];</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: process[items[i++]];</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: process[items[i++]];</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: process[items[i++]];</span><br><span class="line">    &#125;</span><br><span class="line">    startAt = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (--iterations);</span><br></pre></td></tr></table></figure>
<p>Duff’s Device背后基本原理：每次循环中最多可调用8次process()。循环的迭代次数为总数除以8.由于不是所有数字都能被8整除，变量startAt用来存放余数，表示第一次循环中应调用多少次process()。如果是12次，那么第一次循环会调用process()4次，第二次循环调用process()8次，用两次循环替代了12次循环。<br>改进版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// credit: Jeff Greeberg</span></span><br><span class="line"><span class="keyword">var</span> i = items.<span class="property">length</span> % <span class="number">8</span>;</span><br><span class="line"><span class="keyword">while</span> (i) &#123;</span><br><span class="line">    <span class="title function_">process</span>(items[i--]);</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(items.<span class="property">length</span> / <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i) &#123;</span><br><span class="line">    <span class="title function_">process</span>(items[i--]);</span><br><span class="line">    <span class="title function_">process</span>(items[i--]);</span><br><span class="line">    <span class="title function_">process</span>(items[i--]);</span><br><span class="line">    <span class="title function_">process</span>(items[i--]);</span><br><span class="line">    <span class="title function_">process</span>(items[i--]);</span><br><span class="line">    <span class="title function_">process</span>(items[i--]);</span><br><span class="line">    <span class="title function_">process</span>(items[i--]);</span><br><span class="line">    <span class="title function_">process</span>(items[i--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>是否使用Duff’s Device</strong>，取决于整体的迭代次数，如果迭代次数小于1000，很难看到性能提升。如果迭代次数超过1000，那么Duff’s Device的执行效率将明显提升。</p>
<h6 id="基于函数的迭代"><a href="#基于函数的迭代" class="headerlink" title="基于函数的迭代"></a>基于函数的迭代</h6><p>forEach()函数。在运行速度要求严格是，基于函数的迭代不是合适的选择。</p>
<h6 id="if-else对比switch"><a href="#if-else对比switch" class="headerlink" title="if-else对比switch"></a>if-else对比switch</h6><p>使用if-else还是switch，最流行的方法是基于测试条件的数量来判断：条件数量越大，越倾向于使用switch而不是if-else.</p>
<h6 id="优化if-else"><a href="#优化if-else" class="headerlink" title="优化if-else"></a>优化if-else</h6><p>确保最可能出现的条件放在首位</p>
<h6 id="查找表（Lookup-Tables）"><a href="#查找表（Lookup-Tables）" class="headerlink" title="查找表（Lookup Tables）"></a>查找表（Lookup Tables）</h6><p>JavaScript中可以使用数组和普通对象来构建查找表，通过查找表访问数据比用if-else或switch快得多，特别是在条件语句数量很大的时候。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">swith</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> result0;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> result1;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> result2;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> result3;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> result4;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> result5;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">return</span> result6;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">return</span> result7;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>: <span class="keyword">return</span> result8;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>: <span class="keyword">return</span> result9;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> retsult10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swith表达式代码所占的空间可能与他的重要性不成比例。整个结构可以使用一个数组作为查找表来替代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将返回值集合存入数组</span></span><br><span class="line"><span class="keyword">var</span> results = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];</span><br><span class="line"><span class="comment">// 返回当前结果</span></span><br><span class="line"><span class="keyword">return</span> result[value];</span><br></pre></td></tr></table></figure>
<p>当单个键和单个值之间存在逻辑映射时（正如前面的例子），查找表的优势就能体现出来。switch语句更适合于每个键都需要对应一个独特的动作或一系列动作的场合。</p>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>递归函数潜在的问题是：终止条件不明确或缺少终止条件导致函数长时间运行，并使得用户界面处于假死状态。可能还会遇到浏览器的“调用栈大小限制”(Call sstack size limites)</p>
<h6 id="调用栈限制"><a href="#调用栈限制" class="headerlink" title="调用栈限制"></a>调用栈限制</h6><p>JavaScript引擎支持的递归数量与JavaScript调用栈大小直接相关。</p>
<h6 id="递归模式"><a href="#递归模式" class="headerlink" title="递归模式"></a>递归模式</h6><p>当遇到调用栈大小限制时，第一步应该先检查代码中的递归实例。一般，直接递归模式出现的错误很容易定位（递归边界问题）。另一种，“隐伏模式”，即包含两个函数相互调用，形成一个无限循环。<br>因此，如果不是终止条件问题，那么就可能是算法中包含了太多层低估，为了能在浏览器中安全地工作，建议改用<strong>迭代</strong>、<a href="https://en.wikipedia.org/wiki/Memoization">Memoization</a>、或者结合两者使用。</p>
<h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><h3 id="实践场景"><a href="#实践场景" class="headerlink" title="实践场景"></a>实践场景</h3>]]></content>
      <categories>
        <category>JavaScript系列</category>
      </categories>
      <tags>
        <tag>高性能JavaScript</tag>
        <tag>High Performance JavaScript</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript系列</title>
    <url>/post/84ea90f7.html</url>
    <content><![CDATA[<p>JavaScript系列目录</p>
<ul>
<li>读书笔记<ul>
<li>《高性能JavaScript》</li>
<li>《Effective JavaScript》</li>
</ul>
</li>
<li>问题剖析</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript系列</category>
      </categories>
      <tags>
        <tag>Effective JavaScript</tag>
        <tag>高性能JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>工具Tips</title>
    <url>/post/a4b1030a.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本系列罗列日常工作学习中遇到的工具问题以及相应的解决方案，写下来供后续自己参考的同时也作分享一波！</p>
<h3 id="编程相关"><a href="#编程相关" class="headerlink" title="编程相关"></a>编程相关</h3><h4 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h4><h5 id="win10下解决中文输入法光标不跟随问题"><a href="#win10下解决中文输入法光标不跟随问题" class="headerlink" title="win10下解决中文输入法光标不跟随问题"></a>win10下解决中文输入法光标不跟随问题</h5><p>国内一大老Fork并修改之后的IMESupport<a href="http://zcodes.net/2017/02/12/sublime_text_3_imesupport.html">主页地址</a>，在win10下使用完美解决。看下图所示：<br><img data-src="a4b1030a/ChineseTypeWritingInSublimeText_CursorFollowing.jpg" alt="使用效果"></p>
<span id="more"></span>
<p>可以直接从GitHub上下载下来，把插件路径解压到：**%AppData%\Sublime Text 3\Packages**<br>下即可，下图是我本地安装的：<br><img data-src="a4b1030a/SublimeTextInstalledPackages.jpg" alt="本地安装包"></p>
<h5 id="安装Markdown-Editing插件之后文本编辑区域过窄问题"><a href="#安装Markdown-Editing插件之后文本编辑区域过窄问题" class="headerlink" title="安装Markdown Editing插件之后文本编辑区域过窄问题"></a>安装Markdown Editing插件之后文本编辑区域过窄问题</h5><p>跟该插件的默认设置有关，解决方案：<br>打开路径：Preferences-&gt;Package Settings-&gt;Markdown Editing-&gt;Markdown GFM Settings –User，在配置下添加关于<strong>wrap_width</strong>的属性，我修改成了130，如下图所示：<br><img data-src="a4b1030a/MarkdownEditingUserConfiguration.jpg" alt="MarkdownEditing用户配置"><br>设置前效果：<br><img data-src="a4b1030a/BeforeConfiguring.jpg" alt="设置前"><br>设置后效果：<br><img data-src="a4b1030a/AfterConfiguring.jpg" alt="设置后"><br><strong>效果明显！</strong></p>
<h5 id="Markdown-Editing插件配置"><a href="#Markdown-Editing插件配置" class="headerlink" title="Markdown Editing插件配置"></a>Markdown Editing插件配置</h5><p>推荐几个自己常用的配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;color_scheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Packages/Boxy Theme/schemes/Boxy Monokai.tmTheme&quot;</span><span class="punctuation">,</span> <span class="comment">// 修改风格的主题,我这里是sublime的boxy主题自带的,默认有这几种主题</span></span><br><span class="line">    <span class="comment">// &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor.tmTheme&quot;,</span></span><br><span class="line">    <span class="comment">// &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme&quot;,</span></span><br><span class="line">    <span class="comment">// &quot;color_scheme&quot;: &quot;Packages/MarkdownEditing/MarkdownEditor-Yellow.tmTheme&quot;,</span></span><br><span class="line"><span class="attr">&quot;highlight_line&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 高亮正在编辑的行</span></span><br><span class="line"><span class="attr">&quot;line_numbers&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>   <span class="comment">// 显示行号</span></span><br><span class="line"><span class="attr">&quot;tab_size&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span>          <span class="comment">// tab宽度</span></span><br><span class="line"><span class="attr">&quot;translate_tabs_to_spaces&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>   <span class="comment">// tab转换为空格</span></span><br><span class="line"><span class="attr">&quot;trim_trailing_white_space_on_save&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  <span class="comment">// 保存时去掉行尾空格</span></span><br><span class="line"><span class="attr">&quot;word_wrap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>      <span class="comment">// 自动换行</span></span><br><span class="line"><span class="attr">&quot;wrap_width&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span>    <span class="comment">// 换行的宽度,默认80会造成左侧大量留白</span></span><br><span class="line"><span class="attr">&quot;mde.keep_centered&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  <span class="comment">// 可以保持你正在编辑的行始终处于屏幕的中间</span></span><br></pre></td></tr></table></figure>

<h5 id="打开文件新打开标签页，而不是不替换当前标签页"><a href="#打开文件新打开标签页，而不是不替换当前标签页" class="headerlink" title="打开文件新打开标签页，而不是不替换当前标签页"></a>打开文件新打开标签页，而不是不替换当前标签页</h5><p>路径：Preferences-&gt;Settings<br><del>在默认设置页中设置即可</del>： <code>&quot;open_files_in_new_window&quot;: true</code><br>如果发现默认设置页面中就是上述设置，那么在右侧用户设置 <code>&quot;preview_on_click&quot;:false</code><br>此时唯一区别就是打开文件的时候需要双击</p>
<h5 id="卸载插件"><a href="#卸载插件" class="headerlink" title="卸载插件"></a>卸载插件</h5><p>Ctrl+Shift+P，输入Remove，选择Remove Package，之后选择相应的插件，直接回车即可</p>
<h5 id="快速插入代码片段"><a href="#快速插入代码片段" class="headerlink" title="快速插入代码片段"></a>快速插入代码片段</h5><p>打开代码片段（Snippet）: Tools -&gt; Develop -&gt; New Snippet<br>例如，我想要再markdown中快速生成插入shell代码的片段，那么可以安装下图中的方式编写，很简单：<br>这里面的语法很简单：<br><strong><![CDATA[写入你想要快速插入的代码片段]]></strong> 这个XML转义票签里面就是写入你想要快速插入的代码片段<br><strong>tabTrigger</strong>就是你需要再什么单词后按tab键自动插入上述你编写的代码片段<br><img data-src="a4b1030a/ConfigSublimeSnippet.jpg" alt="配置Sublime Snippet"><br>Ctrl + S 保存，目录默认即可，文件名随意，文件后缀名必须是：**.sublime-snippet**，效果就如下图所示：<br><img data-src="a4b1030a/shellAfterPressTabButton.gif" alt="演示效果"></p>
<h5 id="快速查找重复行"><a href="#快速查找重复行" class="headerlink" title="快速查找重复行"></a>快速查找重复行</h5><p>Ctrl + F 打开查找控制面板，输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">^(.+)$[\r\n](^\<span class="number">1</span>$[\r\n]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;)+</span><br></pre></td></tr></table></figure>
<p>点击Find即可。</p>
<h5 id="设置行间距相关"><a href="#设置行间距相关" class="headerlink" title="设置行间距相关"></a>设置行间距相关</h5><p>在个人用户设置里面加上下面的两行json配置即可，段前段后增加间距，设置2个人感觉刚刚好：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;line_padding_bottom&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;line_padding_top&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="办公相关"><a href="#办公相关" class="headerlink" title="办公相关"></a>办公相关</h3><h3 id="Windows相关"><a href="#Windows相关" class="headerlink" title="Windows相关"></a>Windows相关</h3><h4 id="WinDbg（windows-蓝屏分析工具）"><a href="#WinDbg（windows-蓝屏分析工具）" class="headerlink" title="WinDbg（windows 蓝屏分析工具）"></a>WinDbg（windows 蓝屏分析工具）</h4><p>近期周末在玩一款游戏的时候，老是会遇到蓝屏的情况，不清楚什么原因，可见的过程中对这个游戏送一串？？？？</p>
<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><p>windows蓝屏之后，通常都会在C:\Windows\Minidump该目录下面转存储相应的dump文件，如下图所示：<br><img data-src="a4b1030a/windowsbluescreendumpfiles.jpg" alt="windows蓝屏dump文件"><br>此时需要用到微软官方dump文件分析工具，官方下载地址，如下：<br><a href="https://developer.microsoft.com/en-US/windows/downloads/windows-10-sdk">Windows SKD Tool Kits</a><br>点击页面中的“DOWNLOAD THE INSTALLER”<br>下载一个约1.29MB大小的安装文件<br>双击运行之后，前面的安装路径自行填写，其中在“Select the Features you want to download”页面，如下图所示：<br><img data-src="a4b1030a/selectthefutures.jpg" alt="Select the Features you want to download"><br>当中，特别注意“Debuging Tools for Windows”，这个便是我们想要的工具<br><strong>当然，如果你想最简单的方式，直接默认全选，一路next下去，也是可以的</strong><br>等待安装完成<br><em>PS：可能要试具体网络环境，我这边很快，不到5分钟全部安装完成</em></p>
<h5 id="分析dump文件之前的配置工作"><a href="#分析dump文件之前的配置工作" class="headerlink" title="分析dump文件之前的配置工作"></a>分析dump文件之前的配置工作</h5><p>在开始中找到WinDbg(x64)，运行，运行之后是这样的：<br><img data-src="a4b1030a/windbg.jpg" alt="windbg"><br>点击：File-&gt;Symbol File Path，如下图所示：<br><img data-src="a4b1030a/symbolspath.jpg" alt="symbolspath"><br>在Symbol Path会话框里输入如下路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SRV*G:\Symbol*http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure>
<p>其中G:\Symbol是各自symbols文件下载到本地的路径，可以自行配置</p>
<p><strong>如果不配置上述symbol配置会怎样？</strong><br>会提示你，如下一行错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your debugger is not using the correct symbols </span><br></pre></td></tr></table></figure>
<p>是无法正常分析dump文件的</p>
<h5 id="开始分析dump文件"><a href="#开始分析dump文件" class="headerlink" title="开始分析dump文件"></a>开始分析dump文件</h5><p>点击：File-&gt;Open Crash Dump，找到对应的dump文件<br>打开之后，开始由于上述配置symbols路径，会自动从msdl下载分析时遇到的symbols，如下图所示：<br><img data-src="a4b1030a/startdownloadsymbols.jpg" alt="开始下载symbols文件"><br><strong>注意：此时左下角状态栏会显示debuggee not connected字样，这是正常现象，表示debug分析还在准备中，如果你注意最外层WinDbg左下角的状态栏，是可以看到相应的下载Symbols进程的，一个’/‘符号在转圈，注意观察</strong><br>如果网络正常，你会看到在你配置下载的symbols路径下面会多了很多文件夹，如下图所示：<br><img data-src="a4b1030a/downloadedsymbols.jpg" alt="已下载好的符号文件"><br><strong>但是，如果你长时间发现，只有一个文件夹，而且点进去，如果发现一个名为：download.error文件，而且这个文件不是0kb，那么你就要考虑可能是你的网络有问题，不能正常从msdl下载。一种可能DNS解析msdl就是有问题；另一种可能被ban了？没考证，我的解决方案是直接把这个域名msdl.microsoft.com加到黑名单里，走科学上网，发现很快就能正常下载symbols文件了。</strong>下载好的内容如下图所示：<br><img data-src="a4b1030a/onesymboldownloadsuccessfully.jpg" alt="一个成功下载的symbol文件"></p>
<p>稍等片刻，等变成如下图所示的页面，表面可进入到准备分析阶段：<br><img data-src="a4b1030a/readytoanalys.jpg" alt="准备分析"><br><strong>此时注意，左下角状态已变</strong></p>
<p>点击上图中的**!analyze -v**链接，或者在下方状态栏的命令行中直接输入“!analyze -v”，两者等价。<br>等待分析完成之后，提供一则我的dump分析结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*******************************************************************************</span><br><span class="line">*                                                                             *</span><br><span class="line">*                        Bugcheck Analysis                                    *</span><br><span class="line">*                                                                             *</span><br><span class="line">*******************************************************************************</span><br><span class="line"></span><br><span class="line">KMODE_EXCEPTION_NOT_HANDLED (1e)</span><br><span class="line">This is a very common bugcheck.  Usually the exception address pinpoints</span><br><span class="line">the driver/function that caused the problem.  Always note this address</span><br><span class="line">as well as the link date of the driver/image that contains this address.</span><br><span class="line">Arguments:</span><br><span class="line">Arg1: ffffffffc0000005, The exception code that was not handled</span><br><span class="line">Arg2: fffff8036f6d2316, The address that the exception occurred at</span><br><span class="line">Arg3: 0000000000000000, Parameter 0 of the exception</span><br><span class="line">Arg4: 0000000000000014, Parameter 1 of the exception</span><br><span class="line"></span><br><span class="line">Debugging Details:</span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KEY_VALUES_STRING: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIMELINE_ANALYSIS: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DUMP_CLASS: 1</span><br><span class="line"></span><br><span class="line">DUMP_QUALIFIER: 400</span><br><span class="line"></span><br><span class="line">BUILD_VERSION_STRING:  17134.1.amd64fre.rs4_release.180410-1804</span><br><span class="line"></span><br><span class="line">SYSTEM_MANUFACTURER:  System manufacturer</span><br><span class="line"></span><br><span class="line">SYSTEM_PRODUCT_NAME:  System Product Name</span><br><span class="line"></span><br><span class="line">SYSTEM_SKU:  SKU</span><br><span class="line"></span><br><span class="line">SYSTEM_VERSION:  System Version</span><br><span class="line"></span><br><span class="line">BIOS_VENDOR:  American Megatrends Inc.</span><br><span class="line"></span><br><span class="line">BIOS_VERSION:  1009</span><br><span class="line"></span><br><span class="line">BIOS_DATE:  07/23/2017</span><br><span class="line"></span><br><span class="line">BASEBOARD_MANUFACTURER:  ASUSTeK COMPUTER INC.</span><br><span class="line"></span><br><span class="line">BASEBOARD_PRODUCT:  PRIME Z270-A</span><br><span class="line"></span><br><span class="line">BASEBOARD_VERSION:  Rev 1.xx</span><br><span class="line"></span><br><span class="line">DUMP_TYPE:  2</span><br><span class="line"></span><br><span class="line">BUGCHECK_P1: ffffffffc0000005</span><br><span class="line"></span><br><span class="line">BUGCHECK_P2: fffff8036f6d2316</span><br><span class="line"></span><br><span class="line">BUGCHECK_P3: 0</span><br><span class="line"></span><br><span class="line">BUGCHECK_P4: 14</span><br><span class="line"></span><br><span class="line">READ_ADDRESS: fffff8036f661388: Unable to get MiVisibleState</span><br><span class="line">Unable to get NonPagedPoolStart</span><br><span class="line">Unable to get NonPagedPoolEnd</span><br><span class="line">Unable to get PagedPoolStart</span><br><span class="line">Unable to get PagedPoolEnd</span><br><span class="line"> 0000000000000014 </span><br><span class="line"></span><br><span class="line">EXCEPTION_CODE: (NTSTATUS) 0xc0000005 - &lt;Unable to get error code text&gt;</span><br><span class="line"></span><br><span class="line">FAULTING_IP: </span><br><span class="line">nt!CmpCreateKeyBody+166</span><br><span class="line">fffff803`6f6d2316 0fb74514        movzx   eax,word ptr [rbp+14h]</span><br><span class="line"></span><br><span class="line">EXCEPTION_PARAMETER2:  0000000000000014</span><br><span class="line"></span><br><span class="line">BUGCHECK_STR:  0x1E_c0000005_R</span><br><span class="line"></span><br><span class="line">CPU_COUNT: 8</span><br><span class="line"></span><br><span class="line">CPU_MHZ: 1068</span><br><span class="line"></span><br><span class="line">CPU_VENDOR:  GenuineIntel</span><br><span class="line"></span><br><span class="line">CPU_FAMILY: 6</span><br><span class="line"></span><br><span class="line">CPU_MODEL: 9e</span><br><span class="line"></span><br><span class="line">CPU_STEPPING: 9</span><br><span class="line"></span><br><span class="line">CPU_MICROCODE: 6,9e,9,0 (F,M,S,R)  SIG: 70&#x27;00000000 (cache) 70&#x27;00000000 (init)</span><br><span class="line"></span><br><span class="line">BLACKBOXBSD: 1 (!blackboxbsd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLACKBOXPNP: 1 (!blackboxpnp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CUSTOMER_CRASH_COUNT:  1</span><br><span class="line"></span><br><span class="line">DEFAULT_BUCKET_ID:  WIN8_DRIVER_FAULT</span><br><span class="line"></span><br><span class="line">PROCESS_NAME:  services.exe</span><br><span class="line"></span><br><span class="line">CURRENT_IRQL:  0</span><br><span class="line"></span><br><span class="line">ANALYSIS_SESSION_HOST:  KEMI-PC</span><br><span class="line"></span><br><span class="line">ANALYSIS_SESSION_TIME:  08-18-2018 12:38:32.0201</span><br><span class="line"></span><br><span class="line">ANALYSIS_VERSION: 10.0.17134.12 amd64fre</span><br><span class="line"></span><br><span class="line">EXCEPTION_RECORD:  ffffd5896efe0b10 -- (.exr 0xffffd5896efe0b10)</span><br><span class="line">ExceptionAddress: ffffd5896ef03b50</span><br><span class="line">   ExceptionCode: 01000000</span><br><span class="line">  ExceptionFlags: 00000002</span><br><span class="line">NumberParameters: 1896624160</span><br><span class="line">   Parameter[0]: 0000000000000000</span><br><span class="line">   Parameter[1]: 0000000000000000</span><br><span class="line">   Parameter[2]: ffffd5896f0037b0</span><br><span class="line">   Parameter[3]: ffffd5896ec217e0</span><br><span class="line">   Parameter[4]: ffffd5896e780ba0</span><br><span class="line">   Parameter[5]: 0000000000000000</span><br><span class="line">   Parameter[6]: 00000000000a000a</span><br><span class="line">   Parameter[7]: ffffd5896efe0f80</span><br><span class="line">   Parameter[8]: 0000000000180018</span><br><span class="line">   Parameter[9]: ffffd5896efe0f8a</span><br><span class="line">   Parameter[10]: ffffd5896f9a8bd0</span><br><span class="line">   Parameter[11]: ffffd5896e780c70</span><br><span class="line">   Parameter[12]: 0000000000000000</span><br><span class="line">   Parameter[13]: ffffd5896eeff8b0</span><br><span class="line">   Parameter[14]: 0000000000000000</span><br><span class="line"></span><br><span class="line">LAST_CONTROL_TRANSFER:  from fffff8036f2e25dd to fffff8036f3bcca0</span><br><span class="line"></span><br><span class="line">STACK_TEXT:  </span><br><span class="line">ffff8689`0c47e3c8 fffff803`6f2e25dd : 00000000`0000001e ffffffff`c0000005 fffff803`6f6d2316 00000000`00000000 : nt!KeBugCheckEx</span><br><span class="line">ffff8689`0c47e3d0 fffff803`6f3cd942 : ffffd589`6efe0b10 ffffd589`7a2e8730 00000000`00000000 ffffd589`6b5e4938 : nt!KiDispatchException+0x58d</span><br><span class="line">ffff8689`0c47ea80 fffff803`6f3ca4bf : 00000000`00000000 00000000`00000040 ffffd589`69bc6420 ffffc10a`55a3e398 : nt!KiExceptionDispatch+0xc2</span><br><span class="line">ffff8689`0c47ec60 fffff803`6f6d2316 : 00000000`00000010 ffffd589`77284e40 00000000`00000030 ffff8689`0c47ee50 : nt!KiPageFault+0x3ff</span><br><span class="line">ffff8689`0c47edf8 ffff8689`0c47f090 : 00000000`00000001 ffff8689`0c47f840 00000000`00000000 00000000`00000000 : nt!CmpCreateKeyBody+0x166</span><br><span class="line">ffff8689`0c47eea8 00000000`00000001 : ffff8689`0c47f840 00000000`00000000 00000000`00000000 ffff8689`0c47ef80 : 0xffff8689`0c47f090</span><br><span class="line">ffff8689`0c47eeb0 ffff8689`0c47f840 : 00000000`00000000 00000000`00000000 ffff8689`0c47ef80 ffff8689`0c47ef19 : 0x1</span><br><span class="line">ffff8689`0c47eeb8 00000000`00000000 : 00000000`00000000 ffff8689`0c47ef80 ffff8689`0c47ef19 ffff8689`0c47efd0 : 0xffff8689`0c47f840</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">THREAD_SHA1_HASH_MOD_FUNC:  cc68484f0ad7b2ba7711fc62c7e22b20f74cd551</span><br><span class="line"></span><br><span class="line">THREAD_SHA1_HASH_MOD_FUNC_OFFSET:  09da40a0301b7e372ce92d3ab9bddb9d5a57ce52</span><br><span class="line"></span><br><span class="line">THREAD_SHA1_HASH_MOD:  f08ac56120cad14894587db086f77ce277bfae84</span><br><span class="line"></span><br><span class="line">FOLLOWUP_IP: </span><br><span class="line">nt!CmpCreateKeyBody+166</span><br><span class="line">fffff803`6f6d2316 0fb74514        movzx   eax,word ptr [rbp+14h]</span><br><span class="line"></span><br><span class="line">FAULT_INSTR_CODE:  1445b70f</span><br><span class="line"></span><br><span class="line">SYMBOL_STACK_INDEX:  4</span><br><span class="line"></span><br><span class="line">SYMBOL_NAME:  nt!CmpCreateKeyBody+166</span><br><span class="line"></span><br><span class="line">FOLLOWUP_NAME:  MachineOwner</span><br><span class="line"></span><br><span class="line">MODULE_NAME: nt</span><br><span class="line"></span><br><span class="line">IMAGE_NAME:  ntkrnlmp.exe</span><br><span class="line"></span><br><span class="line">DEBUG_FLR_IMAGE_TIMESTAMP:  5b63c7b5</span><br><span class="line"></span><br><span class="line">IMAGE_VERSION:  10.0.17134.228</span><br><span class="line"></span><br><span class="line">STACK_COMMAND:  .thread ; .cxr ; kb</span><br><span class="line"></span><br><span class="line">BUCKET_ID_FUNC_OFFSET:  166</span><br><span class="line"></span><br><span class="line">FAILURE_BUCKET_ID:  0x1E_c0000005_R_nt!CmpCreateKeyBody</span><br><span class="line"></span><br><span class="line">BUCKET_ID:  0x1E_c0000005_R_nt!CmpCreateKeyBody</span><br><span class="line"></span><br><span class="line">PRIMARY_PROBLEM_CLASS:  0x1E_c0000005_R_nt!CmpCreateKeyBody</span><br><span class="line"></span><br><span class="line">TARGET_TIME:  2018-08-18T03:01:10.000Z</span><br><span class="line"></span><br><span class="line">OSBUILD:  17134</span><br><span class="line"></span><br><span class="line">OSSERVICEPACK:  228</span><br><span class="line"></span><br><span class="line">SERVICEPACK_NUMBER: 0</span><br><span class="line"></span><br><span class="line">OS_REVISION: 0</span><br><span class="line"></span><br><span class="line">SUITE_MASK:  272</span><br><span class="line"></span><br><span class="line">PRODUCT_TYPE:  1</span><br><span class="line"></span><br><span class="line">OSPLATFORM_TYPE:  x64</span><br><span class="line"></span><br><span class="line">OSNAME:  Windows 10</span><br><span class="line"></span><br><span class="line">OSEDITION:  Windows 10 WinNt TerminalServer SingleUserTS</span><br><span class="line"></span><br><span class="line">OS_LOCALE:  </span><br><span class="line"></span><br><span class="line">USER_LCID:  0</span><br><span class="line"></span><br><span class="line">OSBUILD_TIMESTAMP:  2018-08-03 11:10:45</span><br><span class="line"></span><br><span class="line">BUILDDATESTAMP_STR:  180410-1804</span><br><span class="line"></span><br><span class="line">BUILDLAB_STR:  rs4_release</span><br><span class="line"></span><br><span class="line">BUILDOSVER_STR:  10.0.17134.1.amd64fre.rs4_release.180410-1804</span><br><span class="line"></span><br><span class="line">ANALYSIS_SESSION_ELAPSED_TIME:  ff90</span><br><span class="line"></span><br><span class="line">ANALYSIS_SOURCE:  KM</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH_STRING:  km:0x1e_c0000005_r_nt!cmpcreatekeybody</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH:  &#123;c4b33015-e33f-270e-d1a4-e4a9a8d630df&#125;</span><br><span class="line"></span><br><span class="line">Followup:     MachineOwner</span><br><span class="line">---------</span><br></pre></td></tr></table></figure>
<h5 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h5><p>从上述结果中，注意观察下述字眼：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEFAULT_BUCKET_ID:  WIN8_DRIVER_FAULT</span><br><span class="line"></span><br><span class="line">PROCESS_NAME:  services.exe</span><br></pre></td></tr></table></figure>
<p>错误原因是<strong>WIN8_DRIVER_FAULT</strong>，错误进程是<strong>services.exe</strong>;在另一个dump文件中，错误原因一样，错误进程是<strong>dwm.exe</strong>，俩程序都是windows自身程序。结合错误原因，大致猜测：<strong>可能是显卡驱动程序问题</strong>。</p>
<h5 id="处理观察"><a href="#处理观察" class="headerlink" title="处理观察"></a>处理观察</h5><p>打开Geforce Experence，更新N卡驱动，之后继续观察还有没有蓝屏发生</p>
<h4 id="又一次蓝屏分析"><a href="#又一次蓝屏分析" class="headerlink" title="又一次蓝屏分析"></a>又一次蓝屏分析</h4><p>昨晚惯例周五晚上打游戏的时间（Gaming Night），玩着玩着，就蓝屏了。<br>蓝屏页面没有拍，报的是：SYSTEM_SERVICE_EXCEPTION的错误。<br>重启之后，WinDbg打开分析一下，发现是OneDrive的锅。<br><img data-src="a4b1030a/SystemServiceException.png" alt="SystemServiceException"><br>很有可能是最近重新做系统之后，OneDrive一直在更新状态导致的，具体原因不知。</p>
<h5 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h5><p>卸载OneDrive，官网重新下载安装包。重新安装。<strong>安装好之后，重新指定新的路径为OD的同步路径</strong></p>
<h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>怀疑是重装系统之后，直接用的老的OD的同步路径，导致OD一直是同步文件的状态。最终在某次偶然的机会，崩溃蓝屏了。。。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Map接口框架</title>
    <url>/post/60ed6a34.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java源码系列</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/post/9753a2e.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本系列主要写关于Java集合框架的一些细节：包括部分类的内部实现、算法探讨、性能分析、相关设计模式等等。Java8集合类中的部分类（比如常用的<code>HashMap</code>）内部实现机制已不同于以往，本系列之余也尽可能会纵向比较Java7版本与Java8框架之间的差异所在。<br>系列文章在追求尽可能的详而细致的描述，难免会有错误不当之处~</p>
<h3 id="集合框架介绍"><a href="#集合框架介绍" class="headerlink" title="集合框架介绍"></a>集合框架介绍</h3><p>在Java8 Api文档中是这么描述集合框架的：</p>
<blockquote>
<p>A collection is an object that represents a group of objects (such as the classic Vector class). A collections framework is a unified architecture for representing and manipulating collections, enabling collections to be manipulated independently of implementation details.</p>
</blockquote>
<p>意在指明Java集合框架总体所需要做的事情：代表并操作各种集合类型。<br>集合框架有如下几点主要优点[^1]：</p>
<ul>
<li>减少编程工作量[Reduces programming effort]：集合类中提供了大量的数据结构和算法的实现，你无需亲自去编写。</li>
<li>提高性能[Increases performance]：提供很多高性能的数据结构以及算法的实现。因许多接口的实现均是通用的[interchangeable]，因而可以根据需要实现相应的接口。</li>
<li>提供在无关API之间的互通[Provides interoperability between unrelated APIs]：建立一个通用语言来回传递集合类</li>
<li>降低学习API的工作量[Reduces the effort required to learn APIs]API：需要学习众多特定[adhoc]集合的API</li>
<li>加速软件重用[Fosters software reuse]：为操作它们提供了许多标准化的集合和算法<span id="more"></span>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4>Java集合框架包含如下内容：</li>
<li>集合类接口[Collection interfaces]：代表了不同类型的集合类，诸如：<code>set</code>、<code>lists</code>、<code>maps</code>。这些都是基础的框架接口</li>
<li>通用实现[General-purpose implementations]：主要集合类的接口实现</li>
<li>传统实现[Legacy implementations]：这些集合类来自于早期版本，例如：<code>Vector</code>和<code>Hashtable</code>，在Java集合框架中均改进了实现</li>
<li>特殊用途实现[Special-purpose implementations]：设计实现用于特殊场景。这些实现类都展现了非标准的性能特征，使用限制，或者行为的差异</li>
<li>并发实现[Concurrent implementations]：用于实现在高并发场景下使用</li>
<li>包装器实现[Concurrent implementations]：提升功能性，例如同步性、以及一些其它实现</li>
<li>便利实现[Convenience implementations]：高性能“迷你实现”的集合类接口</li>
<li>抽象实现[Abstract implementations]：集合接口的局部实现以便于促进定制化的实现类</li>
<li>基础实现[Infrastructure]：为集合接口提供必要的接口</li>
<li>数组工具[Array Utilities]：工具方法主要作用于原生类型和引用对象。严格意义上说这并不是集合框架的一部分，Java平台其它相近的结构也有类似的实现<h4 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h4>集合接口分为两组类型，<code>java.util.Collenction</code>接口子类有如下基本类型接口：</li>
<li>java.util.Set</li>
<li>java.util.SortedSet</li>
<li>java.util.Queue</li>
<li>java.util.concurrent.BlockingQueue</li>
<li>java.util.concurrent.TransferQueue</li>
<li>java.util.Deque</li>
<li>java.util.concurent.BlockingDeque<br>另外一种集合接口类都基于<code>java.util.Map</code>接口，此接口并非真实集合类。然而这些接口包含<em>集合可视</em>操作方法，这些方法运行操作集合类型。<code>Map</code>接口有如下子类：</li>
<li>java.util.SortedMap</li>
<li>java.util.NavigableMap</li>
<li>java.util.concurrent.ConcurrentMap</li>
<li>java.util.concurrent.ConcurrentNavigableMap<h4 id="集合实现"><a href="#集合实现" class="headerlink" title="集合实现"></a>集合实现</h4>集合接口实现类的典型命名方式是*&lt;实现方式&gt;&lt;接口名&gt;*[Implementation-style~~InterFace]。下述表中汇总了这些通用实现类：<br><img data-src="9753a2e/CollectionGenerationPurposeImplementationsTable.jpg" alt="集合类基本实现汇总"><br>在这些集合接口中，通常情况下的实现支持所有可选择的方法并且它们包含的元素并不是严格限制的。这些接口是非同步的[unsynchronized]，但是类<code>Collections</code>包含很多称之为同步包装器[synchronization wrappers]的静态方法，这些方法可以将许多不同步的集合类同步化。所有的实现均拥有快速失败迭代器[fail-fast iterators]，其直接检测到非法的同步修改并且快速失败和清除（而不是超过预先的行为）<h4 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a>并发集合类</h4>当应用超过一个线程操作集合类时必须谨慎编程。简单的说就是并发编程。Java平台包含支持并发编程的扩展。集合类经常被使用，各种友好的并发接口和实现均包含在集合类的相应的API中。这些类型经常被使用在并发编程中超过了之前讨论的同步包装器。<br>这些并发接口组件包括：</li>
<li>BlockingQueue</li>
<li>TransferQueue</li>
<li>BlockingDeque</li>
<li>ConcurrentMap</li>
<li>ConcurrentNavigableMap<br>同步组件的实现类包含如下类。正确的使用方法参考API接口文档。</li>
<li>LinkedBlockingQueue</li>
<li>ArrayBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>DelayQueue</li>
<li>SynchronousQueue</li>
<li>LinkedBlockingDeque</li>
<li>LinkedTransferQueue</li>
<li>CopyOnWriteArrayList</li>
<li>CopyOnWriteArraySet</li>
<li>ConcurrentSkipListSet</li>
<li>ConcurrentHashMap</li>
<li>ConcurrentSkipListMap<h4 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3></li>
<li>[1]Java8 Api Documentation</li>
</ul>
]]></content>
      <categories>
        <category>Java源码系列</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列</title>
    <url>/post/c2b92334.html</url>
    <content><![CDATA[<p>Java系列目录：</p>
<ul>
<li>Core Java<ul>
<li>集合类</li>
</ul>
</li>
<li>JVM</li>
<li>Java多线程</li>
<li>JavaFX</li>
</ul>
]]></content>
      <categories>
        <category>Java系列</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Core Java</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法相关</title>
    <url>/post/7a934d68.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/post/340249a9.html</url>
    <content><![CDATA[<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote>
<p>参照《数据结构》一书中关于线性表的抽象数据类型的基本操作介绍，简化罗列出相关操作定义。</p>
</blockquote>
<ul>
<li>InitList()<ul>
<li>操作结果：构造一个空的线性表L。</li>
</ul>
</li>
<li>DestroyList()<ul>
<li>初始条件：线性表L已存在</li>
<li>操作结果：销毁线性表L。</li>
</ul>
</li>
<li>ClearList()<ul>
<li>初始条件：线性表L已存在</li>
<li>操作结果：将L重置为空表</li>
</ul>
</li>
<li>ListEmpty()<ul>
<li>初始条件：线性表L已经存在</li>
<li>操作结果：若L为空表，则返回<code>TRUE</code>，否则返回<code>FALSE</code></li>
</ul>
</li>
<li>ListLength()<ul>
<li>初始条件：线性表L已经存在</li>
<li>操作结果：返回L中数据元素个数</li>
</ul>
</li>
<li>GetElem(i, e)<ul>
<li>初始条件：线性表L已存在，$1 \leq i \leq ListLength()$</li>
<li>操作结果：用e返回L中第i个数据元素的值<span id="more"></span></li>
</ul>
</li>
<li>LocateElem(e, compare())<ul>
<li>初始条件：线性表L已存在，compare()是数据元素判定函数。</li>
<li>操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。如果这样的元素不存在则返回0。</li>
</ul>
</li>
<li>PriorElem(cur_e, pre_e)<ul>
<li>初始条件：线性表L已存在</li>
<li>操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则失败，pre_e无定义</li>
</ul>
</li>
<li>NextElem(cur_e, next_e)<ul>
<li>初始条件：线性表L已存在</li>
<li>操作结果：若cur_e是L数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义。</li>
</ul>
</li>
<li>ListInsert(i, e)<ul>
<li>初始条件：线性表L已存在，$1 \leq i \leq ListLength() + 1$</li>
<li>操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。</li>
</ul>
</li>
<li>ListDelete(i, e)<ul>
<li>初始条件：线性表L已存在，$1 \leq i \leq ListLength()$</li>
<li>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1。</li>
</ul>
</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><h3 id="ArrayList剖析"><a href="#ArrayList剖析" class="headerlink" title="ArrayList剖析"></a>ArrayList剖析</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>线性结构概念相关</title>
    <url>/post/9848073c.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>罗列一些基本概念，供后续文章使用，后续系列文章中不再过多阐述。</p>
<h3 id="结构特点"><a href="#结构特点" class="headerlink" title="结构特点"></a>结构特点</h3><p>在数据元素的有限集中：</p>
<ol>
<li>存在唯一的一个被称作“第一个”的数据元素</li>
<li>存在唯一的一个被称作“最后一个”的数据元素</li>
<li>除第一个之外，集合中的每个数据元素均只有一个前驱</li>
<li>除最后一个之外，集合中每个数据元素均只有一个后继[^1]<span id="more"></span>

</li>
</ol>
<h3 id="常用的线性结构"><a href="#常用的线性结构" class="headerlink" title="常用的线性结构"></a>常用的线性结构</h3><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><p><strong>基本定义：</strong>具有相同类型的有限多个数据元素组成的一个有序序列。<br>线性表存储结构事例<br><img data-src="linear-strcture-storage-sample.jpg" alt="线性表存储结构事例"></p>
<h5 id="线性表顺序存储"><a href="#线性表顺序存储" class="headerlink" title="线性表顺序存储"></a>线性表顺序存储</h5><p><strong>基本定义：</strong>用一组地址连续的存储单元一次存储线性表的数据元素。常见的便是一维数组类型</p>
<h5 id="线性表链式-linked-存储"><a href="#线性表链式-linked-存储" class="headerlink" title="线性表链式(linked)存储"></a>线性表链式(<em>linked</em>)存储</h5><p><strong>基本定义：</strong>用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。常见的便是单链表或线性链表结构，双向链表，单向循环链表，双向循环链表等。<br><strong>其它概念：</strong>数据域、指针域，其中指针域中存储的信息称之为指针或链。数据域与指针域共同组成一个节点（node）</p>
<h4 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(<em>stack</em>)</h4><p><strong>基本定义： 限定 **仅在</strong> 标尾进行插入或删除操作的线性表。表尾称之为<strong>栈顶</strong>（top），表头称之为<strong>栈底</strong>（bottom）</p>
<h4 id="队列-queue-kyo͞o"><a href="#队列-queue-kyo͞o" class="headerlink" title="队列(queue /kyo͞o/)"></a>队列(<em>queue</em> /kyo͞o/)</h4><p><strong>基本定义：</strong>是一种 <strong>先进先出</strong> (first in first out，缩写为<strong>FIFO</strong>)的线性表。只允许在表的一端进行插入，而在另一端删除元素。</p>
<h4 id="串-string"><a href="#串-string" class="headerlink" title="串(string)"></a>串(<em>string</em>)</h4><p>就是通常意义上的<strong>字符串</strong>。<br><strong>基本定义：</strong>由零个或多个字符组成的有限序列，一般记为[^2]<br>$$<br>s = ‘a_1a_2···a_n’ (a\geq0)<br>$$<br><strong>其它概念：</strong></p>
<ul>
<li>称两个串相等，当且仅当这两个串的值相等，即：两个串长度相等的同时，两者各个位置对应的字符也相等。</li>
<li>串的三种存储方式：<ul>
<li>定长顺序存储：类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。</li>
<li>堆(<em>heap</em>)分配存储表示：任以一组地址连续的存储单元放串值字符序列，但它们的存储空间是在程序执行过程中冬天分配而得。</li>
<li>块链存储表示：与线性表的链式存储类似，串的块链是每个节点存放固定长度的字符，除基本设定头指针外，还需有相应的尾指针来指示当前块链表中的最后结点，与此同时需要给出当前串的长度。<strong>用的不多</strong></li>
</ul>
</li>
</ul>
<h3 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h3><p>[1] 严蔚敏，吴伟民.数据结构：C语言版[M].北京：北京大学出版社，2007: 18.<br>[2] 严蔚敏，吴伟民.数据结构：C语言版[M].北京：北京大学出版社，2007: 70.</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构汇总</title>
    <url>/post/1e0f6ac.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>如果debugging是一种消灭bug的过程，那编程就一定是把bug放进去的过程。<br>Edsger Dijkstra</p>

</blockquote>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一起学习，一起成长，全篇优先用<code>Java</code>实现，必要时会补上伪代码，其它语种再说。<br><strong>如有错误或纰漏之处，请不吝赐教，谢谢！</strong></p>
<h3 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h3><p><em>废话一段，<code>可以直接略过</code></em><br>算法一直以来都是我的弱项，不仅是因为其枯燥无味，更多是因为自身的原因，没有坚持下来。<br>在工作中越来越发现，算法的重要性，并不是说在你在工作中一定能用到多少，而是<strong>算法思想</strong>的重要性！</p>
<span id="more"></span>
<p>经常性的发现，我需要完成一个东西，不论是工作中还是工作外，都发现短板：我不知道有什么更好的方式去实现！<br>从自身的角度，正式因为看到这种思想的重要性，想要全面的提升一下自己，自然系统的重新汇总学习是有必要的。</p>
<h3 id="系列内容细则"><a href="#系列内容细则" class="headerlink" title="系列内容细则"></a>系列内容细则</h3><p>本着汇总，尽量会写的详细，涉及面广一点。如果有时间，有能力的话，也会来写一写当下最新的东西。<br><strong>既然写，能力有限，很多文章可能并不会做到100%原创，所以我会在每篇文章的结尾写上所有内容引用链接，必要的情况下会做好角标。</strong><br>全篇系列中，所有涉及到的，<strong>个人贴的代码块，均会亲自跑一下</strong>。无法跑的代码，会已引用的方式贴出，必要的情况下会以图片的方式贴出。</p>
<h3 id="内容概要-实时更新"><a href="#内容概要-实时更新" class="headerlink" title="内容概要[实时更新]"></a>内容概要[实时更新]</h3><ol>
<li>线性结构<ol>
<li>数组</li>
<li>链表</li>
<li>栈</li>
<li>队列</li>
<li>串</li>
</ol>
</li>
<li>非线性结构<ol>
<li>二叉树</li>
<li>多维数组</li>
<li>广义表</li>
<li>AVL树</li>
<li>伸展树</li>
<li>红黑树</li>
<li>哈夫曼树</li>
</ol>
</li>
<li>堆<ol>
<li>二叉堆</li>
<li>左倾堆</li>
<li>斜堆</li>
<li>二项堆</li>
</ol>
</li>
<li>图</li>
<li>排序算法</li>
</ol>
<h3 id="系列参考链接"><a href="#系列参考链接" class="headerlink" title="系列参考链接"></a>系列参考链接</h3><p><a href="http://www.cnblogs.com/skywang12345/p/3603935.html">博客园skywang12345: 数据结构与算法系列 目录</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>初始页面</title>
    <url>/post/4086e55.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>站点</category>
      </categories>
      <tags>
        <tag>nimbusk</tag>
      </tags>
  </entry>
</search>
