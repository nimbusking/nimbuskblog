---
title: 深入学习Java并发
abbrlink: '181e5700'
date: 2024-10-25 16:35:56
tags:
    - 并发编程
    - 并发原理
categories: Java系列
---

## 理论相关
### 并发三大特性
并发编程BUG的源头，都归纳为三个问题：**可见性、原子性与有序性**问题

### JMM相关
Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。
JMM规范了Java虚拟机与计算机内存是如何协同工作的：**规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。**
JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式。
**JMM是围绕原子性、有序性、可见性展开的。**

![JMM内存模型示意图](181e5700/JMM内存模型示意图.png)
#### 关联两个疑问
1. 本地内存中的变量数据什么时候刷新到主内存中？答：不会立马刷新，而是有一定时间。
2. 本地内存中的变量数据什么时候会失效？答：有缓存淘汰时间，淘汰之后会立马read主内存中新的值。
例子中，使用Thread.yield()也可以保证可见，原因：这个方法释放了当前线程的CPU时间片，即存在上下文切换过程，再次获得时间片的时候，会加载上下文，因此会重新读主内存中的值。

### 可见性问题
**当一个线程修改了共享变量的值，其他线程能够看到修改的值。**
Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。
如何保证内存可见性：
+ 通过 volatile 关键字保证可见性。
+ 通过 内存屏障保证可见性。
	+ UnsafeFactory.getUnsafe().storeFence()，与volatile底层是同一个实现，所以可以。
+ 通过 synchronized 关键字保证可见性。能够的原因：底层还是靠storeFence内存屏障实现的。
	+ System.out.println(); // 这个里面是有syn同步块的
+ 通过 Lock保证可见性。
	+ LockSupport.unpark(Thread.currentThread()); // 底层还是内存屏障
+ 通过 final 关键字保证可见性
	+ 比如包装器类，例如Integer，比较特殊，这个也可以。

#### Java中如何保障
从底层本质归纳起来两种，一种是在JVM层面调用storeFence()内存屏障；另一种就是实现上下文切换。
volatile关键字可以保证可见性原因：
- JVM内存屏障，storeLoad来实现；底层汇编：lock前缀; addl

### 缓存一致性协议-MESI
通过缓存中数据（Cache Line）施加4个状态，来达到缓存一致性目的：M-修改；E-独占；S-共享；I-失效。
当失效的时候，高速缓存会立即加载主内存；
注：TODO  可以搜一下这个实现的状态机
![MESI协议状态流转问题](181e5700/MESI协议状态流转问题.png)

**存在两个问题：**
1. 如果存在跨缓存行的时候，一致性协议有问题
2. 早期处理器是没有实现缓存一致性协议（*不同处理器同时向总线发起总线事务， 通过总线仲裁实现，代价非常大，了解*）

### 关于伪共享
伪共享的本质原因：因为缓存行（Cache Line），linux下默认64字节。当程序的不同变量，在同一个缓存行的时候，不同线程处理对应变量的时候，会造成相互干扰（参考MESI），导致频繁的失效要重新读取，性能严重下降。
![伪共享内存交互示意图](181e5700/伪共享内存交互示意图.png)
上图对应的程序代码片段
```java
class Pointer {
	volatie long x;
	volatie long y;
}
// 起两个线程，分别对x、y进行累加动作
```
#### 避免伪共享
1. **手动填充缓存行**：通过在变量之间插入填充变量（padding），可以将不同的变量分配到不同的缓存行中，从而避免伪共享问题。例如，在多线程环境下访问两个变量a和b，如果它们位于同一个缓存行中，可以在它们之间插入一个long类型的变量c，从而让a和b分别被存储到不同的缓存行中，避免了缓存行的竞争。

2. 使用JDK8提供的```@sun.misc.Contended```注解：在JDK8中，@sun.misc.Contended注解可以用来避免伪共享问题。这个注解只能用于类和属性，并且需要手动启用JVM的-XX:-RestrictContended参数。使用该注解后，JVM会自动为相关变量添加填充字节，确保它们不会位于同一个缓存行中。

3. **使用OpenMP的归约子句（reduction）**：在并行编程中使用OpenMP的归约子句（reduction），可以将多个线程的变量合并到一个共享变量中，从而减少缓存行的冲突。这种方法不同于数据填充进行边界对齐的方式，代码中不再将结果声明为数组而是声明为普通变量，使用reduction子句会使得每个线程都有一个变量，通过指定的运算符进行归约计算。
**注：这个只作为了解即可**，有这么个设计泛型，目前支持OpenMP的只有：C、C++和Fortran。有兴趣的可以去看看该模型的specification，[地址](https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-5-2.pdf)。在Java中，有前面两个功能即可。

## Java线程模型相关
### 有几个主题问题
1. CAS涉及到用户模式到内核模式的切换吗？
	1. CAS不会涉及用户模式到内核模式切换，因为CAS操作最终直接执行的是CPU指令，不涉及切换
2. 为什么说创建Java线程的本质上只有一种？Java线程和go语言的协程有什么区别？
3. 如何优雅的终止线程？
4. Java线程之间如何通信的，有那些方式？

### 线程和进程的区别
- **进程**：操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位
- **线程**：线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位
**两者具体的区别：**
- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享
- 进程间通信较为复杂
	- 同一台计算机的进程通信称为 IPC（Inter-processcommunication）
	- 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP
- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低

### 进程之间的通信方式
1. **管道（pipe）及有名管道（named pipe）**：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
2. **信号（signal）**：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
3. **消息队列（message queue）**：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
4. **共享内存（shared memory）**：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
5. **信号量（semaphore）**：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
6. **套接字（socket）**：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

### 线程的同步互斥
### 上下文切换
- 上下文切换只能在内核模式下发生。
- 上下文切换时多任务操作系统的一个基本特性
- 上下文切换通常是计算密集型的

### 内核模式与用户模式
#### Kernel Mode
在内核模式下，执行代码可以完全且不受限制地访问底层限制。它可以执行任何CPU指令和引用任何内存地址。内核模式通常为操
#### User Mode

#### 两者切换的场景
![用户态和内核态切换的场景](181e5700/用户态和内核态切换的场景.png)
- 系统调用：调用系统底层API
- 异常事件：当发生某些预先不可知的异常，就会切换到内核态，以执行相关的异常事件。
- 设备中断：在使用外围设备时，如外围设备收到用户请求，就会向CPU发送一个中断信号，此时，CPU就会暂停执行原本的下一条指令，转去处理中断事件。此时，如果原来在用户态，自然就会切换到内核态。

### 线程生命周期(操作系统层面)
一般的认为有5种：
![多数的5种状态图](181e5700/多数的5种状态图.png)
在Java层面划分了6种：**NEW, RUNNABLE, BLOCKED, WAITTING, TIMED_WATTING, TERMINATED**，相互交互的示意图如下：
![Java层面的6种](181e5700/Java层面的6种.png)

### 跟Java线程相关
#### 线程的创建方式
1. 直接new Thread类
2. 实现Runnable接口配合Thread
3. 使用有返回值的Callable
4. 使用Lambda表达式
**上述本质上，只有一种创建方式：new Thread(Runnable()).start()方式启动**
关于Thread类中start方法分析：
**注：只有通过start方法**，才能真正调用（通过JNI方式调用）操作系统底层创建线程，大体流程是：
	1. 使用new Thread()创建一个线程，然后调用start()方法进行java层面的线程启动
	2. 调用本地方法start0()，去调用JVM中的JVM_StartThread方法进行线程创建和启动
	3. 调用new JavaThread(&thread_entry, sz)进行线程的创建，并根据不同的操作系统平台调用对应的os::create_thread方法进行线程的创建
	4. 新创建的线程状态为Initialized，调用sync->wait()的方法进行等待，等待被唤醒才会继续执行thread->run()
	5. 调用Thread::start(native_thread)方法进行线程启动，此时将线程状态设置为RSUNNABLE，接着调用os::start_thread(thread)，根据不同的操作系统选择不同的线程启动方式
	6. 线程启动之后状态设置为RUNNABLE，并唤醒第4步中等待的线程，接着执行thread->run()的方法
	7. JavaThread::run()方法会回调第1步new Thread中复写的run方法

#### 协程的概念
协程，英文Coroutines, 是一种**基于线程之上，但又比线程更加轻量级的存在**，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行），具有对内核来说不可见的特性。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

#### Java线程的调度机制
Java线程调度是抢占式调度的

#### 如何优雅的停止线程
为什么不要用Thread.stop方法，**因为stop方法会释放线程锁，导致并发问题**

##### 优雅的方式：利用线程的中断机制
Java没有提供一种安全、直接的方法来停止某个线程，而是提供了中断机制。
**中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理。被中断的线程拥有完全的自主权，它既可以选择立即停止，也可以选择一段时间后停止，也可以选择压根不停止。**

Java中提供了几个API来实现：
- interrupt()： 将线程的中断标志位设置为true，不会停止线程
- isInterrupted(): 判断当前线程的中断标志位是否为true，不会清除中断标志位
- Thread.interrupted()：判断当前线程的中断标志位是否为true，并清除中断标志位，重置为fasle
特别要注意，如果使用中断了，一定要注意中断标志位是否被清除，比如在调用sleep（sleep会清除中断标志）期间，一定要还原中断标志
#### 线程之间的通信
volatile
#### 等待唤醒机制
wait/notify ：这种方式需要依赖synchronized加锁才行，另外notify唤醒，没法指定某个线程唤醒
**park/unpark：这个方式就可以直接指定唤醒具体哪个线程**

#### 管道的输入输出流
Thread.join()


## 线程安全相关(原子与有序问题)
### CAS原子性
#### 什么是CAS
通常指的是这样一种原子操作：针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给它赋一个新值。
**CAS 可以看作是它们合并后的整体——一个不可分割的原子操作，并且其原子性是直接在硬件层面得到保障的。**

**CAS操作天然能够保持内存可见性，硬件底层指令**

#### CAS缺陷
- **自旋CAS长时间不成功，则会给CPU带来非常大的开销**
- **只能保证一个共享变量原子操作**
- **ABA问题：通过额外增加版本号逻辑来避免ABA问题**

#### LongAdder/DoubleAdder
解决AtomicLong等在高并发下**自旋造成的性能影响**

### synchronized
### AQS

## 并发编程相关

## 设计模式相关

## JDK8下的JUC包相关