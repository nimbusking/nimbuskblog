---
title: JVM内存分配策略与垃圾收集
abbrlink: d16864e6
date: 2024-10-14 23:19:28
tags:
    - JVM
    - 周志明
    - 深入理解Java虚拟机
categories: Java系列
---


## 前言
看过部分机构的教学视频，针对这部分内容，仍然觉得是《深入理解Java虚拟机 第三版》（下文简述：该书）一书中解释的更为系统，更为条理。
**先惭愧一番，笔者在2020年第一次阅读该书的时候，曾经做过一次读书笔记**，[链接在这](https://nimbik.cc/post/d7ba81a7)。时隔几年之后，再次看当年写的，那叫什么玩意儿？纯粹的一个书籍摘录？完全没有思考，现在能回忆起来，可能当时跟着书里面敲过几个案例而已。然而，最搞笑的事情是，我竟然忘了自己做过这种蠢事了。直到最近重新捡起JVM的时候，才看到之前写的文章。
**这里纯当给众看官一个笑话吧，一个赤裸裸的反面教材**
<!-- more -->
回到标题，以该书第三章标题作为本篇的标题，也是我们熟悉JVM原理最终调优需要解决的问题，就是如何让这两件事更优雅的去工作。
再次写，梳理好思路，形成自己的东西吧。

### 关于该书的阅读感受
首先，公认的（包括我在内），这本书是**国内**最好的、系统的介绍JVM的书籍（直到2024年了，依旧没有发现与之媲美的）。
再来，笔者阅读过第二版与第三版，如果你还没有，直接入手第三版即可，第三版中增加了很多关于JDK8之后的JVM的介绍与比较，是值得看的。
该书，更多的要当一本JVM手册书去看，时不时的要去翻翻，才能有更多的体会。**建议不要妄想一下子从头到尾啃完，这个难度非常大，至少我是没有这个水平**。
再来说一个问题，周老师的这本书的章节排版上，讲实话读一遍两遍（可能还没读完，读一半的那种），你可能会有一个感觉，**读到后面忘掉前面**。我仔细想了一下，为啥会有这个感觉？
我的体会是，**书中大量地方其实是穿插介绍的，并没有走总分这条线下来**。作者在书中前言也提到：

> 该书前言节选：
> 本书一共分为五个部分：走进Java、自动内存管理、虚拟机执行子系统、程序编译与代码优化、高校并发。各个部分之间基本上是相互独立的，没有必然的前后依赖关系，读者可以从任何一个感兴趣的专题开始阅读，但是各个部分各个章节间则有先后顺序。

正因为如此，所以有个问题就是：**如果你在阅读，需要你自己形成一个总分的脉络，来理解JVM的底层，这样才能助于记忆。** 不然两天不摸，你可能就忘了。
#### 阅读顺序
既然如此，我在翻过3-4遍该书之后，有个新的认识，这里分享出来一个可以参考的阅读顺序。
**注：** 这里的阅读顺序更多的是侧重运行时的原理，该书的主体脉络也是如此。至于编译原理【惭愧，大学学的编译原理课程早就还给老师了】相关的，该书中介绍的篇幅其实是相对少的，在第10章和第11章有所介绍。毕竟我们老生常谈的JVM调优，更多侧重的是运行时的优【解】啊，不是编译的优化。所以这部分，我也不作细节阐述。
1. **JVM内存模型相关**：这部分死磕，一个字都别拉下的那种，而且必须熟记于心，因为这是所有的JVM后续工作的基础。**对应该书，第2.2小节。**
2. **对象的创建过程**：解释如何创建及内存布局相关，**对应该书，第2.3节**
	2.1. **类加载器及对象的加载过程**：**对应书中第7章**，包括双亲委派模型等。
3. **再次细致的熟悉栈帧结构**：第8.2小节
4. **对象内存分配与回收策略**：对应该书，第3.8小节。
5. **垃圾收集算法理论**：对应该书，第3.2、3.3、3.4小节
6. **垃圾收集器相关**：对应该书，第3.5、3.6小节
	6.1. 第3.7小节，如何选择合适的垃圾收集器
7. **调优命令与工具**：第4章，JVM命令行及可视化工具
8. **调优案例分析与实战**：第5章全篇，不要在意书中提到的例子是不是跟你工作有关，重点体会作者调优的思路，以及理解为什么要这样做即可。
9. **剩下的内容**：这部分，我个人觉得，看你兴趣翻阅看即可。
	9.1. 第1章的背景，了解了解Java的发展历程；
	9.2. 第6章，类文件结构，这部分了解，了解之后可能对类加载过程更深刻一点，完全不用背；
	9.3. 第8章其余小节，了解字节码执行引擎其余的细节，比如动态类型支持的原理；
	9.4. 第10、11章，这部分就跟编译原理相关了，第11.4.3小节，逃逸分析可以了解；
	9.5. 第12、13章，这部分介绍JVM在处理并发程序时的一些原理，特别是第12.3小节，Java内存模型（JMM）值得一看。
	9.6. 其余边角，不一一例举。

## JVM内存模型
这部分内容参考，另外一篇文章：[JVM内存模型](https://nimbik.cc/post/6377921b)

## 内存分配与垃圾收集
阐述从分配到垃圾收集过程中的细节
### 内存分配策略
**注：** 这部分非常重要，只有充分理解了一个对象在内存中的分配的过程，在遇到JVM性能调优的问题的时候，再结合具体的垃圾收集器的工作的表现，才有明确的思路去进行参数优化。
否则的话，你虽然看到譬如gc信息的时候，你看到了是这样的，但是不知道为什么会造成这样，间接的你不会直到可能存在的代码问题，更别谈参数调优了。
![对象内存分配示意图](d16864e6/对象内存分配示意图.png)

#### 逃逸分析
**注：** 书中关于这部分描述，在第11章，第11.4.3小节中有详细阐述。**目的就是通过逃逸分析手段，来判断对象是否可以分配或者间接引用栈上内存，而不分配在堆上。这部分隶属于编译优化的技术。**
**逃逸分析基本原理**：分析对象动态作用域，当一个对象在方法里面被定义之后，它可能被外部方法所引用，例如作为调用参数传递到其它方法中，这种称为**方法逃逸**；甚至可能被外部线程访问到，譬如赋值给可以在其它线程中访问的实例变量，这种成为**线程逃逸**。
**从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度**。
如果逃逸程度比较低（除线程逃逸之外的），可以用下面几个方法来优化对象实例的分配：
+ **栈上分配（Stack Allocations）**：直接在栈上分配，减轻垃圾收集器的压力，随着栈销毁而销毁。
	**注**：目前HotSpot里面没有做这项优化。
+ **标量替换（Scalar Replacement）**：标量是指一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就称之为**标量**。反之称之为，**聚合量**。
	如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称之为**标量替换**。对逃逸程度要求更高，不允许方法逃逸之外的情况产生。
+ **同步消除（Synchronization Elimination）**：如果变量不会逃出线程，自然变量的读写不会出现竞争，对这个变量实施的同步措施也可以安全的被消除。
笔者在本地JDK1.8环境中的默认JVM参数发现，目前1.8.0版本，关于逃逸分析（**-XX:+DoEscapeAnalysis**）及标量替换（**-XX:+EliminateAllocations**）和同步消除（**-XX:+EliminateLocks**）两个关联参数是默认打开的。

#### 在Eden区分配
大多数情况下，对象在新生代中 Eden 区分配。当 **Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC**。
大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，让eden区尽量的大，survivor区够用即可，
JVM默认有这个参数 **-XX:+UseAdaptiveSizePolicy**(1.8默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数 **-XX:-UseAdaptiveSizePolicy**

当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现无法存入Survior空间，所以只好把新生代的**对象提前转移到老年代**中去，老年代上的空间如果足够存放，所以不会出现Full GC
##### Minor GC与Full GC不同
+ **Minor GC/Young GC**：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。
+ **Major GC/Full GC**：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。

#### 大对象直接进入老年代
大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 **-XX:PretenureSizeThreshold** 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，**这个参数只在 Serial 和ParNew两个收集器下有效。**

#### 长期存活的对象进入老年代
既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给**每个对象一个对象年龄（Age）计数器**。这个存储在对象头中。
如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 **-XX:MaxTenuringThreshold** 来设置。

#### 对象动态年龄判断
当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(**-XX:TargetSurvivorRatio**可以指定)，那么此时**大于等于**这批对象年龄最大值的对象，就可以直接进入老年代了。
例如Survivor区域里现在有一批对象，**年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%**，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，**尽早进入老年代**。对象动态年龄判断机制一般是在minor gc之后触发的。

#### 老年代空间分配担保机制
**年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间**
如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)就会看一个 **-XX:-HandlePromotionFailure** (jdk1.8默认就设置了)的参数是否设置了如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。
如果上一步结果是**小于或者之前说的参数没有设置**，那么就会触发一次Full GC，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生"OOM"
当然，如果Minor GC之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发Full GC，Full GC完之后如果还是没有空间放Minor GC之后的存活对象，则也会发生“OOM”
![老年代空间分配担保流程](d16864e6/老年代空间分配担保流程.png)

### 垃圾回收算法
这部分重点搞清楚下面几个问题：
+ 什么对象判定为活着的？
+ 无用对象怎么回收？
+ 节点扫描的细节
+ 垃圾收集器相关细节

#### 对象存活判定法则
##### 引用计数法
##### 可达性分析算法
##### 关于finalize方法
##### 回收方法区

#### 垃圾回收理论
##### 分代收集理论
##### 标记-清除
##### 标记-复制
##### 标记-整理

#### HotSpot算法实现细节
##### 根节点枚举问题
##### 安全点
##### 安全区域
##### 写屏障
##### 并发可达性分析

### 垃圾收集器
参考另外一篇博客：[垃圾收集器](https://nimbik.cc/posts/e4c87989)

## 调优工具

## 调优实战

## 其它细节
### Java的发展历程
### Class文件结构
### 节码执行引擎
### Java层面的编译原理
### 高性能并发场景