---
title: Redis相关
abbrlink: c35d37e7
date: 2024-12-26 13:25:34
updated: 2024-12-26 13:25:34
tags:
  - Redis
  - 分布式缓存
categories: Redis
---

## 前言
整理一些关于redis相关的知识，其中包含一些底层原理。
<!-- more -->
## 数据结构
这部分主要以3.0版本介绍为主，会穿插补充跟6.0版本差异的数据结构
![新旧redis版本数据结构差异](c35d37e7/新旧redis版本数据结构差异.jpg)

### 简单动态字符串
Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为**简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。**
在Redis里面，C字符串只会作为字符串字面量（stringliteral）用在一些无须对字符串值进行修改的地方，比如打印日志：
```redisLog(REDIs_WARNING,"Redis is now ready to exit, bye bye...");```
当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的键值对在底层都是由SDS实现的。

这部分结构，完全可以与Java语言中的ArrayList数据结构来对比。

结构示意图如下所示：
```c
struct sdshdr
{
  // 记录buf数组中已使用字节的数量
  // 等于SDS所保存字符串的长度
  int len;

  // 记录buf数组中未使用字节的数量
  int free;

  // 字节数组，用于保存字符串
  char buf[];
};
```
![SDS结构示例](c35d37e7/SDS结构示例.jpg)

#### 为什么要设计SDS
##### 常数复杂度取字符串长度
因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的**复杂度为O(N)**。
![C字符串计算过程示例](c35d37e7/C字符串计算过程示例.jpg)
和C字符串不同，因为SDS在1en属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O(1)。举个例子，对于下图所示的SDS来说，程序只要访问SDS的len属性，就可以立即知道SDS的长度为5字节
![5字节长的SDS](c35d37e7/5字节长的SDS.jpg)

##### 杜绝缓冲区溢出
这部分也得益于SDS记录长度，当发现空间不够存储时，会扩容，然后再进行操作。

##### 减少修改字符串时带来的内存重分配次数
SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和情性空间释放两种优化策略。
- **空间预分配**：空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间。大致的过程分为下面两种情况：
  - 如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将**小于1MB**，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和
free属性的值相同。举个例子，如果进行修改之后，SDS的len将变成13字节，那么程序也会分配13字节的未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的一字节用于保存空字符）。
  - 如果对SDS进行修改之后，SDS的长度将**大于等于1MB**，那么程序会分配1MB的未使用空间。举个例子，如果进行修改之后，SDS的1en将变成30MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte。
- **惰性空间释放**：情性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。

##### 二进制安全
为了确保Redis可以适用于各种不同的使用场景，**SDS的API都是二进制安全的（binary-safe）**，所有SDS的API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写人时是什么样的，它被读取时就是什么样。
这也是我们将SDS的buf属性称为字节数组的原因-—Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。

##### 兼容部分C字符串函数

#### 总结
C 字符串和 SDS 之间的区别

| C字符串        | SDS           |
| ------------- |:-------------:|
|  获取字符串长度的复杂度为O(N)      | 获取字符串长度的复杂度为O(1) |
| API是不安全的,可能会造成缓冲区溢出      | API是安全的,不会造成缓冲区溢出      |
| 修改字符串长度N次必然需要执行N次内存重分配      | 修改字符串长度N次最多需要执行N次内存重分配      |
| 只能保存文本数据      | 可以保存文本或者二进制数据      |
| 可以使用所有`<string.h>`库中的函数      | 可以使用一部分`<string.h>`库中的函数      |

### 链表

## 引用
[1] 黄建宏. Redis设计与实现. 机械工业出版社 2014