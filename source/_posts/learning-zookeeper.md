---
title: ZooKeeper学习
abbrlink: 324f2c0b
date: 2022-08-01 12:20:32
tags:
  - 中间件
  - ZooKeeper
updated: 2024-10-28 20:30:21categories: ZooKeeper
---



## 前言



## 从Paxos到ZooKeeper

<!-- more -->

### 第1章 分布式架构

#### 分布式的特点

- **分布性**：分布式系统中的多台计算机都会在空间上随意分布。
- **对等性**：分布式系统中的计算机没有主／从之分， 既没有控制整个系统的主机，也没有被控 制的从机，组成分布式系统的所有计算机节点都是对等的。
- **并发性**：如果在并发场景下协调好共享资源
- **缺乏全局时钟**：在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。 
- **故障总会发生**：组成分布式系统的所有计算机，都有可能发生任何形式的故障。



#### 分布式环境的各种问题

- 通信异常：分布式节点之间需要网络通信，网络通信就带来，比如延迟等异常情况
- 网络分区：组成分布式系统的所有节点，因为网络异常，导致一部分节点能通信，一部分节点不能通信，这个现象称之为网络分区，俗称为“脑裂”。
- 三态：分布式系统的每一次请求与响应，存在特有的“三态”，即成功、失败和超时。
- 节点故障：



#### 分布式事务

分布式事务场景下的数据一致性等问题

#### 关于CAP与BASE

关于CAP的应用，我们要知道，分布式系统无法同时满足这三个需求的。往往只能满足其中两项，关于这点，在书中有个表格，这里贴出来，需要的时候可以看看缺失其中一项的应用场景是什么：

![CAP定理应用](324f2c0b/CAP定理应用.jpg)

另外，在分布式场景下，分区容错性（P）是一定要解决的，不然怎么称之为分布式系统？

##### 关于BASE

BASE是由Basically Available(基本可用)、Soft state（软状态）和Eventually consistend（最终一致性）这三个短语构成的。

来自EBAY工程师Dan Pritchett在2008年发布的一篇文章中提到的概念，笔者从ACM网站上下载了下来，有需要可以翻阅看看。

 [Introduce BASE different with ACID.pdf](324f2c0b\Introduce BASE different with ACID.pdf) 

原文文章连接：https://dl.acm.org/doi/10.1145/1394127.1394128

【备注】书中介绍了一下ACID背景以及带来的问题，通过引入交易转账的两张小表来阐述怎么做到最终一致性，以及最终一致性的目标。读者可以仔细看看，例子不难，对于理解最终一致性是很有帮助的。

BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是：**即使无法做到强一致性(Strong consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。**

【备注】关于最终一致性，书中还介绍了五类主要的变种，分别是：

- 因果一致性（Causal consistency）
- 读己之所写（Read your writes）
- 会话一致性（Session consistency）
- 单调读一致性（Monotonic /ˌmänəˈtänik/ read consistency）
- 单调写一致性（Monotonic write consistency）



### 第2章 一致性协议

【备注】这个章节中介绍了三种经典的分布式一致性算法，分别是二段提交（2PC, Two-Phase Commit）、三段提交（3PC, Three-Phase Commit）以及大名鼎鼎的Paxos算法。

在介绍二、三段提交算法之前，书中引入了“段式”提交的核心理念：

当一个事务操作需要跨越多个分布式节点的时候， 为了保持事务处理的ACID特性， 就需要引入 一个称为 ＂协调者(Coordinator)" 的组件来统一调度所有分布式节点的执行逻辑， 这些被调度的分布式节点则被称为 “参与者” (Participant)。 **协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。** 

#### 2PC

PC, 是Two-Phase Commit的缩写， 即二阶段提交，是计算机网络尤其是在数据库领域内， 为了使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。

【备注】你可能也听过另外一个二段：二段锁（2PL, Two-Phase Locking），这俩个是完全不同的东西哦。二段锁，是解决单机事务中的数据的一致性和隔离性而诞生的。而，二段提交是处理的分布式事务。

二段提交示意图，如下图所示：

![二段事务提交示意图](324f2c0b/二段事务提交示意图.jpg)

##### 优缺点

**优点**：原理简单，实现方便。

**缺点**：同步阻塞、单点问题、脑裂、太过保守。

关于缺点：

- **同步阻塞**：在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处千阻塞状态
- **单点问题**：**协调者**的角色在整个二阶段提交协议中起到了非常重要的作用。 一旦协调者出现问题， 那么整个二阶段提交流程将无法运转， 更为严重的是， 如果协调者是在阶段二中出现问题的话， 那么其他参与者将会一直处于锁定事务资源的状态中， 而无法继续完成事务操作。
- **数据不一致**：当协调者向所有的参与者发送Commit请求之后， 发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求。 于是， 这部分收到了Commit请求的参与者就会进行事务的提交， 而其他没有收到Commit请求的参与者则无法进行事务提交， 整个分布式系统便出现了数据不一致性现象。
- **太过保守**：如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务， 这样的策略显得比较保守。 换句话说， 二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。

【备注】在书中的这几个缺点的详细描述可以很好的理解二段事务提交的特点，衍生的场景，可以了解一下MySQL中事务是怎么使用二段提交这个特性的。

关于2PC和3PC这两个概念，有兴趣的看官，可以参阅1988年出版，由Philip A. Bernstein等人巨著的，《数据库并发控制理论》（暂译）(*CONCURRENCY CONTROL AND RECOVERY IN DATABASE SYSTEMS*)一书，该书中系统的阐述了在数据库系统设计过程中，并发场景的种种问题及挑战，其中2PC和3PC在书中的第7章有详细阐述。这本书，同样涵盖了，例如MVCC（熟悉MySQL的一定不陌生），2PL等数据库并发控制理论。

当然如果你还不过瘾，在研究完本篇Zookeeper相关概念之后，可以参考参考，知乎上一位博主总结的关于分布式的台前幕后：https://zhuanlan.zhihu.com/p/338161857



#### 3PC

3PC是由2PC演进而来，其过程主要是将二阶段提交协议的“提交事务请求”过程一分为二，形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。

其原理示意图（来自Google）：

![三段事务提交示意图](324f2c0b/三段事务提交示意图.jpg)

##### 优缺点

**优点**：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。

**缺点**：参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。

#### Paxos

Paxos算法是莱斯利·兰伯特( [Leslie Lamport](https://en.wikipedia.org/wiki/Leslie_Lamport)) （【备注】计算机界的一位巨佬，其在分布式领域的贡献不亚于Dijkstra这些巨佬的贡献，2013年图灵奖获得者）注2 千1990年提出的一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。

Paxos主要解决的问题就是在前面提到的，在分布式系统中，如果出现了诸如机器宕机或网络异常等情况。Paxos算法需要解决的问题就是**如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。**



### 第3章 Paxos的工程实践

#### 关于Chubby

要知道：Chubby提供了粗粒度的分布式锁服务，开发人员不需要使用复杂的同步协议，而是直接调用Chubby的锁服务接口即可实现分布式系统中多个进程之间粗粒度的同步控制，从而保证了分布式数据的一致性。

### 第4章 ZooKeeper与Paxos

#### 初识ZooKeeper

ZooKeeper的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。

ZooKeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如现诸如**数据发布／订阅、负载均衡、命名服务、分布式协调／通知、集群管理、Master选举、分布式锁和分布式队列**等功能。ZooKeeper可以保证如下分布式一致性特性：

- **顺序一致性**：从同一个客户端发起的事务请求， 最终将会严格地按照其发起顺序被应用到ZooKeeper中去。
- **原子性：**所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群所有机器都成功应用了某一个事务， 要么都没有应用。
- **单一视图（Single System Image）**：无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。
- **可靠性：**一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来， 除非有另一个事务又对其进行了变更。
- **实时性**：ZooKeeper 仅仅保证在一定的时间段内， 客户端最终一定能够从服务端上读取到最新的数据状态。

#### ZooKeeper的基本概念

【备注】这里只是介绍的基本概念，详细细节再第7章中会详细介绍

##### 集群角色

ZooKeeper不同于传统的Master/Slave模式，将整个集群分为Leader、Follower、Observer三种机器。

- 关于**Leader机器**：ZooKeeper集群中的所有机器通过一个Leader选举过程来选定一台被称为"Leader"的机器，Leader服务器为客户端提供读和写服务。
- **关于Follower和Observer机器**：Follower和Observer都能够提供读服务，唯一的区别在干，Observer机器不参与Leader选举过程，也不参与写操作的“过半写成功”策略。

##### 会话（Session）

客户端启动的时候，首先会与服务器建立一个TCP连接， 从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，同时也能够向ZooKeeper服务器发送请求并接受响应，同时还能够通过该连接**接收来自服务器的Watch事件通知**。

##### 数据节点（Znode）

这里指的数据节点，是指的ZooKeeper的内存数据结构。在ZooKeeper中，ZNode可以分为持久节点和临时节点两类，其中：

- **持久节点**：指一且这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在ZooKeeper上。
- **临时节点**：它的生命周期和客户端会话绑定，一且客户端会话失效，那么这个客户端创建的所有临时节点都会被移除

数据节点还有另外一个额外的属性，**SEQUENTIAL** */səˈkwen(t)SHəl/* ，一旦被标记这个属性，那么这个节点将被创建的时候，会在节点名称后面追加上一个整型数字，这个整型数字是由**父节点维护的一个自增数字**。

##### 版本

每个ZNode，ZooKeeper都会为其维护一个叫作**Stat**的数据结构，Stat中记录了这个ZNode的三个数据版本，分别是**version（当前ZNode的版本）**、cversioo（当前ZNode子节点的版本）和**aversion（当前ZNode的ACL版本）**。

##### 事件监听器（Watcher）

ZooKeeper允许用户在指定节点上注册一些Watcher, 并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。

##### ACL

ZooKeeper采用ACL (Access Control Lists)策略来进行权限控制，类似于UNIX文件系统的权限控制。其中ZooKeeper定义了如下5中权限：

- **CREATE**：创建**子节点**权限
- **READ**：获取节点数据和**子节点**列表的权限
- **WRITE**：更新节点数据的权限
- **DELETE**：删除子节点的权限
- **ADMIN**：设置节点ACL的权限

#### ZooKeeper的ZAB协议

##### ZAB协议概述

要明白一点，ZooKeeper并没有完全采用Paxos算法，而是使用了一种称为**Zookeeper Atomic Broadcast(ZAB，Zookeeper原子消息广播协议)**的协议作为其数据一致性的核心算法。

在ZooKeeper中，**主要依赖ZAB协议来实现分布式数据一致性**，基于该协议，ZooKeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体过程概括如下：

**首先：**ZooKeeper使用**一个单一的主进程**来接收并处理客户端的**所有事务请求**，并采用ZAB的原子广播协议，将服务器数据的状态变更以事务Proposal的形式广播到所有的副本进程上去。这个过程的特点是：ZAB协议的这个主备模型架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端大量的井发请求。

**其次：**考虑到在分布式环境中，顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更。例如变更C需要依赖变更A和变更B。 这样的依赖关系也对ZAB协议提出了一个要求：**ZAB协议必须能够保证一个全局的变更序列被顺序应用**，也就是说，ZAB协议需要保证如果一个状态变更已经被处理了，那么所有其依赖的状态变更都应该巳经被提前处理掉了。

**最后**：考虑到主进程在任何时候都有可能出现崩溃退出或重启现象，因此，ZAB协议还需要做到在当前主进程出现上述异常情况的时候， 依旧能够正常工作。

上述步骤的概述，就是：

*所有事务请求必须由**一个全局唯一的服务器**来协调处理， 这样的服务器被称为 Leader 服务器， 而余下的其他服务器则成为 Follower 服务器。 Leader 服务器负责将一**个客户端事务请求**转换成**一个事务 Proposal**（提议）， 并将该 Proposal **分发**给集群中所有的Follower 服务器。 之后 Leader服务器需要等待所有 Follower 服务器的反馈， 一旦**超过半数**的 Follower 服务器进行了正确的反馈后， 那么 Leader 就会再次向所有的 Follower 服务器分发 Commit 消息要求其将前一个 Proposal 进行提交。*

##### ZAB协议介绍

ZAB协议包含两个基本的模式，分别是崩溃恢复和消息广播。

###### 消息广播

ZAB协议的消息广播过程使用的是一个原子广播协议，***类似于**一个二阶段提交过程*。针ZAB协议的消息广播过程使用的是对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal, 并将其发送给集群中其余所有的机器， 然后再分别收集各自的选票， 最后进行事务提交，如下图所示：

![ZAB协议消息广播流程示意图](324f2c0b/ZAB协议消息广播流程示意图.jpg)

前文中提到这个过程仅仅是类似于一个2PC过程，但是又与2PC过从不同的是：

- 移除了中断逻辑，所有的Follower服务器要么正常反馈Leader 提出的事务Proposal，要么就抛弃Leader服务器。意味着我们可以在过半的Follower服务器已经反馈Ack之后就开始提交事务Proposal了。当然这个过程是解决不了Leader崩溃的问题的，所以由后面的恢复模式来解决这个问题。
- 整个消息广播协议是基于具有FFIO特性的TCP协议来进行网络通信的，因此能够很容易地保证消息广播过程中消息接收与发送的顺序性。

###### 崩溃恢复

崩溃恢复是为了解决Leader节点崩溃或者因为网络原因导致的，失去过半的Follower联系的，就会进入恢复模式。

根本解决的问题是，重新选举的同时，还能很好的通知到整个集群。



### 第5章 使用ZooKeeper

【备注】这里还是非常建议，哪怕是照着书本配置，敲一下，提升一下基础印象还是很有必要的。



### 第6章 ZooKeeper的典型应用场景



### 第7章 ZooKeeper技术内幕



### 第8章 ZooKeeper运维









